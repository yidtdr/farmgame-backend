2024.04.03 10:19:51 INFO  Started: Metals version 1.2.2 in folders 'D:\bestgame' for client Visual Studio Code 1.87.2.
10:19:52.317 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
10:19:52.320 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
10:19:52.322 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
10:19:52.324 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
10:19:52.324 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
10:19:52.324 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
10:19:52.325 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
10:19:52.325 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
10:19:52.326 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/C:/Users/yidtdr/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
10:19:52.331 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
10:19:52.331 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
10:19:52.331 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
10:19:52.331 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
10:19:52.331 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
10:19:52.332 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
10:19:52.337 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:19:52.338 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
10:19:52.338 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
10:19:52.338 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
10:19:52.338 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
10:19:52.427 [pool-1-thread-1] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:D:\bestgame\.metals\metals (H2 2.2)
10:19:52.427 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
10:19:52.427 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
10:19:52.428 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
10:19:52.428 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
10:19:52.432 [pool-1-thread-1] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
10:19:52.433 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
10:19:52.433 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:19:52.440 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
10:19:52.443 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:19:52.450 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
10:19:52.450 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
10:19:52.450 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
10:19:52.450 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
10:19:52.450 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:19:52.451 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
10:19:52.451 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
10:19:52.451 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
10:19:52.451 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
10:19:52.451 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:19:52.452 [pool-1-thread-1] INFO org.flywaydb.core.internal.schemahistory.JdbcTableSchemaHistory -- Schema history table "PUBLIC"."flyway_schema_history" does not exist yet
10:19:52.454 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.013s)
10:19:52.456 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
10:19:52.458 [pool-1-thread-1] INFO org.flywaydb.core.internal.schemahistory.JdbcTableSchemaHistory -- Creating Schema History table "PUBLIC"."flyway_schema_history" ...
10:19:52.459 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.parser.Parser -- Parsing  ...
10:19:52.462 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.ParserSqlScript -- Found statement at line 1: CREATE TABLE IF NOT EXISTS "PUBLIC"."flyway_schema_history" (
    "installed_rank" INT NOT NULL,
    "version" VARCHAR(50),
    "description" VARCHAR(200) NOT NULL,
    "type" VARCHAR(20) NOT NULL,
    "script" VARCHAR(1000) NOT NULL,
    "checksum" INT,
    "installed_by" VARCHAR(100) NOT NULL,
    "installed_on" TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "execution_time" INT NOT NULL,
    "success" BOOLEAN NOT NULL,
    CONSTRAINT "flyway_schema_history_pk" PRIMARY KEY ("installed_rank")
) AS SELECT -1, NULL, '<< Flyway Schema History table created >>', 'TABLE', '', NULL, 'SA', CURRENT_TIMESTAMP, 0, TRUE
10:19:52.463 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.ParserSqlScript -- Found statement at line 14: CREATE INDEX "PUBLIC"."flyway_schema_history_s_idx" ON "PUBLIC"."flyway_schema_history" ("success")
10:19:52.463 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- Executing SQL: CREATE TABLE IF NOT EXISTS "PUBLIC"."flyway_schema_history" (
    "installed_rank" INT NOT NULL,
    "version" VARCHAR(50),
    "description" VARCHAR(200) NOT NULL,
    "type" VARCHAR(20) NOT NULL,
    "script" VARCHAR(1000) NOT NULL,
    "checksum" INT,
    "installed_by" VARCHAR(100) NOT NULL,
    "installed_on" TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "execution_time" INT NOT NULL,
    "success" BOOLEAN NOT NULL,
    CONSTRAINT "flyway_schema_history_pk" PRIMARY KEY ("installed_rank")
) AS SELECT -1, NULL, '<< Flyway Schema History table created >>', 'TABLE', '', NULL, 'SA', CURRENT_TIMESTAMP, 0, TRUE
10:19:52.465 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- 0 rows affected
10:19:52.465 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- Executing SQL: CREATE INDEX "PUBLIC"."flyway_schema_history_s_idx" ON "PUBLIC"."flyway_schema_history" ("success")
10:19:52.466 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- 0 rows affected
10:19:52.466 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.JdbcTableSchemaHistory -- Created Schema History table "PUBLIC"."flyway_schema_history"
10:19:52.470 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": << Empty Schema >>
10:19:52.470 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.parser.Parser -- Parsing V1__Create_tables.sql ...
10:19:52.471 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.ParserSqlScript -- Found statement at line 4: -- The relationship between library dependency sources under .metals/readonly/**
-- and build targets they belong to. Required to know what classpath to use
-- for compiling dependency sources.
create table dependency_source(
  text_document_uri varchar primary key,
  build_target_uri varchar not null
)
10:19:52.471 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.ParserSqlScript -- Found statement at line 12: -- The relationship between library dependency sources under .metals/readonly/**
-- and worksheets they belong to. Required to know what classpath to use
-- for compiling dependency sources.
create table worksheet_dependency_source(
  text_document_uri varchar primary key,
  worksheet_uri varchar not null
)
10:19:52.471 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.ParserSqlScript -- Found statement at line 19: -- The relationship between what library dependency sources under .metals/readonly/**
-- map to which build targets.
create table sbt_digest(
  md5 varchar,
  status tinyint not null,
  when_recorded timestamp
)
10:19:52.472 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.ParserSqlScript -- Found statement at line 27: -- Which window/showMessage and window/showMessageRequest dialogues have been dismissed
-- by the user via "Don't show again" or closed by clicking on "x".
create table dismissed_notification(
  id int,
  when_dismissed timestamp,
  when_expires timestamp
)
10:19:52.472 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.ParserSqlScript -- Found statement at line 34: -- The choice of build tool when multiple build tool files are found in a workspace
create table chosen_build_tool(
  build_tool varchar primary key
)
10:19:52.473 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbMigrate -- Starting migration of schema "PUBLIC" to version "1 - Create tables" ...
10:19:52.473 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Migrating schema "PUBLIC" to version "1 - Create tables"
10:19:52.474 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- Executing SQL: -- The relationship between library dependency sources under .metals/readonly/**
-- and build targets they belong to. Required to know what classpath to use
-- for compiling dependency sources.
create table dependency_source(
  text_document_uri varchar primary key,
  build_target_uri varchar not null
)
10:19:52.475 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- 0 rows affected
10:19:52.475 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- Executing SQL: -- The relationship between library dependency sources under .metals/readonly/**
-- and worksheets they belong to. Required to know what classpath to use
-- for compiling dependency sources.
create table worksheet_dependency_source(
  text_document_uri varchar primary key,
  worksheet_uri varchar not null
)
10:19:52.475 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- 0 rows affected
10:19:52.475 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- Executing SQL: -- The relationship between what library dependency sources under .metals/readonly/**
-- map to which build targets.
create table sbt_digest(
  md5 varchar,
  status tinyint not null,
  when_recorded timestamp
)
10:19:52.476 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- 0 rows affected
10:19:52.476 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- Executing SQL: -- Which window/showMessage and window/showMessageRequest dialogues have been dismissed
-- by the user via "Don't show again" or closed by clicking on "x".
create table dismissed_notification(
  id int,
  when_dismissed timestamp,
  when_expires timestamp
)
10:19:52.476 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- 0 rows affected
10:19:52.476 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- Executing SQL: -- The choice of build tool when multiple build tool files are found in a workspace
create table chosen_build_tool(
  build_tool varchar primary key
)
10:19:52.477 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- 0 rows affected
10:19:52.477 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbMigrate -- Successfully completed migration of schema "PUBLIC" to version "1 - Create tables"
10:19:52.480 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.JdbcTableSchemaHistory -- Schema History table "PUBLIC"."flyway_schema_history" successfully updated to reflect changes
10:19:52.483 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.parser.Parser -- Parsing V2__Server_discovery.sql ...
10:19:52.484 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.ParserSqlScript -- Found statement at line 4: -- For each unique combination of installed build servers we select one server.
-- The md5 checksum is computed from the names of the installed build servers, and
-- the selected server is the server which the user chose for this workspace.
create table chosen_build_server(
  md5 varchar primary key,
  selected_server varchar,
  when_recorded timestamp
)
10:19:52.484 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbMigrate -- Starting migration of schema "PUBLIC" to version "2 - Server discovery" ...
10:19:52.484 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Migrating schema "PUBLIC" to version "2 - Server discovery"
10:19:52.484 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- Executing SQL: -- For each unique combination of installed build servers we select one server.
-- The md5 checksum is computed from the names of the installed build servers, and
-- the selected server is the server which the user chose for this workspace.
create table chosen_build_server(
  md5 varchar primary key,
  selected_server varchar,
  when_recorded timestamp
)
10:19:52.485 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- 0 rows affected
10:19:52.485 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbMigrate -- Successfully completed migration of schema "PUBLIC" to version "2 - Server discovery"
10:19:52.486 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.JdbcTableSchemaHistory -- Schema History table "PUBLIC"."flyway_schema_history" successfully updated to reflect changes
10:19:52.489 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.parser.Parser -- Parsing V3__Jar_symbols.sql ...
10:19:52.489 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.ParserSqlScript -- Found statement at line 2: -- Indexed jars, the MD5 digest of path, modified time and size as key
create table indexed_jar(
  id int auto_increment unique,
  md5 varchar primary key
)
10:19:52.490 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.ParserSqlScript -- Found statement at line 7: -- Top Level Symbols per jar, allow for multiple jars with same symbols and paths
create table toplevel_symbol(
  symbol varchar not null,
  path varchar not null,
  jar int,
  foreign key (jar) references indexed_jar (id) on delete cascade,
  primary key (jar, path, symbol)
)
10:19:52.490 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.ParserSqlScript -- Found statement at line 15: -- Create index to speedup lookup of jar symbols
create index toplevel_symbol_jar on toplevel_symbol(jar)
10:19:52.490 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbMigrate -- Starting migration of schema "PUBLIC" to version "3 - Jar symbols" ...
10:19:52.491 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Migrating schema "PUBLIC" to version "3 - Jar symbols"
10:19:52.491 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- Executing SQL: -- Indexed jars, the MD5 digest of path, modified time and size as key
create table indexed_jar(
  id int auto_increment unique,
  md5 varchar primary key
)
10:19:52.496 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- 0 rows affected
10:19:52.497 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- Executing SQL: -- Top Level Symbols per jar, allow for multiple jars with same symbols and paths
create table toplevel_symbol(
  symbol varchar not null,
  path varchar not null,
  jar int,
  foreign key (jar) references indexed_jar (id) on delete cascade,
  primary key (jar, path, symbol)
)
10:19:52.500 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- 0 rows affected
10:19:52.500 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- Executing SQL: -- Create index to speedup lookup of jar symbols
create index toplevel_symbol_jar on toplevel_symbol(jar)
10:19:52.500 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- 0 rows affected
10:19:52.500 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbMigrate -- Successfully completed migration of schema "PUBLIC" to version "3 - Jar symbols"
10:19:52.501 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.JdbcTableSchemaHistory -- Schema History table "PUBLIC"."flyway_schema_history" successfully updated to reflect changes
10:19:52.502 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.parser.Parser -- Parsing V4__Fingerprints.sql ...
10:19:52.503 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.ParserSqlScript -- Found statement at line 2: -- Fingerprints saved between invocations
create table fingerprints(
  path varchar not null,
  text varchar not null,
  md5 varchar not null,
  id int auto_increment unique
)
10:19:52.503 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbMigrate -- Starting migration of schema "PUBLIC" to version "4 - Fingerprints" ...
10:19:52.504 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Migrating schema "PUBLIC" to version "4 - Fingerprints"
10:19:52.504 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- Executing SQL: -- Fingerprints saved between invocations
create table fingerprints(
  path varchar not null,
  text varchar not null,
  md5 varchar not null,
  id int auto_increment unique
)
10:19:52.505 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.sqlscript.DefaultSqlScriptExecutor -- 0 rows affected
10:19:52.505 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbMigrate -- Successfully completed migration of schema "PUBLIC" to version "4 - Fingerprints"
10:19:52.505 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.JdbcTableSchemaHistory -- Schema History table "PUBLIC"."flyway_schema_history" successfully updated to reflect changes
10:19:52.510 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Successfully applied 4 migrations to schema "PUBLIC", now at version v4 (execution time 00:00.015s)
10:19:52.516 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 49 of 100M
ΰοπ. 03, 2024 10:19:52 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1
2024.04.03 10:19:52 WARN  Build server is not auto-connectable.
2024.04.03 10:19:58 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals4243704786992487842\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 10:20:00 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 10:20:01 INFO  no build target found for D:\bestgame\build.sbt. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.03 10:20:03 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 10:20:03 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:20:03 INFO  time: code lens generation in 4.04s
2024.04.03 10:20:05 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 10:20:08 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 10:20:08 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 10:20:14 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 10:20:14 INFO  [success] Total time: 5 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 10:20:14
2024.04.03 10:20:16 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.03 10:20:16 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.03 10:20:16 INFO  [warn] 
2024.04.03 10:20:16 INFO  [warn] 	Note: Unresolved dependencies path:
2024.04.03 10:20:16 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.04.03 10:20:16 INFO  [error] sbt.librarymanagement.ResolveException: Error downloading zio:zio_2.13:2.0.5
2024.04.03 10:20:16 INFO  [error]   Not found
2024.04.03 10:20:16 INFO  [error]   Not found
2024.04.03 10:20:16 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localzio\zio_2.13\2.0.5\ivys\ivy.xml
2024.04.03 10:20:16 INFO  [error]   not found: https://repo1.maven.org/maven2/zio/zio_2.13/2.0.5/zio_2.13-2.0.5.pom
2024.04.03 10:20:16 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.unresolvedWarningOrThrow(CoursierDependencyResolution.scala:344)
2024.04.03 10:20:16 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.$anonfun$update$38(CoursierDependencyResolution.scala:313)
2024.04.03 10:20:16 INFO  [error] 	at scala.util.Either$LeftProjection.map(Either.scala:573)
2024.04.03 10:20:16 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.update(CoursierDependencyResolution.scala:313)
2024.04.03 10:20:16 INFO  [error] 	at sbt.librarymanagement.DependencyResolution.update(DependencyResolution.scala:60)
2024.04.03 10:20:16 INFO  [error] 	at sbt.internal.LibraryManagement$.resolve$1(LibraryManagement.scala:60)
2024.04.03 10:20:16 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$12(LibraryManagement.scala:134)
2024.04.03 10:20:16 INFO  [error] 	at sbt.util.Tracked$.$anonfun$lastOutput$1(Tracked.scala:74)
2024.04.03 10:20:16 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$20(LibraryManagement.scala:147)
2024.04.03 10:20:16 INFO  [error] 	at scala.util.control.Exception$Catch.apply(Exception.scala:228)
2024.04.03 10:20:16 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11(LibraryManagement.scala:147)
2024.04.03 10:20:16 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11$adapted(LibraryManagement.scala:128)
2024.04.03 10:20:16 INFO  [error] 	at sbt.util.Tracked$.$anonfun$inputChangedW$1(Tracked.scala:220)
2024.04.03 10:20:16 INFO  [error] 	at sbt.internal.LibraryManagement$.cachedUpdate(LibraryManagement.scala:161)
2024.04.03 10:20:16 INFO  [error] 	at sbt.Classpaths$.$anonfun$updateTask0$1(Defaults.scala:3801)
2024.04.03 10:20:16 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.04.03 10:20:16 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.04.03 10:20:16 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.04.03 10:20:16 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.04.03 10:20:16 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.04.03 10:20:16 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.04.03 10:20:16 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.04.03 10:20:16 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.04.03 10:20:16 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.04.03 10:20:16 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 10:20:16 INFO  [error] 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
2024.04.03 10:20:16 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 10:20:16 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
2024.04.03 10:20:16 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
2024.04.03 10:20:16 INFO  [error] 	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.03 10:20:16 INFO  [error] (update) sbt.librarymanagement.ResolveException: Error downloading zio:zio_2.13:2.0.5
2024.04.03 10:20:16 INFO  [error]   Not found
2024.04.03 10:20:16 INFO  [error]   Not found
2024.04.03 10:20:16 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localzio\zio_2.13\2.0.5\ivys\ivy.xml
2024.04.03 10:20:16 INFO  [error]   not found: https://repo1.maven.org/maven2/zio/zio_2.13/2.0.5/zio_2.13-2.0.5.pom
2024.04.03 10:20:16 INFO  [error] Total time: 0 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 10:20:17
2024.04.03 10:20:17 INFO  time: ran 'sbt bloopInstall' in 19s
2024.04.03 10:20:17 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals4243704786992487842\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 10:21:06 WARN  no build target for: D:\bestgame\src\main\scala\main.scala
2024.04.03 10:21:06 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:21:06 WARN  Could not find semantic tokens for: file:///D:/bestgame/src/main/scala/main.scala
2024.04.03 10:21:26 WARN  no build target for: D:\bestgame\src\main\scala\main.scala
2024.04.03 10:22:10 WARN  no build target for: D:\bestgame\src\main\scala\main.scala
2024.04.03 10:22:10 WARN  no build target for: D:\bestgame\src\main\scala\main.scala
2024.04.03 10:22:57 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:27:04 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:27:23 WARN  no build target for: D:\bestgame\build.sbt
2024.04.03 10:27:23 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:27:25 WARN  no build target for: D:\bestgame\build.sbt
2024.04.03 10:27:25 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
ΰοπ. 03, 2024 10:27:25 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.reflect.InvocationTargetException
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: file:///D:/bestgame/build.sbt:6: error: unclosed string literal
  "zio" %% "zio" % 2.0.21"
                         ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.mtags.ScalaToplevelMtags.acceptBalancedDelimeters(ScalaToplevelMtags.scala:691)
	at scala.meta.internal.mtags.ScalaToplevelMtags.loop(ScalaToplevelMtags.scala:437)
	at scala.meta.internal.mtags.ScalaToplevelMtags.indexRoot(ScalaToplevelMtags.scala:56)
	at scala.meta.internal.mtags.MtagsIndexer.index(MtagsIndexer.scala:19)
	at scala.meta.internal.mtags.MtagsIndexer.index$(MtagsIndexer.scala:18)
	at scala.meta.internal.mtags.ScalaToplevelMtags.index(ScalaToplevelMtags.scala:43)
	at scala.meta.internal.mtags.Mtags$.allToplevels(Mtags.scala:125)
	at scala.meta.internal.metals.DefinitionProvider.fromMtags(DefinitionProvider.scala:376)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$positionOccurrence$4(DefinitionProvider.scala:296)
	at scala.Option.orElse(Option.scala:477)
	at scala.meta.internal.metals.DefinitionProvider.$anonfun$positionOccurrence$1(DefinitionProvider.scala:296)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.DefinitionProvider.positionOccurrence(DefinitionProvider.scala:288)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definitionOrReferences$1(MetalsLspService.scala:2564)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.MetalsLspService.definitionOrReferences(MetalsLspService.scala:2560)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$definition$1(MetalsLspService.scala:1404)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLspService.definition(MetalsLspService.scala:1403)
	at scala.meta.internal.metals.WorkspaceLspService.definition(WorkspaceLspService.scala:373)
	at scala.meta.metals.lsp.DelegatingScalaService.definition(DelegatingScalaService.scala:69)
	... 16 more

2024.04.03 10:27:27 WARN  no build target for: D:\bestgame\build.sbt
2024.04.03 10:27:27 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:27:28 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals1195273732601895216\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 10:27:30 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 10:27:31 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 10:27:31 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 10:27:33 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 10:27:33 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 10:27:36 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 10:27:36 INFO  [success] Total time: 3 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 10:27:36
2024.04.03 10:27:38 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.03 10:27:38 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.03 10:27:40 INFO  [warn] 
2024.04.03 10:27:40 INFO  [warn] 	Note: Unresolved dependencies path:
2024.04.03 10:27:40 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.04.03 10:27:40 INFO  [error] sbt.librarymanagement.ResolveException: Error downloading zio:zio_2.13:2.0.21
2024.04.03 10:27:40 INFO  [error]   Not found
2024.04.03 10:27:40 INFO  [error]   Not found
2024.04.03 10:27:40 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localzio\zio_2.13\2.0.21\ivys\ivy.xml
2024.04.03 10:27:40 INFO  [error]   not found: https://repo1.maven.org/maven2/zio/zio_2.13/2.0.21/zio_2.13-2.0.21.pom
2024.04.03 10:27:40 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.unresolvedWarningOrThrow(CoursierDependencyResolution.scala:344)
2024.04.03 10:27:40 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.$anonfun$update$38(CoursierDependencyResolution.scala:313)
2024.04.03 10:27:40 INFO  [error] 	at scala.util.Either$LeftProjection.map(Either.scala:573)
2024.04.03 10:27:40 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.update(CoursierDependencyResolution.scala:313)
2024.04.03 10:27:40 INFO  [error] 	at sbt.librarymanagement.DependencyResolution.update(DependencyResolution.scala:60)
2024.04.03 10:27:40 INFO  [error] 	at sbt.internal.LibraryManagement$.resolve$1(LibraryManagement.scala:60)
2024.04.03 10:27:40 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$12(LibraryManagement.scala:134)
2024.04.03 10:27:40 INFO  [error] 	at sbt.util.Tracked$.$anonfun$lastOutput$1(Tracked.scala:74)
2024.04.03 10:27:40 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$20(LibraryManagement.scala:147)
2024.04.03 10:27:40 INFO  [error] 	at scala.util.control.Exception$Catch.apply(Exception.scala:228)
2024.04.03 10:27:40 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11(LibraryManagement.scala:147)
2024.04.03 10:27:40 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11$adapted(LibraryManagement.scala:128)
2024.04.03 10:27:40 INFO  [error] 	at sbt.util.Tracked$.$anonfun$inputChangedW$1(Tracked.scala:220)
2024.04.03 10:27:40 INFO  [error] 	at sbt.internal.LibraryManagement$.cachedUpdate(LibraryManagement.scala:161)
2024.04.03 10:27:40 INFO  [error] 	at sbt.Classpaths$.$anonfun$updateTask0$1(Defaults.scala:3801)
2024.04.03 10:27:40 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.04.03 10:27:40 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.04.03 10:27:40 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.04.03 10:27:40 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.04.03 10:27:40 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.04.03 10:27:40 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.04.03 10:27:40 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.04.03 10:27:40 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.04.03 10:27:40 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.04.03 10:27:40 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 10:27:40 INFO  [error] 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
2024.04.03 10:27:40 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 10:27:40 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
2024.04.03 10:27:40 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
2024.04.03 10:27:40 INFO  [error] 	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.03 10:27:40 INFO  [error] (update) sbt.librarymanagement.ResolveException: Error downloading zio:zio_2.13:2.0.21
2024.04.03 10:27:40 INFO  [error]   Not found
2024.04.03 10:27:40 INFO  [error]   Not found
2024.04.03 10:27:40 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localzio\zio_2.13\2.0.21\ivys\ivy.xml
2024.04.03 10:27:40 INFO  [error]   not found: https://repo1.maven.org/maven2/zio/zio_2.13/2.0.21/zio_2.13-2.0.21.pom
2024.04.03 10:27:40 INFO  [error] Total time: 1 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 10:27:40
2024.04.03 10:27:40 INFO  time: ran 'sbt bloopInstall' in 11s
2024.04.03 10:27:40 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals1195273732601895216\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 10:27:40 INFO  skipping build import with status 'Failed'
ΰοπ. 03, 2024 10:29:28 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 144
2024.04.03 10:29:28 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:29:36 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:29:40 WARN  no build target for: D:\bestgame\build.sbt
2024.04.03 10:29:40 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:29:43 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals13226041715827762541\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 10:29:44 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 10:29:44 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 10:29:46 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 10:29:46 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 10:29:47 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 10:29:49 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 10:29:49 INFO  [success] Total time: 3 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 10:29:50
2024.04.03 10:29:52 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.03 10:29:52 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.03 10:29:53 INFO  [warn] 
2024.04.03 10:29:53 INFO  [warn] 	Note: Unresolved dependencies path:
2024.04.03 10:29:53 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.04.03 10:29:53 INFO  [error] sbt.librarymanagement.ResolveException: Error downloading org.scala-lang:scala-library:3
2024.04.03 10:29:53 INFO  [error]   Not found
2024.04.03 10:29:53 INFO  [error]   Not found
2024.04.03 10:29:53 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localorg.scala-lang\scala-library\3\ivys\ivy.xml
2024.04.03 10:29:53 INFO  [error]   not found: https://repo1.maven.org/maven2/org/scala-lang/scala-library/3/scala-library-3.pom
2024.04.03 10:29:53 INFO  [error] Error downloading zio:zio_3:2.0.21
2024.04.03 10:29:53 INFO  [error]   Not found
2024.04.03 10:29:53 INFO  [error]   Not found
2024.04.03 10:29:53 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localzio\zio_3\2.0.21\ivys\ivy.xml
2024.04.03 10:29:53 INFO  [error]   not found: https://repo1.maven.org/maven2/zio/zio_3/2.0.21/zio_3-2.0.21.pom
2024.04.03 10:29:53 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.unresolvedWarningOrThrow(CoursierDependencyResolution.scala:344)
2024.04.03 10:29:53 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.$anonfun$update$38(CoursierDependencyResolution.scala:313)
2024.04.03 10:29:53 INFO  [error] 	at scala.util.Either$LeftProjection.map(Either.scala:573)
2024.04.03 10:29:53 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.update(CoursierDependencyResolution.scala:313)
2024.04.03 10:29:53 INFO  [error] 	at sbt.librarymanagement.DependencyResolution.update(DependencyResolution.scala:60)
2024.04.03 10:29:53 INFO  [error] 	at sbt.internal.LibraryManagement$.resolve$1(LibraryManagement.scala:60)
2024.04.03 10:29:53 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$12(LibraryManagement.scala:134)
2024.04.03 10:29:53 INFO  [error] 	at sbt.util.Tracked$.$anonfun$lastOutput$1(Tracked.scala:74)
2024.04.03 10:29:53 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$20(LibraryManagement.scala:147)
2024.04.03 10:29:53 INFO  [error] 	at scala.util.control.Exception$Catch.apply(Exception.scala:228)
2024.04.03 10:29:53 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11(LibraryManagement.scala:147)
2024.04.03 10:29:53 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11$adapted(LibraryManagement.scala:128)
2024.04.03 10:29:53 INFO  [error] 	at sbt.util.Tracked$.$anonfun$inputChangedW$1(Tracked.scala:220)
2024.04.03 10:29:53 INFO  [error] 	at sbt.internal.LibraryManagement$.cachedUpdate(LibraryManagement.scala:161)
2024.04.03 10:29:53 INFO  [error] 	at sbt.Classpaths$.$anonfun$updateTask0$1(Defaults.scala:3801)
2024.04.03 10:29:53 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.04.03 10:29:53 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.04.03 10:29:53 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.04.03 10:29:53 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.04.03 10:29:53 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.04.03 10:29:53 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.04.03 10:29:53 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.04.03 10:29:53 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.04.03 10:29:53 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.04.03 10:29:53 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 10:29:53 INFO  [error] 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
2024.04.03 10:29:53 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 10:29:53 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
2024.04.03 10:29:53 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
2024.04.03 10:29:53 INFO  [error] 	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.03 10:29:53 INFO  [error] (update) sbt.librarymanagement.ResolveException: Error downloading org.scala-lang:scala-library:3
2024.04.03 10:29:53 INFO  [error]   Not found
2024.04.03 10:29:53 INFO  [error]   Not found
2024.04.03 10:29:53 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localorg.scala-lang\scala-library\3\ivys\ivy.xml
2024.04.03 10:29:53 INFO  [error]   not found: https://repo1.maven.org/maven2/org/scala-lang/scala-library/3/scala-library-3.pom
2024.04.03 10:29:53 INFO  [error] Error downloading zio:zio_3:2.0.21
2024.04.03 10:29:53 INFO  [error]   Not found
2024.04.03 10:29:53 INFO  [error]   Not found
2024.04.03 10:29:53 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localzio\zio_3\2.0.21\ivys\ivy.xml
2024.04.03 10:29:53 INFO  [error]   not found: https://repo1.maven.org/maven2/zio/zio_3/2.0.21/zio_3-2.0.21.pom
2024.04.03 10:29:53 INFO  [error] Total time: 1 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 10:29:53
2024.04.03 10:29:53 INFO  time: ran 'sbt bloopInstall' in 10s
2024.04.03 10:29:53 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals13226041715827762541\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 10:29:59 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:30:01 WARN  no build target for: D:\bestgame\build.sbt
2024.04.03 10:30:01 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:30:02 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals12832721190353847293\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 10:30:04 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 10:30:05 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 10:30:06 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 10:30:08 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 10:30:08 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 10:30:13 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 10:30:13 INFO  [success] Total time: 5 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 10:30:13
2024.04.03 10:30:17 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.03 10:30:17 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.03 10:30:18 INFO  [warn] 
2024.04.03 10:30:18 INFO  [warn] 	Note: Unresolved dependencies path:
2024.04.03 10:30:18 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.04.03 10:30:18 INFO  [error] sbt.librarymanagement.ResolveException: Error downloading zio:zio_3:2.0.21
2024.04.03 10:30:18 INFO  [error]   Not found
2024.04.03 10:30:18 INFO  [error]   Not found
2024.04.03 10:30:18 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localzio\zio_3\2.0.21\ivys\ivy.xml
2024.04.03 10:30:18 INFO  [error]   not found: https://repo1.maven.org/maven2/zio/zio_3/2.0.21/zio_3-2.0.21.pom
2024.04.03 10:30:18 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.unresolvedWarningOrThrow(CoursierDependencyResolution.scala:344)
2024.04.03 10:30:18 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.$anonfun$update$38(CoursierDependencyResolution.scala:313)
2024.04.03 10:30:18 INFO  [error] 	at scala.util.Either$LeftProjection.map(Either.scala:573)
2024.04.03 10:30:18 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.update(CoursierDependencyResolution.scala:313)
2024.04.03 10:30:18 INFO  [error] 	at sbt.librarymanagement.DependencyResolution.update(DependencyResolution.scala:60)
2024.04.03 10:30:18 INFO  [error] 	at sbt.internal.LibraryManagement$.resolve$1(LibraryManagement.scala:60)
2024.04.03 10:30:18 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$12(LibraryManagement.scala:134)
2024.04.03 10:30:18 INFO  [error] 	at sbt.util.Tracked$.$anonfun$lastOutput$1(Tracked.scala:74)
2024.04.03 10:30:18 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$20(LibraryManagement.scala:147)
2024.04.03 10:30:18 INFO  [error] 	at scala.util.control.Exception$Catch.apply(Exception.scala:228)
2024.04.03 10:30:18 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11(LibraryManagement.scala:147)
2024.04.03 10:30:18 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11$adapted(LibraryManagement.scala:128)
2024.04.03 10:30:18 INFO  [error] 	at sbt.util.Tracked$.$anonfun$inputChangedW$1(Tracked.scala:220)
2024.04.03 10:30:18 INFO  [error] 	at sbt.internal.LibraryManagement$.cachedUpdate(LibraryManagement.scala:161)
2024.04.03 10:30:18 INFO  [error] 	at sbt.Classpaths$.$anonfun$updateTask0$1(Defaults.scala:3801)
2024.04.03 10:30:18 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.04.03 10:30:18 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.04.03 10:30:18 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.04.03 10:30:18 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.04.03 10:30:18 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.04.03 10:30:18 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.04.03 10:30:18 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.04.03 10:30:18 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.04.03 10:30:18 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.04.03 10:30:18 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 10:30:18 INFO  [error] 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
2024.04.03 10:30:18 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 10:30:18 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
2024.04.03 10:30:18 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
2024.04.03 10:30:18 INFO  [error] 	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.03 10:30:18 INFO  [error] (update) sbt.librarymanagement.ResolveException: Error downloading zio:zio_3:2.0.21
2024.04.03 10:30:18 INFO  [error]   Not found
2024.04.03 10:30:18 INFO  [error]   Not found
2024.04.03 10:30:18 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localzio\zio_3\2.0.21\ivys\ivy.xml
2024.04.03 10:30:18 INFO  [error]   not found: https://repo1.maven.org/maven2/zio/zio_3/2.0.21/zio_3-2.0.21.pom
2024.04.03 10:30:18 INFO  [error] Total time: 1 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 10:30:18
2024.04.03 10:30:18 INFO  time: ran 'sbt bloopInstall' in 15s
2024.04.03 10:30:18 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals12832721190353847293\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 10:33:14 INFO  Shutting down server
2024.04.03 10:33:14 INFO  shutting down Metals
2024.04.03 10:33:14 INFO  Exiting server
2024.04.03 10:33:25 INFO  Started: Metals version 1.2.2 in folders 'D:\bestgame' for client Visual Studio Code 1.87.2.
10:33:26.153 [pool-1-thread-4] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
10:33:26.154 [pool-1-thread-4] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
10:33:26.154 [pool-1-thread-4] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
10:33:26.155 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
10:33:26.155 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
10:33:26.155 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
10:33:26.155 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
10:33:26.155 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
10:33:26.155 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/C:/Users/yidtdr/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
10:33:26.158 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
10:33:26.158 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
10:33:26.158 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
10:33:26.158 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
10:33:26.158 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
10:33:26.158 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
10:33:26.161 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:33:26.161 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
10:33:26.161 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
10:33:26.161 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
10:33:26.161 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
10:33:26.229 [pool-1-thread-4] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:D:\bestgame\.metals\metals (H2 2.2)
10:33:26.229 [pool-1-thread-4] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
10:33:26.229 [pool-1-thread-4] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
10:33:26.230 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
10:33:26.230 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
10:33:26.232 [pool-1-thread-4] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
10:33:26.233 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
10:33:26.233 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:33:26.237 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
10:33:26.239 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:33:26.243 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
10:33:26.244 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
10:33:26.244 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
10:33:26.244 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
10:33:26.244 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:33:26.244 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
10:33:26.244 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
10:33:26.244 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
10:33:26.244 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
10:33:26.245 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:33:26.252 [pool-1-thread-4] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.015s)
10:33:26.253 [pool-1-thread-4] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
10:33:26.257 [pool-1-thread-4] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
10:33:26.261 [pool-1-thread-4] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
10:33:26.467 [pool-1-thread-4] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 40 of 100M
2024.04.03 10:33:26 WARN  Build server is not auto-connectable.
2024.04.03 10:33:26 INFO  skipping build import with status 'Failed'
2024.04.03 10:35:33 INFO  no build target found for D:\bestgame\build.sbt. Using presentation compiler with project's scala-library version: 3.3.1
ΰοπ. 03, 2024 10:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1
2024.04.03 10:35:34 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:35:49 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:35:50 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:35:50 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:35:51 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:35:52 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:35:54 WARN  no build target for: D:\bestgame\build.sbt
2024.04.03 10:35:54 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:35:56 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals2810946910031733759\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 10:35:58 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 10:35:58 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 10:36:00 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 10:36:00 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 10:36:01 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 10:36:04 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 10:36:04 INFO  [success] Total time: 3 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 10:36:04
2024.04.03 10:36:07 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.03 10:36:07 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.03 10:36:10 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:36:12 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:36:16 INFO  [success] Generated .bloop\bestgame-test.json
2024.04.03 10:36:16 INFO  [success] Generated .bloop\bestgame.json
2024.04.03 10:36:16 INFO  [success] Total time: 9 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 10:36:16
2024.04.03 10:36:16 INFO  time: ran 'sbt bloopInstall' in 20s
2024.04.03 10:36:16 INFO  Attempting to connect to the build server...
2024.04.03 10:36:16 INFO  Setting up current java home C:\Program Files\Java\jdk-17 in C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 10:36:20 WARN  no build target for: D:\bestgame\build.sbt
2024.04.03 10:36:20 INFO  skipping build import with status 'Installed'
2024.04.03 10:36:20 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:36:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 10:36:27 INFO  Attempting to connect to the build server...
2024.04.03 10:36:27 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 10:36:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 10:36:29 WARN  no build target for: D:\bestgame\build.sbt
2024.04.03 10:36:29 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.03 10:36:29 INFO  skipping build import with status 'Installed'
2024.04.03 10:36:30 INFO  time: Connected to build server in 13s
2024.04.03 10:36:30 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 10:36:29 WARN  3.0.0 is no longer supported in the current Metals versions, using the last known supported version 0.11.10
2024.04.03 10:36:44 INFO  time: indexed workspace in 14s
2024.04.03 10:36:48 INFO  time: code lens generation in 3.27s
2024.04.03 10:36:51 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals15488414852162927894\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 10:36:53 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 10:36:53 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 10:36:55 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 10:36:56 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 10:36:56 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 10:36:58 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 10:36:58 INFO  [success] Total time: 2 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 10:36:58
2024.04.03 10:37:00 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.03 10:37:00 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.03 10:37:03 INFO  [success] Generated .bloop\bestgame-test.json
2024.04.03 10:37:03 INFO  [success] Generated .bloop\bestgame.json
2024.04.03 10:37:03 INFO  [success] Total time: 2 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 10:37:03
2024.04.03 10:37:03 INFO  time: ran 'sbt bloopInstall' in 12s
2024.04.03 10:37:03 INFO  Disconnecting from Bloop session...
2024.04.03 10:37:03 INFO  Shut down connection with build server.
2024.04.03 10:37:03 INFO  Shut down connection with build server.
2024.04.03 10:37:03 INFO  Attempting to connect to the build server...
2024.04.03 10:37:03 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 10:37:03 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 10:37:03 INFO  Attempting to connect to the build server...
2024.04.03 10:37:03 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 10:37:03 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 10:37:03 INFO  time: Connected to build server in 0.12s
2024.04.03 10:37:03 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 10:37:04 INFO  time: indexed workspace in 1.13s
2024.04.03 10:37:07 INFO  time: code lens generation in 1.95s
ΰοπ. 03, 2024 10:38:50 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-03\r_compiler-error_(bestgame-build)_10-38-50-604.md
ΰοπ. 03, 2024 10:38:51 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-03\r_compiler-error_(bestgame-build)_10-38-51-609.md
ΰοπ. 03, 2024 10:38:52 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-03\r_compiler-error_(bestgame-build)_10-38-52-270.md
ΰοπ. 03, 2024 10:38:53 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-03\r_compiler-error_(bestgame-build)_10-38-53-195.md
ΰοπ. 03, 2024 10:38:55 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-03\r_compiler-error_(bestgame-build)_10-38-55-119.md
ΰοπ. 03, 2024 10:38:55 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-03\r_compiler-error_(bestgame-build)_10-38-55-957.md
ΰοπ. 03, 2024 10:38:59 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-03\r_compiler-error_(bestgame-build)_10-38-59-832.md
ΰοπ. 03, 2024 10:39:00 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-03\r_compiler-error_(bestgame-build)_10-39-00-811.md
ΰοπ. 03, 2024 10:39:01 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-03\r_compiler-error_(bestgame-build)_10-39-01-470.md
ΰοπ. 03, 2024 10:39:14 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-03\r_compiler-error_(bestgame-build)_10-39-14-225.md
ΰοπ. 03, 2024 10:39:17 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-03\r_compiler-error_(bestgame-build)_10-39-17-478.md
2024.04.03 10:39:20 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals17184281617752775831\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 10:39:22 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 10:39:22 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 10:39:23 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 10:39:23 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 10:39:24 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 10:39:27 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 10:39:27 INFO  [success] Total time: 3 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 10:39:27
2024.04.03 10:39:30 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.03 10:39:30 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.03 10:39:32 INFO  [warn] 
2024.04.03 10:39:32 INFO  [warn] 	Note: Unresolved dependencies path:
2024.04.03 10:39:32 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.04.03 10:39:32 INFO  [warn] Removed stale D:\bestgame\.bloop\bestgame-test.json
2024.04.03 10:39:32 INFO  [warn] Removed stale D:\bestgame\.bloop\bestgame.json
2024.04.03 10:39:32 INFO  [error] sbt.librarymanagement.ResolveException: Error downloading dev.zio:zio-schema-protobuf_3:0.4.17+4-0acf5af7-SNAPSHOT
2024.04.03 10:39:32 INFO  [error]   Not found
2024.04.03 10:39:32 INFO  [error]   Not found
2024.04.03 10:39:32 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localdev.zio\zio-schema-protobuf_3\0.4.17+4-0acf5af7-SNAPSHOT\ivys\ivy.xml
2024.04.03 10:39:32 INFO  [error]   not found: https://repo1.maven.org/maven2/dev/zio/zio-schema-protobuf_3/0.4.17+4-0acf5af7-SNAPSHOT/zio-schema-protobuf_3-0.4.17+4-0acf5af7-SNAPSHOT.pom
2024.04.03 10:39:32 INFO  [error] Error downloading dev.zio:zio-schema_3:0.4.17+4-0acf5af7-SNAPSHOT
2024.04.03 10:39:32 INFO  [error]   Not found
2024.04.03 10:39:32 INFO  [error]   Not found
2024.04.03 10:39:32 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localdev.zio\zio-schema_3\0.4.17+4-0acf5af7-SNAPSHOT\ivys\ivy.xml
2024.04.03 10:39:32 INFO  [error]   not found: https://repo1.maven.org/maven2/dev/zio/zio-schema_3/0.4.17+4-0acf5af7-SNAPSHOT/zio-schema_3-0.4.17+4-0acf5af7-SNAPSHOT.pom
2024.04.03 10:39:32 INFO  [error] Error downloading dev.zio:zio-schema-json_3:0.4.17+4-0acf5af7-SNAPSHOT
2024.04.03 10:39:32 INFO  [error]   Not found
2024.04.03 10:39:32 INFO  [error]   Not found
2024.04.03 10:39:32 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localdev.zio\zio-schema-json_3\0.4.17+4-0acf5af7-SNAPSHOT\ivys\ivy.xml
2024.04.03 10:39:32 INFO  [error]   not found: https://repo1.maven.org/maven2/dev/zio/zio-schema-json_3/0.4.17+4-0acf5af7-SNAPSHOT/zio-schema-json_3-0.4.17+4-0acf5af7-SNAPSHOT.pom
2024.04.03 10:39:32 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.unresolvedWarningOrThrow(CoursierDependencyResolution.scala:344)
2024.04.03 10:39:32 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.$anonfun$update$38(CoursierDependencyResolution.scala:313)
2024.04.03 10:39:32 INFO  [error] 	at scala.util.Either$LeftProjection.map(Either.scala:573)
2024.04.03 10:39:32 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.update(CoursierDependencyResolution.scala:313)
2024.04.03 10:39:32 INFO  [error] 	at sbt.librarymanagement.DependencyResolution.update(DependencyResolution.scala:60)
2024.04.03 10:39:32 INFO  [error] 	at sbt.internal.LibraryManagement$.resolve$1(LibraryManagement.scala:60)
2024.04.03 10:39:32 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$12(LibraryManagement.scala:134)
2024.04.03 10:39:32 INFO  [error] 	at sbt.util.Tracked$.$anonfun$lastOutput$1(Tracked.scala:74)
2024.04.03 10:39:32 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$20(LibraryManagement.scala:147)
2024.04.03 10:39:32 INFO  [error] 	at scala.util.control.Exception$Catch.apply(Exception.scala:228)
2024.04.03 10:39:32 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11(LibraryManagement.scala:147)
2024.04.03 10:39:32 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11$adapted(LibraryManagement.scala:128)
2024.04.03 10:39:32 INFO  [error] 	at sbt.util.Tracked$.$anonfun$inputChangedW$1(Tracked.scala:220)
2024.04.03 10:39:32 INFO  [error] 	at sbt.internal.LibraryManagement$.cachedUpdate(LibraryManagement.scala:161)
2024.04.03 10:39:32 INFO  [error] 	at sbt.Classpaths$.$anonfun$updateTask0$1(Defaults.scala:3801)
2024.04.03 10:39:32 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.04.03 10:39:32 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.04.03 10:39:32 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.04.03 10:39:32 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.04.03 10:39:32 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.04.03 10:39:32 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.04.03 10:39:32 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.04.03 10:39:32 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.04.03 10:39:32 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.04.03 10:39:32 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 10:39:32 INFO  [error] 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
2024.04.03 10:39:32 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 10:39:32 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
2024.04.03 10:39:32 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
2024.04.03 10:39:32 INFO  [error] 	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.03 10:39:32 INFO  [error] (update) sbt.librarymanagement.ResolveException: Error downloading dev.zio:zio-schema-protobuf_3:0.4.17+4-0acf5af7-SNAPSHOT
2024.04.03 10:39:32 INFO  [error]   Not found
2024.04.03 10:39:32 INFO  [error]   Not found
2024.04.03 10:39:32 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localdev.zio\zio-schema-protobuf_3\0.4.17+4-0acf5af7-SNAPSHOT\ivys\ivy.xml
2024.04.03 10:39:32 INFO  [error]   not found: https://repo1.maven.org/maven2/dev/zio/zio-schema-protobuf_3/0.4.17+4-0acf5af7-SNAPSHOT/zio-schema-protobuf_3-0.4.17+4-0acf5af7-SNAPSHOT.pom
2024.04.03 10:39:32 INFO  [error] Error downloading dev.zio:zio-schema_3:0.4.17+4-0acf5af7-SNAPSHOT
2024.04.03 10:39:32 INFO  [error]   Not found
2024.04.03 10:39:32 INFO  [error]   Not found
2024.04.03 10:39:32 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localdev.zio\zio-schema_3\0.4.17+4-0acf5af7-SNAPSHOT\ivys\ivy.xml
2024.04.03 10:39:32 INFO  [error]   not found: https://repo1.maven.org/maven2/dev/zio/zio-schema_3/0.4.17+4-0acf5af7-SNAPSHOT/zio-schema_3-0.4.17+4-0acf5af7-SNAPSHOT.pom
2024.04.03 10:39:32 INFO  [error] Error downloading dev.zio:zio-schema-json_3:0.4.17+4-0acf5af7-SNAPSHOT
2024.04.03 10:39:32 INFO  [error]   Not found
2024.04.03 10:39:32 INFO  [error]   Not found
2024.04.03 10:39:32 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localdev.zio\zio-schema-json_3\0.4.17+4-0acf5af7-SNAPSHOT\ivys\ivy.xml
2024.04.03 10:39:32 INFO  [error]   not found: https://repo1.maven.org/maven2/dev/zio/zio-schema-json_3/0.4.17+4-0acf5af7-SNAPSHOT/zio-schema-json_3-0.4.17+4-0acf5af7-SNAPSHOT.pom
2024.04.03 10:39:32 INFO  [error] Total time: 2 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 10:39:32
2024.04.03 10:39:32 INFO  time: ran 'sbt bloopInstall' in 11s
2024.04.03 10:39:32 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals17184281617752775831\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 10:39:32 INFO  Disconnecting from Bloop session...
2024.04.03 10:39:32 INFO  Shut down connection with build server.
2024.04.03 10:39:32 INFO  Shut down connection with build server.
2024.04.03 10:39:32 INFO  Attempting to connect to the build server...
2024.04.03 10:39:32 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 10:39:32 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 10:39:32 INFO  Attempting to connect to the build server...
2024.04.03 10:39:32 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 10:39:32 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 10:39:32 INFO  time: Connected to build server in 94ms
2024.04.03 10:39:32 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 10:39:33 INFO  time: indexed workspace in 1.01s
2024.04.03 10:39:35 INFO  skipping build import with status 'Installed'
2024.04.03 10:39:35 INFO  time: code lens generation in 1.84s
2024.04.03 10:41:37 INFO  skipping build import with status 'Dismissed'
2024.04.03 10:41:46 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals9033799382231336805\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 10:41:48 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 10:41:48 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 10:41:49 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 10:41:49 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 10:41:50 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 10:41:53 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 10:41:53 INFO  [success] Total time: 3 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 10:41:53
2024.04.03 10:41:56 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.03 10:41:56 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.03 10:41:57 INFO  [warn] 
2024.04.03 10:41:57 INFO  [warn] 	Note: Unresolved dependencies path:
2024.04.03 10:41:57 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.04.03 10:41:57 INFO  [error] sbt.librarymanagement.ResolveException: Error downloading dev.zio:zio-schema-protobuf_3:0.4.17+4-0acf5af7-SNAPSHOT
2024.04.03 10:41:57 INFO  [error]   Not found
2024.04.03 10:41:57 INFO  [error]   Not found
2024.04.03 10:41:57 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localdev.zio\zio-schema-protobuf_3\0.4.17+4-0acf5af7-SNAPSHOT\ivys\ivy.xml
2024.04.03 10:41:57 INFO  [error]   not found: https://repo1.maven.org/maven2/dev/zio/zio-schema-protobuf_3/0.4.17+4-0acf5af7-SNAPSHOT/zio-schema-protobuf_3-0.4.17+4-0acf5af7-SNAPSHOT.pom
2024.04.03 10:41:57 INFO  [error] Error downloading dev.zio:zio-schema_3:0.4.17+4-0acf5af7-SNAPSHOT
2024.04.03 10:41:57 INFO  [error]   Not found
2024.04.03 10:41:57 INFO  [error]   Not found
2024.04.03 10:41:57 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localdev.zio\zio-schema_3\0.4.17+4-0acf5af7-SNAPSHOT\ivys\ivy.xml
2024.04.03 10:41:57 INFO  [error]   not found: https://repo1.maven.org/maven2/dev/zio/zio-schema_3/0.4.17+4-0acf5af7-SNAPSHOT/zio-schema_3-0.4.17+4-0acf5af7-SNAPSHOT.pom
2024.04.03 10:41:57 INFO  [error] Error downloading dev.zio:zio-schema-json_3:0.4.17+4-0acf5af7-SNAPSHOT
2024.04.03 10:41:57 INFO  [error]   Not found
2024.04.03 10:41:57 INFO  [error]   Not found
2024.04.03 10:41:57 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localdev.zio\zio-schema-json_3\0.4.17+4-0acf5af7-SNAPSHOT\ivys\ivy.xml
2024.04.03 10:41:57 INFO  [error]   not found: https://repo1.maven.org/maven2/dev/zio/zio-schema-json_3/0.4.17+4-0acf5af7-SNAPSHOT/zio-schema-json_3-0.4.17+4-0acf5af7-SNAPSHOT.pom
2024.04.03 10:41:57 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.unresolvedWarningOrThrow(CoursierDependencyResolution.scala:344)
2024.04.03 10:41:57 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.$anonfun$update$38(CoursierDependencyResolution.scala:313)
2024.04.03 10:41:57 INFO  [error] 	at scala.util.Either$LeftProjection.map(Either.scala:573)
2024.04.03 10:41:57 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.update(CoursierDependencyResolution.scala:313)
2024.04.03 10:41:57 INFO  [error] 	at sbt.librarymanagement.DependencyResolution.update(DependencyResolution.scala:60)
2024.04.03 10:41:57 INFO  [error] 	at sbt.internal.LibraryManagement$.resolve$1(LibraryManagement.scala:60)
2024.04.03 10:41:57 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$12(LibraryManagement.scala:134)
2024.04.03 10:41:57 INFO  [error] 	at sbt.util.Tracked$.$anonfun$lastOutput$1(Tracked.scala:74)
2024.04.03 10:41:57 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$20(LibraryManagement.scala:147)
2024.04.03 10:41:57 INFO  [error] 	at scala.util.control.Exception$Catch.apply(Exception.scala:228)
2024.04.03 10:41:57 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11(LibraryManagement.scala:147)
2024.04.03 10:41:57 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11$adapted(LibraryManagement.scala:128)
2024.04.03 10:41:57 INFO  [error] 	at sbt.util.Tracked$.$anonfun$inputChangedW$1(Tracked.scala:220)
2024.04.03 10:41:57 INFO  [error] 	at sbt.internal.LibraryManagement$.cachedUpdate(LibraryManagement.scala:161)
2024.04.03 10:41:57 INFO  [error] 	at sbt.Classpaths$.$anonfun$updateTask0$1(Defaults.scala:3801)
2024.04.03 10:41:57 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.04.03 10:41:57 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.04.03 10:41:57 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.04.03 10:41:57 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.04.03 10:41:57 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.04.03 10:41:57 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.04.03 10:41:57 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.04.03 10:41:57 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.04.03 10:41:57 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.04.03 10:41:57 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 10:41:57 INFO  [error] 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
2024.04.03 10:41:57 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 10:41:57 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
2024.04.03 10:41:57 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
2024.04.03 10:41:57 INFO  [error] 	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.03 10:41:57 INFO  [error] (update) sbt.librarymanagement.ResolveException: Error downloading dev.zio:zio-schema-protobuf_3:0.4.17+4-0acf5af7-SNAPSHOT
2024.04.03 10:41:57 INFO  [error]   Not found
2024.04.03 10:41:57 INFO  [error]   Not found
2024.04.03 10:41:57 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localdev.zio\zio-schema-protobuf_3\0.4.17+4-0acf5af7-SNAPSHOT\ivys\ivy.xml
2024.04.03 10:41:57 INFO  [error]   not found: https://repo1.maven.org/maven2/dev/zio/zio-schema-protobuf_3/0.4.17+4-0acf5af7-SNAPSHOT/zio-schema-protobuf_3-0.4.17+4-0acf5af7-SNAPSHOT.pom
2024.04.03 10:41:57 INFO  [error] Error downloading dev.zio:zio-schema_3:0.4.17+4-0acf5af7-SNAPSHOT
2024.04.03 10:41:57 INFO  [error]   Not found
2024.04.03 10:41:57 INFO  [error]   Not found
2024.04.03 10:41:57 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localdev.zio\zio-schema_3\0.4.17+4-0acf5af7-SNAPSHOT\ivys\ivy.xml
2024.04.03 10:41:57 INFO  [error]   not found: https://repo1.maven.org/maven2/dev/zio/zio-schema_3/0.4.17+4-0acf5af7-SNAPSHOT/zio-schema_3-0.4.17+4-0acf5af7-SNAPSHOT.pom
2024.04.03 10:41:57 INFO  [error] Error downloading dev.zio:zio-schema-json_3:0.4.17+4-0acf5af7-SNAPSHOT
2024.04.03 10:41:57 INFO  [error]   Not found
2024.04.03 10:41:57 INFO  [error]   Not found
2024.04.03 10:41:57 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localdev.zio\zio-schema-json_3\0.4.17+4-0acf5af7-SNAPSHOT\ivys\ivy.xml
2024.04.03 10:41:57 INFO  [error]   not found: https://repo1.maven.org/maven2/dev/zio/zio-schema-json_3/0.4.17+4-0acf5af7-SNAPSHOT/zio-schema-json_3-0.4.17+4-0acf5af7-SNAPSHOT.pom
2024.04.03 10:41:57 INFO  [error] Total time: 1 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 10:41:57
2024.04.03 10:41:57 INFO  time: ran 'sbt bloopInstall' in 11s
2024.04.03 10:41:57 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals9033799382231336805\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 10:41:57 INFO  Disconnecting from Bloop session...
2024.04.03 10:41:57 INFO  Shut down connection with build server.
2024.04.03 10:41:57 INFO  Shut down connection with build server.
2024.04.03 10:41:57 INFO  Attempting to connect to the build server...
2024.04.03 10:41:57 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 10:41:57 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 10:41:57 INFO  Attempting to connect to the build server...
2024.04.03 10:41:57 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 10:41:57 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 10:41:57 INFO  time: Connected to build server in 81ms
2024.04.03 10:41:57 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 10:41:59 INFO  time: indexed workspace in 1.07s
2024.04.03 10:41:59 WARN  no build target for: D:\bestgame\src\main\scala\main.scala
2024.04.03 10:42:01 INFO  time: code lens generation in 1.76s
2024.04.03 10:42:20 INFO  Shutting down server
2024.04.03 10:42:20 INFO  shutting down Metals
2024.04.03 10:42:20 INFO  Shut down connection with build server.
2024.04.03 10:42:20 INFO  Shut down connection with build server.
2024.04.03 10:42:20 INFO  Exiting server
2024.04.03 10:42:31 INFO  Started: Metals version 1.2.2 in folders 'D:\bestgame' for client Visual Studio Code 1.87.2.
10:42:31.859 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
10:42:31.860 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
10:42:31.860 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
10:42:31.862 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
10:42:31.862 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
10:42:31.862 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
10:42:31.862 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
10:42:31.862 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
10:42:31.862 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/C:/Users/yidtdr/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
10:42:31.864 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
10:42:31.864 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
10:42:31.864 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
10:42:31.864 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
10:42:31.864 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
10:42:31.864 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
10:42:31.867 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:42:31.867 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
10:42:31.867 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
10:42:31.867 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
10:42:31.868 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
10:42:31.962 [pool-1-thread-1] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:D:\bestgame\.metals\metals (H2 2.2)
10:42:31.962 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
10:42:31.962 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
10:42:31.963 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
10:42:31.963 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
10:42:31.965 [pool-1-thread-1] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
10:42:31.966 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
10:42:31.966 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:42:31.970 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
10:42:31.972 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:42:31.975 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
10:42:31.975 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
10:42:31.975 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
10:42:31.975 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
10:42:31.975 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:42:31.976 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
10:42:31.976 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
10:42:31.976 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
10:42:31.976 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
10:42:31.976 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
10:42:31.982 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.012s)
10:42:31.983 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
10:42:31.986 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
10:42:31.989 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
10:42:31.993 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 34 of 100M
ΰοπ. 03, 2024 10:42:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1
2024.04.03 10:42:32 INFO  Attempting to connect to the build server...
2024.04.03 10:42:32 INFO  skipping build import with status 'Dismissed'
2024.04.03 10:42:32 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 10:42:32 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 10:42:32 INFO  Attempting to connect to the build server...
2024.04.03 10:42:32 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 10:42:32 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 10:42:32 INFO  time: Connected to build server in 0.51s
2024.04.03 10:42:32 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 10:42:33 INFO  time: Imported build in 0.12s
2024.04.03 10:42:36 INFO  no build target found for D:\bestgame\build.sbt. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.03 10:42:36 INFO  skipping build import with status 'Dismissed'
ΰοπ. 03, 2024 10:42:36 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11
ΰοπ. 03, 2024 10:42:36 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13
ΰοπ. 03, 2024 10:42:36 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10
2024.04.03 10:42:36 INFO  skipping build import with status 'Dismissed'
ΰοπ. 03, 2024 10:42:37 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15
ΰοπ. 03, 2024 10:42:37 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17
2024.04.03 10:42:37 INFO  skipping build import with status 'Dismissed'
2024.04.03 10:42:37 INFO  skipping build import with status 'Dismissed'
2024.04.03 10:42:38 INFO  time: indexed workspace in 1.93s
2024.04.03 10:42:39 INFO  skipping build import with status 'Dismissed'
2024.04.03 10:42:40 INFO  time: code lens generation in 1.42s
2024.04.03 10:42:40 INFO  time: code lens generation in 1.42s
2024.04.03 10:42:40 INFO  time: code lens generation in 1.42s
2024.04.03 10:42:40 INFO  time: code lens generation in 1.42s
2024.04.03 10:44:11 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals18427202015274497823\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 10:44:13 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 10:44:13 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 10:44:14 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 10:44:14 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 10:44:14 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 10:44:17 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 10:44:17 INFO  [success] Total time: 2 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 10:44:17
2024.04.03 10:44:17 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.03 10:44:17 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.03 10:44:19 INFO  [warn] 
2024.04.03 10:44:19 INFO  [warn] 	Note: Unresolved dependencies path:
2024.04.03 10:44:19 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.04.03 10:44:19 INFO  [error] sbt.librarymanagement.ResolveException: Error downloading dev.zio:zio-schema-protobuf_3:0.4.17+4-0acf5af7-SNAPSHOT
2024.04.03 10:44:19 INFO  [error]   Not found
2024.04.03 10:44:19 INFO  [error]   Not found
2024.04.03 10:44:19 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localdev.zio\zio-schema-protobuf_3\0.4.17+4-0acf5af7-SNAPSHOT\ivys\ivy.xml
2024.04.03 10:44:19 INFO  [error]   not found: https://repo1.maven.org/maven2/dev/zio/zio-schema-protobuf_3/0.4.17+4-0acf5af7-SNAPSHOT/zio-schema-protobuf_3-0.4.17+4-0acf5af7-SNAPSHOT.pom
2024.04.03 10:44:19 INFO  [error] Error downloading dev.zio:zio-schema_3:0.4.17+4-0acf5af7-SNAPSHOT
2024.04.03 10:44:19 INFO  [error]   Not found
2024.04.03 10:44:19 INFO  [error]   Not found
2024.04.03 10:44:19 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localdev.zio\zio-schema_3\0.4.17+4-0acf5af7-SNAPSHOT\ivys\ivy.xml
2024.04.03 10:44:19 INFO  [error]   not found: https://repo1.maven.org/maven2/dev/zio/zio-schema_3/0.4.17+4-0acf5af7-SNAPSHOT/zio-schema_3-0.4.17+4-0acf5af7-SNAPSHOT.pom
2024.04.03 10:44:19 INFO  [error] Error downloading dev.zio:zio-schema-json_3:0.4.17+4-0acf5af7-SNAPSHOT
2024.04.03 10:44:19 INFO  [error]   Not found
2024.04.03 10:44:19 INFO  [error]   Not found
2024.04.03 10:44:19 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localdev.zio\zio-schema-json_3\0.4.17+4-0acf5af7-SNAPSHOT\ivys\ivy.xml
2024.04.03 10:44:19 INFO  [error]   not found: https://repo1.maven.org/maven2/dev/zio/zio-schema-json_3/0.4.17+4-0acf5af7-SNAPSHOT/zio-schema-json_3-0.4.17+4-0acf5af7-SNAPSHOT.pom
2024.04.03 10:44:19 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.unresolvedWarningOrThrow(CoursierDependencyResolution.scala:344)
2024.04.03 10:44:19 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.$anonfun$update$38(CoursierDependencyResolution.scala:313)
2024.04.03 10:44:19 INFO  [error] 	at scala.util.Either$LeftProjection.map(Either.scala:573)
2024.04.03 10:44:19 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.update(CoursierDependencyResolution.scala:313)
2024.04.03 10:44:19 INFO  [error] 	at sbt.librarymanagement.DependencyResolution.update(DependencyResolution.scala:60)
2024.04.03 10:44:19 INFO  [error] 	at sbt.internal.LibraryManagement$.resolve$1(LibraryManagement.scala:60)
2024.04.03 10:44:19 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$12(LibraryManagement.scala:134)
2024.04.03 10:44:19 INFO  [error] 	at sbt.util.Tracked$.$anonfun$lastOutput$1(Tracked.scala:74)
2024.04.03 10:44:19 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$20(LibraryManagement.scala:147)
2024.04.03 10:44:19 INFO  [error] 	at scala.util.control.Exception$Catch.apply(Exception.scala:228)
2024.04.03 10:44:19 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11(LibraryManagement.scala:147)
2024.04.03 10:44:19 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11$adapted(LibraryManagement.scala:128)
2024.04.03 10:44:19 INFO  [error] 	at sbt.util.Tracked$.$anonfun$inputChangedW$1(Tracked.scala:220)
2024.04.03 10:44:19 INFO  [error] 	at sbt.internal.LibraryManagement$.cachedUpdate(LibraryManagement.scala:161)
2024.04.03 10:44:19 INFO  [error] 	at sbt.Classpaths$.$anonfun$updateTask0$1(Defaults.scala:3801)
2024.04.03 10:44:19 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.04.03 10:44:19 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.04.03 10:44:19 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.04.03 10:44:19 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.04.03 10:44:19 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.04.03 10:44:19 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.04.03 10:44:19 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.04.03 10:44:19 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.04.03 10:44:19 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.04.03 10:44:19 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 10:44:19 INFO  [error] 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
2024.04.03 10:44:19 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 10:44:19 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
2024.04.03 10:44:19 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
2024.04.03 10:44:19 INFO  [error] 	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.03 10:44:19 INFO  [error] (update) sbt.librarymanagement.ResolveException: Error downloading dev.zio:zio-schema-protobuf_3:0.4.17+4-0acf5af7-SNAPSHOT
2024.04.03 10:44:19 INFO  [error]   Not found
2024.04.03 10:44:19 INFO  [error]   Not found
2024.04.03 10:44:19 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localdev.zio\zio-schema-protobuf_3\0.4.17+4-0acf5af7-SNAPSHOT\ivys\ivy.xml
2024.04.03 10:44:19 INFO  [error]   not found: https://repo1.maven.org/maven2/dev/zio/zio-schema-protobuf_3/0.4.17+4-0acf5af7-SNAPSHOT/zio-schema-protobuf_3-0.4.17+4-0acf5af7-SNAPSHOT.pom
2024.04.03 10:44:19 INFO  [error] Error downloading dev.zio:zio-schema_3:0.4.17+4-0acf5af7-SNAPSHOT
2024.04.03 10:44:19 INFO  [error]   Not found
2024.04.03 10:44:19 INFO  [error]   Not found
2024.04.03 10:44:19 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localdev.zio\zio-schema_3\0.4.17+4-0acf5af7-SNAPSHOT\ivys\ivy.xml
2024.04.03 10:44:19 INFO  [error]   not found: https://repo1.maven.org/maven2/dev/zio/zio-schema_3/0.4.17+4-0acf5af7-SNAPSHOT/zio-schema_3-0.4.17+4-0acf5af7-SNAPSHOT.pom
2024.04.03 10:44:19 INFO  [error] Error downloading dev.zio:zio-schema-json_3:0.4.17+4-0acf5af7-SNAPSHOT
2024.04.03 10:44:19 INFO  [error]   Not found
2024.04.03 10:44:19 INFO  [error]   Not found
2024.04.03 10:44:19 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localdev.zio\zio-schema-json_3\0.4.17+4-0acf5af7-SNAPSHOT\ivys\ivy.xml
2024.04.03 10:44:19 INFO  [error]   not found: https://repo1.maven.org/maven2/dev/zio/zio-schema-json_3/0.4.17+4-0acf5af7-SNAPSHOT/zio-schema-json_3-0.4.17+4-0acf5af7-SNAPSHOT.pom
2024.04.03 10:44:19 INFO  [error] Total time: 1 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 10:44:19
2024.04.03 10:44:19 INFO  time: ran 'sbt bloopInstall' in 8.27s
2024.04.03 10:44:19 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals18427202015274497823\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 10:44:19 INFO  Disconnecting from Bloop session...
2024.04.03 10:44:19 INFO  Shut down connection with build server.
2024.04.03 10:44:19 INFO  Shut down connection with build server.
2024.04.03 10:44:19 INFO  Attempting to connect to the build server...
2024.04.03 10:44:19 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 10:44:19 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 10:44:19 INFO  Attempting to connect to the build server...
2024.04.03 10:44:19 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 10:44:19 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 10:44:19 INFO  time: Connected to build server in 84ms
2024.04.03 10:44:19 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 10:44:21 INFO  time: indexed workspace in 1s
2024.04.03 10:44:23 INFO  time: code lens generation in 2.21s
2024.04.03 10:46:59 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals1951155102332171461\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 10:47:00 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 10:47:00 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 10:47:02 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 10:47:02 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 10:47:03 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 10:47:06 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 10:47:06 INFO  [success] Total time: 3 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 10:47:06
2024.04.03 10:47:09 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.03 10:47:09 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.03 10:47:15 INFO  [success] Generated .bloop\bestgame.json
2024.04.03 10:47:15 INFO  [success] Generated .bloop\bestgame-test.json
2024.04.03 10:47:15 INFO  [success] Total time: 5 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 10:47:15
2024.04.03 10:47:15 INFO  time: ran 'sbt bloopInstall' in 15s
2024.04.03 10:47:15 INFO  Disconnecting from Bloop session...
2024.04.03 10:47:15 INFO  Shut down connection with build server.
2024.04.03 10:47:15 INFO  Shut down connection with build server.
2024.04.03 10:47:15 INFO  Attempting to connect to the build server...
2024.04.03 10:47:15 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 10:47:15 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 10:47:15 INFO  Attempting to connect to the build server...
2024.04.03 10:47:15 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 10:47:15 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 10:47:15 INFO  time: Connected to build server in 0.1s
2024.04.03 10:47:15 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 10:47:16 INFO  time: indexed workspace in 1.63s
2024.04.03 10:47:20 INFO  time: code lens generation in 2.79s
2024.04.03 10:47:41 INFO  compiling bestgame (1 scala source)
2024.04.03 10:47:45 INFO  time: compiled bestgame in 4.7s
2024.04.03 10:48:37 INFO  compiling bestgame (1 scala source)
2024.04.03 10:48:37 INFO  time: compiled bestgame in 0.99s
2024.04.03 10:49:36 INFO  compiling bestgame (1 scala source)
2024.04.03 10:49:36 INFO  time: compiled bestgame in 0.32s
2024.04.03 10:49:46 INFO  compiling bestgame (1 scala source)
2024.04.03 10:49:46 INFO  time: compiled bestgame in 0.89s
2024.04.03 10:50:32 INFO  compiling bestgame (1 scala source)
2024.04.03 10:50:32 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 10:50:33 INFO  time: compiled bestgame in 1.09s
2024.04.03 10:53:33 INFO  compiling bestgame (1 scala source)
2024.04.03 10:53:35 INFO  time: compiled bestgame in 1.07s
ΰοπ. 03, 2024 10:55:15 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 260
2024.04.03 10:55:47 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 10:55:47 INFO  compiling bestgame (1 scala source)
2024.04.03 10:55:48 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 10:55:48 INFO  time: compiled bestgame in 1.05s
2024.04.03 10:55:48 INFO  compiling bestgame (1 scala source)
2024.04.03 10:55:50 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 10:55:51 INFO  time: compiled bestgame in 2.34s
2024.04.03 10:55:51 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 10:55:58 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 10:55:59 INFO  compiling bestgame (1 scala source)
2024.04.03 10:55:59 INFO  time: compiled bestgame in 0.65s
2024.04.03 10:56:00 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 10:56:07 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 10:56:07 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 10:56:08 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 10:56:09 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 10:56:10 INFO  compiling bestgame (1 scala source)
2024.04.03 10:56:10 INFO  time: compiled bestgame in 0.52s
2024.04.03 10:56:11 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 10:56:19 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 10:56:21 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 10:56:22 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 10:56:22 INFO  compiling bestgame (1 scala source)
2024.04.03 10:56:22 INFO  time: compiled bestgame in 0.47s
2024.04.03 10:56:32 INFO  compiling bestgame (1 scala source)
2024.04.03 10:56:32 INFO  time: compiled bestgame in 0.46s
2024.04.03 10:56:44 INFO  compiling bestgame (1 scala source)
2024.04.03 10:56:44 INFO  time: compiled bestgame in 0.35s
2024.04.03 10:57:49 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\main.scala
scala.meta.tokenizers.TokenizeException: <input>:8: error: unclosed string literal
  Method.ANY / "*" -> handler(Response.text("),
                                            ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 10:58:14 INFO  compiling bestgame (1 scala source)
2024.04.03 10:58:14 INFO  time: compiled bestgame in 0.47s
ΰοπ. 03, 2024 10:58:50 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 925
2024.04.03 10:59:05 INFO  compiling bestgame (1 scala source)
2024.04.03 10:59:05 INFO  time: compiled bestgame in 0.52s
2024.04.03 11:01:37 INFO  compiling bestgame (1 scala source)
2024.04.03 11:01:37 INFO  time: compiled bestgame in 0.57s
2024.04.03 11:02:22 INFO  compiling bestgame (1 scala source)
2024.04.03 11:02:22 INFO  time: compiled bestgame in 0.43s
2024.04.03 11:05:08 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\main.scala
scala.meta.tokenizers.TokenizeException: <input>:8: error: unclosed string interpolation
  Method.ANY / "*" -> handler(Response(body = Body.fromString"))),
                                                              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 11:05:09 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\main.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed string literal
  "))),
  ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

ΰοπ. 03, 2024 11:05:11 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1275
2024.04.03 11:05:27 INFO  compiling bestgame (1 scala source)
2024.04.03 11:05:27 INFO  time: compiled bestgame in 0.61s
2024.04.03 11:08:01 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\main.scala
scala.meta.tokenizers.TokenizeException: <input>:10: error: `$$', `$'ident, `$'this, `$'BlockExpr`$'_
  Method.ANY / "*" -> handler(Response(body = Body.fromString(s"<div><h1>Pizda</h1>$ da</div>"))),
                                                                ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:649)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 11:08:47 INFO  compiling bestgame (1 scala source)
2024.04.03 11:08:47 INFO  time: compiled bestgame in 0.81s
ΰοπ. 03, 2024 11:08:49 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1628
2024.04.03 11:10:14 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\main.scala
scala.meta.tokenizers.TokenizeException: <input>:10: error: Invalid literal number
  Method.ANY / "*" -> handler(() => (k+= 1Response(body = Body.fromString(s"<div><h1>Pizda</h1>${k} da</div>")))),
                                         ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:820)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfUncertainToken$1(LegacyScanner.scala:864)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:872)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:335)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 11:10:44 INFO  compiling bestgame (1 scala source)
2024.04.03 11:10:44 INFO  time: compiled bestgame in 0.67s
ΰοπ. 03, 2024 11:10:47 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-03\r_compiler-error_(bestgame)_11-10-47-407.md
2024.04.03 11:11:24 INFO  compiling bestgame (1 scala source)
2024.04.03 11:11:24 INFO  time: compiled bestgame in 0.14s
2024.04.03 11:15:47 INFO  compiling bestgame (1 scala source)
2024.04.03 11:15:47 INFO  time: compiled bestgame in 0.53s
ΰοπ. 03, 2024 11:16:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2166
2024.04.03 11:16:05 INFO  compiling bestgame (1 scala source)
2024.04.03 11:16:05 INFO  time: compiled bestgame in 0.41s
2024.04.03 11:16:31 INFO  compiling bestgame (1 scala source)
2024.04.03 11:16:31 INFO  time: compiled bestgame in 0.14s
2024.04.03 11:16:43 INFO  compiling bestgame (1 scala source)
2024.04.03 11:16:43 INFO  time: compiled bestgame in 0.43s
ΰοπ. 03, 2024 11:16:47 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2275
2024.04.03 11:16:49 INFO  compiling bestgame (1 scala source)
2024.04.03 11:16:49 INFO  time: compiled bestgame in 0.71s
2024.04.03 11:16:54 INFO  compiling bestgame (1 scala source)
2024.04.03 11:16:54 INFO  time: compiled bestgame in 0.48s
2024.04.03 11:17:16 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\main.scala
scala.meta.tokenizers.TokenizeException: <input>:10: error: Invalid literal number
  Method.ANY / "*" -> handler{(req: Request) => Response(body = k+=1Body.fromString(s"<div><h1>Pizda</h1>${k} da</div>"))},
                                                                   ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:820)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfUncertainToken$1(LegacyScanner.scala:864)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:872)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:335)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

ΰοπ. 03, 2024 11:17:27 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2415
2024.04.03 11:17:32 INFO  compiling bestgame (1 scala source)
2024.04.03 11:17:32 INFO  time: compiled bestgame in 0.47s
2024.04.03 11:17:36 INFO  compiling bestgame (1 scala source)
2024.04.03 11:17:36 INFO  time: compiled bestgame in 0.42s
2024.04.03 11:18:20 INFO  compiling bestgame (1 scala source)
2024.04.03 11:18:20 INFO  time: compiled bestgame in 91ms
2024.04.03 11:19:08 INFO  compiling bestgame (1 scala source)
2024.04.03 11:19:08 INFO  time: compiled bestgame in 0.41s
2024.04.03 11:20:14 INFO  compiling bestgame (1 scala source)
2024.04.03 11:20:14 INFO  time: compiled bestgame in 0.38s
2024.04.03 11:20:21 INFO  compiling bestgame (1 scala source)
2024.04.03 11:20:21 INFO  time: compiled bestgame in 0.38s
2024.04.03 11:20:31 INFO  compiling bestgame (1 scala source)
2024.04.03 11:20:31 INFO  time: compiled bestgame in 0.13s
2024.04.03 11:20:32 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 11:20:33 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 11:20:43 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 11:20:48 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 11:20:49 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 11:20:51 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 11:20:52 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 11:20:52 INFO  compiling bestgame (1 scala source)
2024.04.03 11:20:52 INFO  time: compiled bestgame in 0.53s
2024.04.03 11:20:53 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 11:20:57 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 11:20:58 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 11:20:59 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 11:21:16 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 11:21:16 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 11:21:16 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 11:21:16 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 11:21:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.03 11:21:19 INFO  compiling bestgame (1 scala source)
2024.04.03 11:21:19 INFO  time: compiled bestgame in 0.33s
2024.04.03 11:36:02 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals8027993124389427626\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 11:36:04 INFO  sbt thinks that server is already booting because of this exception:
2024.04.03 11:36:04 ERROR sbt.internal.ServerAlreadyBootingException: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-1466779760368203317_lock, error 5
2024.04.03 11:36:04 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:357)
2024.04.03 11:36:04 ERROR 	at sbt.internal.BootServerSocket.<init>(BootServerSocket.java:296)
2024.04.03 11:36:04 ERROR 	at sbt.xMain$.getSocketOrExit(Main.scala:152)
2024.04.03 11:36:04 ERROR 	at sbt.xMain$.bootServerSocket$lzycompute$1(Main.scala:78)
2024.04.03 11:36:04 ERROR 	at sbt.xMain$.bootServerSocket$1(Main.scala:78)
2024.04.03 11:36:04 ERROR 	at sbt.xMain$.withStreams$1(Main.scala:86)
2024.04.03 11:36:04 ERROR 	at sbt.xMain$.run(Main.scala:123)
2024.04.03 11:36:04 ERROR 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
2024.04.03 11:36:04 ERROR 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
2024.04.03 11:36:04 ERROR 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
2024.04.03 11:36:04 ERROR 	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
2024.04.03 11:36:04 ERROR 	at sbt.internal.XMainConfiguration.run(XMainConfiguration.java:59)
2024.04.03 11:36:04 ERROR 	at sbt.xMain.run(Main.scala:47)
2024.04.03 11:36:04 ERROR 	at xsbt.boot.Launch$.$anonfun$run$1(Launch.scala:149)
2024.04.03 11:36:04 ERROR 	at xsbt.boot.Launch$.withContextLoader(Launch.scala:176)
2024.04.03 11:36:04 ERROR 	at xsbt.boot.Launch$.run(Launch.scala:149)
2024.04.03 11:36:04 ERROR 	at xsbt.boot.Launch$.$anonfun$apply$1(Launch.scala:44)
2024.04.03 11:36:04 ERROR 	at xsbt.boot.Launch$.launch(Launch.scala:159)
2024.04.03 11:36:04 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:44)
2024.04.03 11:36:04 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:21)
2024.04.03 11:36:04 ERROR 	at xsbt.boot.Boot$.runImpl(Boot.scala:78)
2024.04.03 11:36:04 ERROR 	at xsbt.boot.Boot$.run(Boot.scala:73)
2024.04.03 11:36:04 ERROR 	at xsbt.boot.Boot$.main(Boot.scala:21)
2024.04.03 11:36:04 ERROR 	at xsbt.boot.Boot.main(Boot.scala)
2024.04.03 11:36:04 ERROR Caused by: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-1466779760368203317_lock, error 5
2024.04.03 11:36:04 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:129)
2024.04.03 11:36:04 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:48)
2024.04.03 11:36:04 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:351)
2024.04.03 11:36:04 ERROR 	... 23 more
2024.04.03 11:36:04 INFO  time: ran 'sbt bloopInstall' in 1.26s
2024.04.03 11:36:04 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals8027993124389427626\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 11:36:04 INFO  Disconnecting from Bloop session...
2024.04.03 11:36:04 INFO  Shut down connection with build server.
2024.04.03 11:36:04 INFO  Shut down connection with build server.
2024.04.03 11:36:04 INFO  Attempting to connect to the build server...
2024.04.03 11:36:04 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 11:36:04 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 11:36:04 INFO  Attempting to connect to the build server...
2024.04.03 11:36:04 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 11:36:04 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 11:36:04 INFO  time: Connected to build server in 0.18s
2024.04.03 11:36:04 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 11:36:06 INFO  time: indexed workspace in 2.37s
2024.04.03 11:36:10 INFO  time: code lens generation in 3.51s
ΰοπ. 03, 2024 11:36:52 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-03\r_compiler-error_(bestgame-build)_11-36-52-701.md
2024.04.03 11:36:52 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\plugins.sbt
scala.meta.tokenizers.TokenizeException: <input>:7: error: unclosed string literal
addSbtPlugin("io.spray" % "sbt-revolver" % "0.10.0
                                           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 11:37:01 INFO  skipping build import with status 'Installed'
2024.04.03 11:37:05 INFO  skipping build import with status 'Installed'
2024.04.03 11:37:43 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals2442646894723746458\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 11:37:43 INFO  sbt thinks that server is already booting because of this exception:
2024.04.03 11:37:43 ERROR sbt.internal.ServerAlreadyBootingException: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-1466779760368203317_lock, error 5
2024.04.03 11:37:43 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:357)
2024.04.03 11:37:43 ERROR 	at sbt.internal.BootServerSocket.<init>(BootServerSocket.java:296)
2024.04.03 11:37:43 ERROR 	at sbt.xMain$.getSocketOrExit(Main.scala:152)
2024.04.03 11:37:43 ERROR 	at sbt.xMain$.bootServerSocket$lzycompute$1(Main.scala:78)
2024.04.03 11:37:43 ERROR 	at sbt.xMain$.bootServerSocket$1(Main.scala:78)
2024.04.03 11:37:43 ERROR 	at sbt.xMain$.withStreams$1(Main.scala:86)
2024.04.03 11:37:43 ERROR 	at sbt.xMain$.run(Main.scala:123)
2024.04.03 11:37:43 ERROR 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
2024.04.03 11:37:43 ERROR 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
2024.04.03 11:37:43 ERROR 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
2024.04.03 11:37:43 ERROR 	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
2024.04.03 11:37:43 ERROR 	at sbt.internal.XMainConfiguration.run(XMainConfiguration.java:59)
2024.04.03 11:37:43 ERROR 	at sbt.xMain.run(Main.scala:47)
2024.04.03 11:37:43 ERROR 	at xsbt.boot.Launch$.$anonfun$run$1(Launch.scala:149)
2024.04.03 11:37:43 ERROR 	at xsbt.boot.Launch$.withContextLoader(Launch.scala:176)
2024.04.03 11:37:43 ERROR 	at xsbt.boot.Launch$.run(Launch.scala:149)
2024.04.03 11:37:43 ERROR 	at xsbt.boot.Launch$.$anonfun$apply$1(Launch.scala:44)
2024.04.03 11:37:43 ERROR 	at xsbt.boot.Launch$.launch(Launch.scala:159)
2024.04.03 11:37:43 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:44)
2024.04.03 11:37:43 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:21)
2024.04.03 11:37:43 ERROR 	at xsbt.boot.Boot$.runImpl(Boot.scala:78)
2024.04.03 11:37:43 ERROR 	at xsbt.boot.Boot$.run(Boot.scala:73)
2024.04.03 11:37:43 ERROR 	at xsbt.boot.Boot$.main(Boot.scala:21)
2024.04.03 11:37:43 ERROR 	at xsbt.boot.Boot.main(Boot.scala)
2024.04.03 11:37:43 ERROR Caused by: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-1466779760368203317_lock, error 5
2024.04.03 11:37:43 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:129)
2024.04.03 11:37:43 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:48)
2024.04.03 11:37:43 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:351)
2024.04.03 11:37:43 ERROR 	... 23 more
2024.04.03 11:37:44 INFO  time: ran 'sbt bloopInstall' in 0.82s
2024.04.03 11:37:44 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals2442646894723746458\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 11:37:43 INFO  Disconnecting from Bloop session...
2024.04.03 11:37:44 INFO  Shut down connection with build server.
2024.04.03 11:37:43 INFO  Shut down connection with build server.
2024.04.03 11:37:44 INFO  Attempting to connect to the build server...
2024.04.03 11:37:44 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 11:37:44 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 11:37:44 INFO  Attempting to connect to the build server...
2024.04.03 11:37:44 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 11:37:44 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 11:37:44 INFO  time: Connected to build server in 61ms
2024.04.03 11:37:44 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 11:37:45 INFO  time: indexed workspace in 1.48s
2024.04.03 11:37:48 INFO  time: code lens generation in 2.23s
ΰοπ. 03, 2024 11:38:52 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
ΰοπ. 03, 2024 11:38:52 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-03\r_compiler-error_(bestgame-build)_11-38-52-315.md
2024.04.03 11:38:55 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals12884319669408724044\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 11:38:57 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 11:38:57 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 11:38:59 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 11:38:59 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 11:39:00 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 11:39:02 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 11:39:02 INFO  [success] Total time: 2 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 11:39:02
2024.04.03 11:39:05 INFO  [info] loading settings for project bestgame from build.sbt,plugins.sbt ...
2024.04.03 11:39:05 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.03 11:39:07 INFO  [warn] 
2024.04.03 11:39:07 INFO  [warn] 	Note: Some unresolved dependencies have extra attributes.  Check that these dependencies exist with the requested attributes.
2024.04.03 11:39:07 INFO  [warn] 		io.spray:sbt-revolver:0.10.0 (sbtVersion=1.0, scalaVersion=3)
2024.04.03 11:39:07 INFO  [warn] 
2024.04.03 11:39:07 INFO  [warn] 	Note: Unresolved dependencies path:
2024.04.03 11:39:07 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.04.03 11:39:07 INFO  [warn] Removed stale D:\bestgame\.bloop\bestgame-test.json
2024.04.03 11:39:07 INFO  [warn] Removed stale D:\bestgame\.bloop\bestgame.json
2024.04.03 11:39:07 INFO  [error] sbt.librarymanagement.ResolveException: Error downloading io.spray:sbt-revolver;sbtVersion=1.0;scalaVersion=3:0.10.0
2024.04.03 11:39:07 INFO  [error]   Not found
2024.04.03 11:39:07 INFO  [error]   Not found
2024.04.03 11:39:07 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localio.spray\sbt-revolver\scala_3\sbt_1.0\0.10.0\ivys\ivy.xml
2024.04.03 11:39:07 INFO  [error]   not found: https://repo1.maven.org/maven2/io/spray/sbt-revolver_3_1.0/0.10.0/sbt-revolver-0.10.0.pom
2024.04.03 11:39:07 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.unresolvedWarningOrThrow(CoursierDependencyResolution.scala:344)
2024.04.03 11:39:07 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.$anonfun$update$38(CoursierDependencyResolution.scala:313)
2024.04.03 11:39:07 INFO  [error] 	at scala.util.Either$LeftProjection.map(Either.scala:573)
2024.04.03 11:39:07 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.update(CoursierDependencyResolution.scala:313)
2024.04.03 11:39:07 INFO  [error] 	at sbt.librarymanagement.DependencyResolution.update(DependencyResolution.scala:60)
2024.04.03 11:39:07 INFO  [error] 	at sbt.internal.LibraryManagement$.resolve$1(LibraryManagement.scala:60)
2024.04.03 11:39:07 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$12(LibraryManagement.scala:134)
2024.04.03 11:39:07 INFO  [error] 	at sbt.util.Tracked$.$anonfun$lastOutput$1(Tracked.scala:74)
2024.04.03 11:39:07 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$20(LibraryManagement.scala:147)
2024.04.03 11:39:07 INFO  [error] 	at scala.util.control.Exception$Catch.apply(Exception.scala:228)
2024.04.03 11:39:07 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11(LibraryManagement.scala:147)
2024.04.03 11:39:07 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11$adapted(LibraryManagement.scala:128)
2024.04.03 11:39:07 INFO  [error] 	at sbt.util.Tracked$.$anonfun$inputChangedW$1(Tracked.scala:220)
2024.04.03 11:39:07 INFO  [error] 	at sbt.internal.LibraryManagement$.cachedUpdate(LibraryManagement.scala:161)
2024.04.03 11:39:07 INFO  [error] 	at sbt.Classpaths$.$anonfun$updateTask0$1(Defaults.scala:3801)
2024.04.03 11:39:07 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.04.03 11:39:07 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.04.03 11:39:07 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.04.03 11:39:07 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.04.03 11:39:07 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.04.03 11:39:07 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.04.03 11:39:07 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.04.03 11:39:07 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.04.03 11:39:07 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.04.03 11:39:07 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 11:39:07 INFO  [error] 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
2024.04.03 11:39:07 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 11:39:07 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
2024.04.03 11:39:07 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
2024.04.03 11:39:07 INFO  [error] 	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.03 11:39:07 INFO  [error] (update) sbt.librarymanagement.ResolveException: Error downloading io.spray:sbt-revolver;sbtVersion=1.0;scalaVersion=3:0.10.0
2024.04.03 11:39:07 INFO  [error]   Not found
2024.04.03 11:39:07 INFO  [error]   Not found
2024.04.03 11:39:07 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localio.spray\sbt-revolver\scala_3\sbt_1.0\0.10.0\ivys\ivy.xml
2024.04.03 11:39:07 INFO  [error]   not found: https://repo1.maven.org/maven2/io/spray/sbt-revolver_3_1.0/0.10.0/sbt-revolver-0.10.0.pom
2024.04.03 11:39:07 INFO  [error] Total time: 2 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 11:39:07
2024.04.03 11:39:07 INFO  time: ran 'sbt bloopInstall' in 11s
2024.04.03 11:39:07 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals12884319669408724044\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 11:39:07 INFO  Disconnecting from Bloop session...
2024.04.03 11:39:07 INFO  Shut down connection with build server.
2024.04.03 11:39:07 INFO  Shut down connection with build server.
2024.04.03 11:39:07 INFO  Attempting to connect to the build server...
2024.04.03 11:39:07 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 11:39:07 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 11:39:07 INFO  Attempting to connect to the build server...
2024.04.03 11:39:07 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 11:39:07 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 11:39:07 INFO  time: Connected to build server in 79ms
2024.04.03 11:39:07 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 11:39:08 INFO  time: indexed workspace in 0.97s
2024.04.03 11:39:08 WARN  no build target for: D:\bestgame\src\main\scala\main.scala
2024.04.03 11:39:10 INFO  time: code lens generation in 2.12s
ΰοπ. 03, 2024 11:39:25 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3175
2024.04.03 11:39:32 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals5130607924045792554\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 11:39:34 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 11:39:34 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 11:39:35 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 11:39:37 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 11:39:37 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 11:39:40 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 11:39:40 INFO  [success] Total time: 3 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 11:39:40
2024.04.03 11:39:40 INFO  [info] loading settings for project bestgame from build.sbt,plugins.sbt ...
2024.04.03 11:39:40 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.03 11:39:42 INFO  [warn] 
2024.04.03 11:39:42 INFO  [warn] 	Note: Some unresolved dependencies have extra attributes.  Check that these dependencies exist with the requested attributes.
2024.04.03 11:39:42 INFO  [warn] 		io.spray:sbt-revolver:0.10.0 (sbtVersion=1.0, scalaVersion=3)
2024.04.03 11:39:42 INFO  [warn] 
2024.04.03 11:39:42 INFO  [warn] 	Note: Unresolved dependencies path:
2024.04.03 11:39:42 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.04.03 11:39:42 INFO  [error] sbt.librarymanagement.ResolveException: Error downloading io.spray:sbt-revolver;sbtVersion=1.0;scalaVersion=3:0.10.0
2024.04.03 11:39:42 INFO  [error]   Not found
2024.04.03 11:39:42 INFO  [error]   Not found
2024.04.03 11:39:42 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localio.spray\sbt-revolver\scala_3\sbt_1.0\0.10.0\ivys\ivy.xml
2024.04.03 11:39:42 INFO  [error]   not found: https://repo1.maven.org/maven2/io/spray/sbt-revolver_3_1.0/0.10.0/sbt-revolver-0.10.0.pom
2024.04.03 11:39:42 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.unresolvedWarningOrThrow(CoursierDependencyResolution.scala:344)
2024.04.03 11:39:42 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.$anonfun$update$38(CoursierDependencyResolution.scala:313)
2024.04.03 11:39:42 INFO  [error] 	at scala.util.Either$LeftProjection.map(Either.scala:573)
2024.04.03 11:39:42 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.update(CoursierDependencyResolution.scala:313)
2024.04.03 11:39:42 INFO  [error] 	at sbt.librarymanagement.DependencyResolution.update(DependencyResolution.scala:60)
2024.04.03 11:39:42 INFO  [error] 	at sbt.internal.LibraryManagement$.resolve$1(LibraryManagement.scala:60)
2024.04.03 11:39:42 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$12(LibraryManagement.scala:134)
2024.04.03 11:39:42 INFO  [error] 	at sbt.util.Tracked$.$anonfun$lastOutput$1(Tracked.scala:74)
2024.04.03 11:39:42 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$20(LibraryManagement.scala:147)
2024.04.03 11:39:42 INFO  [error] 	at scala.util.control.Exception$Catch.apply(Exception.scala:228)
2024.04.03 11:39:42 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11(LibraryManagement.scala:147)
2024.04.03 11:39:42 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11$adapted(LibraryManagement.scala:128)
2024.04.03 11:39:42 INFO  [error] 	at sbt.util.Tracked$.$anonfun$inputChangedW$1(Tracked.scala:220)
2024.04.03 11:39:42 INFO  [error] 	at sbt.internal.LibraryManagement$.cachedUpdate(LibraryManagement.scala:161)
2024.04.03 11:39:42 INFO  [error] 	at sbt.Classpaths$.$anonfun$updateTask0$1(Defaults.scala:3801)
2024.04.03 11:39:42 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.04.03 11:39:42 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.04.03 11:39:42 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.04.03 11:39:42 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.04.03 11:39:42 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.04.03 11:39:42 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.04.03 11:39:42 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.04.03 11:39:42 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.04.03 11:39:42 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.04.03 11:39:42 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 11:39:42 INFO  [error] 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
2024.04.03 11:39:42 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 11:39:42 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
2024.04.03 11:39:42 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
2024.04.03 11:39:42 INFO  [error] 	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.03 11:39:42 INFO  [error] (update) sbt.librarymanagement.ResolveException: Error downloading io.spray:sbt-revolver;sbtVersion=1.0;scalaVersion=3:0.10.0
2024.04.03 11:39:42 INFO  [error]   Not found
2024.04.03 11:39:42 INFO  [error]   Not found
2024.04.03 11:39:42 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localio.spray\sbt-revolver\scala_3\sbt_1.0\0.10.0\ivys\ivy.xml
2024.04.03 11:39:42 INFO  [error]   not found: https://repo1.maven.org/maven2/io/spray/sbt-revolver_3_1.0/0.10.0/sbt-revolver-0.10.0.pom
2024.04.03 11:39:42 INFO  [error] Total time: 1 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 11:39:42
2024.04.03 11:39:42 INFO  time: ran 'sbt bloopInstall' in 9.79s
2024.04.03 11:39:42 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals5130607924045792554\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 11:39:42 INFO  Disconnecting from Bloop session...
2024.04.03 11:39:42 INFO  Shut down connection with build server.
2024.04.03 11:39:42 INFO  Shut down connection with build server.
2024.04.03 11:39:42 INFO  Attempting to connect to the build server...
2024.04.03 11:39:42 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 11:39:42 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 11:39:42 INFO  Attempting to connect to the build server...
2024.04.03 11:39:42 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 11:39:42 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 11:39:42 INFO  time: Connected to build server in 85ms
2024.04.03 11:39:42 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 11:39:43 INFO  time: indexed workspace in 1.12s
2024.04.03 11:39:43 WARN  no build target for: D:\bestgame\src\main\scala\main.scala
ΰοπ. 03, 2024 11:39:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3215
ΰοπ. 03, 2024 11:39:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3216
2024.04.03 11:40:00 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals10597230017674197439\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 11:40:02 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 11:40:02 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 11:40:03 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 11:40:03 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 11:40:04 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 11:40:07 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 11:40:07 INFO  [success] Total time: 3 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 11:40:07
2024.04.03 11:40:08 ERROR D:\bestgame\plugins.sbt:1: error: reassignment to val
2024.04.03 11:40:08 ERROR sbtVersion = "1.9.9"
2024.04.03 11:40:08 ERROR            ^
2024.04.03 11:40:08 INFO  [error] Type error in expression
2024.04.03 11:40:08 INFO  [warn] Project loading failed: (r)etry, (q)uit, (l)ast, or (i)gnore? (default: r)
2024.04.03 11:40:09 INFO  time: ran 'sbt bloopInstall' in 8.37s
2024.04.03 11:40:09 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals10597230017674197439\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 11:40:09 INFO  Disconnecting from Bloop session...
2024.04.03 11:40:09 INFO  Shut down connection with build server.
2024.04.03 11:40:09 INFO  Shut down connection with build server.
2024.04.03 11:40:09 INFO  Attempting to connect to the build server...
2024.04.03 11:40:09 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 11:40:09 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 11:40:09 INFO  Attempting to connect to the build server...
2024.04.03 11:40:09 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 11:40:09 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 11:40:09 INFO  time: Connected to build server in 96ms
2024.04.03 11:40:09 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 11:40:10 INFO  time: indexed workspace in 1.04s
2024.04.03 11:40:10 WARN  no build target for: D:\bestgame\src\main\scala\main.scala
2024.04.03 11:40:12 INFO  time: code lens generation in 2.05s
ΰοπ. 03, 2024 11:40:31 AM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
ΰοπ. 03, 2024 11:40:31 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-03\r_compiler-error_(bestgame-build)_11-40-31-367.md
2024.04.03 11:40:32 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals1831907908530810600\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 11:40:33 INFO  sbt thinks that server is already booting because of this exception:
2024.04.03 11:40:33 ERROR sbt.internal.ServerAlreadyBootingException: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-1466779760368203317_lock, error 5
2024.04.03 11:40:33 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:357)
2024.04.03 11:40:33 ERROR 	at sbt.internal.BootServerSocket.<init>(BootServerSocket.java:296)
2024.04.03 11:40:33 ERROR 	at sbt.xMain$.getSocketOrExit(Main.scala:152)
2024.04.03 11:40:33 ERROR 	at sbt.xMain$.bootServerSocket$lzycompute$1(Main.scala:78)
2024.04.03 11:40:33 ERROR 	at sbt.xMain$.bootServerSocket$1(Main.scala:78)
2024.04.03 11:40:33 ERROR 	at sbt.xMain$.withStreams$1(Main.scala:86)
2024.04.03 11:40:33 ERROR 	at sbt.xMain$.run(Main.scala:123)
2024.04.03 11:40:33 ERROR 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
2024.04.03 11:40:33 ERROR 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
2024.04.03 11:40:33 ERROR 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
2024.04.03 11:40:33 ERROR 	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
2024.04.03 11:40:33 ERROR 	at sbt.internal.XMainConfiguration.run(XMainConfiguration.java:59)
2024.04.03 11:40:33 ERROR 	at sbt.xMain.run(Main.scala:47)
2024.04.03 11:40:33 ERROR 	at xsbt.boot.Launch$.$anonfun$run$1(Launch.scala:149)
2024.04.03 11:40:33 ERROR 	at xsbt.boot.Launch$.withContextLoader(Launch.scala:176)
2024.04.03 11:40:33 ERROR 	at xsbt.boot.Launch$.run(Launch.scala:149)
2024.04.03 11:40:33 ERROR 	at xsbt.boot.Launch$.$anonfun$apply$1(Launch.scala:44)
2024.04.03 11:40:33 ERROR 	at xsbt.boot.Launch$.launch(Launch.scala:159)
2024.04.03 11:40:33 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:44)
2024.04.03 11:40:33 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:21)
2024.04.03 11:40:33 ERROR 	at xsbt.boot.Boot$.runImpl(Boot.scala:78)
2024.04.03 11:40:33 ERROR 	at xsbt.boot.Boot$.run(Boot.scala:73)
2024.04.03 11:40:33 ERROR 	at xsbt.boot.Boot$.main(Boot.scala:21)
2024.04.03 11:40:33 ERROR 	at xsbt.boot.Boot.main(Boot.scala)
2024.04.03 11:40:33 ERROR Caused by: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-1466779760368203317_lock, error 5
2024.04.03 11:40:33 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:129)
2024.04.03 11:40:33 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:48)
2024.04.03 11:40:33 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:351)
2024.04.03 11:40:33 ERROR 	... 23 more
2024.04.03 11:40:32 INFO  time: ran 'sbt bloopInstall' in 0.82s
2024.04.03 11:40:33 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals1831907908530810600\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 11:40:33 INFO  Disconnecting from Bloop session...
2024.04.03 11:40:33 INFO  Shut down connection with build server.
2024.04.03 11:40:33 INFO  Shut down connection with build server.
2024.04.03 11:40:33 INFO  Attempting to connect to the build server...
2024.04.03 11:40:33 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 11:40:33 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 11:40:33 INFO  Attempting to connect to the build server...
2024.04.03 11:40:33 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 11:40:33 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 11:40:33 INFO  time: Connected to build server in 55ms
2024.04.03 11:40:33 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 11:40:34 INFO  time: indexed workspace in 1.16s
2024.04.03 11:40:34 WARN  no build target for: D:\bestgame\src\main\scala\main.scala
2024.04.03 11:40:36 INFO  time: code lens generation in 1.72s
ΰοπ. 03, 2024 11:44:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3417
2024.04.03 11:44:05 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals16809237620814636111\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 11:44:06 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 11:44:06 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 11:44:08 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 11:44:08 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 11:44:09 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 11:44:12 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 11:44:12 INFO  [success] Total time: 3 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 11:44:12
2024.04.03 11:44:14 INFO  [info] loading settings for project bestgame from build.sbt,plugins.sbt ...
2024.04.03 11:44:14 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.03 11:44:16 INFO  [warn] 
2024.04.03 11:44:16 INFO  [warn] 	Note: Some unresolved dependencies have extra attributes.  Check that these dependencies exist with the requested attributes.
2024.04.03 11:44:16 INFO  [warn] 		io.spray:sbt-revolver:0.9.3 (sbtVersion=1.0, scalaVersion=3)
2024.04.03 11:44:16 INFO  [warn] 
2024.04.03 11:44:16 INFO  [warn] 	Note: Unresolved dependencies path:
2024.04.03 11:44:16 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.04.03 11:44:16 INFO  [error] sbt.librarymanagement.ResolveException: Error downloading io.spray:sbt-revolver;sbtVersion=1.0;scalaVersion=3:0.9.3
2024.04.03 11:44:16 INFO  [error]   Not found
2024.04.03 11:44:16 INFO  [error]   Not found
2024.04.03 11:44:16 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localio.spray\sbt-revolver\scala_3\sbt_1.0\0.9.3\ivys\ivy.xml
2024.04.03 11:44:16 INFO  [error]   not found: https://repo1.maven.org/maven2/io/spray/sbt-revolver_3_1.0/0.9.3/sbt-revolver-0.9.3.pom
2024.04.03 11:44:16 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.unresolvedWarningOrThrow(CoursierDependencyResolution.scala:344)
2024.04.03 11:44:16 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.$anonfun$update$38(CoursierDependencyResolution.scala:313)
2024.04.03 11:44:16 INFO  [error] 	at scala.util.Either$LeftProjection.map(Either.scala:573)
2024.04.03 11:44:16 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.update(CoursierDependencyResolution.scala:313)
2024.04.03 11:44:16 INFO  [error] 	at sbt.librarymanagement.DependencyResolution.update(DependencyResolution.scala:60)
2024.04.03 11:44:16 INFO  [error] 	at sbt.internal.LibraryManagement$.resolve$1(LibraryManagement.scala:60)
2024.04.03 11:44:16 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$12(LibraryManagement.scala:134)
2024.04.03 11:44:16 INFO  [error] 	at sbt.util.Tracked$.$anonfun$lastOutput$1(Tracked.scala:74)
2024.04.03 11:44:16 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$20(LibraryManagement.scala:147)
2024.04.03 11:44:16 INFO  [error] 	at scala.util.control.Exception$Catch.apply(Exception.scala:228)
2024.04.03 11:44:16 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11(LibraryManagement.scala:147)
2024.04.03 11:44:16 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11$adapted(LibraryManagement.scala:128)
2024.04.03 11:44:16 INFO  [error] 	at sbt.util.Tracked$.$anonfun$inputChangedW$1(Tracked.scala:220)
2024.04.03 11:44:16 INFO  [error] 	at sbt.internal.LibraryManagement$.cachedUpdate(LibraryManagement.scala:161)
2024.04.03 11:44:16 INFO  [error] 	at sbt.Classpaths$.$anonfun$updateTask0$1(Defaults.scala:3801)
2024.04.03 11:44:16 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.04.03 11:44:16 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.04.03 11:44:16 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.04.03 11:44:16 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.04.03 11:44:16 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.04.03 11:44:16 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.04.03 11:44:16 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.04.03 11:44:16 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.04.03 11:44:16 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.04.03 11:44:16 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 11:44:16 INFO  [error] 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
2024.04.03 11:44:16 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 11:44:16 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
2024.04.03 11:44:16 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
2024.04.03 11:44:16 INFO  [error] 	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.03 11:44:16 INFO  [error] (update) sbt.librarymanagement.ResolveException: Error downloading io.spray:sbt-revolver;sbtVersion=1.0;scalaVersion=3:0.9.3
2024.04.03 11:44:16 INFO  [error]   Not found
2024.04.03 11:44:16 INFO  [error]   Not found
2024.04.03 11:44:16 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localio.spray\sbt-revolver\scala_3\sbt_1.0\0.9.3\ivys\ivy.xml
2024.04.03 11:44:16 INFO  [error]   not found: https://repo1.maven.org/maven2/io/spray/sbt-revolver_3_1.0/0.9.3/sbt-revolver-0.9.3.pom
2024.04.03 11:44:16 INFO  [error] Total time: 1 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 11:44:16
2024.04.03 11:44:16 INFO  time: ran 'sbt bloopInstall' in 11s
2024.04.03 11:44:16 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals16809237620814636111\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 11:44:16 INFO  Disconnecting from Bloop session...
2024.04.03 11:44:16 INFO  Shut down connection with build server.
2024.04.03 11:44:16 INFO  Shut down connection with build server.
2024.04.03 11:44:16 INFO  Attempting to connect to the build server...
2024.04.03 11:44:16 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 11:44:16 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 11:44:16 INFO  Attempting to connect to the build server...
2024.04.03 11:44:16 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 11:44:16 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 11:44:16 INFO  time: Connected to build server in 72ms
2024.04.03 11:44:16 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 11:44:17 INFO  time: indexed workspace in 1.19s
2024.04.03 11:44:17 WARN  no build target for: D:\bestgame\src\main\scala\main.scala
2024.04.03 11:44:20 INFO  time: code lens generation in 2.22s
2024.04.03 11:44:31 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals1477389019973968295\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 11:44:32 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 11:44:32 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 11:44:34 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 11:44:34 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 11:44:35 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 11:44:37 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 11:44:37 INFO  [success] Total time: 2 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 11:44:37
2024.04.03 11:44:37 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.03 11:44:37 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.03 11:44:38 INFO  [success] Generated .bloop\bestgame-test.json
2024.04.03 11:44:38 INFO  [success] Generated .bloop\bestgame.json
2024.04.03 11:44:38 INFO  [success] Total time: 1 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 11:44:38
2024.04.03 11:44:38 INFO  time: ran 'sbt bloopInstall' in 7.78s
2024.04.03 11:44:38 INFO  Disconnecting from Bloop session...
2024.04.03 11:44:38 INFO  Shut down connection with build server.
2024.04.03 11:44:38 INFO  Shut down connection with build server.
2024.04.03 11:44:38 INFO  Attempting to connect to the build server...
2024.04.03 11:44:38 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 11:44:38 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 11:44:38 INFO  Attempting to connect to the build server...
2024.04.03 11:44:38 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 11:44:38 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 11:44:38 INFO  time: Connected to build server in 0.12s
2024.04.03 11:44:38 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 11:44:40 INFO  time: indexed workspace in 1.11s
2024.04.03 11:44:42 INFO  time: code lens generation in 1.79s
2024.04.03 11:48:40 INFO  compiling bestgame (1 scala source)
2024.04.03 11:48:42 INFO  time: compiled bestgame in 1.97s
2024.04.03 11:49:39 INFO  compiling bestgame (1 scala source)
2024.04.03 11:49:41 INFO  time: compiled bestgame in 1.14s
ΰοπ. 03, 2024 11:49:48 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3498
2024.04.03 11:50:14 INFO  compiling bestgame (1 scala source)
2024.04.03 11:50:14 INFO  time: compiled bestgame in 0.44s
2024.04.03 11:52:59 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\main.scala
scala.meta.tokenizers.TokenizeException: <input>:52: error: Invalid literal number
  override val run = Server.serve(app).provide(Server.defaultWithPort(8000y))
                                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:820)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfUncertainToken$1(LegacyScanner.scala:864)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:872)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:335)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

ΰοπ. 03, 2024 11:53:27 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3679
ΰοπ. 03, 2024 11:56:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3700
2024.04.03 11:58:22 INFO  compiling bestgame (1 scala source)
2024.04.03 11:58:22 INFO  time: compiled bestgame in 0.51s
2024.04.03 11:59:40 INFO  compiling bestgame (1 scala source)
2024.04.03 11:59:41 INFO  time: compiled bestgame in 1.14s
2024.04.03 12:00:37 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals6654991600769132787\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 12:00:38 INFO  sbt thinks that server is already booting because of this exception:
2024.04.03 12:00:38 ERROR sbt.internal.ServerAlreadyBootingException: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-1466779760368203317_lock, error 5
2024.04.03 12:00:38 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:357)
2024.04.03 12:00:38 ERROR 	at sbt.internal.BootServerSocket.<init>(BootServerSocket.java:296)
2024.04.03 12:00:38 ERROR 	at sbt.xMain$.getSocketOrExit(Main.scala:152)
2024.04.03 12:00:38 ERROR 	at sbt.xMain$.bootServerSocket$lzycompute$1(Main.scala:78)
2024.04.03 12:00:38 ERROR 	at sbt.xMain$.bootServerSocket$1(Main.scala:78)
2024.04.03 12:00:38 ERROR 	at sbt.xMain$.withStreams$1(Main.scala:86)
2024.04.03 12:00:38 ERROR 	at sbt.xMain$.run(Main.scala:123)
2024.04.03 12:00:38 ERROR 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
2024.04.03 12:00:38 ERROR 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
2024.04.03 12:00:38 ERROR 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
2024.04.03 12:00:38 ERROR 	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
2024.04.03 12:00:38 ERROR 	at sbt.internal.XMainConfiguration.run(XMainConfiguration.java:59)
2024.04.03 12:00:38 ERROR 	at sbt.xMain.run(Main.scala:47)
2024.04.03 12:00:38 ERROR 	at xsbt.boot.Launch$.$anonfun$run$1(Launch.scala:149)
2024.04.03 12:00:38 ERROR 	at xsbt.boot.Launch$.withContextLoader(Launch.scala:176)
2024.04.03 12:00:38 ERROR 	at xsbt.boot.Launch$.run(Launch.scala:149)
2024.04.03 12:00:38 ERROR 	at xsbt.boot.Launch$.$anonfun$apply$1(Launch.scala:44)
2024.04.03 12:00:38 ERROR 	at xsbt.boot.Launch$.launch(Launch.scala:159)
2024.04.03 12:00:38 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:44)
2024.04.03 12:00:38 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:21)
2024.04.03 12:00:38 ERROR 	at xsbt.boot.Boot$.runImpl(Boot.scala:78)
2024.04.03 12:00:38 ERROR 	at xsbt.boot.Boot$.run(Boot.scala:73)
2024.04.03 12:00:38 ERROR 	at xsbt.boot.Boot$.main(Boot.scala:21)
2024.04.03 12:00:38 ERROR 	at xsbt.boot.Boot.main(Boot.scala)
2024.04.03 12:00:38 ERROR Caused by: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-1466779760368203317_lock, error 5
2024.04.03 12:00:38 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:129)
2024.04.03 12:00:38 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:48)
2024.04.03 12:00:38 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:351)
2024.04.03 12:00:38 ERROR 	... 23 more
2024.04.03 12:00:39 INFO  time: ran 'sbt bloopInstall' in 1.4s
2024.04.03 12:00:39 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals6654991600769132787\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 12:00:39 INFO  Disconnecting from Bloop session...
2024.04.03 12:00:39 INFO  Shut down connection with build server.
2024.04.03 12:00:39 INFO  Shut down connection with build server.
2024.04.03 12:00:39 INFO  Attempting to connect to the build server...
2024.04.03 12:00:39 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 12:00:39 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 12:00:39 INFO  Attempting to connect to the build server...
2024.04.03 12:00:39 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 12:00:39 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 12:00:39 INFO  time: Connected to build server in 0.13s
2024.04.03 12:00:39 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 12:00:40 INFO  time: indexed workspace in 1.3s
2024.04.03 12:00:44 INFO  time: code lens generation in 3.65s
2024.04.03 12:01:10 INFO  compiling bestgame (1 scala source)
2024.04.03 12:01:10 INFO  time: compiled bestgame in 0.47s
2024.04.03 12:01:12 INFO  skipping build import with status 'Dismissed'
2024.04.03 12:01:15 INFO  skipping build import with status 'Dismissed'
2024.04.03 12:01:17 INFO  compiling bestgame (1 scala source)
2024.04.03 12:01:17 INFO  time: compiled bestgame in 0.59s
2024.04.03 12:01:19 INFO  compiling bestgame (1 scala source)
2024.04.03 12:01:19 INFO  time: compiled bestgame in 0.2s
2024.04.03 12:11:41 INFO  compiling bestgame (1 scala source)
2024.04.03 12:11:41 INFO  time: compiled bestgame in 0.25s
ΰοπ. 03, 2024 12:15:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4785
2024.04.03 12:15:21 INFO  compiling bestgame (1 scala source)
2024.04.03 12:15:21 INFO  time: compiled bestgame in 0.76s
2024.04.03 12:20:23 INFO  compiling bestgame (1 scala source)
2024.04.03 12:20:23 INFO  time: compiled bestgame in 0.84s
2024.04.03 12:20:28 INFO  compiling bestgame (1 scala source)
2024.04.03 12:20:28 INFO  time: compiled bestgame in 0.65s
ΰοπ. 03, 2024 12:22:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5001
2024.04.03 12:25:50 INFO  compiling bestgame (1 scala source)
2024.04.03 12:25:51 INFO  time: compiled bestgame in 1.61s
2024.04.03 12:26:17 INFO  compiling bestgame (1 scala source)
2024.04.03 12:26:17 INFO  time: compiled bestgame in 0.42s
2024.04.03 12:37:26 INFO  compiling bestgame (1 scala source)
2024.04.03 12:37:29 INFO  time: compiled bestgame in 2.23s
2024.04.03 12:38:07 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals3607124514168655939\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 12:38:09 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 12:38:09 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 12:38:10 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 12:38:10 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 12:38:11 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 12:38:14 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 12:38:14 INFO  [success] Total time: 2 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 12:38:14
2024.04.03 12:38:16 INFO  [info] loading settings for project bestgame from build.sbt,plugins.sbt ...
2024.04.03 12:38:16 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.03 12:38:18 INFO  [warn] 
2024.04.03 12:38:18 INFO  [warn] 	Note: Some unresolved dependencies have extra attributes.  Check that these dependencies exist with the requested attributes.
2024.04.03 12:38:18 INFO  [warn] 		io.spray:sbt-revolver:0.7.2 (sbtVersion=1.0, scalaVersion=3)
2024.04.03 12:38:18 INFO  [warn] 
2024.04.03 12:38:18 INFO  [warn] 	Note: Unresolved dependencies path:
2024.04.03 12:38:18 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.04.03 12:38:18 INFO  [warn] Removed stale D:\bestgame\.bloop\bestgame-test.json
2024.04.03 12:38:18 INFO  [warn] Removed stale D:\bestgame\.bloop\bestgame.json
2024.04.03 12:38:18 INFO  [error] sbt.librarymanagement.ResolveException: Error downloading io.spray:sbt-revolver;sbtVersion=1.0;scalaVersion=3:0.7.2
2024.04.03 12:38:18 INFO  [error]   Not found
2024.04.03 12:38:18 INFO  [error]   Not found
2024.04.03 12:38:18 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localio.spray\sbt-revolver\scala_3\sbt_1.0\0.7.2\ivys\ivy.xml
2024.04.03 12:38:18 INFO  [error]   not found: https://repo1.maven.org/maven2/io/spray/sbt-revolver_3_1.0/0.7.2/sbt-revolver-0.7.2.pom
2024.04.03 12:38:18 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.unresolvedWarningOrThrow(CoursierDependencyResolution.scala:344)
2024.04.03 12:38:18 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.$anonfun$update$38(CoursierDependencyResolution.scala:313)
2024.04.03 12:38:18 INFO  [error] 	at scala.util.Either$LeftProjection.map(Either.scala:573)
2024.04.03 12:38:18 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.update(CoursierDependencyResolution.scala:313)
2024.04.03 12:38:18 INFO  [error] 	at sbt.librarymanagement.DependencyResolution.update(DependencyResolution.scala:60)
2024.04.03 12:38:18 INFO  [error] 	at sbt.internal.LibraryManagement$.resolve$1(LibraryManagement.scala:60)
2024.04.03 12:38:18 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$12(LibraryManagement.scala:134)
2024.04.03 12:38:18 INFO  [error] 	at sbt.util.Tracked$.$anonfun$lastOutput$1(Tracked.scala:74)
2024.04.03 12:38:18 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$20(LibraryManagement.scala:147)
2024.04.03 12:38:18 INFO  [error] 	at scala.util.control.Exception$Catch.apply(Exception.scala:228)
2024.04.03 12:38:18 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11(LibraryManagement.scala:147)
2024.04.03 12:38:18 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11$adapted(LibraryManagement.scala:128)
2024.04.03 12:38:18 INFO  [error] 	at sbt.util.Tracked$.$anonfun$inputChangedW$1(Tracked.scala:220)
2024.04.03 12:38:18 INFO  [error] 	at sbt.internal.LibraryManagement$.cachedUpdate(LibraryManagement.scala:161)
2024.04.03 12:38:18 INFO  [error] 	at sbt.Classpaths$.$anonfun$updateTask0$1(Defaults.scala:3801)
2024.04.03 12:38:18 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.04.03 12:38:18 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.04.03 12:38:18 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.04.03 12:38:18 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.04.03 12:38:18 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.04.03 12:38:18 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.04.03 12:38:18 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.04.03 12:38:18 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.04.03 12:38:18 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.04.03 12:38:18 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 12:38:18 INFO  [error] 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
2024.04.03 12:38:18 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 12:38:18 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
2024.04.03 12:38:18 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
2024.04.03 12:38:18 INFO  [error] 	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.03 12:38:18 INFO  [error] (update) sbt.librarymanagement.ResolveException: Error downloading io.spray:sbt-revolver;sbtVersion=1.0;scalaVersion=3:0.7.2
2024.04.03 12:38:18 INFO  [error]   Not found
2024.04.03 12:38:18 INFO  [error]   Not found
2024.04.03 12:38:18 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localio.spray\sbt-revolver\scala_3\sbt_1.0\0.7.2\ivys\ivy.xml
2024.04.03 12:38:18 INFO  [error]   not found: https://repo1.maven.org/maven2/io/spray/sbt-revolver_3_1.0/0.7.2/sbt-revolver-0.7.2.pom
2024.04.03 12:38:18 INFO  [error] Total time: 2 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 12:38:18
2024.04.03 12:38:18 INFO  time: ran 'sbt bloopInstall' in 10s
2024.04.03 12:38:18 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals3607124514168655939\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 12:38:18 INFO  Disconnecting from Bloop session...
2024.04.03 12:38:18 INFO  Shut down connection with build server.
2024.04.03 12:38:18 INFO  Shut down connection with build server.
2024.04.03 12:38:18 INFO  Attempting to connect to the build server...
2024.04.03 12:38:18 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 12:38:18 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 12:38:18 INFO  Attempting to connect to the build server...
2024.04.03 12:38:18 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 12:38:18 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 12:38:18 INFO  time: Connected to build server in 0.21s
2024.04.03 12:38:18 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 12:38:20 INFO  time: indexed workspace in 1.22s
2024.04.03 12:38:20 WARN  no build target for: D:\bestgame\src\main\scala\main.scala
2024.04.03 12:38:23 INFO  time: code lens generation in 3.2s
2024.04.03 12:46:45 INFO  skipping build import with status 'Installed'
ΰοπ. 03, 2024 12:47:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5383
2024.04.03 12:47:36 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals4708461616157386663\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 12:47:37 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 12:47:37 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 12:47:39 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 12:47:40 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 12:47:40 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 12:47:43 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 12:47:43 INFO  [success] Total time: 3 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 12:47:43
2024.04.03 12:47:45 INFO  [info] loading settings for project bestgame from build.sbt,plugins.sbt ...
2024.04.03 12:47:45 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.03 12:47:47 INFO  [warn] 
2024.04.03 12:47:47 INFO  [warn] 	Note: Some unresolved dependencies have extra attributes.  Check that these dependencies exist with the requested attributes.
2024.04.03 12:47:47 INFO  [warn] 		io.spray:sbt-revolver_2.12_1.0:0.7.2 (sbtVersion=1.0, scalaVersion=3)
2024.04.03 12:47:47 INFO  [warn] 
2024.04.03 12:47:47 INFO  [warn] 	Note: Unresolved dependencies path:
2024.04.03 12:47:47 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.04.03 12:47:47 INFO  [error] sbt.librarymanagement.ResolveException: Error downloading io.spray:sbt-revolver_2.12_1.0;sbtVersion=1.0;scalaVersion=3:0.7.2
2024.04.03 12:47:47 INFO  [error]   Not found
2024.04.03 12:47:47 INFO  [error]   Not found
2024.04.03 12:47:47 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localio.spray\sbt-revolver_2.12_1.0\scala_3\sbt_1.0\0.7.2\ivys\ivy.xml
2024.04.03 12:47:47 INFO  [error]   not found: https://repo1.maven.org/maven2/io/spray/sbt-revolver_2.12_1.0_3_1.0/0.7.2/sbt-revolver_2.12_1.0-0.7.2.pom
2024.04.03 12:47:47 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.unresolvedWarningOrThrow(CoursierDependencyResolution.scala:344)
2024.04.03 12:47:47 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.$anonfun$update$38(CoursierDependencyResolution.scala:313)
2024.04.03 12:47:47 INFO  [error] 	at scala.util.Either$LeftProjection.map(Either.scala:573)
2024.04.03 12:47:47 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.update(CoursierDependencyResolution.scala:313)
2024.04.03 12:47:47 INFO  [error] 	at sbt.librarymanagement.DependencyResolution.update(DependencyResolution.scala:60)
2024.04.03 12:47:47 INFO  [error] 	at sbt.internal.LibraryManagement$.resolve$1(LibraryManagement.scala:60)
2024.04.03 12:47:47 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$12(LibraryManagement.scala:134)
2024.04.03 12:47:47 INFO  [error] 	at sbt.util.Tracked$.$anonfun$lastOutput$1(Tracked.scala:74)
2024.04.03 12:47:47 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$20(LibraryManagement.scala:147)
2024.04.03 12:47:47 INFO  [error] 	at scala.util.control.Exception$Catch.apply(Exception.scala:228)
2024.04.03 12:47:47 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11(LibraryManagement.scala:147)
2024.04.03 12:47:47 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11$adapted(LibraryManagement.scala:128)
2024.04.03 12:47:47 INFO  [error] 	at sbt.util.Tracked$.$anonfun$inputChangedW$1(Tracked.scala:220)
2024.04.03 12:47:47 INFO  [error] 	at sbt.internal.LibraryManagement$.cachedUpdate(LibraryManagement.scala:161)
2024.04.03 12:47:47 INFO  [error] 	at sbt.Classpaths$.$anonfun$updateTask0$1(Defaults.scala:3801)
2024.04.03 12:47:47 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.04.03 12:47:47 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.04.03 12:47:47 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.04.03 12:47:47 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.04.03 12:47:47 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.04.03 12:47:47 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.04.03 12:47:47 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.04.03 12:47:47 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.04.03 12:47:47 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.04.03 12:47:47 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 12:47:47 INFO  [error] 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
2024.04.03 12:47:47 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 12:47:47 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
2024.04.03 12:47:47 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
2024.04.03 12:47:47 INFO  [error] 	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.03 12:47:47 INFO  [error] (update) sbt.librarymanagement.ResolveException: Error downloading io.spray:sbt-revolver_2.12_1.0;sbtVersion=1.0;scalaVersion=3:0.7.2
2024.04.03 12:47:47 INFO  [error]   Not found
2024.04.03 12:47:47 INFO  [error]   Not found
2024.04.03 12:47:47 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localio.spray\sbt-revolver_2.12_1.0\scala_3\sbt_1.0\0.7.2\ivys\ivy.xml
2024.04.03 12:47:47 INFO  [error]   not found: https://repo1.maven.org/maven2/io/spray/sbt-revolver_2.12_1.0_3_1.0/0.7.2/sbt-revolver_2.12_1.0-0.7.2.pom
2024.04.03 12:47:47 INFO  [error] Total time: 2 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 12:47:47
2024.04.03 12:47:47 INFO  time: ran 'sbt bloopInstall' in 11s
2024.04.03 12:47:47 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals4708461616157386663\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 12:47:47 INFO  Disconnecting from Bloop session...
2024.04.03 12:47:47 INFO  Shut down connection with build server.
2024.04.03 12:47:47 INFO  Shut down connection with build server.
2024.04.03 12:47:47 INFO  Attempting to connect to the build server...
2024.04.03 12:47:47 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 12:47:47 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 12:47:47 INFO  Attempting to connect to the build server...
2024.04.03 12:47:47 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 12:47:47 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 12:47:47 INFO  time: Connected to build server in 76ms
2024.04.03 12:47:47 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 12:47:48 INFO  time: indexed workspace in 1.01s
2024.04.03 12:47:48 WARN  no build target for: D:\bestgame\src\main\scala\main.scala
2024.04.03 12:47:51 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals15609900839227978567\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 12:47:52 INFO  time: code lens generation in 3.46s
2024.04.03 12:47:52 INFO  time: code lens generation in 2.73s
2024.04.03 12:47:52 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 12:47:52 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 12:47:54 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 12:47:54 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 12:47:55 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 12:47:58 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 12:47:58 INFO  [success] Total time: 3 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 12:47:58
2024.04.03 12:48:00 INFO  [info] loading settings for project bestgame from build.sbt,plugins.sbt ...
2024.04.03 12:48:00 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.03 12:48:02 INFO  [warn] 
2024.04.03 12:48:02 INFO  [warn] 	Note: Some unresolved dependencies have extra attributes.  Check that these dependencies exist with the requested attributes.
2024.04.03 12:48:02 INFO  [warn] 		io.spray:sbt-revolver_2.12_1.0:0.10.0 (sbtVersion=1.0, scalaVersion=3)
2024.04.03 12:48:02 INFO  [warn] 
2024.04.03 12:48:02 INFO  [warn] 	Note: Unresolved dependencies path:
2024.04.03 12:48:02 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.04.03 12:48:02 INFO  [error] sbt.librarymanagement.ResolveException: Error downloading io.spray:sbt-revolver_2.12_1.0;sbtVersion=1.0;scalaVersion=3:0.10.0
2024.04.03 12:48:02 INFO  [error]   Not found
2024.04.03 12:48:02 INFO  [error]   Not found
2024.04.03 12:48:02 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localio.spray\sbt-revolver_2.12_1.0\scala_3\sbt_1.0\0.10.0\ivys\ivy.xml
2024.04.03 12:48:02 INFO  [error]   not found: https://repo1.maven.org/maven2/io/spray/sbt-revolver_2.12_1.0_3_1.0/0.10.0/sbt-revolver_2.12_1.0-0.10.0.pom
2024.04.03 12:48:02 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.unresolvedWarningOrThrow(CoursierDependencyResolution.scala:344)
2024.04.03 12:48:02 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.$anonfun$update$38(CoursierDependencyResolution.scala:313)
2024.04.03 12:48:02 INFO  [error] 	at scala.util.Either$LeftProjection.map(Either.scala:573)
2024.04.03 12:48:02 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.update(CoursierDependencyResolution.scala:313)
2024.04.03 12:48:02 INFO  [error] 	at sbt.librarymanagement.DependencyResolution.update(DependencyResolution.scala:60)
2024.04.03 12:48:02 INFO  [error] 	at sbt.internal.LibraryManagement$.resolve$1(LibraryManagement.scala:60)
2024.04.03 12:48:02 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$12(LibraryManagement.scala:134)
2024.04.03 12:48:02 INFO  [error] 	at sbt.util.Tracked$.$anonfun$lastOutput$1(Tracked.scala:74)
2024.04.03 12:48:02 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$20(LibraryManagement.scala:147)
2024.04.03 12:48:02 INFO  [error] 	at scala.util.control.Exception$Catch.apply(Exception.scala:228)
2024.04.03 12:48:02 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11(LibraryManagement.scala:147)
2024.04.03 12:48:02 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11$adapted(LibraryManagement.scala:128)
2024.04.03 12:48:02 INFO  [error] 	at sbt.util.Tracked$.$anonfun$inputChangedW$1(Tracked.scala:220)
2024.04.03 12:48:02 INFO  [error] 	at sbt.internal.LibraryManagement$.cachedUpdate(LibraryManagement.scala:161)
2024.04.03 12:48:02 INFO  [error] 	at sbt.Classpaths$.$anonfun$updateTask0$1(Defaults.scala:3801)
2024.04.03 12:48:02 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.04.03 12:48:02 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.04.03 12:48:02 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.04.03 12:48:02 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.04.03 12:48:02 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.04.03 12:48:02 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.04.03 12:48:02 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.04.03 12:48:02 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.04.03 12:48:02 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.04.03 12:48:02 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 12:48:02 INFO  [error] 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
2024.04.03 12:48:02 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 12:48:02 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
2024.04.03 12:48:02 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
2024.04.03 12:48:02 INFO  [error] 	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.03 12:48:02 INFO  [error] (update) sbt.librarymanagement.ResolveException: Error downloading io.spray:sbt-revolver_2.12_1.0;sbtVersion=1.0;scalaVersion=3:0.10.0
2024.04.03 12:48:02 INFO  [error]   Not found
2024.04.03 12:48:02 INFO  [error]   Not found
2024.04.03 12:48:02 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localio.spray\sbt-revolver_2.12_1.0\scala_3\sbt_1.0\0.10.0\ivys\ivy.xml
2024.04.03 12:48:02 INFO  [error]   not found: https://repo1.maven.org/maven2/io/spray/sbt-revolver_2.12_1.0_3_1.0/0.10.0/sbt-revolver_2.12_1.0-0.10.0.pom
2024.04.03 12:48:02 INFO  [error] Total time: 1 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 12:48:02
2024.04.03 12:48:02 INFO  time: ran 'sbt bloopInstall' in 11s
2024.04.03 12:48:02 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals15609900839227978567\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 12:48:02 INFO  Disconnecting from Bloop session...
2024.04.03 12:48:02 INFO  Shut down connection with build server.
2024.04.03 12:48:02 INFO  Shut down connection with build server.
2024.04.03 12:48:02 INFO  Attempting to connect to the build server...
2024.04.03 12:48:02 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 12:48:02 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 12:48:02 INFO  Attempting to connect to the build server...
2024.04.03 12:48:02 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 12:48:02 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 12:48:02 INFO  time: Connected to build server in 73ms
2024.04.03 12:48:02 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 12:48:03 INFO  time: indexed workspace in 1.04s
2024.04.03 12:48:03 WARN  no build target for: D:\bestgame\src\main\scala\main.scala
ΰοπ. 03, 2024 12:48:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5497
2024.04.03 12:49:08 INFO  skipping build import with status 'Installed'
ΰοπ. 03, 2024 12:49:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5539
ΰοπ. 03, 2024 12:50:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5546
2024.04.03 12:50:28 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals16334035766075107346\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 12:50:30 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 12:50:30 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 12:50:32 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 12:50:33 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 12:50:33 INFO  user cancelled sbt bloopInstall
2024.04.03 12:50:33 INFO  skipping build import with status 'Cancelled'
2024.04.03 12:50:33 INFO  time: ran 'sbt bloopInstall' in 4.69s
2024.04.03 12:50:33 INFO  skipping build import with status 'Cancelled'
2024.04.03 12:50:34 INFO  skipping build import with status 'Cancelled'
2024.04.03 12:50:39 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals5254775910665085249\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 12:50:41 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 12:50:41 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 12:50:42 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 12:50:42 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 12:50:43 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 12:50:46 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 12:50:46 INFO  [success] Total time: 3 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 12:50:46
2024.04.03 12:50:49 INFO  [info] loading settings for project bestgame from build.sbt,plugins.sbt ...
2024.04.03 12:50:49 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
ΰοπ. 03, 2024 12:50:50 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-03\r_compiler-error_(bestgame-build)_12-50-50-328.md
2024.04.03 12:50:51 INFO  [warn] 
2024.04.03 12:50:51 INFO  [warn] 	Note: Unresolved dependencies path:
2024.04.03 12:50:51 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.04.03 12:50:51 INFO  [error] sbt.librarymanagement.ResolveException: Error downloading org.scala-lang:scala-library:2.12
2024.04.03 12:50:51 INFO  [error]   Not found
2024.04.03 12:50:51 INFO  [error]   Not found
2024.04.03 12:50:51 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localorg.scala-lang\scala-library\2.12\ivys\ivy.xml
2024.04.03 12:50:51 INFO  [error]   not found: https://repo1.maven.org/maven2/org/scala-lang/scala-library/2.12/scala-library-2.12.pom
2024.04.03 12:50:51 INFO  [error] Error downloading org.scala-lang:scala-reflect:2.12
2024.04.03 12:50:51 INFO  [error]   Not found
2024.04.03 12:50:51 INFO  [error]   Not found
2024.04.03 12:50:51 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localorg.scala-lang\scala-reflect\2.12\ivys\ivy.xml
2024.04.03 12:50:51 INFO  [error]   not found: https://repo1.maven.org/maven2/org/scala-lang/scala-reflect/2.12/scala-reflect-2.12.pom
2024.04.03 12:50:51 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.unresolvedWarningOrThrow(CoursierDependencyResolution.scala:344)
2024.04.03 12:50:51 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.$anonfun$update$38(CoursierDependencyResolution.scala:313)
2024.04.03 12:50:51 INFO  [error] 	at scala.util.Either$LeftProjection.map(Either.scala:573)
2024.04.03 12:50:51 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.update(CoursierDependencyResolution.scala:313)
2024.04.03 12:50:51 INFO  [error] 	at sbt.librarymanagement.DependencyResolution.update(DependencyResolution.scala:60)
2024.04.03 12:50:51 INFO  [error] 	at sbt.internal.LibraryManagement$.resolve$1(LibraryManagement.scala:60)
2024.04.03 12:50:51 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$12(LibraryManagement.scala:134)
2024.04.03 12:50:51 INFO  [error] 	at sbt.util.Tracked$.$anonfun$lastOutput$1(Tracked.scala:74)
2024.04.03 12:50:51 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$20(LibraryManagement.scala:147)
2024.04.03 12:50:51 INFO  [error] 	at scala.util.control.Exception$Catch.apply(Exception.scala:228)
2024.04.03 12:50:51 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11(LibraryManagement.scala:147)
2024.04.03 12:50:51 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11$adapted(LibraryManagement.scala:128)
2024.04.03 12:50:51 INFO  [error] 	at sbt.util.Tracked$.$anonfun$inputChangedW$1(Tracked.scala:220)
2024.04.03 12:50:51 INFO  [error] 	at sbt.internal.LibraryManagement$.cachedUpdate(LibraryManagement.scala:161)
2024.04.03 12:50:51 INFO  [error] 	at sbt.Classpaths$.$anonfun$updateTask0$1(Defaults.scala:3801)
2024.04.03 12:50:51 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.04.03 12:50:51 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.04.03 12:50:51 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.04.03 12:50:51 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.04.03 12:50:51 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.04.03 12:50:51 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.04.03 12:50:51 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.04.03 12:50:51 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.04.03 12:50:51 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.04.03 12:50:51 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 12:50:51 INFO  [error] 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
2024.04.03 12:50:51 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 12:50:51 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
2024.04.03 12:50:51 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
2024.04.03 12:50:51 INFO  [error] 	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.03 12:50:51 INFO  [error] (update) sbt.librarymanagement.ResolveException: Error downloading org.scala-lang:scala-library:2.12
2024.04.03 12:50:51 INFO  [error]   Not found
2024.04.03 12:50:51 INFO  [error]   Not found
2024.04.03 12:50:51 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localorg.scala-lang\scala-library\2.12\ivys\ivy.xml
2024.04.03 12:50:51 INFO  [error]   not found: https://repo1.maven.org/maven2/org/scala-lang/scala-library/2.12/scala-library-2.12.pom
2024.04.03 12:50:51 INFO  [error] Error downloading org.scala-lang:scala-reflect:2.12
2024.04.03 12:50:51 INFO  [error]   Not found
2024.04.03 12:50:51 INFO  [error]   Not found
2024.04.03 12:50:51 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localorg.scala-lang\scala-reflect\2.12\ivys\ivy.xml
2024.04.03 12:50:51 INFO  [error]   not found: https://repo1.maven.org/maven2/org/scala-lang/scala-reflect/2.12/scala-reflect-2.12.pom
2024.04.03 12:50:51 INFO  [error] Total time: 2 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 12:50:51
2024.04.03 12:50:51 INFO  time: ran 'sbt bloopInstall' in 12s
2024.04.03 12:50:51 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals5254775910665085249\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 12:50:51 INFO  Disconnecting from Bloop session...
2024.04.03 12:50:51 INFO  Shut down connection with build server.
2024.04.03 12:50:51 INFO  Shut down connection with build server.
2024.04.03 12:50:51 INFO  Attempting to connect to the build server...
2024.04.03 12:50:51 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 12:50:51 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 12:50:51 INFO  Attempting to connect to the build server...
2024.04.03 12:50:51 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 12:50:51 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 12:50:51 INFO  time: Connected to build server in 71ms
2024.04.03 12:50:51 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 12:50:53 INFO  time: indexed workspace in 1.11s
2024.04.03 12:50:53 WARN  no build target for: D:\bestgame\src\main\scala\main.scala
2024.04.03 12:50:55 INFO  skipping build import with status 'Installed'
2024.04.03 12:50:55 INFO  time: code lens generation in 2.06s
ΰοπ. 03, 2024 12:51:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5754
ΰοπ. 03, 2024 12:51:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5773
2024.04.03 12:51:34 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals18327648540791240429\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 12:51:36 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 12:51:36 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 12:51:37 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 12:51:37 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 12:51:38 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 12:51:41 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 12:51:41 INFO  [success] Total time: 2 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 12:51:41
2024.04.03 12:51:41 INFO  [info] loading settings for project bestgame from build.sbt,plugins.sbt ...
2024.04.03 12:51:41 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.03 12:51:43 INFO  [warn] 
2024.04.03 12:51:43 INFO  [warn] 	Note: Some unresolved dependencies have extra attributes.  Check that these dependencies exist with the requested attributes.
2024.04.03 12:51:43 INFO  [warn] 		io.spray:sbt-revolver:0.10.0 (sbtVersion=1.0, scalaVersion=3)
2024.04.03 12:51:43 INFO  [warn] 
2024.04.03 12:51:43 INFO  [warn] 	Note: Unresolved dependencies path:
2024.04.03 12:51:43 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.04.03 12:51:43 INFO  [error] sbt.librarymanagement.ResolveException: Error downloading io.spray:sbt-revolver;sbtVersion=1.0;scalaVersion=3:0.10.0
2024.04.03 12:51:43 INFO  [error]   Not found
2024.04.03 12:51:43 INFO  [error]   Not found
2024.04.03 12:51:43 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localio.spray\sbt-revolver\scala_3\sbt_1.0\0.10.0\ivys\ivy.xml
2024.04.03 12:51:43 INFO  [error]   not found: https://repo1.maven.org/maven2/io/spray/sbt-revolver_3_1.0/0.10.0/sbt-revolver-0.10.0.pom
2024.04.03 12:51:43 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.unresolvedWarningOrThrow(CoursierDependencyResolution.scala:344)
2024.04.03 12:51:43 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.$anonfun$update$38(CoursierDependencyResolution.scala:313)
2024.04.03 12:51:43 INFO  [error] 	at scala.util.Either$LeftProjection.map(Either.scala:573)
2024.04.03 12:51:43 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.update(CoursierDependencyResolution.scala:313)
2024.04.03 12:51:43 INFO  [error] 	at sbt.librarymanagement.DependencyResolution.update(DependencyResolution.scala:60)
2024.04.03 12:51:43 INFO  [error] 	at sbt.internal.LibraryManagement$.resolve$1(LibraryManagement.scala:60)
2024.04.03 12:51:43 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$12(LibraryManagement.scala:134)
2024.04.03 12:51:43 INFO  [error] 	at sbt.util.Tracked$.$anonfun$lastOutput$1(Tracked.scala:74)
2024.04.03 12:51:43 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$20(LibraryManagement.scala:147)
2024.04.03 12:51:43 INFO  [error] 	at scala.util.control.Exception$Catch.apply(Exception.scala:228)
2024.04.03 12:51:43 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11(LibraryManagement.scala:147)
2024.04.03 12:51:43 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11$adapted(LibraryManagement.scala:128)
2024.04.03 12:51:43 INFO  [error] 	at sbt.util.Tracked$.$anonfun$inputChangedW$1(Tracked.scala:220)
2024.04.03 12:51:43 INFO  [error] 	at sbt.internal.LibraryManagement$.cachedUpdate(LibraryManagement.scala:161)
2024.04.03 12:51:43 INFO  [error] 	at sbt.Classpaths$.$anonfun$updateTask0$1(Defaults.scala:3801)
2024.04.03 12:51:43 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.04.03 12:51:43 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.04.03 12:51:43 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.04.03 12:51:43 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.04.03 12:51:43 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.04.03 12:51:43 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.04.03 12:51:43 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.04.03 12:51:43 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.04.03 12:51:43 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.04.03 12:51:43 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 12:51:43 INFO  [error] 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
2024.04.03 12:51:43 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 12:51:43 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
2024.04.03 12:51:43 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
2024.04.03 12:51:43 INFO  [error] 	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.03 12:51:43 INFO  [error] (update) sbt.librarymanagement.ResolveException: Error downloading io.spray:sbt-revolver;sbtVersion=1.0;scalaVersion=3:0.10.0
2024.04.03 12:51:43 INFO  [error]   Not found
2024.04.03 12:51:43 INFO  [error]   Not found
2024.04.03 12:51:43 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localio.spray\sbt-revolver\scala_3\sbt_1.0\0.10.0\ivys\ivy.xml
2024.04.03 12:51:43 INFO  [error]   not found: https://repo1.maven.org/maven2/io/spray/sbt-revolver_3_1.0/0.10.0/sbt-revolver-0.10.0.pom
2024.04.03 12:51:43 INFO  [error] Total time: 2 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 12:51:43
2024.04.03 12:51:43 INFO  time: ran 'sbt bloopInstall' in 8.7s
2024.04.03 12:51:43 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals18327648540791240429\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 12:51:43 INFO  Disconnecting from Bloop session...
2024.04.03 12:51:43 INFO  Shut down connection with build server.
2024.04.03 12:51:43 INFO  Shut down connection with build server.
2024.04.03 12:51:43 INFO  Attempting to connect to the build server...
2024.04.03 12:51:43 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 12:51:43 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 12:51:43 INFO  Attempting to connect to the build server...
2024.04.03 12:51:43 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 12:51:43 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 12:51:43 INFO  time: Connected to build server in 81ms
2024.04.03 12:51:43 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 12:51:44 INFO  time: indexed workspace in 1.04s
2024.04.03 12:51:44 WARN  no build target for: D:\bestgame\src\main\scala\main.scala
2024.04.03 12:51:47 INFO  time: code lens generation in 2.07s
2024.04.03 12:51:52 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals3760052105899379638\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 12:51:54 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 12:51:55 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 12:51:55 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 12:51:57 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 12:51:57 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 12:51:59 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 12:51:59 INFO  [success] Total time: 3 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 12:52:00
2024.04.03 12:51:59 INFO  [info] loading settings for project bestgame from build.sbt,plugins.sbt ...
2024.04.03 12:51:59 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.03 12:52:02 INFO  [warn] 
2024.04.03 12:52:02 INFO  [warn] 	Note: Some unresolved dependencies have extra attributes.  Check that these dependencies exist with the requested attributes.
2024.04.03 12:52:02 INFO  [warn] 		io.spray:sbt-revolver:0.10.0 (sbtVersion=1.0, scalaVersion=3)
2024.04.03 12:52:02 INFO  [warn] 
2024.04.03 12:52:02 INFO  [warn] 	Note: Unresolved dependencies path:
2024.04.03 12:52:02 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.04.03 12:52:02 INFO  [error] sbt.librarymanagement.ResolveException: Error downloading io.spray:sbt-revolver;sbtVersion=1.0;scalaVersion=3:0.10.0
2024.04.03 12:52:02 INFO  [error]   Not found
2024.04.03 12:52:02 INFO  [error]   Not found
2024.04.03 12:52:02 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localio.spray\sbt-revolver\scala_3\sbt_1.0\0.10.0\ivys\ivy.xml
2024.04.03 12:52:02 INFO  [error]   not found: https://repo1.maven.org/maven2/io/spray/sbt-revolver_3_1.0/0.10.0/sbt-revolver-0.10.0.pom
2024.04.03 12:52:02 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.unresolvedWarningOrThrow(CoursierDependencyResolution.scala:344)
2024.04.03 12:52:02 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.$anonfun$update$38(CoursierDependencyResolution.scala:313)
2024.04.03 12:52:02 INFO  [error] 	at scala.util.Either$LeftProjection.map(Either.scala:573)
2024.04.03 12:52:02 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.update(CoursierDependencyResolution.scala:313)
2024.04.03 12:52:02 INFO  [error] 	at sbt.librarymanagement.DependencyResolution.update(DependencyResolution.scala:60)
2024.04.03 12:52:02 INFO  [error] 	at sbt.internal.LibraryManagement$.resolve$1(LibraryManagement.scala:60)
2024.04.03 12:52:02 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$12(LibraryManagement.scala:134)
2024.04.03 12:52:02 INFO  [error] 	at sbt.util.Tracked$.$anonfun$lastOutput$1(Tracked.scala:74)
2024.04.03 12:52:02 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$20(LibraryManagement.scala:147)
2024.04.03 12:52:02 INFO  [error] 	at scala.util.control.Exception$Catch.apply(Exception.scala:228)
2024.04.03 12:52:02 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11(LibraryManagement.scala:147)
2024.04.03 12:52:02 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11$adapted(LibraryManagement.scala:128)
2024.04.03 12:52:02 INFO  [error] 	at sbt.util.Tracked$.$anonfun$inputChangedW$1(Tracked.scala:220)
2024.04.03 12:52:02 INFO  [error] 	at sbt.internal.LibraryManagement$.cachedUpdate(LibraryManagement.scala:161)
2024.04.03 12:52:02 INFO  [error] 	at sbt.Classpaths$.$anonfun$updateTask0$1(Defaults.scala:3801)
2024.04.03 12:52:02 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.04.03 12:52:02 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.04.03 12:52:02 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.04.03 12:52:02 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.04.03 12:52:02 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.04.03 12:52:02 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.04.03 12:52:02 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.04.03 12:52:02 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.04.03 12:52:02 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.04.03 12:52:02 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 12:52:02 INFO  [error] 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
2024.04.03 12:52:02 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.03 12:52:02 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
2024.04.03 12:52:02 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
2024.04.03 12:52:02 INFO  [error] 	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.03 12:52:02 INFO  [error] (update) sbt.librarymanagement.ResolveException: Error downloading io.spray:sbt-revolver;sbtVersion=1.0;scalaVersion=3:0.10.0
2024.04.03 12:52:02 INFO  [error]   Not found
2024.04.03 12:52:02 INFO  [error]   Not found
2024.04.03 12:52:02 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localio.spray\sbt-revolver\scala_3\sbt_1.0\0.10.0\ivys\ivy.xml
2024.04.03 12:52:02 INFO  [error]   not found: https://repo1.maven.org/maven2/io/spray/sbt-revolver_3_1.0/0.10.0/sbt-revolver-0.10.0.pom
2024.04.03 12:52:02 INFO  [error] Total time: 1 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 12:52:02
2024.04.03 12:52:02 INFO  time: ran 'sbt bloopInstall' in 10s
2024.04.03 12:52:02 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals3760052105899379638\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.03 12:52:02 INFO  Disconnecting from Bloop session...
2024.04.03 12:52:02 INFO  Shut down connection with build server.
2024.04.03 12:52:02 INFO  Shut down connection with build server.
2024.04.03 12:52:02 INFO  Attempting to connect to the build server...
2024.04.03 12:52:02 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 12:52:02 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 12:52:02 INFO  Attempting to connect to the build server...
2024.04.03 12:52:02 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 12:52:02 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 12:52:02 INFO  time: Connected to build server in 84ms
2024.04.03 12:52:02 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 12:52:04 INFO  time: indexed workspace in 1.62s
2024.04.03 12:52:04 WARN  no build target for: D:\bestgame\src\main\scala\main.scala
2024.04.03 12:52:07 INFO  time: code lens generation in 3.24s
ΰοπ. 03, 2024 12:53:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5816
2024.04.03 12:56:20 WARN  no build target for: D:\bestgame\src\main\scala\main.scala
2024.04.03 12:58:08 INFO  Shutting down server
2024.04.03 12:58:08 INFO  shutting down Metals
2024.04.03 12:58:08 INFO  Shut down connection with build server.
2024.04.03 12:58:08 INFO  Shut down connection with build server.
2024.04.03 12:58:08 INFO  Exiting server
2024.04.03 14:29:55 INFO  Started: Metals version 1.2.2 in folders 'D:\bestgame' for client Visual Studio Code 1.87.2.
14:29:56.508 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
14:29:56.508 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
14:29:56.508 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
14:29:56.524 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
14:29:56.524 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
14:29:56.524 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
14:29:56.524 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
14:29:56.524 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
14:29:56.524 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/C:/Users/yidtdr/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
14:29:56.534 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
14:29:56.534 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
14:29:56.534 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
14:29:56.534 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
14:29:56.534 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
14:29:56.534 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
14:29:56.534 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
14:29:56.534 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
14:29:56.534 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
14:29:56.534 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
14:29:56.534 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
14:29:56.654 [pool-1-thread-1] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:D:\bestgame\.metals\metals (H2 2.2)
14:29:56.654 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
14:29:56.654 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
14:29:56.657 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
14:29:56.659 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
14:29:56.663 [pool-1-thread-1] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
14:29:56.664 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
14:29:56.664 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
14:29:56.674 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
14:29:56.686 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
14:29:56.698 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
14:29:56.698 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
14:29:56.698 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
14:29:56.698 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
14:29:56.698 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
14:29:56.698 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
14:29:56.698 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
14:29:56.698 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
14:29:56.698 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
14:29:56.698 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
14:29:56.714 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.037s)
14:29:56.714 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
14:29:56.722 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
14:29:56.730 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
14:29:56.742 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 35 of 100M
2024.04.03 14:29:58 INFO  Attempting to connect to the build server...
2024.04.03 14:29:58 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 14:30:04 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals1743157226114037605\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.03 14:30:06 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 14:30:06 INFO  Attempting to connect to the build server...
2024.04.03 14:30:06 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 14:30:07 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 14:30:07 INFO  time: Connected to build server in 9.5s
2024.04.03 14:30:07 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 14:30:08 INFO  time: Imported build in 0.61s
2024.04.03 14:30:08 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.03 14:30:10 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.03 14:30:12 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.03 14:30:15 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.03 14:30:15 INFO  no build target found for D:\bestgame\src\main\scala\main.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.03 14:30:15 INFO  [info] loading project definition from D:\bestgame\project
2024.04.03 14:30:19 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.03 14:30:19 INFO  [success] Total time: 4 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 14:30:19
2024.04.03 14:30:20 INFO  time: indexed workspace in 3.99s
2024.04.03 14:30:20 WARN  no build target for: D:\bestgame\src\main\scala\main.scala
2024.04.03 14:30:19 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.03 14:30:19 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.03 14:30:21 INFO  [success] Generated .bloop\bestgame.json
2024.04.03 14:30:21 INFO  [success] Generated .bloop\bestgame-test.json
2024.04.03 14:30:21 INFO  [success] Total time: 1 s, completed 3 Π°ΠΏΡ€. 2024 Π³., 14:30:21
2024.04.03 14:30:22 INFO  time: ran 'sbt bloopInstall' in 17s
2024.04.03 14:30:22 INFO  Disconnecting from Bloop session...
2024.04.03 14:30:22 INFO  Shut down connection with build server.
2024.04.03 14:30:22 INFO  Shut down connection with build server.
2024.04.03 14:30:22 INFO  Attempting to connect to the build server...
2024.04.03 14:30:22 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 14:30:22 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 14:30:22 INFO  Attempting to connect to the build server...
2024.04.03 14:30:22 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 14:30:22 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 14:30:22 INFO  time: Connected to build server in 0.21s
2024.04.03 14:30:22 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 14:30:26 INFO  time: indexed workspace in 2.59s
2024.04.03 14:30:27 INFO  no build target found for D:\bestgame\src\main\scala\main.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.03 14:30:31 INFO  time: code lens generation in 9.14s
2024.04.03 14:30:31 INFO  time: code lens generation in 9.14s
2024.04.03 14:30:31 INFO  time: code lens generation in 9.14s
2024.04.03 14:30:31 INFO  time: code lens generation in 9.14s
2024.04.03 14:30:53 INFO  compiling bestgame (1 scala source)
2024.04.03 14:31:01 INFO  time: compiled bestgame in 8.21s
ΰοπ. 03, 2024 2:34:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 182
ΰοπ. 03, 2024 2:35:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 262
2024.04.03 14:35:27 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\main.scala
scala.meta.tokenizers.TokenizeException: <input>:10: error: Non-zero integral values may not have a leading zero.
  def money = 00;
              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfUncertainToken$1(LegacyScanner.scala:856)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:872)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchZero$1(LegacyScanner.scala:330)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:332)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 14:35:48 INFO  compiling bestgame (1 scala source)
2024.04.03 14:35:48 INFO  time: compiled bestgame in 0.88s
2024.04.03 14:35:56 INFO  compiling bestgame (1 scala source)
2024.04.03 14:35:58 INFO  time: compiled bestgame in 1.44s
ΰοπ. 03, 2024 2:38:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 489
2024.04.03 14:41:20 INFO  compiling bestgame (1 scala source)
2024.04.03 14:41:22 INFO  time: compiled bestgame in 2.08s
2024.04.03 14:41:37 INFO  compiling bestgame (1 scala source)
2024.04.03 14:41:39 INFO  time: compiled bestgame in 1.3s
2024.04.03 14:43:33 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\main.scala
scala.meta.tokenizers.TokenizeException: <input>:28: error: unclosed quoted identifier
`
^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getBackquotedIdent(LegacyScanner.scala:489)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:337)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 14:43:34 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\main.scala
scala.meta.tokenizers.TokenizeException: <input>:28: error: unclosed quoted identifier
`
^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getBackquotedIdent(LegacyScanner.scala:489)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:337)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 14:43:34 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\main.scala
scala.meta.tokenizers.TokenizeException: <input>:28: error: empty quoted identifier
``
^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getBackquotedIdent(LegacyScanner.scala:485)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:337)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 14:43:54 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\main.scala
scala.meta.tokenizers.TokenizeException: <input>:28: error: unclosed character literal
        case Read(WebSocketFrame.Text('')) => 
                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 14:44:58 INFO  compiling bestgame (1 scala source)
2024.04.03 14:44:59 INFO  time: compiled bestgame in 1.21s
ΰοπ. 03, 2024 2:45:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1424
2024.04.03 14:45:34 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\main.scala
scala.meta.tokenizers.TokenizeException: <input>:28: error: unclosed string interpolation
        case Read(WebSocketFrame.Text(s"connect/username&=$"))            => 
                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 14:45:43 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\main.scala
scala.meta.tokenizers.TokenizeException: <input>:28: error: unclosed string interpolation
        case Read(WebSocketFrame.Text(s"connect/username&=$"))            => 
                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

ΰοπ. 03, 2024 2:48:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1774
2024.04.03 14:48:33 INFO  compiling bestgame (1 scala source)
2024.04.03 14:48:33 INFO  time: compiled bestgame in 0.97s
2024.04.03 14:48:40 INFO  compiling bestgame (1 scala source)
2024.04.03 14:48:42 INFO  time: compiled bestgame in 1.44s
2024.04.03 14:48:42 INFO  compiling bestgame (1 scala source)
2024.04.03 14:48:43 INFO  time: compiled bestgame in 1.15s
ΰοπ. 03, 2024 2:48:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1894
2024.04.03 14:50:26 INFO  compiling bestgame (1 scala source)
2024.04.03 14:50:26 INFO  time: compiled bestgame in 0.74s
2024.04.03 14:50:53 INFO  compiling bestgame (1 scala source)
2024.04.03 14:50:53 INFO  time: compiled bestgame in 0.67s
2024.04.03 14:51:39 INFO  compiling bestgame (1 scala source)
2024.04.03 14:51:39 INFO  time: compiled bestgame in 0.6s
2024.04.03 14:52:16 INFO  compiling bestgame (1 scala source)
2024.04.03 14:52:16 INFO  time: compiled bestgame in 0.56s
2024.04.03 14:52:23 INFO  compiling bestgame (1 scala source)
2024.04.03 14:52:23 INFO  time: compiled bestgame in 0.83s
2024.04.03 14:53:05 INFO  compiling bestgame (1 scala source)
2024.04.03 14:53:05 INFO  time: compiled bestgame in 0.45s
2024.04.03 14:53:17 INFO  compiling bestgame (1 scala source)
2024.04.03 14:53:17 INFO  time: compiled bestgame in 0.53s
2024.04.03 14:54:07 INFO  compiling bestgame (1 scala source)
2024.04.03 14:54:07 INFO  time: compiled bestgame in 0.67s
2024.04.03 14:54:45 INFO  compiling bestgame (1 scala source)
2024.04.03 14:54:45 INFO  time: compiled bestgame in 0.62s
2024.04.03 14:55:03 INFO  compiling bestgame (1 scala source)
2024.04.03 14:55:03 INFO  time: compiled bestgame in 0.54s
ΰοπ. 03, 2024 2:55:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2834
2024.04.03 14:56:09 INFO  compiling bestgame (1 scala source)
2024.04.03 14:56:10 INFO  time: compiled bestgame in 1.02s
ΰοπ. 03, 2024 2:56:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2912
2024.04.03 14:56:41 INFO  compiling bestgame (1 scala source)
2024.04.03 14:56:41 INFO  time: compiled bestgame in 0.96s
2024.04.03 14:56:47 INFO  compiling bestgame (1 scala source)
2024.04.03 14:56:47 INFO  time: compiled bestgame in 0.62s
2024.04.03 14:58:58 INFO  compiling bestgame (1 scala source)
2024.04.03 14:58:58 INFO  time: compiled bestgame in 0.98s
ΰοπ. 03, 2024 2:59:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2983
ΰοπ. 03, 2024 2:59:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2989
2024.04.03 14:59:48 INFO  compiling bestgame (1 scala source)
2024.04.03 14:59:48 INFO  time: compiled bestgame in 0.58s
ΰοπ. 03, 2024 2:59:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3022
ΰοπ. 03, 2024 2:59:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3028
ΰοπ. 03, 2024 2:59:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3030
2024.04.03 15:00:07 INFO  compiling bestgame (1 scala source)
2024.04.03 15:00:07 INFO  time: compiled bestgame in 0.54s
2024.04.03 15:00:17 INFO  compiling bestgame (1 scala source)
2024.04.03 15:00:17 INFO  time: compiled bestgame in 0.61s
2024.04.03 15:00:53 INFO  compiling bestgame (1 scala source)
2024.04.03 15:00:53 INFO  time: compiled bestgame in 0.42s
2024.04.03 15:01:09 INFO  compiling bestgame (1 scala source)
2024.04.03 15:01:09 INFO  time: compiled bestgame in 0.38s
2024.04.03 15:01:09 INFO  compiling bestgame (1 scala source)
2024.04.03 15:01:10 INFO  time: compiled bestgame in 0.52s
2024.04.03 15:01:21 INFO  compiling bestgame (1 scala source)
2024.04.03 15:01:21 INFO  time: compiled bestgame in 0.42s
2024.04.03 15:02:56 INFO  compiling bestgame (1 scala source)
2024.04.03 15:02:56 INFO  time: compiled bestgame in 0.15s
2024.04.03 15:03:56 INFO  compiling bestgame (1 scala source)
2024.04.03 15:03:56 INFO  time: compiled bestgame in 0.46s
ΰοπ. 03, 2024 3:04:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3610
2024.04.03 15:05:54 INFO  compiling bestgame (1 scala source)
2024.04.03 15:05:54 INFO  time: compiled bestgame in 0.19s
2024.04.03 15:06:29 INFO  compiling bestgame (1 scala source)
2024.04.03 15:06:29 INFO  time: compiled bestgame in 0.36s
2024.04.03 15:06:32 INFO  compiling bestgame (1 scala source)
2024.04.03 15:06:32 INFO  time: compiled bestgame in 0.17s
2024.04.03 15:06:38 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\main.scala
scala.meta.tokenizers.TokenizeException: <input>:21: error: unclosed string interpolation
    return(s"$")
             ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 15:06:53 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\main.scala
scala.meta.tokenizers.TokenizeException: <input>:21: error: unclosed string interpolation
    return(s"${this.name} $")
                         ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:249)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 15:07:06 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\main.scala
scala.meta.tokenizers.TokenizeException: <input>:21: error: unclosed string interpolation
    return(s"${this.name} ${this.money} $")
                                       ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:249)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 15:07:13 INFO  compiling bestgame (1 scala source)
2024.04.03 15:07:13 INFO  time: compiled bestgame in 0.18s
2024.04.03 15:07:29 INFO  compiling bestgame (1 scala source)
2024.04.03 15:07:29 INFO  time: compiled bestgame in 0.62s
2024.04.03 15:14:25 INFO  compiling bestgame (1 scala source)
2024.04.03 15:14:25 INFO  time: compiled bestgame in 0.6s
2024.04.03 15:14:58 INFO  compiling bestgame (1 scala source)
2024.04.03 15:14:58 INFO  time: compiled bestgame in 0.36s
2024.04.03 15:17:26 INFO  compiling bestgame (1 scala source)
2024.04.03 15:17:26 INFO  time: compiled bestgame in 0.89s
2024.04.03 15:17:30 INFO  compiling bestgame (1 scala source)
2024.04.03 15:17:30 INFO  time: compiled bestgame in 0.92s
ΰοπ. 03, 2024 3:17:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4866
2024.04.03 15:17:36 INFO  compiling bestgame (1 scala source)
2024.04.03 15:17:36 INFO  time: compiled bestgame in 0.73s
2024.04.03 20:36:33 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 20:36:33 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 20:36:33 INFO  Connected to Build server: Bloop v1.5.15
2024.04.03 20:36:34 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.03 20:36:34 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.03 20:37:41 INFO  compiling bestgame (1 scala source)
2024.04.03 20:37:43 INFO  time: compiled bestgame in 2.38s
2024.04.03 20:38:15 INFO  compiling bestgame (1 scala source)
2024.04.03 20:38:15 INFO  time: compiled bestgame in 0.5s
2024.04.03 20:38:26 INFO  compiling bestgame (1 scala source)
2024.04.03 20:38:26 INFO  time: compiled bestgame in 0.52s
2024.04.03 20:38:30 INFO  compiling bestgame (1 scala source)
2024.04.03 20:38:30 INFO  time: compiled bestgame in 0.93s
2024.04.03 20:38:50 INFO  compiling bestgame (1 scala source)
2024.04.03 20:38:50 INFO  time: compiled bestgame in 0.7s
2024.04.03 20:38:58 INFO  compiling bestgame (1 scala source)
2024.04.03 20:38:58 INFO  time: compiled bestgame in 0.42s
2024.04.03 20:39:01 INFO  compiling bestgame (1 scala source)
2024.04.03 20:39:01 INFO  time: compiled bestgame in 0.37s
2024.04.03 20:43:30 INFO  compiling bestgame (1 scala source)
2024.04.03 20:43:30 INFO  time: compiled bestgame in 0.48s
2024.04.03 20:43:43 INFO  compiling bestgame (1 scala source)
2024.04.03 20:43:43 INFO  time: compiled bestgame in 0.65s
ΰοπ. 03, 2024 8:45:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: org.scalameta.invariants.InvariantFailedException: invariant failed:
when verifying scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable
found that scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable is false
where tpe = false
java.util.concurrent.CompletionException: org.scalameta.invariants.InvariantFailedException: invariant failed:
when verifying scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable
found that scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable is false
where tpe = false
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: org.scalameta.invariants.InvariantFailedException: invariant failed:
when verifying scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable
found that scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable is false
where tpe = false
	at org.scalameta.invariants.InvariantFailedException$.raise(Exceptions.scala:19)
	at scala.meta.Init$.apply(Trees.scala:860)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$initRest$1(ScalametaParser.scala:4146)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:322)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.initRest(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.initInsideTemplate(ScalametaParser.scala:4089)
	at scala.meta.internal.parsers.ScalametaParser.init(ScalametaParser.scala:4231)
	at scala.meta.internal.parsers.ScalametaParser.templateParents(ScalametaParser.scala:4241)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4289)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4277)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$2(ScalametaParser.scala:2257)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2255)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2223)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2206)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2081)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:1676)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:322)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1581)
	at scala.meta.internal.parsers.ScalametaParser.iter$2(ScalametaParser.scala:1703)
	at scala.meta.internal.parsers.ScalametaParser.exprOtherRest(ScalametaParser.scala:1728)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:1677)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:322)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1581)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$4(ScalametaParser.scala:4581)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4421)
	at scala.meta.internal.parsers.ScalametaParser.iter$6(ScalametaParser.scala:4581)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$1(ScalametaParser.scala:4598)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$1$adapted(ScalametaParser.scala:4548)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$listBy(ScalametaParser.scala:567)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4548)
	at scala.meta.internal.parsers.ScalametaParser.blockWithinDelims(ScalametaParser.scala:2487)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockInDelims$2(ScalametaParser.scala:2490)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOnOpen(ScalametaParser.scala:264)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockOnBrace$1(ScalametaParser.scala:2496)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockInDelims$1(ScalametaParser.scala:2490)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.blockInDelims(ScalametaParser.scala:2490)
	at scala.meta.internal.parsers.ScalametaParser.blockOnBrace(ScalametaParser.scala:2496)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExprOnBrace$2(ScalametaParser.scala:2499)
	at scala.meta.internal.parsers.ScalametaParser.blockExprPartial(ScalametaParser.scala:2483)
	at scala.meta.internal.parsers.ScalametaParser.blockExprOnBrace(ScalametaParser.scala:2499)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2252)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2223)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2206)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2081)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:1676)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:322)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1581)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1480)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$ifClause$1(ScalametaParser.scala:1541)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:368)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:373)
	at scala.meta.internal.parsers.ScalametaParser.ifClause(ScalametaParser.scala:1530)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:1587)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:322)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1581)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$4(ScalametaParser.scala:4581)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4421)
	at scala.meta.internal.parsers.ScalametaParser.iter$6(ScalametaParser.scala:4581)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$1(ScalametaParser.scala:4598)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$1$adapted(ScalametaParser.scala:4548)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$listBy(ScalametaParser.scala:567)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4548)
	at scala.meta.internal.parsers.ScalametaParser.blockWithinDelims(ScalametaParser.scala:2487)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockInDelims$2(ScalametaParser.scala:2490)
	at scala.meta.internal.parsers.ScalametaParser.indentedOnOpen(ScalametaParser.scala:278)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockOnIndent$1(ScalametaParser.scala:2492)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockInDelims$1(ScalametaParser.scala:2490)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.blockInDelims(ScalametaParser.scala:2490)
	at scala.meta.internal.parsers.ScalametaParser.blockOnIndent(ScalametaParser.scala:2492)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExprOnIndent$2(ScalametaParser.scala:2493)
	at scala.meta.internal.parsers.ScalametaParser.blockExprPartial(ScalametaParser.scala:2483)
	at scala.meta.internal.parsers.ScalametaParser.blockExprOnIndent(ScalametaParser.scala:2493)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2268)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2223)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2206)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2081)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:1676)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:322)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1581)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1480)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:3807)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:368)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:373)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:3769)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:3714)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3544)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3523)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1.applyOrElse(ScalametaParser.scala:4495)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1.applyOrElse(ScalametaParser.scala:4489)
	at scala.PartialFunction.$anonfun$runWith$1(PartialFunction.scala:231)
	at scala.PartialFunction.$anonfun$runWith$1$adapted(PartialFunction.scala:230)
	at scala.meta.internal.parsers.ScalametaParser.statSeqBuf(ScalametaParser.scala:4440)
	at scala.meta.internal.parsers.ScalametaParser.getStats$2(ScalametaParser.scala:4479)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$scala$meta$internal$parsers$ScalametaParser$$templateStatSeq$3(ScalametaParser.scala:4480)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$scala$meta$internal$parsers$ScalametaParser$$templateStatSeq$3$adapted(ScalametaParser.scala:4477)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$listBy(ScalametaParser.scala:567)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$templateStatSeq(ScalametaParser.scala:4477)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$templateStatSeq(ScalametaParser.scala:4469)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4322)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOr(ScalametaParser.scala:260)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:256)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4322)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4326)
	at scala.meta.internal.parsers.ScalametaParser.templateAfterExtends(ScalametaParser.scala:4269)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateOpt$1(ScalametaParser.scala:4317)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4307)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4007)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:368)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:373)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:3999)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:3876)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:3857)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$2.applyOrElse(ScalametaParser.scala:4461)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$2.applyOrElse(ScalametaParser.scala:4449)
	at scala.PartialFunction.$anonfun$runWith$1(PartialFunction.scala:231)
	at scala.PartialFunction.$anonfun$runWith$1$adapted(PartialFunction.scala:230)
	at scala.meta.internal.parsers.ScalametaParser.statSeqBuf(ScalametaParser.scala:4440)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$13(ScalametaParser.scala:4674)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:4674)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4630)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4623)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4623)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4628)
	at scala.meta.internal.parsers.ScalametaParser.parseSourceImpl(ScalametaParser.scala:135)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$1(ScalametaParser.scala:132)
	at scala.meta.internal.parsers.ScalametaParser.parseRuleAfterBOF(ScalametaParser.scala:59)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:54)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:132)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.parsers.Parse$$anon$1.apply(Parse.scala:36)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.parsing.Trees.$anonfun$parse$2(Trees.scala:151)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.parsing.Trees.parse(Trees.scala:142)
	at scala.meta.internal.parsing.Trees.didChange(Trees.scala:101)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$parseTreesAndPublishDiags$2(MetalsLspService.scala:849)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

ΰοπ. 03, 2024 8:45:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: org.scalameta.invariants.InvariantFailedException: invariant failed:
when verifying scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable
found that scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable is false
where tpe = false
java.util.concurrent.CompletionException: org.scalameta.invariants.InvariantFailedException: invariant failed:
when verifying scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable
found that scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable is false
where tpe = false
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: org.scalameta.invariants.InvariantFailedException: invariant failed:
when verifying scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable
found that scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable is false
where tpe = false
	at org.scalameta.invariants.InvariantFailedException$.raise(Exceptions.scala:19)
	at scala.meta.Init$.apply(Trees.scala:860)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$initRest$1(ScalametaParser.scala:4146)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:322)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.initRest(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.initInsideTemplate(ScalametaParser.scala:4089)
	at scala.meta.internal.parsers.ScalametaParser.init(ScalametaParser.scala:4231)
	at scala.meta.internal.parsers.ScalametaParser.templateParents(ScalametaParser.scala:4241)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4289)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4277)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$2(ScalametaParser.scala:2257)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2255)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2223)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2206)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2081)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:1676)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:322)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1581)
	at scala.meta.internal.parsers.ScalametaParser.iter$2(ScalametaParser.scala:1703)
	at scala.meta.internal.parsers.ScalametaParser.exprOtherRest(ScalametaParser.scala:1728)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:1677)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:322)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1581)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$4(ScalametaParser.scala:4581)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4421)
	at scala.meta.internal.parsers.ScalametaParser.iter$6(ScalametaParser.scala:4581)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$1(ScalametaParser.scala:4598)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$1$adapted(ScalametaParser.scala:4548)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$listBy(ScalametaParser.scala:567)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4548)
	at scala.meta.internal.parsers.ScalametaParser.blockWithinDelims(ScalametaParser.scala:2487)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockInDelims$2(ScalametaParser.scala:2490)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOnOpen(ScalametaParser.scala:264)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockOnBrace$1(ScalametaParser.scala:2496)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockInDelims$1(ScalametaParser.scala:2490)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.blockInDelims(ScalametaParser.scala:2490)
	at scala.meta.internal.parsers.ScalametaParser.blockOnBrace(ScalametaParser.scala:2496)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExprOnBrace$2(ScalametaParser.scala:2499)
	at scala.meta.internal.parsers.ScalametaParser.blockExprPartial(ScalametaParser.scala:2483)
	at scala.meta.internal.parsers.ScalametaParser.blockExprOnBrace(ScalametaParser.scala:2499)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2252)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2223)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2206)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2081)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:1676)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:322)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1581)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1480)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$ifClause$1(ScalametaParser.scala:1541)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:368)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:373)
	at scala.meta.internal.parsers.ScalametaParser.ifClause(ScalametaParser.scala:1530)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:1587)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:322)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1581)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$4(ScalametaParser.scala:4581)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4421)
	at scala.meta.internal.parsers.ScalametaParser.iter$6(ScalametaParser.scala:4581)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$1(ScalametaParser.scala:4598)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$1$adapted(ScalametaParser.scala:4548)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$listBy(ScalametaParser.scala:567)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4548)
	at scala.meta.internal.parsers.ScalametaParser.blockWithinDelims(ScalametaParser.scala:2487)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockInDelims$2(ScalametaParser.scala:2490)
	at scala.meta.internal.parsers.ScalametaParser.indentedOnOpen(ScalametaParser.scala:278)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockOnIndent$1(ScalametaParser.scala:2492)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockInDelims$1(ScalametaParser.scala:2490)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.blockInDelims(ScalametaParser.scala:2490)
	at scala.meta.internal.parsers.ScalametaParser.blockOnIndent(ScalametaParser.scala:2492)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExprOnIndent$2(ScalametaParser.scala:2493)
	at scala.meta.internal.parsers.ScalametaParser.blockExprPartial(ScalametaParser.scala:2483)
	at scala.meta.internal.parsers.ScalametaParser.blockExprOnIndent(ScalametaParser.scala:2493)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2268)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2223)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2206)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2081)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:1676)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:322)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1581)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1480)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:3807)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:368)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:373)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:3769)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:3714)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3544)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3523)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1.applyOrElse(ScalametaParser.scala:4495)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1.applyOrElse(ScalametaParser.scala:4489)
	at scala.PartialFunction.$anonfun$runWith$1(PartialFunction.scala:231)
	at scala.PartialFunction.$anonfun$runWith$1$adapted(PartialFunction.scala:230)
	at scala.meta.internal.parsers.ScalametaParser.statSeqBuf(ScalametaParser.scala:4440)
	at scala.meta.internal.parsers.ScalametaParser.getStats$2(ScalametaParser.scala:4479)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$scala$meta$internal$parsers$ScalametaParser$$templateStatSeq$3(ScalametaParser.scala:4480)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$scala$meta$internal$parsers$ScalametaParser$$templateStatSeq$3$adapted(ScalametaParser.scala:4477)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$listBy(ScalametaParser.scala:567)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$templateStatSeq(ScalametaParser.scala:4477)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$templateStatSeq(ScalametaParser.scala:4469)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4322)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOr(ScalametaParser.scala:260)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:256)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4322)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4326)
	at scala.meta.internal.parsers.ScalametaParser.templateAfterExtends(ScalametaParser.scala:4269)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateOpt$1(ScalametaParser.scala:4317)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4307)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4007)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:368)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:373)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:3999)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:3876)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:3857)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$2.applyOrElse(ScalametaParser.scala:4461)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$2.applyOrElse(ScalametaParser.scala:4449)
	at scala.PartialFunction.$anonfun$runWith$1(PartialFunction.scala:231)
	at scala.PartialFunction.$anonfun$runWith$1$adapted(PartialFunction.scala:230)
	at scala.meta.internal.parsers.ScalametaParser.statSeqBuf(ScalametaParser.scala:4440)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$13(ScalametaParser.scala:4674)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:4674)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4630)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4623)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4623)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4628)
	at scala.meta.internal.parsers.ScalametaParser.parseSourceImpl(ScalametaParser.scala:135)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$1(ScalametaParser.scala:132)
	at scala.meta.internal.parsers.ScalametaParser.parseRuleAfterBOF(ScalametaParser.scala:59)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:54)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:132)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.parsers.Parse$$anon$1.apply(Parse.scala:36)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.parsing.Trees.$anonfun$parse$2(Trees.scala:151)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.parsing.Trees.parse(Trees.scala:142)
	at scala.meta.internal.parsing.Trees.didChange(Trees.scala:101)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$parseTreesAndPublishDiags$2(MetalsLspService.scala:849)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2024.04.03 20:45:05 INFO  compiling bestgame (1 scala source)
2024.04.03 20:45:05 INFO  time: compiled bestgame in 0.35s
ΰοπ. 03, 2024 8:45:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5949
2024.04.03 20:45:54 INFO  compiling bestgame (1 scala source)
2024.04.03 20:45:54 INFO  time: compiled bestgame in 0.34s
2024.04.03 20:46:10 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\main.scala
scala.meta.tokenizers.TokenizeException: <input>:29: error: Invalid literal number
  var socketUsername: scala.collection.mutable.Map[0WebSocketChannel] = scala.collection.mutable.Map.empty
                                                   ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:820)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfUncertainToken$1(LegacyScanner.scala:864)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:872)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchZero$1(LegacyScanner.scala:330)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:332)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.03 20:46:16 INFO  compiling bestgame (1 scala source)
2024.04.03 20:46:16 INFO  time: compiled bestgame in 0.15s
2024.04.03 20:46:27 INFO  compiling bestgame (1 scala source)
2024.04.03 20:46:27 INFO  time: compiled bestgame in 0.13s
2024.04.03 20:46:55 INFO  compiling bestgame (1 scala source)
2024.04.03 20:46:55 INFO  time: compiled bestgame in 0.38s
ΰοπ. 03, 2024 8:47:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6340
2024.04.03 20:47:44 INFO  compiling bestgame (1 scala source)
2024.04.03 20:47:44 INFO  time: compiled bestgame in 0.36s
ΰοπ. 03, 2024 8:48:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6397
2024.04.03 20:48:14 INFO  compiling bestgame (1 scala source)
2024.04.03 20:48:14 INFO  time: compiled bestgame in 0.54s
2024.04.03 20:48:22 INFO  compiling bestgame (1 scala source)
2024.04.03 20:48:22 INFO  time: compiled bestgame in 0.52s
2024.04.03 20:48:39 INFO  compiling bestgame (1 scala source)
2024.04.03 20:48:39 INFO  time: compiled bestgame in 0.45s
2024.04.03 20:48:49 INFO  compiling bestgame (1 scala source)
2024.04.03 20:48:49 INFO  time: compiled bestgame in 0.34s
ΰοπ. 03, 2024 8:49:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6621
2024.04.03 20:51:28 INFO  compiling bestgame (1 scala source)
2024.04.03 20:51:28 INFO  time: compiled bestgame in 0.21s
2024.04.03 20:51:35 INFO  compiling bestgame (1 scala source)
2024.04.03 20:51:35 INFO  time: compiled bestgame in 0.64s
2024.04.03 20:52:31 INFO  compiling bestgame (1 scala source)
2024.04.03 20:52:31 INFO  time: compiled bestgame in 0.95s
2024.04.03 20:52:34 INFO  compiling bestgame (1 scala source)
2024.04.03 20:52:35 INFO  time: compiled bestgame in 1.58s
2024.04.03 20:52:57 INFO  compiling bestgame (1 scala source)
2024.04.03 20:52:57 INFO  time: compiled bestgame in 0.28s
2024.04.03 20:53:02 INFO  compiling bestgame (1 scala source)
2024.04.03 20:53:02 INFO  time: compiled bestgame in 0.2s
2024.04.03 20:53:17 INFO  compiling bestgame (1 scala source)
2024.04.03 20:53:17 INFO  time: compiled bestgame in 0.67s
2024.04.03 20:53:22 INFO  compiling bestgame (1 scala source)
2024.04.03 20:53:22 INFO  time: compiled bestgame in 0.14s
2024.04.03 20:53:34 INFO  compiling bestgame (1 scala source)
2024.04.03 20:53:34 INFO  time: compiled bestgame in 0.74s
2024.04.03 20:53:36 INFO  compiling bestgame (1 scala source)
2024.04.03 20:53:36 INFO  time: compiled bestgame in 0.52s
2024.04.03 20:53:55 INFO  compiling bestgame (1 scala source)
2024.04.03 20:53:55 INFO  time: compiled bestgame in 0.68s
2024.04.03 20:56:28 INFO  compiling bestgame (1 scala source)
2024.04.03 20:56:28 INFO  time: compiled bestgame in 0.36s
2024.04.03 20:57:14 INFO  compiling bestgame (1 scala source)
2024.04.03 20:57:14 INFO  time: compiled bestgame in 0.42s
2024.04.03 20:57:20 INFO  compiling bestgame (1 scala source)
2024.04.03 20:57:20 INFO  time: compiled bestgame in 0.66s
2024.04.03 20:57:30 INFO  compiling bestgame (1 scala source)
2024.04.03 20:57:30 INFO  time: compiled bestgame in 0.71s
2024.04.03 20:57:38 INFO  compiling bestgame (1 scala source)
2024.04.03 20:57:38 INFO  time: compiled bestgame in 0.51s
2024.04.03 20:57:51 INFO  compiling bestgame (1 scala source)
2024.04.03 20:57:51 INFO  time: compiled bestgame in 0.5s
2024.04.03 20:57:59 INFO  compiling bestgame (1 scala source)
2024.04.03 20:57:59 INFO  time: compiled bestgame in 0.38s
ΰοπ. 03, 2024 8:58:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7626
ΰοπ. 03, 2024 8:59:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7643
2024.04.03 20:59:42 INFO  time: code lens generation in 2.7s
2024.04.03 21:00:25 INFO  compiling bestgame (1 scala source)
2024.04.03 21:00:25 INFO  time: compiled bestgame in 0.19s
2024.04.03 21:00:32 INFO  compiling bestgame (1 scala source)
2024.04.03 21:00:32 INFO  time: compiled bestgame in 0.56s
2024.04.03 21:00:43 INFO  compiling bestgame (1 scala source)
2024.04.03 21:00:43 INFO  time: compiled bestgame in 0.36s
2024.04.03 21:02:09 INFO  compiling bestgame (1 scala source)
2024.04.03 21:02:09 INFO  time: compiled bestgame in 0.68s
ΰοπ. 03, 2024 9:02:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8039
2024.04.03 21:02:56 INFO  compiling bestgame (1 scala source)
2024.04.03 21:02:56 INFO  time: compiled bestgame in 0.5s
2024.04.03 21:03:16 INFO  compiling bestgame (1 scala source)
2024.04.03 21:03:16 INFO  time: compiled bestgame in 0.53s
2024.04.06 16:28:07 INFO  Started: Metals version 1.2.2 in folders 'D:\bestgame' for client Visual Studio Code 1.87.2.
16:28:11.554 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
16:28:11.556 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
16:28:11.556 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
16:28:11.558 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
16:28:11.558 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
16:28:11.558 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
16:28:11.558 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
16:28:11.558 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
16:28:11.559 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/C:/Users/yidtdr/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
16:28:11.561 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
16:28:11.561 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
16:28:11.561 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
16:28:11.561 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
16:28:11.561 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
16:28:11.561 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
16:28:11.564 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
16:28:11.564 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
16:28:11.564 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
16:28:11.565 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
16:28:11.565 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
16:28:11.642 [pool-1-thread-1] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:D:\bestgame\.metals\metals (H2 2.2)
16:28:11.642 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
16:28:11.643 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
16:28:11.643 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
16:28:11.644 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
16:28:11.647 [pool-1-thread-1] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
16:28:11.648 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
16:28:11.648 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
16:28:11.653 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
16:28:11.656 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
16:28:11.662 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
16:28:11.662 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
16:28:11.662 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
16:28:11.662 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
16:28:11.662 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
16:28:11.663 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
16:28:11.663 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
16:28:11.663 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
16:28:11.663 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
16:28:11.663 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
16:28:11.671 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.016s)
16:28:11.672 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
16:28:11.676 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
16:28:11.681 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
16:28:11.685 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 36 of 100M
2024.04.06 16:28:12 INFO  Attempting to connect to the build server...
2024.04.06 16:28:12 INFO  skipping build import with status 'Started'
2024.04.06 16:28:12 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.06 16:28:17 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.06 16:28:17 INFO  Attempting to connect to the build server...
2024.04.06 16:28:17 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.06 16:28:17 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.06 16:28:17 INFO  time: Connected to build server in 5.54s
2024.04.06 16:28:17 INFO  Connected to Build server: Bloop v1.5.15
2024.04.06 16:28:18 INFO  time: Imported build in 0.18s
2024.04.06 16:28:22 INFO  no build target found for D:\bestgame\src\main\scala\main.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.06 16:28:25 INFO  time: indexed workspace in 3.23s
2024.04.06 16:29:52 INFO  Shutting down server
2024.04.06 16:29:52 INFO  shutting down Metals
2024.04.06 16:29:52 INFO  Shut down connection with build server.
2024.04.06 16:29:52 INFO  Shut down connection with build server.
2024.04.06 16:29:52 INFO  Exiting server
2024.04.06 19:09:24 INFO  Started: Metals version 1.2.2 in folders 'D:\bestgame' for client Visual Studio Code 1.88.0.
19:09:26.163 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
19:09:26.165 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
19:09:26.165 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
19:09:26.170 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
19:09:26.170 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
19:09:26.170 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
19:09:26.171 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
19:09:26.171 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
19:09:26.171 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/C:/Users/yidtdr/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
19:09:26.173 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
19:09:26.173 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
19:09:26.173 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
19:09:26.173 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
19:09:26.173 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
19:09:26.173 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
19:09:26.178 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
19:09:26.179 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
19:09:26.179 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
19:09:26.179 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
19:09:26.179 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
19:09:26.355 [pool-1-thread-1] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:D:\bestgame\.metals\metals (H2 2.2)
19:09:26.357 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
19:09:26.357 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
19:09:26.358 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
19:09:26.359 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
19:09:26.366 [pool-1-thread-1] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
19:09:26.369 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
19:09:26.370 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
19:09:26.380 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
19:09:26.388 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
19:09:26.413 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
19:09:26.414 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
19:09:26.414 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
19:09:26.414 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
19:09:26.414 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
19:09:26.415 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
19:09:26.415 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
19:09:26.415 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
19:09:26.415 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
19:09:26.415 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
19:09:26.442 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.060s)
19:09:26.446 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
19:09:26.457 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
19:09:26.470 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
19:09:26.486 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 36 of 100M
2024.04.06 19:09:26 INFO  Attempting to connect to the build server...
2024.04.06 19:09:26 INFO  skipping build import with status 'Installed'
2024.04.06 19:09:26 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.06 19:09:26 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.06 19:09:26 INFO  Attempting to connect to the build server...
2024.04.06 19:09:26 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.06 19:09:27 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.06 19:09:27 INFO  time: Connected to build server in 1.07s
2024.04.06 19:09:27 INFO  Connected to Build server: Bloop v1.5.15
2024.04.06 19:09:28 INFO  time: Imported build in 0.28s
2024.04.06 19:09:40 INFO  no build target found for D:\bestgame\src\main\scala\main.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.06 19:09:45 INFO  time: indexed workspace in 4.34s
2024.04.06 19:25:40 INFO  Shutting down server
2024.04.06 19:25:40 INFO  shutting down Metals
2024.04.06 19:25:40 INFO  Shut down connection with build server.
2024.04.06 19:25:40 INFO  Shut down connection with build server.
2024.04.06 19:25:40 INFO  Exiting server
2024.04.07 16:15:13 INFO  Started: Metals version 1.2.2 in folders 'D:\bestgame' for client Visual Studio Code 1.88.0.
16:15:14.268 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
16:15:14.269 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
16:15:14.269 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
16:15:14.271 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
16:15:14.271 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
16:15:14.272 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
16:15:14.272 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
16:15:14.272 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
16:15:14.272 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/C:/Users/yidtdr/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
16:15:14.274 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
16:15:14.274 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
16:15:14.274 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
16:15:14.274 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
16:15:14.274 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
16:15:14.274 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
16:15:14.276 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
16:15:14.276 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
16:15:14.277 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
16:15:14.277 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
16:15:14.277 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
16:15:14.363 [pool-1-thread-1] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:D:\bestgame\.metals\metals (H2 2.2)
16:15:14.364 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
16:15:14.364 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
16:15:14.365 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
16:15:14.365 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
16:15:14.367 [pool-1-thread-1] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
16:15:14.368 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
16:15:14.368 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
16:15:14.373 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
16:15:14.376 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
16:15:14.381 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
16:15:14.381 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
16:15:14.381 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
16:15:14.381 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
16:15:14.381 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
16:15:14.381 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
16:15:14.382 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
16:15:14.382 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
16:15:14.382 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
16:15:14.382 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
16:15:14.389 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.016s)
16:15:14.391 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
16:15:14.394 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
16:15:14.398 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
16:15:14.403 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 34 of 100M
2024.04.07 16:15:15 INFO  Attempting to connect to the build server...
2024.04.07 16:15:15 INFO  skipping build import with status 'Installed'
2024.04.07 16:15:15 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 16:15:19 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 16:15:19 INFO  Attempting to connect to the build server...
2024.04.07 16:15:19 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 16:15:19 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 16:15:19 INFO  time: Connected to build server in 4.29s
2024.04.07 16:15:19 INFO  Connected to Build server: Bloop v1.5.15
2024.04.07 16:15:19 INFO  time: Imported build in 0.21s
2024.04.07 16:15:21 INFO  no build target found for D:\bestgame\src\main\scala\main.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.07 16:15:24 INFO  time: indexed workspace in 2.52s
ΰοπ. 07, 2024 4:15:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 21
2024.04.07 16:15:28 INFO  compiling bestgame (1 scala source)
2024.04.07 16:15:35 INFO  time: compiled bestgame in 7.32s
2024.04.07 16:15:35 INFO  compiling bestgame (1 scala source)
2024.04.07 16:15:38 INFO  time: compiled bestgame in 2.25s
ΰοπ. 07, 2024 4:15:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 46
2024.04.07 16:15:39 INFO  compiling bestgame (1 scala source)
2024.04.07 16:15:40 INFO  time: compiled bestgame in 1.69s
2024.04.07 16:17:44 INFO  compiling bestgame (1 scala source)
2024.04.07 16:17:44 INFO  time: compiled bestgame in 0.22s
2024.04.07 16:17:52 INFO  compiling bestgame (2 scala sources)
2024.04.07 16:17:52 INFO  time: compiled bestgame in 0.49s
2024.04.07 16:17:56 INFO  compiling bestgame (2 scala sources)
2024.04.07 16:17:56 INFO  time: compiled bestgame in 0.27s
ΰοπ. 07, 2024 4:18:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 146
2024.04.07 16:18:21 INFO  compiling bestgame (2 scala sources)
2024.04.07 16:18:21 INFO  time: compiled bestgame in 0.75s
2024.04.07 16:18:37 INFO  compiling bestgame (1 scala source)
2024.04.07 16:18:37 INFO  time: compiled bestgame in 0.2s
2024.04.07 16:18:51 INFO  compiling bestgame (3 scala sources)
2024.04.07 16:18:51 INFO  time: compiled bestgame in 0.35s
2024.04.07 16:19:05 INFO  compiling bestgame (3 scala sources)
2024.04.07 16:19:05 INFO  time: compiled bestgame in 0.28s
2024.04.07 16:19:06 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.07 16:19:14 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
ΰοπ. 07, 2024 4:19:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 327
2024.04.07 16:19:26 INFO  compiling bestgame (3 scala sources)
2024.04.07 16:19:26 INFO  time: compiled bestgame in 0.18s
2024.04.07 16:19:27 INFO  compiling bestgame (3 scala sources)
2024.04.07 16:19:27 INFO  time: compiled bestgame in 0.56s
ΰοπ. 07, 2024 4:19:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 406
ΰοπ. 07, 2024 4:19:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 414
2024.04.07 16:46:10 INFO  compiling bestgame (1 scala source)
2024.04.07 16:46:12 INFO  time: compiled bestgame in 1.75s
ΰοπ. 07, 2024 4:47:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 473
2024.04.07 16:47:37 INFO  compiling bestgame (1 scala source)
2024.04.07 16:47:37 INFO  time: compiled bestgame in 0.52s
ΰοπ. 07, 2024 4:58:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 663
2024.04.07 17:03:19 INFO  compiling bestgame (1 scala source)
2024.04.07 17:03:19 INFO  time: compiled bestgame in 0.46s
2024.04.07 17:06:08 INFO  compiling bestgame (1 scala source)
2024.04.07 17:06:08 INFO  time: compiled bestgame in 0.14s
2024.04.07 17:06:17 INFO  compiling bestgame (1 scala source)
2024.04.07 17:06:17 INFO  time: compiled bestgame in 0.11s
2024.04.07 17:06:24 WARN  Could not find semantic tokens for: file:///D:/bestgame/src/main/scala/SocketEvents.scala
2024.04.07 17:06:25 WARN  Could not find semantic tokens for: file:///D:/bestgame/src/main/scala/SocketEvents.scala
2024.04.07 17:06:26 INFO  compiling bestgame (1 scala source)
2024.04.07 17:06:26 INFO  time: compiled bestgame in 60ms
ΰοπ. 07, 2024 5:08:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 777
2024.04.07 17:08:37 INFO  compiling bestgame (1 scala source)
2024.04.07 17:08:37 INFO  time: compiled bestgame in 0.1s
2024.04.07 17:10:49 INFO  compiling bestgame (1 scala source)
2024.04.07 17:10:49 INFO  time: compiled bestgame in 0.27s
Exception in thread "pool-4-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:243)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
ΰοπ. 07, 2024 5:10:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1020
2024.04.07 17:10:53 INFO  compiling bestgame (1 scala source)
2024.04.07 17:10:53 INFO  time: compiled bestgame in 77ms
2024.04.07 17:11:09 INFO  compiling bestgame (1 scala source)
2024.04.07 17:11:09 INFO  time: compiled bestgame in 43ms
2024.04.07 17:11:18 INFO  compiling bestgame (1 scala source)
2024.04.07 17:11:18 INFO  time: compiled bestgame in 38ms
ΰοπ. 07, 2024 5:11:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1188
ΰοπ. 07, 2024 5:11:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1197
2024.04.07 17:12:05 INFO  compiling bestgame (1 scala source)
2024.04.07 17:12:05 INFO  time: compiled bestgame in 44ms
ΰοπ. 07, 2024 5:12:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1237
2024.04.07 17:12:09 INFO  compiling bestgame (1 scala source)
2024.04.07 17:12:09 INFO  time: compiled bestgame in 0.23s
2024.04.07 17:12:14 INFO  compiling bestgame (1 scala source)
2024.04.07 17:12:14 INFO  time: compiled bestgame in 0.16s
2024.04.07 17:12:20 INFO  compiling bestgame (1 scala source)
2024.04.07 17:12:20 INFO  time: compiled bestgame in 0.27s
2024.04.07 17:12:35 INFO  compiling bestgame (1 scala source)
2024.04.07 17:12:35 INFO  time: compiled bestgame in 0.15s
2024.04.07 17:12:37 INFO  compiling bestgame (1 scala source)
2024.04.07 17:12:37 INFO  time: compiled bestgame in 0.19s
2024.04.07 17:13:04 INFO  compiling bestgame (1 scala source)
2024.04.07 17:13:04 INFO  time: compiled bestgame in 89ms
2024.04.07 17:13:04 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:13:05 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:13:06 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:13:06 INFO  compiling bestgame (1 scala source)
2024.04.07 17:13:06 INFO  time: compiled bestgame in 66ms
2024.04.07 17:13:06 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:13:15 INFO  compiling bestgame (1 scala source)
2024.04.07 17:13:15 INFO  time: compiled bestgame in 64ms
2024.04.07 17:13:15 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:13:19 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:13:20 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:13:20 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:13:20 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:13:20 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:13:21 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:13:21 INFO  compiling bestgame (1 scala source)
2024.04.07 17:13:20 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:13:21 INFO  time: compiled bestgame in 37ms
2024.04.07 17:13:20 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:13:21 WARN  Using indexes to guess the definition of SocketEvent
2024.04.07 17:13:22 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:13:22 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:13:22 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:13:22 WARN  Using indexes to guess the definition of SocketEvent
2024.04.07 17:13:24 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:13:24 INFO  compiling bestgame (1 scala source)
2024.04.07 17:13:24 INFO  time: compiled bestgame in 58ms
2024.04.07 17:13:24 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:14:11 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:14:19 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:14:19 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:14:19 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.07 17:14:19 INFO  compiling bestgame (1 scala source)
2024.04.07 17:14:19 INFO  time: compiled bestgame in 0.17s
2024.04.07 17:15:12 INFO  compiling bestgame (1 scala source)
2024.04.07 17:15:12 INFO  time: compiled bestgame in 59ms
2024.04.07 17:15:23 INFO  compiling bestgame (1 scala source)
2024.04.07 17:15:23 INFO  time: compiled bestgame in 70ms
2024.04.07 17:15:35 INFO  compiling bestgame (1 scala source)
2024.04.07 17:15:35 INFO  time: compiled bestgame in 64ms
2024.04.07 17:15:44 INFO  compiling bestgame (1 scala source)
2024.04.07 17:15:44 INFO  time: compiled bestgame in 83ms
2024.04.07 17:15:58 INFO  compiling bestgame (1 scala source)
2024.04.07 17:15:58 INFO  time: compiled bestgame in 35ms
2024.04.07 17:16:10 INFO  compiling bestgame (1 scala source)
2024.04.07 17:16:10 INFO  time: compiled bestgame in 59ms
2024.04.07 17:16:42 INFO  compiling bestgame (1 scala source)
2024.04.07 17:16:42 INFO  time: compiled bestgame in 0.3s
2024.04.07 17:16:47 WARN  Using indexes to guess the definition of SocketEvent
2024.04.07 17:16:48 INFO  compiling bestgame (1 scala source)
2024.04.07 17:16:48 INFO  time: compiled bestgame in 0.21s
2024.04.07 17:16:54 INFO  compiling bestgame (1 scala source)
2024.04.07 17:16:54 INFO  time: compiled bestgame in 60ms
2024.04.07 17:17:02 INFO  compiling bestgame (1 scala source)
2024.04.07 17:17:02 INFO  time: compiled bestgame in 0.17s
2024.04.07 17:17:17 INFO  compiling bestgame (1 scala source)
2024.04.07 17:17:17 INFO  time: compiled bestgame in 71ms
2024.04.07 17:17:23 INFO  compiling bestgame (1 scala source)
2024.04.07 17:17:23 INFO  time: compiled bestgame in 80ms
2024.04.07 17:17:25 INFO  compiling bestgame (1 scala source)
2024.04.07 17:17:25 INFO  time: compiled bestgame in 78ms
2024.04.07 17:17:57 INFO  compiling bestgame (1 scala source)
2024.04.07 17:17:57 INFO  time: compiled bestgame in 64ms
ΰοπ. 07, 2024 5:17:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2290
2024.04.07 17:17:59 INFO  compiling bestgame (1 scala source)
2024.04.07 17:17:59 INFO  time: compiled bestgame in 59ms
2024.04.07 17:18:02 INFO  compiling bestgame (1 scala source)
2024.04.07 17:18:02 INFO  time: compiled bestgame in 63ms
2024.04.07 17:18:05 INFO  compiling bestgame (1 scala source)
2024.04.07 17:18:05 INFO  time: compiled bestgame in 0.19s
ΰοπ. 07, 2024 5:18:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2380
2024.04.07 17:18:47 INFO  compiling bestgame (1 scala source)
2024.04.07 17:18:47 INFO  time: compiled bestgame in 0.16s
2024.04.07 17:19:32 INFO  compiling bestgame (1 scala source)
2024.04.07 17:19:32 INFO  time: compiled bestgame in 0.18s
2024.04.07 17:20:29 INFO  compiling bestgame (1 scala source)
2024.04.07 17:20:29 INFO  time: compiled bestgame in 0.23s
ΰοπ. 07, 2024 5:20:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2752
2024.04.07 17:20:41 INFO  compiling bestgame (1 scala source)
2024.04.07 17:20:41 INFO  time: compiled bestgame in 59ms
2024.04.07 17:20:50 INFO  compiling bestgame (1 scala source)
2024.04.07 17:20:50 INFO  time: compiled bestgame in 0.16s
ΰοπ. 07, 2024 5:20:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2803
ΰοπ. 07, 2024 5:21:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2826
ΰοπ. 07, 2024 5:21:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2841
ΰοπ. 07, 2024 5:21:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2849
2024.04.07 17:21:54 INFO  compiling bestgame (1 scala source)
2024.04.07 17:21:54 INFO  time: compiled bestgame in 0.17s
2024.04.07 17:22:51 INFO  compiling bestgame (1 scala source)
2024.04.07 17:22:51 INFO  time: compiled bestgame in 0.26s
ΰοπ. 07, 2024 5:23:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2977
ΰοπ. 07, 2024 5:23:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2994
2024.04.07 17:23:34 INFO  compiling bestgame (1 scala source)
2024.04.07 17:23:34 INFO  time: compiled bestgame in 0.46s
2024.04.07 17:23:51 INFO  compiling bestgame (1 scala source)
2024.04.07 17:23:51 INFO  time: compiled bestgame in 0.75s
2024.04.07 17:24:33 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:24:37 INFO  time: compiled bestgame in 4.43s
2024.04.07 17:24:47 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:24:48 INFO  time: compiled bestgame in 1.2s
2024.04.07 17:24:56 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:24:56 INFO  time: compiled bestgame in 0.7s
2024.04.07 17:24:58 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:24:58 INFO  time: compiled bestgame in 0.77s
2024.04.07 17:25:01 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:25:01 INFO  time: compiled bestgame in 0.8s
2024.04.07 17:25:04 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:25:04 INFO  time: compiled bestgame in 0.72s
ΰοπ. 07, 2024 5:25:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3405
2024.04.07 17:25:25 INFO  compiling bestgame (2 scala sources)
ΰοπ. 07, 2024 5:25:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3496
2024.04.07 17:25:27 INFO  time: compiled bestgame in 1.88s
2024.04.07 17:25:52 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:25:52 INFO  time: compiled bestgame in 0.72s
ΰοπ. 07, 2024 5:25:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3591
2024.04.07 17:26:02 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:26:02 INFO  time: compiled bestgame in 0.61s
2024.04.07 17:26:35 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:26:36 INFO  time: compiled bestgame in 1.77s
2024.04.07 17:27:22 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:27:22 INFO  time: compiled bestgame in 0.72s
2024.04.07 17:27:29 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:27:29 INFO  time: compiled bestgame in 0.16s
2024.04.07 17:27:33 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:27:33 INFO  time: compiled bestgame in 0.14s
2024.04.07 17:27:35 WARN  Using indexes to guess the definition of Ok
2024.04.07 17:27:41 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:27:41 INFO  time: compiled bestgame in 0.15s
2024.04.07 17:27:41 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:27:41 INFO  time: compiled bestgame in 0.14s
2024.04.07 17:27:50 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:27:50 INFO  time: compiled bestgame in 0.15s
2024.04.07 17:27:50 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:27:50 INFO  time: compiled bestgame in 0.15s
2024.04.07 17:27:51 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:27:51 INFO  time: compiled bestgame in 0.13s
2024.04.07 17:27:51 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:27:51 INFO  time: compiled bestgame in 0.14s
2024.04.07 17:27:54 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:27:54 INFO  time: compiled bestgame in 0.14s
2024.04.07 17:27:54 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:27:54 INFO  time: compiled bestgame in 0.13s
2024.04.07 17:28:02 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:28:02 INFO  time: compiled bestgame in 0.13s
2024.04.07 17:28:02 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:28:02 INFO  time: compiled bestgame in 0.15s
2024.04.07 17:28:06 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:28:06 INFO  time: compiled bestgame in 0.15s
2024.04.07 17:28:06 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:28:06 INFO  time: compiled bestgame in 0.14s
2024.04.07 17:28:06 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:28:06 INFO  time: compiled bestgame in 0.15s
2024.04.07 17:28:06 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:28:06 INFO  time: compiled bestgame in 0.15s
2024.04.07 17:28:06 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:28:06 INFO  time: compiled bestgame in 0.17s
2024.04.07 17:28:06 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:28:07 INFO  time: compiled bestgame in 0.21s
2024.04.07 17:28:10 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:28:10 INFO  time: compiled bestgame in 0.35s
2024.04.07 17:28:12 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:28:12 INFO  time: compiled bestgame in 0.15s
2024.04.07 17:28:18 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:28:18 INFO  time: compiled bestgame in 0.45s
2024.04.07 17:28:20 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:28:20 INFO  time: compiled bestgame in 0.13s
ΰοπ. 07, 2024 5:28:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4252
2024.04.07 17:28:29 INFO  compiling bestgame (2 scala sources)
2024.04.07 17:28:29 INFO  time: compiled bestgame in 0.63s
ΰοπ. 07, 2024 5:28:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4290
2024.04.07 17:29:11 INFO  compiling bestgame (1 scala source)
2024.04.07 17:29:11 INFO  time: compiled bestgame in 0.47s
2024.04.07 17:29:26 INFO  compiling bestgame (1 scala source)
2024.04.07 17:29:26 INFO  time: compiled bestgame in 0.42s
2024.04.07 17:29:37 INFO  compiling bestgame (1 scala source)
2024.04.07 17:29:37 INFO  time: compiled bestgame in 0.12s
2024.04.07 17:29:52 INFO  compiling bestgame (1 scala source)
2024.04.07 17:29:52 INFO  time: compiled bestgame in 0.41s
2024.04.07 17:29:58 WARN  Using indexes to guess the definition of Read
2024.04.07 17:30:17 INFO  compiling bestgame (1 scala source)
2024.04.07 17:30:17 INFO  time: compiled bestgame in 0.13s
2024.04.07 17:30:20 INFO  compiling bestgame (1 scala source)
2024.04.07 17:30:20 INFO  time: compiled bestgame in 0.32s
ΰοπ. 07, 2024 5:30:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4730
2024.04.07 17:31:22 WARN  Using indexes to guess the definition of App
2024.04.07 17:32:56 INFO  compiling bestgame (1 scala source)
2024.04.07 17:32:56 INFO  time: compiled bestgame in 0.4s
2024.04.07 17:32:59 INFO  compiling bestgame (1 scala source)
2024.04.07 17:32:59 INFO  time: compiled bestgame in 0.37s
2024.04.07 17:33:19 INFO  compiling bestgame (1 scala source)
2024.04.07 17:33:19 INFO  time: compiled bestgame in 0.64s
ΰοπ. 07, 2024 5:33:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5115
ΰοπ. 07, 2024 5:33:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5124
2024.04.07 17:33:53 INFO  compiling bestgame (1 scala source)
2024.04.07 17:33:53 INFO  time: compiled bestgame in 0.37s
2024.04.07 17:34:19 INFO  compiling bestgame (1 scala source)
2024.04.07 17:34:19 INFO  time: compiled bestgame in 0.12s
2024.04.07 17:36:31 INFO  compiling bestgame (1 scala source)
2024.04.07 17:36:31 INFO  time: compiled bestgame in 64ms
2024.04.07 17:36:38 INFO  compiling bestgame (1 scala source)
2024.04.07 17:36:38 INFO  time: compiled bestgame in 48ms
2024.04.07 17:36:48 INFO  compiling bestgame (1 scala source)
2024.04.07 17:36:48 INFO  time: compiled bestgame in 57ms
2024.04.07 17:36:53 INFO  compiling bestgame (1 scala source)
2024.04.07 17:36:53 INFO  time: compiled bestgame in 51ms
2024.04.07 17:37:00 INFO  compiling bestgame (1 scala source)
2024.04.07 17:37:00 INFO  time: compiled bestgame in 65ms
2024.04.07 17:37:12 INFO  compiling bestgame (1 scala source)
2024.04.07 17:37:12 INFO  time: compiled bestgame in 90ms
2024.04.07 17:37:17 INFO  compiling bestgame (1 scala source)
2024.04.07 17:37:17 INFO  time: compiled bestgame in 63ms
2024.04.07 17:37:30 INFO  compiling bestgame (1 scala source)
2024.04.07 17:37:30 INFO  time: compiled bestgame in 0.18s
2024.04.07 17:38:19 WARN  Using indexes to guess the definition of plant
2024.04.07 17:38:22 INFO  compiling bestgame (1 scala source)
2024.04.07 17:38:22 INFO  time: compiled bestgame in 0.16s
2024.04.07 17:38:40 INFO  compiling bestgame (1 scala source)
2024.04.07 17:38:40 INFO  time: compiled bestgame in 71ms
2024.04.07 17:38:44 INFO  compiling bestgame (1 scala source)
2024.04.07 17:38:44 INFO  time: compiled bestgame in 0.13s
2024.04.07 17:39:15 INFO  compiling bestgame (1 scala source)
2024.04.07 17:39:15 INFO  time: compiled bestgame in 0.15s
ΰοπ. 07, 2024 5:39:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6028
2024.04.07 17:39:20 INFO  compiling bestgame (1 scala source)
2024.04.07 17:39:20 INFO  time: compiled bestgame in 0.14s
2024.04.07 17:39:37 INFO  compiling bestgame (1 scala source)
2024.04.07 17:39:37 INFO  time: compiled bestgame in 0.16s
2024.04.07 17:40:10 INFO  compiling bestgame (1 scala source)
2024.04.07 17:40:10 INFO  time: compiled bestgame in 0.19s
ΰοπ. 07, 2024 5:49:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6257
ΰοπ. 07, 2024 5:50:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6301
2024.04.07 17:50:42 INFO  compiling bestgame (1 scala source)
2024.04.07 17:50:44 INFO  time: compiled bestgame in 1.61s
2024.04.07 18:35:40 INFO  compiling bestgame (1 scala source)
2024.04.07 18:35:41 INFO  time: compiled bestgame in 1.62s
2024.04.07 18:35:41 INFO  compiling bestgame (1 scala source)
2024.04.07 18:35:41 INFO  time: compiled bestgame in 0.3s
2024.04.07 18:35:43 INFO  compiling bestgame (1 scala source)
2024.04.07 18:35:43 INFO  time: compiled bestgame in 6ms
2024.04.07 18:35:46 INFO  compiling bestgame (1 scala source)
2024.04.07 18:35:46 INFO  time: compiled bestgame in 0.31s
ΰοπ. 07, 2024 6:35:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6427
2024.04.07 18:35:59 INFO  compiling bestgame (1 scala source)
2024.04.07 18:36:01 INFO  time: compiled bestgame in 1.9s
2024.04.07 18:36:17 INFO  compiling bestgame (1 scala source)
2024.04.07 18:36:17 INFO  time: compiled bestgame in 0.77s
2024.04.07 18:37:11 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\App.scala
scala.meta.tokenizers.TokenizeException: <input>:43: error: Invalid literal number
                ((1toInt).+(1.toInt))  // νσ ηΰοθυνσςό ξαπΰαξςκσ ξψθακθ χςξ χελ ρ χθςΰμθ νες ςΰκθυ ρξξαεωνθι
                  ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:820)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfUncertainToken$1(LegacyScanner.scala:864)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:872)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:335)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.07 18:37:14 INFO  compiling bestgame (1 scala source)
2024.04.07 18:37:14 INFO  time: compiled bestgame in 0.34s
2024.04.07 18:37:19 INFO  compiling bestgame (1 scala source)
2024.04.07 18:37:19 INFO  time: compiled bestgame in 0.14s
2024.04.07 18:37:30 INFO  compiling bestgame (1 scala source)
2024.04.07 18:37:30 INFO  time: compiled bestgame in 0.11s
2024.04.07 18:37:52 INFO  compiling bestgame (1 scala source)
2024.04.07 18:37:52 INFO  time: compiled bestgame in 0.18s
2024.04.07 18:37:57 INFO  compiling bestgame (1 scala source)
2024.04.07 18:37:57 INFO  time: compiled bestgame in 93ms
2024.04.07 18:38:03 INFO  compiling bestgame (1 scala source)
2024.04.07 18:38:03 INFO  time: compiled bestgame in 72ms
2024.04.07 18:38:06 INFO  compiling bestgame (1 scala source)
2024.04.07 18:38:06 INFO  time: compiled bestgame in 65ms
2024.04.07 18:38:07 INFO  compiling bestgame (1 scala source)
2024.04.07 18:38:07 INFO  time: compiled bestgame in 65ms
2024.04.07 18:38:09 INFO  compiling bestgame (1 scala source)
2024.04.07 18:38:09 INFO  time: compiled bestgame in 0.24s
2024.04.07 18:38:15 INFO  compiling bestgame (1 scala source)
2024.04.07 18:38:15 INFO  time: compiled bestgame in 0.14s
2024.04.07 18:38:22 INFO  compiling bestgame (1 scala source)
2024.04.07 18:38:22 INFO  time: compiled bestgame in 0.14s
2024.04.07 18:38:35 INFO  compiling bestgame (1 scala source)
2024.04.07 18:38:35 INFO  time: compiled bestgame in 0.17s
2024.04.07 18:38:42 INFO  compiling bestgame (1 scala source)
2024.04.07 18:38:42 INFO  time: compiled bestgame in 0.14s
ΰοπ. 07, 2024 6:39:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7122
ΰοπ. 07, 2024 6:39:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7135
2024.04.07 18:39:10 INFO  compiling bestgame (1 scala source)
2024.04.07 18:39:10 INFO  time: compiled bestgame in 0.87s
2024.04.07 18:39:13 INFO  compiling bestgame (1 scala source)
2024.04.07 18:39:13 INFO  time: compiled bestgame in 0.12s
2024.04.07 18:39:13 INFO  compiling bestgame (1 scala source)
2024.04.07 18:39:14 INFO  time: compiled bestgame in 67ms
2024.04.07 18:39:35 INFO  compiling bestgame (1 scala source)
2024.04.07 18:39:35 INFO  time: compiled bestgame in 0.66s
2024.04.07 18:39:43 INFO  compiling bestgame (1 scala source)
2024.04.07 18:39:43 INFO  time: compiled bestgame in 0.34s
2024.04.07 20:55:29 INFO  time: code lens generation in 1.07s
2024.04.07 20:55:29 INFO  time: code lens generation in 4.61s
2024.04.07 20:55:29 INFO  time: code lens generation in 6.72s
2024.04.07 20:55:29 INFO  time: code lens generation in 5.52s
2024.04.07 20:55:29 INFO  time: code lens generation in 7.91s
2024.04.07 20:55:33 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals1306774444531873506\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.07 20:55:34 ERROR sbt.internal.ServerAlreadyBootingException: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-1466779760368203317_lock, error 5
2024.04.07 20:55:34 INFO  sbt thinks that server is already booting because of this exception:
2024.04.07 20:55:34 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:357)
2024.04.07 20:55:34 ERROR 	at sbt.internal.BootServerSocket.<init>(BootServerSocket.java:296)
2024.04.07 20:55:34 ERROR 	at sbt.xMain$.getSocketOrExit(Main.scala:152)
2024.04.07 20:55:34 ERROR 	at sbt.xMain$.bootServerSocket$lzycompute$1(Main.scala:78)
2024.04.07 20:55:34 ERROR 	at sbt.xMain$.bootServerSocket$1(Main.scala:78)
2024.04.07 20:55:34 ERROR 	at sbt.xMain$.withStreams$1(Main.scala:86)
2024.04.07 20:55:34 ERROR 	at sbt.xMain$.run(Main.scala:123)
2024.04.07 20:55:34 ERROR 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
2024.04.07 20:55:34 ERROR 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
2024.04.07 20:55:34 ERROR 	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
2024.04.07 20:55:34 ERROR 	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
2024.04.07 20:55:34 ERROR 	at sbt.internal.XMainConfiguration.run(XMainConfiguration.java:59)
2024.04.07 20:55:34 ERROR 	at sbt.xMain.run(Main.scala:47)
2024.04.07 20:55:34 ERROR 	at xsbt.boot.Launch$.$anonfun$run$1(Launch.scala:149)
2024.04.07 20:55:34 ERROR 	at xsbt.boot.Launch$.withContextLoader(Launch.scala:176)
2024.04.07 20:55:34 ERROR 	at xsbt.boot.Launch$.run(Launch.scala:149)
2024.04.07 20:55:34 ERROR 	at xsbt.boot.Launch$.$anonfun$apply$1(Launch.scala:44)
2024.04.07 20:55:34 ERROR 	at xsbt.boot.Launch$.launch(Launch.scala:159)
2024.04.07 20:55:34 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:44)
2024.04.07 20:55:34 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:21)
2024.04.07 20:55:34 ERROR 	at xsbt.boot.Boot$.runImpl(Boot.scala:78)
2024.04.07 20:55:34 ERROR 	at xsbt.boot.Boot$.run(Boot.scala:73)
2024.04.07 20:55:34 ERROR 	at xsbt.boot.Boot$.main(Boot.scala:21)
2024.04.07 20:55:34 ERROR 	at xsbt.boot.Boot.main(Boot.scala)
2024.04.07 20:55:34 ERROR Caused by: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-1466779760368203317_lock, error 5
2024.04.07 20:55:34 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:129)
2024.04.07 20:55:34 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:48)
2024.04.07 20:55:34 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:351)
2024.04.07 20:55:34 ERROR 	... 23 more
2024.04.07 20:55:34 INFO  time: ran 'sbt bloopInstall' in 1.15s
2024.04.07 20:55:34 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals1306774444531873506\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.07 20:55:34 INFO  Disconnecting from Bloop session...
2024.04.07 20:55:34 INFO  Shut down connection with build server.
2024.04.07 20:55:34 INFO  Shut down connection with build server.
2024.04.07 20:55:34 INFO  Attempting to connect to the build server...
2024.04.07 20:55:34 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 20:55:34 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 20:55:34 INFO  Attempting to connect to the build server...
2024.04.07 20:55:34 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 20:55:34 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 20:55:34 INFO  time: Connected to build server in 0.58s
2024.04.07 20:55:34 INFO  Connected to Build server: Bloop v1.5.15
2024.04.07 20:55:35 INFO  time: Imported build in 0.29s
2024.04.07 20:55:41 INFO  time: indexed workspace in 5.83s
2024.04.07 20:55:47 INFO  time: code lens generation in 5.35s
ΰοπ. 07, 2024 8:56:00 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-07\r_compiler-error_(bestgame-build)_20-56-00-830.md
ΰοπ. 07, 2024 8:56:08 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-07\r_compiler-error_(bestgame-build)_20-56-08-353.md
ΰοπ. 07, 2024 8:56:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7474
ΰοπ. 07, 2024 8:56:14 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-07\r_compiler-error_(bestgame-build)_20-56-14-154.md
ΰοπ. 07, 2024 8:56:19 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-07\r_compiler-error_(bestgame-build)_20-56-19-581.md
2024.04.07 20:56:23 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\build.sbt
scala.meta.tokenizers.TokenizeException: <input>:16: error: unclosed string literal
libraryDependencies += "io.getquill" %% "quill-jdbc-zio" % "4.8.0"   "io.getquill" %% "quill-jdbc-zio" % "4.
                                                                                                         ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.07 20:56:23 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\build.sbt
scala.meta.tokenizers.TokenizeException: <input>:16: error: unclosed string literal
libraryDependencies += "io.getquill" %% "quill-jdbc-zio" % "4.8.0"   "io.getquill" %% "quill-jdbc-
                                                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.07 20:56:24 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\build.sbt
scala.meta.tokenizers.TokenizeException: <input>:16: error: unclosed string literal
libraryDependencies += "io.getquill" %% "quill-jdbc-zio" % "4.8.0"   "io.getquill" %% "
                                                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.07 20:56:25 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\build.sbt
scala.meta.tokenizers.TokenizeException: <input>:16: error: unclosed string literal
libraryDependencies += "io.getquill" %% "quill-jdbc-zio" % "4.8.0"   "io.
                                                                     ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.07 20:56:25 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\build.sbt
scala.meta.tokenizers.TokenizeException: <input>:16: error: unclosed string literal
libraryDependencies += "io.getquill" %% "quill-jdbc-zio" % "4.8.0"   "
                                                                     ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

ΰοπ. 07, 2024 8:57:11 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-07\r_compiler-error_(bestgame-build)_20-57-11-005.md
ΰοπ. 07, 2024 8:57:11 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-07\r_compiler-error_(bestgame-build)_20-57-11-855.md
2024.04.07 20:57:11 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\build.sbt
scala.meta.tokenizers.TokenizeException: <input>:14: error: unclosed string literal
libraryDependencies += "dev.zio" %% "zio-http" % "3.0.0-RC3
                                                 ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:30)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.lang.Thread.run(Thread.java:833)

2024.04.07 20:58:30 INFO  Shutting down server
2024.04.07 20:58:30 INFO  shutting down Metals
2024.04.07 20:58:30 INFO  Shut down connection with build server.
2024.04.07 20:58:30 INFO  Shut down connection with build server.
2024.04.07 20:58:30 INFO  Exiting server
2024.04.07 20:58:43 INFO  Started: Metals version 1.2.2 in folders 'D:\bestgame' for client Visual Studio Code 1.88.0.
20:58:43.450 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
20:58:43.451 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
20:58:43.451 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
20:58:43.453 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
20:58:43.453 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
20:58:43.453 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
20:58:43.453 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
20:58:43.453 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
20:58:43.454 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/C:/Users/yidtdr/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
20:58:43.455 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
20:58:43.455 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
20:58:43.455 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
20:58:43.456 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
20:58:43.456 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
20:58:43.456 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
20:58:43.458 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
20:58:43.458 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
20:58:43.459 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
20:58:43.459 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
20:58:43.459 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
20:58:43.531 [pool-1-thread-1] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:D:\bestgame\.metals\metals (H2 2.2)
20:58:43.531 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
20:58:43.531 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
20:58:43.531 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
20:58:43.531 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
20:58:43.534 [pool-1-thread-1] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
20:58:43.535 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
20:58:43.535 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
20:58:43.540 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
20:58:43.542 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
20:58:43.546 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
20:58:43.547 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
20:58:43.547 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
20:58:43.547 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
20:58:43.547 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
20:58:43.547 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
20:58:43.547 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
20:58:43.547 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
20:58:43.547 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
20:58:43.547 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
20:58:43.556 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.015s)
20:58:43.558 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
20:58:43.561 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
20:58:43.564 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
20:58:43.568 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 34 of 100M
2024.04.07 20:58:43 WARN  no build target for: D:\bestgame\build.sbt
ΰοπ. 07, 2024 8:58:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1
2024.04.07 20:58:44 INFO  Attempting to connect to the build server...
2024.04.07 20:58:44 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 20:58:44 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 20:58:44 INFO  Attempting to connect to the build server...
2024.04.07 20:58:44 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 20:58:44 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 20:58:44 INFO  time: Connected to build server in 0.69s
2024.04.07 20:58:44 INFO  Connected to Build server: Bloop v1.5.15
2024.04.07 20:58:45 INFO  time: Imported build in 0.33s
2024.04.07 20:58:45 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals13767970681568820220\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.07 20:58:47 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.07 20:58:49 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.07 20:58:50 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.07 20:58:52 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.07 20:58:52 INFO  [info] loading project definition from D:\bestgame\project
2024.04.07 20:58:53 INFO  no build target found for D:\bestgame\build.sbt. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.07 20:58:57 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.07 20:58:57 INFO  [success] Total time: 5 s, completed 7 Π°ΠΏΡ€. 2024 Π³., 20:58:57
2024.04.07 20:58:57 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.07 20:58:57 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.07 20:58:59 INFO  [success] Generated .bloop\bestgame.json
2024.04.07 20:58:59 INFO  [success] Generated .bloop\bestgame-test.json
2024.04.07 20:58:59 INFO  [success] Total time: 1 s, completed 7 Π°ΠΏΡ€. 2024 Π³., 20:58:59
2024.04.07 20:58:59 INFO  time: ran 'sbt bloopInstall' in 13s
2024.04.07 20:58:59 INFO  Disconnecting from Bloop session...
2024.04.07 20:58:59 INFO  Shut down connection with build server.
2024.04.07 20:58:59 INFO  Shut down connection with build server.
2024.04.07 20:58:59 INFO  Attempting to connect to the build server...
2024.04.07 20:58:59 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 20:58:59 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 20:58:59 INFO  Attempting to connect to the build server...
2024.04.07 20:58:59 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 20:58:59 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 20:58:59 INFO  time: Connected to build server in 0.21s
2024.04.07 20:58:59 INFO  Connected to Build server: Bloop v1.5.15
2024.04.07 20:58:59 INFO  time: Imported build in 0.11s
ΰοπ. 07, 2024 8:59:00 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-07\r_compiler-error_(bestgame-build)_20-59-00-108.md
2024.04.07 20:58:59 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.07 20:59:00 INFO  time: indexed workspace in 6.02s
2024.04.07 20:59:01 INFO  time: indexed workspace in 1.81s
2024.04.07 20:59:02 INFO  skipping build import with status 'Dismissed'
2024.04.07 20:59:04 INFO  skipping build import with status 'Dismissed'
2024.04.07 20:59:05 INFO  skipping build import with status 'Dismissed'
2024.04.07 20:59:05 INFO  time: code lens generation in 2.9s
2024.04.07 20:59:05 INFO  time: code lens generation in 2.9s
2024.04.07 20:59:05 INFO  time: code lens generation in 2.5s
2024.04.07 20:59:05 INFO  time: code lens generation in 2.9s
2024.04.07 20:59:05 INFO  time: code lens generation in 2.9s
2024.04.07 20:59:05 INFO  time: code lens generation in 2.9s
2024.04.07 20:59:05 INFO  time: code lens generation in 2.9s
2024.04.07 20:59:05 INFO  time: code lens generation in 2.9s
2024.04.07 20:59:05 INFO  time: code lens generation in 2.9s
2024.04.07 20:59:06 INFO  skipping build import with status 'Dismissed'
2024.04.07 20:59:05 INFO  skipping build import with status 'Dismissed'
2024.04.07 20:59:06 INFO  skipping build import with status 'Dismissed'
2024.04.07 20:59:07 INFO  skipping build import with status 'Dismissed'
2024.04.07 20:59:07 INFO  skipping build import with status 'Dismissed'
2024.04.07 20:59:07 INFO  skipping build import with status 'Dismissed'
2024.04.07 20:59:09 INFO  skipping build import with status 'Dismissed'
2024.04.07 20:59:09 INFO  skipping build import with status 'Dismissed'
2024.04.07 20:59:12 INFO  skipping build import with status 'Dismissed'
2024.04.07 20:59:15 INFO  skipping build import with status 'Dismissed'
2024.04.07 20:59:17 INFO  skipping build import with status 'Dismissed'
2024.04.07 20:59:18 INFO  Shutting down server
2024.04.07 20:59:18 INFO  shutting down Metals
2024.04.07 20:59:18 INFO  Shut down connection with build server.
2024.04.07 20:59:18 INFO  Shut down connection with build server.
2024.04.07 20:59:18 INFO  Exiting server
2024.04.07 20:59:28 INFO  Started: Metals version 1.2.2 in folders 'D:\bestgame' for client Visual Studio Code 1.88.0.
20:59:29.443 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
20:59:29.445 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
20:59:29.445 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
20:59:29.448 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
20:59:29.448 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
20:59:29.448 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
20:59:29.448 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
20:59:29.448 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
20:59:29.448 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/C:/Users/yidtdr/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
20:59:29.450 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
20:59:29.450 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
20:59:29.450 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
20:59:29.450 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
20:59:29.450 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
20:59:29.450 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
20:59:29.452 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
20:59:29.452 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
20:59:29.453 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
20:59:29.453 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
20:59:29.453 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
20:59:29.540 [pool-1-thread-1] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:D:\bestgame\.metals\metals (H2 2.2)
20:59:29.540 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
20:59:29.540 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
20:59:29.541 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
20:59:29.541 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
20:59:29.543 [pool-1-thread-1] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
20:59:29.544 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
20:59:29.545 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
20:59:29.551 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
20:59:29.554 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
20:59:29.558 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
20:59:29.559 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
20:59:29.559 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
20:59:29.559 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
20:59:29.559 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
20:59:29.559 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
20:59:29.559 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
20:59:29.559 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
20:59:29.559 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
20:59:29.559 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
20:59:29.566 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.013s)
20:59:29.567 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
20:59:29.573 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
20:59:29.575 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
20:59:29.579 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 34 of 100M
2024.04.07 20:59:29 INFO  Attempting to connect to the build server...
2024.04.07 20:59:29 INFO  skipping build import with status 'Dismissed'
2024.04.07 20:59:29 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 20:59:30 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 20:59:30 INFO  Attempting to connect to the build server...
2024.04.07 20:59:30 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 20:59:30 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 20:59:30 INFO  time: Connected to build server in 0.52s
2024.04.07 20:59:30 INFO  Connected to Build server: Bloop v1.5.15
2024.04.07 20:59:29 INFO  skipping build import with status 'Dismissed'
2024.04.07 20:59:30 WARN  no build target for: D:\bestgame\build.sbt
2024.04.07 20:59:34 WARN  no build target for: D:\bestgame\build.sbt
2024.04.07 20:59:34 INFO  skipping build import with status 'Dismissed'
2024.04.07 20:59:34 INFO  no build target found for D:\bestgame\build.sbt. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.07 20:59:38 INFO  time: indexed workspace in 3.39s
2024.04.07 20:59:38 INFO  no build target found for D:\bestgame\build.sbt. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.07 20:59:40 INFO  time: code lens generation in 1.31s
2024.04.07 20:59:40 INFO  time: code lens generation in 1.31s
2024.04.07 20:59:40 INFO  time: code lens generation in 1.31s
2024.04.07 20:59:43 INFO  skipping build import with status 'Dismissed'
2024.04.07 20:59:45 INFO  Shutting down server
2024.04.07 20:59:45 INFO  shutting down Metals
2024.04.07 20:59:45 INFO  Shut down connection with build server.
2024.04.07 20:59:45 INFO  Shut down connection with build server.
2024.04.07 20:59:45 INFO  Exiting server
2024.04.07 20:59:55 INFO  Started: Metals version 1.2.2 in folders 'D:\bestgame' for client Visual Studio Code 1.88.0.
20:59:55.878 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
20:59:55.879 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
20:59:55.879 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
20:59:55.881 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
20:59:55.881 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
20:59:55.881 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
20:59:55.881 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
20:59:55.881 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
20:59:55.881 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/C:/Users/yidtdr/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
20:59:55.884 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
20:59:55.884 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
20:59:55.884 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
20:59:55.884 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
20:59:55.884 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
20:59:55.884 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
20:59:55.886 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
20:59:55.886 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
20:59:55.888 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
20:59:55.888 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
20:59:55.888 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
20:59:55.968 [pool-1-thread-1] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:D:\bestgame\.metals\metals (H2 2.2)
20:59:55.968 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
20:59:55.968 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
20:59:55.969 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
20:59:55.969 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
20:59:55.972 [pool-1-thread-1] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
20:59:55.973 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
20:59:55.973 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
20:59:55.979 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
20:59:55.981 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
20:59:55.988 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
20:59:55.988 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
20:59:55.988 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
20:59:55.988 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
20:59:55.988 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
20:59:55.989 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
20:59:55.989 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
20:59:55.989 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
20:59:55.989 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
20:59:55.989 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
20:59:55.996 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.016s)
20:59:55.997 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
20:59:56.000 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
20:59:56.002 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
20:59:56.007 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 35 of 100M
2024.04.07 20:59:56 INFO  Attempting to connect to the build server...
2024.04.07 20:59:56 INFO  skipping build import with status 'Dismissed'
2024.04.07 20:59:56 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 20:59:56 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 20:59:56 INFO  Attempting to connect to the build server...
2024.04.07 20:59:56 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 20:59:56 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 20:59:56 INFO  time: Connected to build server in 0.43s
2024.04.07 20:59:56 INFO  Connected to Build server: Bloop v1.5.15
2024.04.07 20:59:59 WARN  no build target for: D:\bestgame\build.sbt
2024.04.07 20:59:59 INFO  skipping build import with status 'Dismissed'
2024.04.07 21:00:00 INFO  no build target found for D:\bestgame\build.sbt. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.07 21:00:03 INFO  time: indexed workspace in 3.4s
2024.04.07 21:00:08 INFO  time: code lens generation in 1.66s
2024.04.07 21:00:08 INFO  time: code lens generation in 2.07s
2024.04.07 21:00:08 INFO  time: code lens generation in 2.07s
2024.04.07 21:00:08 INFO  time: code lens generation in 2.07s
2024.04.07 21:00:08 INFO  time: code lens generation in 2.07s
2024.04.07 21:00:08 INFO  time: code lens generation in 2.07s
2024.04.07 21:00:35 INFO  skipping build import with status 'Dismissed'
2024.04.07 21:00:47 INFO  Shutting down server
2024.04.07 21:00:47 INFO  shutting down Metals
2024.04.07 21:00:48 INFO  Shut down connection with build server.
2024.04.07 21:00:48 INFO  Shut down connection with build server.
2024.04.07 21:00:47 INFO  Exiting server
2024.04.07 21:00:59 INFO  Started: Metals version 1.2.2 in folders 'D:\bestgame' for client Visual Studio Code 1.88.0.
21:01:00.131 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
21:01:00.133 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
21:01:00.133 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
21:01:00.135 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
21:01:00.135 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
21:01:00.135 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
21:01:00.135 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
21:01:00.135 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@2a139a55 ...
21:01:00.135 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/C:/Users/yidtdr/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
21:01:00.136 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
21:01:00.137 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
21:01:00.137 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
21:01:00.137 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
21:01:00.137 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
21:01:00.137 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
21:01:00.139 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
21:01:00.139 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
21:01:00.139 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
21:01:00.139 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
21:01:00.139 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
21:01:00.217 [pool-1-thread-1] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:D:\bestgame\.metals\metals (H2 2.2)
21:01:00.217 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
21:01:00.217 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
21:01:00.218 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
21:01:00.219 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
21:01:00.221 [pool-1-thread-1] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
21:01:00.222 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
21:01:00.222 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
21:01:00.226 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
21:01:00.228 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
21:01:00.232 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
21:01:00.232 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
21:01:00.232 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
21:01:00.232 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
21:01:00.232 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
21:01:00.233 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
21:01:00.233 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
21:01:00.233 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
21:01:00.233 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
21:01:00.233 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
21:01:00.239 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.012s)
21:01:00.240 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
21:01:00.243 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
21:01:00.247 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
21:01:00.251 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 34 of 100M
2024.04.07 21:01:00 WARN  no build target for: D:\bestgame\build.sbt
2024.04.07 21:01:00 INFO  skipping build import with status 'Installed'
2024.04.07 21:01:00 INFO  skipping build import with status 'Installed'
2024.04.07 21:01:00 INFO  Attempting to connect to the build server...
2024.04.07 21:01:00 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 21:01:00 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 21:01:00 INFO  Attempting to connect to the build server...
2024.04.07 21:01:00 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 21:01:00 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 21:01:00 INFO  time: Connected to build server in 0.46s
2024.04.07 21:01:00 INFO  Connected to Build server: Bloop v1.5.15
2024.04.07 21:01:01 INFO  time: Imported build in 0.1s
2024.04.07 21:01:02 INFO  skipping build import with status 'Started'
2024.04.07 21:01:02 WARN  no build target for: D:\bestgame\build.sbt
2024.04.07 21:01:05 INFO  no build target found for D:\bestgame\build.sbt. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.07 21:01:08 INFO  time: indexed workspace in 2.52s
2024.04.07 21:01:08 INFO  no build target found for D:\bestgame\build.sbt. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.07 21:01:50 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals6752154661739495986\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.07 21:01:51 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.07 21:01:51 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.07 21:01:53 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.07 21:01:55 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.07 21:01:55 INFO  [info] loading project definition from D:\bestgame\project
2024.04.07 21:01:58 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.07 21:01:58 INFO  [success] Total time: 3 s, completed 7 Π°ΠΏΡ€. 2024 Π³., 21:01:58
2024.04.07 21:01:58 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.07 21:01:58 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.07 21:01:59 INFO  [success] Generated .bloop\bestgame.json
2024.04.07 21:01:59 INFO  [success] Generated .bloop\bestgame-test.json
2024.04.07 21:01:59 INFO  [success] Total time: 1 s, completed 7 Π°ΠΏΡ€. 2024 Π³., 21:01:59
2024.04.07 21:02:00 INFO  time: ran 'sbt bloopInstall' in 9.65s
2024.04.07 21:02:00 INFO  Disconnecting from Bloop session...
2024.04.07 21:02:00 INFO  Shut down connection with build server.
2024.04.07 21:02:00 INFO  Shut down connection with build server.
2024.04.07 21:02:00 INFO  Attempting to connect to the build server...
2024.04.07 21:02:00 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 21:02:00 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 21:02:00 INFO  Attempting to connect to the build server...
2024.04.07 21:02:00 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 21:02:00 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 21:02:00 INFO  time: Connected to build server in 0.13s
2024.04.07 21:02:00 INFO  Connected to Build server: Bloop v1.5.15
2024.04.07 21:02:01 INFO  time: indexed workspace in 1.35s
2024.04.07 21:02:04 INFO  time: code lens generation in 1.08s
2024.04.07 21:02:04 INFO  time: code lens generation in 1.63s
2024.04.07 21:02:04 INFO  time: code lens generation in 2.59s
2024.04.07 21:02:07 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals3877168373912054042\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.07 21:02:08 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.07 21:02:08 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.07 21:02:10 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.07 21:02:10 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.07 21:02:11 INFO  [info] loading project definition from D:\bestgame\project
2024.04.07 21:02:13 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.07 21:02:13 INFO  [success] Total time: 3 s, completed 7 Π°ΠΏΡ€. 2024 Π³., 21:02:14
2024.04.07 21:02:16 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.07 21:02:16 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.07 21:02:19 INFO  [warn] 
2024.04.07 21:02:19 INFO  [warn] 	Note: Unresolved dependencies path:
2024.04.07 21:02:19 INFO  [error] Couldn't run bloopGenerate. The issue could be caused by failing to compile the project.
2024.04.07 21:02:19 INFO  [warn] Removed stale D:\bestgame\.bloop\bestgame-test.json
2024.04.07 21:02:19 INFO  [warn] Removed stale D:\bestgame\.bloop\bestgame.json
2024.04.07 21:02:19 INFO  [error] sbt.librarymanagement.ResolveException: Error downloading org.postgresql:postgresql_3:42.3.1
2024.04.07 21:02:19 INFO  [error]   Not found
2024.04.07 21:02:19 INFO  [error]   Not found
2024.04.07 21:02:19 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localorg.postgresql\postgresql_3\42.3.1\ivys\ivy.xml
2024.04.07 21:02:19 INFO  [error]   not found: https://repo1.maven.org/maven2/org/postgresql/postgresql_3/42.3.1/postgresql_3-42.3.1.pom
2024.04.07 21:02:19 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.unresolvedWarningOrThrow(CoursierDependencyResolution.scala:344)
2024.04.07 21:02:19 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.$anonfun$update$38(CoursierDependencyResolution.scala:313)
2024.04.07 21:02:19 INFO  [error] 	at scala.util.Either$LeftProjection.map(Either.scala:573)
2024.04.07 21:02:19 INFO  [error] 	at lmcoursier.CoursierDependencyResolution.update(CoursierDependencyResolution.scala:313)
2024.04.07 21:02:19 INFO  [error] 	at sbt.librarymanagement.DependencyResolution.update(DependencyResolution.scala:60)
2024.04.07 21:02:19 INFO  [error] 	at sbt.internal.LibraryManagement$.resolve$1(LibraryManagement.scala:60)
2024.04.07 21:02:19 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$12(LibraryManagement.scala:134)
2024.04.07 21:02:19 INFO  [error] 	at sbt.util.Tracked$.$anonfun$lastOutput$1(Tracked.scala:74)
2024.04.07 21:02:19 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$20(LibraryManagement.scala:147)
2024.04.07 21:02:19 INFO  [error] 	at scala.util.control.Exception$Catch.apply(Exception.scala:228)
2024.04.07 21:02:19 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11(LibraryManagement.scala:147)
2024.04.07 21:02:19 INFO  [error] 	at sbt.internal.LibraryManagement$.$anonfun$cachedUpdate$11$adapted(LibraryManagement.scala:128)
2024.04.07 21:02:19 INFO  [error] 	at sbt.util.Tracked$.$anonfun$inputChangedW$1(Tracked.scala:220)
2024.04.07 21:02:19 INFO  [error] 	at sbt.internal.LibraryManagement$.cachedUpdate(LibraryManagement.scala:161)
2024.04.07 21:02:19 INFO  [error] 	at sbt.Classpaths$.$anonfun$updateTask0$1(Defaults.scala:3801)
2024.04.07 21:02:19 INFO  [error] 	at scala.Function1.$anonfun$compose$1(Function1.scala:49)
2024.04.07 21:02:19 INFO  [error] 	at sbt.internal.util.$tilde$greater.$anonfun$$u2219$1(TypeFunctions.scala:63)
2024.04.07 21:02:19 INFO  [error] 	at sbt.std.Transform$$anon$4.work(Transform.scala:69)
2024.04.07 21:02:19 INFO  [error] 	at sbt.Execute.$anonfun$submit$2(Execute.scala:283)
2024.04.07 21:02:19 INFO  [error] 	at sbt.internal.util.ErrorHandling$.wideConvert(ErrorHandling.scala:24)
2024.04.07 21:02:19 INFO  [error] 	at sbt.Execute.work(Execute.scala:292)
2024.04.07 21:02:19 INFO  [error] 	at sbt.Execute.$anonfun$submit$1(Execute.scala:283)
2024.04.07 21:02:19 INFO  [error] 	at sbt.ConcurrentRestrictions$$anon$4.$anonfun$submitValid$1(ConcurrentRestrictions.scala:265)
2024.04.07 21:02:19 INFO  [error] 	at sbt.CompletionService$$anon$2.call(CompletionService.scala:65)
2024.04.07 21:02:19 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.07 21:02:19 INFO  [error] 	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
2024.04.07 21:02:19 INFO  [error] 	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
2024.04.07 21:02:19 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
2024.04.07 21:02:19 INFO  [error] 	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
2024.04.07 21:02:19 INFO  [error] 	at java.base/java.lang.Thread.run(Thread.java:833)
2024.04.07 21:02:19 INFO  [error] (update) sbt.librarymanagement.ResolveException: Error downloading org.postgresql:postgresql_3:42.3.1
2024.04.07 21:02:19 INFO  [error]   Not found
2024.04.07 21:02:19 INFO  [error]   Not found
2024.04.07 21:02:19 INFO  [error]   not found: C:\Users\yidtdr\.ivy2\localorg.postgresql\postgresql_3\42.3.1\ivys\ivy.xml
2024.04.07 21:02:19 INFO  [error]   not found: https://repo1.maven.org/maven2/org/postgresql/postgresql_3/42.3.1/postgresql_3-42.3.1.pom
2024.04.07 21:02:19 INFO  [error] Total time: 2 s, completed 7 Π°ΠΏΡ€. 2024 Π³., 21:02:19
2024.04.07 21:02:19 INFO  time: ran 'sbt bloopInstall' in 12s
2024.04.07 21:02:19 ERROR sbt command failed: C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals3877168373912054042\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall
2024.04.07 21:02:19 INFO  Disconnecting from Bloop session...
2024.04.07 21:02:19 INFO  Shut down connection with build server.
2024.04.07 21:02:19 INFO  Shut down connection with build server.
2024.04.07 21:02:19 INFO  Attempting to connect to the build server...
2024.04.07 21:02:19 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 21:02:19 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 21:02:19 INFO  Attempting to connect to the build server...
2024.04.07 21:02:19 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 21:02:19 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 21:02:19 INFO  time: Connected to build server in 0.13s
2024.04.07 21:02:19 INFO  Connected to Build server: Bloop v1.5.15
2024.04.07 21:02:19 INFO  time: Imported build in 0.28s
2024.04.07 21:02:21 INFO  time: indexed workspace in 0.95s
2024.04.07 21:02:24 INFO  time: code lens generation in 3.24s
2024.04.07 21:03:43 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals4799688845136819515\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.07 21:03:44 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.07 21:03:44 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.07 21:03:45 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.07 21:03:45 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.07 21:03:47 INFO  [info] loading project definition from D:\bestgame\project
2024.04.07 21:03:50 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.07 21:03:50 INFO  [success] Total time: 3 s, completed 7 Π°ΠΏΡ€. 2024 Π³., 21:03:50
2024.04.07 21:03:52 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.07 21:03:52 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.07 21:04:02 INFO  [success] Generated .bloop\bestgame.json
2024.04.07 21:04:02 INFO  [success] Generated .bloop\bestgame-test.json
2024.04.07 21:04:02 INFO  [success] Total time: 9 s, completed 7 Π°ΠΏΡ€. 2024 Π³., 21:04:02
2024.04.07 21:04:02 INFO  time: ran 'sbt bloopInstall' in 18s
2024.04.07 21:04:02 INFO  Disconnecting from Bloop session...
2024.04.07 21:04:02 INFO  Shut down connection with build server.
2024.04.07 21:04:02 INFO  Shut down connection with build server.
2024.04.07 21:04:02 INFO  Attempting to connect to the build server...
2024.04.07 21:04:02 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 21:04:02 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 21:04:02 INFO  Attempting to connect to the build server...
2024.04.07 21:04:02 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 21:04:02 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 21:04:02 INFO  time: Connected to build server in 0.12s
2024.04.07 21:04:02 INFO  Connected to Build server: Bloop v1.5.15
2024.04.07 21:04:04 INFO  time: indexed workspace in 2.43s
2024.04.07 21:04:08 INFO  time: code lens generation in 2.95s
2024.04.07 21:33:54 INFO  compiling bestgame (5 scala sources)
2024.04.07 21:33:58 INFO  time: compiled bestgame in 4.64s
ΰοπ. 07, 2024 9:35:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 173
2024.04.07 21:35:14 INFO  compiling bestgame (1 scala source)
2024.04.07 21:35:14 INFO  time: compiled bestgame in 0.41s
2024.04.07 21:36:11 INFO  compiling bestgame (1 scala source)
2024.04.07 21:36:11 INFO  time: compiled bestgame in 0.54s
ΰοπ. 07, 2024 9:36:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 254
2024.04.07 21:36:37 INFO  compiling bestgame (1 scala source)
2024.04.07 21:36:37 INFO  time: compiled bestgame in 0.7s
2024.04.07 21:37:02 INFO  compiling bestgame (1 scala source)
2024.04.07 21:37:02 INFO  time: compiled bestgame in 0.12s
2024.04.07 21:37:11 INFO  compiling bestgame (1 scala source)
2024.04.07 21:37:11 INFO  time: compiled bestgame in 96ms
2024.04.07 21:37:36 INFO  compiling bestgame (1 scala source)
2024.04.07 21:37:36 INFO  time: compiled bestgame in 0.1s
2024.04.07 21:37:43 INFO  compiling bestgame (1 scala source)
2024.04.07 21:37:43 INFO  time: compiled bestgame in 0.4s
2024.04.07 21:37:47 INFO  compiling bestgame (1 scala source)
2024.04.07 21:37:47 INFO  time: compiled bestgame in 0.29s
2024.04.07 21:40:01 INFO  compiling bestgame (1 scala source)
2024.04.07 21:40:01 INFO  time: compiled bestgame in 0.38s
2024.04.07 21:40:06 INFO  compiling bestgame (1 scala source)
2024.04.07 21:40:06 INFO  time: compiled bestgame in 0.15s
2024.04.07 21:41:07 INFO  compiling bestgame (1 scala source)
2024.04.07 21:41:07 INFO  time: compiled bestgame in 0.22s
2024.04.07 21:41:21 INFO  compiling bestgame (1 scala source)
2024.04.07 21:41:21 INFO  time: compiled bestgame in 0.15s
2024.04.07 21:41:22 INFO  compiling bestgame (1 scala source)
2024.04.07 21:41:22 INFO  time: compiled bestgame in 0.27s
ΰοπ. 07, 2024 9:41:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 142,
      "uri": "file:///d%3A/bestgame/src/main/scala/DataBaseManager.scala"
    },
    "contentChanges": [
      {
        "text": "\ncase class User(name: String, money: Int, planted: Boolean)\n\nclass DataService(quill: Quill.Postgres[SnakeCase]) {\n  import quill._\n\n  def getPeople: ZIO[Any, Throwable, List[Person]] \u003d\n    run(query[Person])\n}\n\nobject DataService {\n  def getPeople: ZIO[DataService, Throwable, List[Person]] \u003d\n    ZIO.serviceWithZIODataService\n\n  val live: ZLayer[Any, Throwable, DataService] \u003d\n    ZLayer.fromFunction(new DataService(_))\n}"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor7.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..425]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:54)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:48)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:39)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionMetaPosition.toLsp(ScalametaCommonEnrichments.scala:77)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.$anonfun$toRevised$8(TokenEditDistance.scala:310)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:241)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:281)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$2(Diagnostics.scala:239)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$2$adapted(Diagnostics.scala:238)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:576)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:574)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:933)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:238)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:203)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:138)
	at scala.meta.internal.metals.MetalsLspService.didChange(MetalsLspService.scala:1192)
	at scala.meta.internal.metals.WorkspaceLspService.didChange(WorkspaceLspService.scala:355)
	at scala.meta.metals.lsp.DelegatingScalaService.didChange(DelegatingScalaService.scala:50)
	... 15 more

2024.04.07 21:41:29 INFO  compiling bestgame (1 scala source)
2024.04.07 21:41:29 INFO  time: compiled bestgame in 0.27s
2024.04.07 21:41:54 INFO  compiling bestgame (1 scala source)
2024.04.07 21:41:54 INFO  time: compiled bestgame in 0.15s
2024.04.07 21:41:57 INFO  compiling bestgame (1 scala source)
2024.04.07 21:41:57 INFO  time: compiled bestgame in 0.17s
ΰοπ. 07, 2024 9:42:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 787
2024.04.07 21:42:46 INFO  compiling bestgame (1 scala source)
2024.04.07 21:42:48 INFO  time: compiled bestgame in 1.69s
2024.04.07 21:42:54 INFO  compiling bestgame (1 scala source)
2024.04.07 21:42:54 INFO  time: compiled bestgame in 0.65s
2024.04.07 21:42:58 INFO  compiling bestgame (1 scala source)
2024.04.07 21:42:58 INFO  time: compiled bestgame in 0.52s
2024.04.07 21:43:06 INFO  compiling bestgame (1 scala source)
2024.04.07 21:43:06 INFO  time: compiled bestgame in 0.17s
2024.04.07 21:43:09 INFO  compiling bestgame (1 scala source)
2024.04.07 21:43:09 INFO  time: compiled bestgame in 0.17s
2024.04.07 21:43:16 INFO  compiling bestgame (1 scala source)
2024.04.07 21:43:16 INFO  time: compiled bestgame in 0.15s
2024.04.07 21:43:23 INFO  compiling bestgame (1 scala source)
2024.04.07 21:43:23 INFO  time: compiled bestgame in 0.27s
2024.04.07 21:43:26 INFO  compiling bestgame (1 scala source)
2024.04.07 21:43:26 INFO  time: compiled bestgame in 0.15s
2024.04.07 21:45:17 INFO  compiling bestgame (1 scala source)
2024.04.07 21:45:17 INFO  time: compiled bestgame in 0.19s
2024.04.07 21:45:20 INFO  compiling bestgame (1 scala source)
2024.04.07 21:45:20 INFO  time: compiled bestgame in 0.14s
2024.04.07 21:45:32 INFO  compiling bestgame (1 scala source)
2024.04.07 21:45:32 INFO  time: compiled bestgame in 0.55s
2024.04.07 21:45:34 INFO  compiling bestgame (1 scala source)
2024.04.07 21:45:34 INFO  time: compiled bestgame in 0.2s
ΰοπ. 07, 2024 9:45:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1349
ΰοπ. 07, 2024 9:45:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1374
2024.04.07 21:45:59 INFO  compiling bestgame (1 scala source)
2024.04.07 21:45:59 INFO  time: compiled bestgame in 0.23s
2024.04.07 21:46:02 INFO  compiling bestgame (1 scala source)
2024.04.07 21:46:02 INFO  time: compiled bestgame in 0.14s
2024.04.07 21:46:07 INFO  compiling bestgame (1 scala source)
2024.04.07 21:46:07 INFO  time: compiled bestgame in 0.16s
2024.04.07 21:46:15 INFO  compiling bestgame (1 scala source)
2024.04.07 21:46:17 INFO  time: compiled bestgame in 2.16s
2024.04.07 21:47:14 INFO  compiling bestgame (1 scala source)
2024.04.07 21:47:16 INFO  time: compiled bestgame in 1.76s
2024.04.07 21:47:20 INFO  compiling bestgame (1 scala source)
2024.04.07 21:47:21 INFO  time: compiled bestgame in 1.56s
2024.04.07 21:47:30 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java

Uri: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:689)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

ΰοπ. 07, 2024 9:47:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.sql/java/sql/SQLException.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.sql;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n\n/**\n * \u003cP\u003eAn exception that provides information on a database access\n * error or other errors.\n *\n * \u003cP\u003eEach {@code SQLException} provides several kinds of information:\n * \u003cUL\u003e\n *   \u003cLI\u003e a string describing the error.  This is used as the Java Exception\n *       message, available via the method {@code getMessage}.\n *   \u003cLI\u003e a \"SQLstate\" string, which follows either the XOPEN SQLstate conventions\n *        or the SQL:2003 conventions.\n *       The values of the SQLState string are described in the appropriate spec.\n *       The {@code DatabaseMetaData} method {@code getSQLStateType}\n *       can be used to discover whether the driver returns the XOPEN type or\n *       the SQL:2003 type.\n *   \u003cLI\u003e an integer error code that is specific to each vendor.  Normally this will\n *       be the actual error code returned by the underlying database.\n *   \u003cLI\u003e a chain to a next Exception.  This can be used to provide additional\n *       error information.\n *   \u003cLI\u003e the causal relationship, if any for this {@code SQLException}.\n * \u003c/UL\u003e\n *\n * @since 1.1\n */\npublic class SQLException extends java.lang.Exception\n                          implements Iterable\u003cThrowable\u003e {\n\n    /**\n     *  Constructs a {@code SQLException} object with a given\n     * {@code reason}, {@code SQLState}  and\n     * {@code vendorCode}.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method.\n     *\n     * @param reason a description of the exception\n     * @param SQLState an XOPEN or SQL:2003 code identifying the exception\n     * @param vendorCode a database vendor-specific exception code\n     */\n    public SQLException(String reason, String SQLState, int vendorCode) {\n        super(reason);\n        this.SQLState \u003d SQLState;\n        this.vendorCode \u003d vendorCode;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                DriverManager.println(\"SQLState(\" + SQLState +\n                                                \") vendor code(\" + vendorCode + \")\");\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason} and {@code SQLState}.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method. The vendor code\n     * is initialized to 0.\n     *\n     * @param reason a description of the exception\n     * @param SQLState an XOPEN or SQL:2003 code identifying the exception\n     */\n    public SQLException(String reason, String SQLState) {\n        super(reason);\n        this.SQLState \u003d SQLState;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n                DriverManager.println(\"SQLException: SQLState(\" + SQLState + \")\");\n            }\n        }\n    }\n\n    /**\n     *  Constructs a {@code SQLException} object with a given\n     * {@code reason}. The  {@code SQLState}  is initialized to\n     * {@code null} and the vendor code is initialized to 0.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method.\n     *\n     * @param reason a description of the exception\n     */\n    public SQLException(String reason) {\n        super(reason);\n        this.SQLState \u003d null;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object.\n     * The {@code reason}, {@code SQLState} are initialized\n     * to {@code null} and the vendor code is initialized to 0.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method.\n     *\n     */\n    public SQLException() {\n        super();\n        this.SQLState \u003d null;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     *  Constructs a {@code SQLException} object with a given\n     * {@code cause}.\n     * The {@code SQLState} is initialized\n     * to {@code null} and the vendor code is initialized to 0.\n     * The {@code reason}  is initialized to {@code null} if\n     * {@code cause\u003d\u003dnull} or to {@code cause.toString()} if\n     * {@code cause!\u003dnull}.\n     *\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the {@code getCause()} method);\n     * may be null indicating the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(Throwable cause) {\n        super(cause);\n\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason} and  {@code cause}.\n     * The {@code SQLState} is  initialized to {@code null}\n     * and the vendor code is initialized to 0.\n     *\n     * @param reason a description of the exception.\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the {@code getCause()} method);\n     * may be null indicating the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(String reason, Throwable cause) {\n        super(reason,cause);\n\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                    printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason}, {@code SQLState} and  {@code cause}.\n     * The vendor code is initialized to 0.\n     *\n     * @param reason a description of the exception.\n     * @param sqlState an XOPEN or SQL:2003 code identifying the exception\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the\n     * {@code getCause()} method); may be null indicating\n     *     the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(String reason, String sqlState, Throwable cause) {\n        super(reason,cause);\n\n        this.SQLState \u003d sqlState;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n                DriverManager.println(\"SQLState(\" + SQLState + \")\");\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason}, {@code SQLState}, {@code vendorCode}\n     * and  {@code cause}.\n     *\n     * @param reason a description of the exception\n     * @param sqlState an XOPEN or SQL:2003 code identifying the exception\n     * @param vendorCode a database vendor-specific exception code\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the {@code getCause()} method);\n     * may be null indicating the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(String reason, String sqlState, int vendorCode, Throwable cause) {\n        super(reason,cause);\n\n        this.SQLState \u003d sqlState;\n        this.vendorCode \u003d vendorCode;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                DriverManager.println(\"SQLState(\" + SQLState +\n                                                \") vendor code(\" + vendorCode + \")\");\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Retrieves the SQLState for this {@code SQLException} object.\n     *\n     * @return the SQLState value\n     */\n    public String getSQLState() {\n        return (SQLState);\n    }\n\n    /**\n     * Retrieves the vendor-specific exception code\n     * for this {@code SQLException} object.\n     *\n     * @return the vendor\u0027s error code\n     */\n    public int getErrorCode() {\n        return (vendorCode);\n    }\n\n    /**\n     * Retrieves the exception chained to this\n     * {@code SQLException} object by setNextException(SQLException ex).\n     *\n     * @return the next {@code SQLException} object in the chain;\n     *         {@code null} if there are none\n     * @see #setNextException\n     */\n    public SQLException getNextException() {\n        return (next);\n    }\n\n    /**\n     * Adds an {@code SQLException} object to the end of the chain.\n     *\n     * @param ex the new exception that will be added to the end of\n     *            the {@code SQLException} chain\n     * @see #getNextException\n     */\n    public void setNextException(SQLException ex) {\n\n        SQLException current \u003d this;\n        for(;;) {\n            SQLException next\u003dcurrent.next;\n            if (next !\u003d null) {\n                current \u003d next;\n                continue;\n            }\n\n            if (nextUpdater.compareAndSet(current,null,ex)) {\n                return;\n            }\n            current\u003dcurrent.next;\n        }\n    }\n\n    /**\n     * Returns an iterator over the chained SQLExceptions.  The iterator will\n     * be used to iterate over each SQLException and its underlying cause\n     * (if any).\n     *\n     * @return an iterator over the chained SQLExceptions and causes in the proper\n     * order\n     *\n     * @since 1.6\n     */\n    public Iterator\u003cThrowable\u003e iterator() {\n\n       return new Iterator\u003cThrowable\u003e() {\n\n           SQLException firstException \u003d SQLException.this;\n           SQLException nextException \u003d firstException.getNextException();\n           Throwable cause \u003d firstException.getCause();\n\n           public boolean hasNext() {\n               if(firstException !\u003d null || nextException !\u003d null || cause !\u003d null)\n                   return true;\n               return false;\n           }\n\n           public Throwable next() {\n               Throwable throwable \u003d null;\n               if(firstException !\u003d null){\n                   throwable \u003d firstException;\n                   firstException \u003d null;\n               }\n               else if(cause !\u003d null){\n                   throwable \u003d cause;\n                   cause \u003d cause.getCause();\n               }\n               else if(nextException !\u003d null){\n                   throwable \u003d nextException;\n                   cause \u003d nextException.getCause();\n                   nextException \u003d nextException.getNextException();\n               }\n               else\n                   throw new NoSuchElementException();\n               return throwable;\n           }\n\n           public void remove() {\n               throw new UnsupportedOperationException();\n           }\n\n       };\n\n    }\n\n    /**\n         * @serial\n         */\n    private String SQLState;\n\n        /**\n         * @serial\n         */\n    private int vendorCode;\n\n        /**\n         * @serial\n         */\n    private volatile SQLException next;\n\n    private static final AtomicReferenceFieldUpdater\u003cSQLException,SQLException\u003e nextUpdater \u003d\n            AtomicReferenceFieldUpdater.newUpdater(SQLException.class,SQLException.class,\"next\");\n\n    private static final long serialVersionUID \u003d 2135244094396331484L;\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

ΰοπ. 07, 2024 9:47:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.sql/java/sql/SQLException.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.04.07 21:47:32 INFO  compiling bestgame (1 scala source)
2024.04.07 21:47:35 INFO  time: compiled bestgame in 3.03s
2024.04.07 21:47:43 INFO  compiling bestgame (1 scala source)
2024.04.07 21:47:46 INFO  time: compiled bestgame in 2.99s
ΰοπ. 07, 2024 9:47:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1816
2024.04.07 21:50:07 WARN  Using indexes to guess the definition of Any
2024.04.07 21:50:09 INFO  compiling bestgame (1 scala source)
2024.04.07 21:50:11 INFO  time: compiled bestgame in 2.5s
2024.04.07 21:50:16 INFO  compiling bestgame (1 scala source)
2024.04.07 21:50:19 INFO  time: compiled bestgame in 2.69s
ΰοπ. 07, 2024 9:50:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1987
2024.04.07 21:50:22 INFO  compiling bestgame (1 scala source)
2024.04.07 21:50:23 INFO  time: compiled bestgame in 1.34s
ΰοπ. 07, 2024 9:50:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2068
ΰοπ. 07, 2024 9:50:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2082
ΰοπ. 07, 2024 9:50:35 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-07\r_compiler-error_(bestgame)_21-50-35-718.md
2024.04.07 21:50:50 INFO  compiling bestgame (1 scala source)
2024.04.07 21:50:50 INFO  time: compiled bestgame in 0.83s
2024.04.07 21:50:54 INFO  compiling bestgame (1 scala source)
2024.04.07 21:50:56 INFO  time: compiled bestgame in 1.98s
2024.04.07 21:50:58 INFO  compiling bestgame (1 scala source)
2024.04.07 21:51:00 INFO  time: compiled bestgame in 2.48s
2024.04.07 21:51:15 INFO  compiling bestgame (1 scala source)
2024.04.07 21:51:15 INFO  time: compiled bestgame in 0.8s
2024.04.07 21:51:27 INFO  compiling bestgame (1 scala source)
2024.04.07 21:51:27 INFO  time: compiled bestgame in 0.83s
2024.04.07 21:51:29 INFO  compiling bestgame (1 scala source)
2024.04.07 21:51:30 INFO  time: compiled bestgame in 1.21s
2024.04.07 21:51:30 INFO  compiling bestgame (1 scala source)
2024.04.07 21:51:31 INFO  time: compiled bestgame in 1.17s
2024.04.07 21:52:30 INFO  compiling bestgame (1 scala source)
2024.04.07 21:52:31 INFO  time: compiled bestgame in 1.18s
2024.04.07 21:52:33 INFO  compiling bestgame (1 scala source)
2024.04.07 21:52:35 INFO  time: compiled bestgame in 1.24s
2024.04.07 21:52:39 INFO  compiling bestgame (1 scala source)
2024.04.07 21:52:40 INFO  time: compiled bestgame in 1.17s
2024.04.07 21:52:45 INFO  compiling bestgame (1 scala source)
2024.04.07 21:52:45 INFO  time: compiled bestgame in 0.12s
2024.04.07 21:52:47 INFO  compiling bestgame (1 scala source)
2024.04.07 21:52:47 INFO  time: compiled bestgame in 0.93s
2024.04.07 21:52:51 INFO  compiling bestgame (1 scala source)
2024.04.07 21:52:51 INFO  time: compiled bestgame in 0.1s
2024.04.07 21:52:53 INFO  compiling bestgame (1 scala source)
2024.04.07 21:52:53 INFO  time: compiled bestgame in 0.1s
2024.04.07 21:52:58 INFO  compiling bestgame (1 scala source)
2024.04.07 21:52:58 INFO  time: compiled bestgame in 0.89s
2024.04.07 21:53:01 INFO  compiling bestgame (1 scala source)
2024.04.07 21:53:01 INFO  time: compiled bestgame in 0.81s
2024.04.07 21:53:25 INFO  compiling bestgame (1 scala source)
2024.04.07 21:53:25 INFO  time: compiled bestgame in 0.59s
2024.04.07 21:53:28 INFO  compiling bestgame (1 scala source)
2024.04.07 21:53:28 INFO  time: compiled bestgame in 0.51s
2024.04.07 21:53:44 INFO  compiling bestgame (1 scala source)
2024.04.07 21:53:44 INFO  time: compiled bestgame in 0.48s
2024.04.07 21:53:47 INFO  compiling bestgame (1 scala source)
2024.04.07 21:53:47 INFO  time: compiled bestgame in 0.69s
2024.04.07 21:53:58 INFO  compiling bestgame (1 scala source)
2024.04.07 21:53:58 INFO  time: compiled bestgame in 0.21s
2024.04.07 21:54:01 INFO  compiling bestgame (1 scala source)
2024.04.07 21:54:01 INFO  time: compiled bestgame in 0.49s
2024.04.07 21:54:29 INFO  compiling bestgame (1 scala source)
2024.04.07 21:54:29 INFO  time: compiled bestgame in 0.52s
2024.04.07 21:54:32 INFO  compiling bestgame (1 scala source)
2024.04.07 21:54:32 INFO  time: compiled bestgame in 0.5s
2024.04.07 21:54:35 INFO  compiling bestgame (1 scala source)
2024.04.07 21:54:35 INFO  time: compiled bestgame in 0.71s
2024.04.07 21:54:37 INFO  compiling bestgame (1 scala source)
2024.04.07 21:54:37 INFO  time: compiled bestgame in 0.88s
2024.04.07 21:54:55 INFO  compiling bestgame (1 scala source)
2024.04.07 21:54:55 INFO  time: compiled bestgame in 0.69s
2024.04.07 21:56:51 INFO  compiling bestgame (1 scala source)
2024.04.07 21:56:51 INFO  time: compiled bestgame in 0.99s
2024.04.07 21:57:08 WARN  Using indexes to guess the definition of User
2024.04.07 21:57:09 INFO  compiling bestgame (1 scala source)
2024.04.07 21:57:10 INFO  time: compiled bestgame in 1.22s
2024.04.07 21:57:15 INFO  compiling bestgame (1 scala source)
2024.04.07 21:57:15 INFO  time: compiled bestgame in 0.84s
2024.04.07 21:57:25 INFO  compiling bestgame (1 scala source)
2024.04.07 21:57:25 INFO  time: compiled bestgame in 0.76s
2024.04.07 22:01:29 INFO  compiling bestgame (1 scala source)
2024.04.07 22:01:32 INFO  time: compiled bestgame in 2.89s
2024.04.07 22:03:17 INFO  compiling bestgame (1 scala source)
2024.04.07 22:03:19 INFO  time: compiled bestgame in 1.86s
2024.04.07 22:03:26 INFO  compiling bestgame (1 scala source)
2024.04.07 22:03:26 INFO  time: compiled bestgame in 0.71s
2024.04.07 22:03:36 INFO  compiling bestgame (1 scala source)
2024.04.07 22:03:36 INFO  time: compiled bestgame in 0.49s
2024.04.07 22:04:02 INFO  compiling bestgame (1 scala source)
2024.04.07 22:04:02 INFO  time: compiled bestgame in 0.84s
2024.04.07 22:04:04 INFO  compiling bestgame (1 scala source)
2024.04.07 22:04:04 INFO  time: compiled bestgame in 0.7s
2024.04.07 22:04:22 INFO  compiling bestgame (1 scala source)
2024.04.07 22:04:22 INFO  time: compiled bestgame in 0.54s
2024.04.07 22:05:10 INFO  compiling bestgame (1 scala source)
2024.04.07 22:05:10 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java

Uri: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:689)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

ΰοπ. 07, 2024 10:05:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.sql/java/sql/SQLException.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.sql;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n\n/**\n * \u003cP\u003eAn exception that provides information on a database access\n * error or other errors.\n *\n * \u003cP\u003eEach {@code SQLException} provides several kinds of information:\n * \u003cUL\u003e\n *   \u003cLI\u003e a string describing the error.  This is used as the Java Exception\n *       message, available via the method {@code getMessage}.\n *   \u003cLI\u003e a \"SQLstate\" string, which follows either the XOPEN SQLstate conventions\n *        or the SQL:2003 conventions.\n *       The values of the SQLState string are described in the appropriate spec.\n *       The {@code DatabaseMetaData} method {@code getSQLStateType}\n *       can be used to discover whether the driver returns the XOPEN type or\n *       the SQL:2003 type.\n *   \u003cLI\u003e an integer error code that is specific to each vendor.  Normally this will\n *       be the actual error code returned by the underlying database.\n *   \u003cLI\u003e a chain to a next Exception.  This can be used to provide additional\n *       error information.\n *   \u003cLI\u003e the causal relationship, if any for this {@code SQLException}.\n * \u003c/UL\u003e\n *\n * @since 1.1\n */\npublic class SQLException extends java.lang.Exception\n                          implements Iterable\u003cThrowable\u003e {\n\n    /**\n     *  Constructs a {@code SQLException} object with a given\n     * {@code reason}, {@code SQLState}  and\n     * {@code vendorCode}.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method.\n     *\n     * @param reason a description of the exception\n     * @param SQLState an XOPEN or SQL:2003 code identifying the exception\n     * @param vendorCode a database vendor-specific exception code\n     */\n    public SQLException(String reason, String SQLState, int vendorCode) {\n        super(reason);\n        this.SQLState \u003d SQLState;\n        this.vendorCode \u003d vendorCode;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                DriverManager.println(\"SQLState(\" + SQLState +\n                                                \") vendor code(\" + vendorCode + \")\");\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason} and {@code SQLState}.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method. The vendor code\n     * is initialized to 0.\n     *\n     * @param reason a description of the exception\n     * @param SQLState an XOPEN or SQL:2003 code identifying the exception\n     */\n    public SQLException(String reason, String SQLState) {\n        super(reason);\n        this.SQLState \u003d SQLState;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n                DriverManager.println(\"SQLException: SQLState(\" + SQLState + \")\");\n            }\n        }\n    }\n\n    /**\n     *  Constructs a {@code SQLException} object with a given\n     * {@code reason}. The  {@code SQLState}  is initialized to\n     * {@code null} and the vendor code is initialized to 0.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method.\n     *\n     * @param reason a description of the exception\n     */\n    public SQLException(String reason) {\n        super(reason);\n        this.SQLState \u003d null;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object.\n     * The {@code reason}, {@code SQLState} are initialized\n     * to {@code null} and the vendor code is initialized to 0.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method.\n     *\n     */\n    public SQLException() {\n        super();\n        this.SQLState \u003d null;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     *  Constructs a {@code SQLException} object with a given\n     * {@code cause}.\n     * The {@code SQLState} is initialized\n     * to {@code null} and the vendor code is initialized to 0.\n     * The {@code reason}  is initialized to {@code null} if\n     * {@code cause\u003d\u003dnull} or to {@code cause.toString()} if\n     * {@code cause!\u003dnull}.\n     *\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the {@code getCause()} method);\n     * may be null indicating the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(Throwable cause) {\n        super(cause);\n\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason} and  {@code cause}.\n     * The {@code SQLState} is  initialized to {@code null}\n     * and the vendor code is initialized to 0.\n     *\n     * @param reason a description of the exception.\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the {@code getCause()} method);\n     * may be null indicating the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(String reason, Throwable cause) {\n        super(reason,cause);\n\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                    printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason}, {@code SQLState} and  {@code cause}.\n     * The vendor code is initialized to 0.\n     *\n     * @param reason a description of the exception.\n     * @param sqlState an XOPEN or SQL:2003 code identifying the exception\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the\n     * {@code getCause()} method); may be null indicating\n     *     the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(String reason, String sqlState, Throwable cause) {\n        super(reason,cause);\n\n        this.SQLState \u003d sqlState;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n                DriverManager.println(\"SQLState(\" + SQLState + \")\");\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason}, {@code SQLState}, {@code vendorCode}\n     * and  {@code cause}.\n     *\n     * @param reason a description of the exception\n     * @param sqlState an XOPEN or SQL:2003 code identifying the exception\n     * @param vendorCode a database vendor-specific exception code\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the {@code getCause()} method);\n     * may be null indicating the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(String reason, String sqlState, int vendorCode, Throwable cause) {\n        super(reason,cause);\n\n        this.SQLState \u003d sqlState;\n        this.vendorCode \u003d vendorCode;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                DriverManager.println(\"SQLState(\" + SQLState +\n                                                \") vendor code(\" + vendorCode + \")\");\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Retrieves the SQLState for this {@code SQLException} object.\n     *\n     * @return the SQLState value\n     */\n    public String getSQLState() {\n        return (SQLState);\n    }\n\n    /**\n     * Retrieves the vendor-specific exception code\n     * for this {@code SQLException} object.\n     *\n     * @return the vendor\u0027s error code\n     */\n    public int getErrorCode() {\n        return (vendorCode);\n    }\n\n    /**\n     * Retrieves the exception chained to this\n     * {@code SQLException} object by setNextException(SQLException ex).\n     *\n     * @return the next {@code SQLException} object in the chain;\n     *         {@code null} if there are none\n     * @see #setNextException\n     */\n    public SQLException getNextException() {\n        return (next);\n    }\n\n    /**\n     * Adds an {@code SQLException} object to the end of the chain.\n     *\n     * @param ex the new exception that will be added to the end of\n     *            the {@code SQLException} chain\n     * @see #getNextException\n     */\n    public void setNextException(SQLException ex) {\n\n        SQLException current \u003d this;\n        for(;;) {\n            SQLException next\u003dcurrent.next;\n            if (next !\u003d null) {\n                current \u003d next;\n                continue;\n            }\n\n            if (nextUpdater.compareAndSet(current,null,ex)) {\n                return;\n            }\n            current\u003dcurrent.next;\n        }\n    }\n\n    /**\n     * Returns an iterator over the chained SQLExceptions.  The iterator will\n     * be used to iterate over each SQLException and its underlying cause\n     * (if any).\n     *\n     * @return an iterator over the chained SQLExceptions and causes in the proper\n     * order\n     *\n     * @since 1.6\n     */\n    public Iterator\u003cThrowable\u003e iterator() {\n\n       return new Iterator\u003cThrowable\u003e() {\n\n           SQLException firstException \u003d SQLException.this;\n           SQLException nextException \u003d firstException.getNextException();\n           Throwable cause \u003d firstException.getCause();\n\n           public boolean hasNext() {\n               if(firstException !\u003d null || nextException !\u003d null || cause !\u003d null)\n                   return true;\n               return false;\n           }\n\n           public Throwable next() {\n               Throwable throwable \u003d null;\n               if(firstException !\u003d null){\n                   throwable \u003d firstException;\n                   firstException \u003d null;\n               }\n               else if(cause !\u003d null){\n                   throwable \u003d cause;\n                   cause \u003d cause.getCause();\n               }\n               else if(nextException !\u003d null){\n                   throwable \u003d nextException;\n                   cause \u003d nextException.getCause();\n                   nextException \u003d nextException.getNextException();\n               }\n               else\n                   throw new NoSuchElementException();\n               return throwable;\n           }\n\n           public void remove() {\n               throw new UnsupportedOperationException();\n           }\n\n       };\n\n    }\n\n    /**\n         * @serial\n         */\n    private String SQLState;\n\n        /**\n         * @serial\n         */\n    private int vendorCode;\n\n        /**\n         * @serial\n         */\n    private volatile SQLException next;\n\n    private static final AtomicReferenceFieldUpdater\u003cSQLException,SQLException\u003e nextUpdater \u003d\n            AtomicReferenceFieldUpdater.newUpdater(SQLException.class,SQLException.class,\"next\");\n\n    private static final long serialVersionUID \u003d 2135244094396331484L;\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

ΰοπ. 07, 2024 10:05:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.sql/java/sql/SQLException.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.04.07 22:05:10 INFO  time: compiled bestgame in 0.85s
2024.04.07 22:05:13 WARN  Using indexes to guess the definition of addUser
2024.04.07 22:05:13 WARN  Using indexes to guess the definition of addUser
2024.04.07 22:05:14 INFO  compiling bestgame (1 scala source)
2024.04.07 22:05:14 INFO  time: compiled bestgame in 0.74s
2024.04.07 22:12:33 INFO  compiling bestgame (1 scala source)
2024.04.07 22:12:36 INFO  time: compiled bestgame in 3.29s
2024.04.07 22:12:36 INFO  compiling bestgame (1 scala source)
2024.04.07 22:12:36 INFO  time: compiled bestgame in 0.88s
2024.04.07 22:12:45 INFO  compiling bestgame (1 scala source)
2024.04.07 22:12:45 INFO  time: compiled bestgame in 0.65s
2024.04.07 22:13:05 INFO  compiling bestgame (1 scala source)
2024.04.07 22:13:05 INFO  time: compiled bestgame in 0.6s
2024.04.07 22:13:52 INFO  compiling bestgame (1 scala source)
2024.04.07 22:13:52 INFO  time: compiled bestgame in 0.24s
2024.04.07 22:13:54 INFO  compiling bestgame (1 scala source)
2024.04.07 22:13:54 INFO  time: compiled bestgame in 0.5s
2024.04.07 22:14:04 INFO  compiling bestgame (1 scala source)
2024.04.07 22:14:04 INFO  time: compiled bestgame in 0.51s
2024.04.07 22:14:21 WARN  Using indexes to guess the definition of run
2024.04.07 22:14:46 INFO  compiling bestgame (1 scala source)
2024.04.07 22:14:46 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java

Uri: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:689)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

ΰοπ. 07, 2024 10:14:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.sql/java/sql/SQLException.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.sql;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n\n/**\n * \u003cP\u003eAn exception that provides information on a database access\n * error or other errors.\n *\n * \u003cP\u003eEach {@code SQLException} provides several kinds of information:\n * \u003cUL\u003e\n *   \u003cLI\u003e a string describing the error.  This is used as the Java Exception\n *       message, available via the method {@code getMessage}.\n *   \u003cLI\u003e a \"SQLstate\" string, which follows either the XOPEN SQLstate conventions\n *        or the SQL:2003 conventions.\n *       The values of the SQLState string are described in the appropriate spec.\n *       The {@code DatabaseMetaData} method {@code getSQLStateType}\n *       can be used to discover whether the driver returns the XOPEN type or\n *       the SQL:2003 type.\n *   \u003cLI\u003e an integer error code that is specific to each vendor.  Normally this will\n *       be the actual error code returned by the underlying database.\n *   \u003cLI\u003e a chain to a next Exception.  This can be used to provide additional\n *       error information.\n *   \u003cLI\u003e the causal relationship, if any for this {@code SQLException}.\n * \u003c/UL\u003e\n *\n * @since 1.1\n */\npublic class SQLException extends java.lang.Exception\n                          implements Iterable\u003cThrowable\u003e {\n\n    /**\n     *  Constructs a {@code SQLException} object with a given\n     * {@code reason}, {@code SQLState}  and\n     * {@code vendorCode}.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method.\n     *\n     * @param reason a description of the exception\n     * @param SQLState an XOPEN or SQL:2003 code identifying the exception\n     * @param vendorCode a database vendor-specific exception code\n     */\n    public SQLException(String reason, String SQLState, int vendorCode) {\n        super(reason);\n        this.SQLState \u003d SQLState;\n        this.vendorCode \u003d vendorCode;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                DriverManager.println(\"SQLState(\" + SQLState +\n                                                \") vendor code(\" + vendorCode + \")\");\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason} and {@code SQLState}.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method. The vendor code\n     * is initialized to 0.\n     *\n     * @param reason a description of the exception\n     * @param SQLState an XOPEN or SQL:2003 code identifying the exception\n     */\n    public SQLException(String reason, String SQLState) {\n        super(reason);\n        this.SQLState \u003d SQLState;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n                DriverManager.println(\"SQLException: SQLState(\" + SQLState + \")\");\n            }\n        }\n    }\n\n    /**\n     *  Constructs a {@code SQLException} object with a given\n     * {@code reason}. The  {@code SQLState}  is initialized to\n     * {@code null} and the vendor code is initialized to 0.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method.\n     *\n     * @param reason a description of the exception\n     */\n    public SQLException(String reason) {\n        super(reason);\n        this.SQLState \u003d null;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object.\n     * The {@code reason}, {@code SQLState} are initialized\n     * to {@code null} and the vendor code is initialized to 0.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method.\n     *\n     */\n    public SQLException() {\n        super();\n        this.SQLState \u003d null;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     *  Constructs a {@code SQLException} object with a given\n     * {@code cause}.\n     * The {@code SQLState} is initialized\n     * to {@code null} and the vendor code is initialized to 0.\n     * The {@code reason}  is initialized to {@code null} if\n     * {@code cause\u003d\u003dnull} or to {@code cause.toString()} if\n     * {@code cause!\u003dnull}.\n     *\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the {@code getCause()} method);\n     * may be null indicating the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(Throwable cause) {\n        super(cause);\n\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason} and  {@code cause}.\n     * The {@code SQLState} is  initialized to {@code null}\n     * and the vendor code is initialized to 0.\n     *\n     * @param reason a description of the exception.\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the {@code getCause()} method);\n     * may be null indicating the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(String reason, Throwable cause) {\n        super(reason,cause);\n\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                    printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason}, {@code SQLState} and  {@code cause}.\n     * The vendor code is initialized to 0.\n     *\n     * @param reason a description of the exception.\n     * @param sqlState an XOPEN or SQL:2003 code identifying the exception\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the\n     * {@code getCause()} method); may be null indicating\n     *     the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(String reason, String sqlState, Throwable cause) {\n        super(reason,cause);\n\n        this.SQLState \u003d sqlState;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n                DriverManager.println(\"SQLState(\" + SQLState + \")\");\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason}, {@code SQLState}, {@code vendorCode}\n     * and  {@code cause}.\n     *\n     * @param reason a description of the exception\n     * @param sqlState an XOPEN or SQL:2003 code identifying the exception\n     * @param vendorCode a database vendor-specific exception code\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the {@code getCause()} method);\n     * may be null indicating the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(String reason, String sqlState, int vendorCode, Throwable cause) {\n        super(reason,cause);\n\n        this.SQLState \u003d sqlState;\n        this.vendorCode \u003d vendorCode;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                DriverManager.println(\"SQLState(\" + SQLState +\n                                                \") vendor code(\" + vendorCode + \")\");\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Retrieves the SQLState for this {@code SQLException} object.\n     *\n     * @return the SQLState value\n     */\n    public String getSQLState() {\n        return (SQLState);\n    }\n\n    /**\n     * Retrieves the vendor-specific exception code\n     * for this {@code SQLException} object.\n     *\n     * @return the vendor\u0027s error code\n     */\n    public int getErrorCode() {\n        return (vendorCode);\n    }\n\n    /**\n     * Retrieves the exception chained to this\n     * {@code SQLException} object by setNextException(SQLException ex).\n     *\n     * @return the next {@code SQLException} object in the chain;\n     *         {@code null} if there are none\n     * @see #setNextException\n     */\n    public SQLException getNextException() {\n        return (next);\n    }\n\n    /**\n     * Adds an {@code SQLException} object to the end of the chain.\n     *\n     * @param ex the new exception that will be added to the end of\n     *            the {@code SQLException} chain\n     * @see #getNextException\n     */\n    public void setNextException(SQLException ex) {\n\n        SQLException current \u003d this;\n        for(;;) {\n            SQLException next\u003dcurrent.next;\n            if (next !\u003d null) {\n                current \u003d next;\n                continue;\n            }\n\n            if (nextUpdater.compareAndSet(current,null,ex)) {\n                return;\n            }\n            current\u003dcurrent.next;\n        }\n    }\n\n    /**\n     * Returns an iterator over the chained SQLExceptions.  The iterator will\n     * be used to iterate over each SQLException and its underlying cause\n     * (if any).\n     *\n     * @return an iterator over the chained SQLExceptions and causes in the proper\n     * order\n     *\n     * @since 1.6\n     */\n    public Iterator\u003cThrowable\u003e iterator() {\n\n       return new Iterator\u003cThrowable\u003e() {\n\n           SQLException firstException \u003d SQLException.this;\n           SQLException nextException \u003d firstException.getNextException();\n           Throwable cause \u003d firstException.getCause();\n\n           public boolean hasNext() {\n               if(firstException !\u003d null || nextException !\u003d null || cause !\u003d null)\n                   return true;\n               return false;\n           }\n\n           public Throwable next() {\n               Throwable throwable \u003d null;\n               if(firstException !\u003d null){\n                   throwable \u003d firstException;\n                   firstException \u003d null;\n               }\n               else if(cause !\u003d null){\n                   throwable \u003d cause;\n                   cause \u003d cause.getCause();\n               }\n               else if(nextException !\u003d null){\n                   throwable \u003d nextException;\n                   cause \u003d nextException.getCause();\n                   nextException \u003d nextException.getNextException();\n               }\n               else\n                   throw new NoSuchElementException();\n               return throwable;\n           }\n\n           public void remove() {\n               throw new UnsupportedOperationException();\n           }\n\n       };\n\n    }\n\n    /**\n         * @serial\n         */\n    private String SQLState;\n\n        /**\n         * @serial\n         */\n    private int vendorCode;\n\n        /**\n         * @serial\n         */\n    private volatile SQLException next;\n\n    private static final AtomicReferenceFieldUpdater\u003cSQLException,SQLException\u003e nextUpdater \u003d\n            AtomicReferenceFieldUpdater.newUpdater(SQLException.class,SQLException.class,\"next\");\n\n    private static final long serialVersionUID \u003d 2135244094396331484L;\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

ΰοπ. 07, 2024 10:14:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.sql/java/sql/SQLException.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.04.07 22:14:46 INFO  time: compiled bestgame in 0.84s
2024.04.07 22:14:48 INFO  compiling bestgame (1 scala source)
2024.04.07 22:14:48 INFO  time: compiled bestgame in 0.49s
2024.04.07 22:14:53 INFO  compiling bestgame (1 scala source)
2024.04.07 22:14:53 INFO  time: compiled bestgame in 0.53s
2024.04.07 22:15:06 INFO  compiling bestgame (1 scala source)
2024.04.07 22:15:06 INFO  time: compiled bestgame in 0.53s
2024.04.07 22:15:19 INFO  compiling bestgame (1 scala source)
2024.04.07 22:15:19 INFO  time: compiled bestgame in 0.45s
2024.04.07 22:15:27 INFO  compiling bestgame (1 scala source)
2024.04.07 22:15:27 INFO  time: compiled bestgame in 0.54s
2024.04.07 22:16:23 INFO  compiling bestgame (1 scala source)
2024.04.07 22:16:23 INFO  time: compiled bestgame in 0.6s
2024.04.07 22:18:01 INFO  compiling bestgame (1 scala source)
2024.04.07 22:18:01 INFO  time: compiled bestgame in 0.38s
2024.04.07 22:18:06 INFO  compiling bestgame (1 scala source)
2024.04.07 22:18:06 INFO  time: compiled bestgame in 0.21s
2024.04.07 22:19:03 INFO  compiling bestgame (1 scala source)
2024.04.07 22:19:03 INFO  time: compiled bestgame in 0.84s
2024.04.07 22:19:11 INFO  compiling bestgame (1 scala source)
2024.04.07 22:19:11 INFO  time: compiled bestgame in 0.18s
2024.04.07 22:19:14 INFO  compiling bestgame (1 scala source)
2024.04.07 22:19:14 INFO  time: compiled bestgame in 0.63s
2024.04.07 22:19:43 INFO  compiling bestgame (1 scala source)
2024.04.07 22:19:43 INFO  time: compiled bestgame in 0.47s
2024.04.07 22:20:27 INFO  compiling bestgame (1 scala source)
2024.04.07 22:20:27 INFO  time: compiled bestgame in 0.55s
2024.04.07 22:20:36 INFO  compiling bestgame (1 scala source)
2024.04.07 22:20:36 INFO  time: compiled bestgame in 0.5s
2024.04.07 22:20:55 INFO  compiling bestgame (1 scala source)
2024.04.07 22:20:55 INFO  time: compiled bestgame in 0.51s
2024.04.07 22:21:13 INFO  compiling bestgame (1 scala source)
2024.04.07 22:21:13 INFO  time: compiled bestgame in 0.61s
ΰοπ. 07, 2024 10:21:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: org.scalameta.invariants.InvariantFailedException: invariant failed:
when verifying parentCheckOk.&&(org.scalameta.`package`.debug(this, parentPrefix, destination))
found that parentCheckOk is false
where TermRepeatedImpl = _.addUser*
where destination = body
where parentCheckOk = false
where parentPrefix = Term.AnonymousFunction
where this = _.addUser*
java.util.concurrent.CompletionException: org.scalameta.invariants.InvariantFailedException: invariant failed:
when verifying parentCheckOk.&&(org.scalameta.`package`.debug(this, parentPrefix, destination))
found that parentCheckOk is false
where TermRepeatedImpl = _.addUser*
where destination = body
where parentCheckOk = false
where parentPrefix = Term.AnonymousFunction
where this = _.addUser*
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: org.scalameta.invariants.InvariantFailedException: invariant failed:
when verifying parentCheckOk.&&(org.scalameta.`package`.debug(this, parentPrefix, destination))
found that parentCheckOk is false
where TermRepeatedImpl = _.addUser*
where destination = body
where parentCheckOk = false
where parentPrefix = Term.AnonymousFunction
where this = _.addUser*
	at org.scalameta.invariants.InvariantFailedException$.raise(Exceptions.scala:19)
	at scala.meta.Term$Repeated$TermRepeatedImpl.checkParent$8(Trees.scala:240)
	at scala.meta.Term$Repeated$TermRepeatedImpl.privateCopy(Trees.scala:241)
	at scala.meta.Term$AnonymousFunction$.apply(Trees.scala:219)
	at scala.meta.internal.parsers.ScalametaParser$.$anonfun$scala$meta$internal$parsers$ScalametaParser$$maybeAnonymousFunction$2(ScalametaParser.scala:4703)
	at scala.meta.internal.parsers.ScalametaParser$.scala$meta$internal$parsers$ScalametaParser$$copyPos(ScalametaParser.scala:4733)
	at scala.meta.internal.parsers.ScalametaParser$.scala$meta$internal$parsers$ScalametaParser$$maybeAnonymousFunction(ScalametaParser.scala:4703)
	at scala.meta.internal.parsers.ScalametaParser$.scala$meta$internal$parsers$ScalametaParser$$maybeAnonymousFunctionUnlessPostfix(ScalametaParser.scala:4699)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1678)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2434)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsInParens$1(ScalametaParser.scala:2461)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$commaSeparated$1(ScalametaParser.scala:655)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$commaSeparated$1$adapted(ScalametaParser.scala:655)
	at scala.meta.internal.parsers.ScalametaParser.iter$1(ScalametaParser.scala:645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$tokenSeparated$1(ScalametaParser.scala:651)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$tokenSeparated$1$adapted(ScalametaParser.scala:638)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$listBy(ScalametaParser.scala:567)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:638)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparatedWithIndex(ScalametaParser.scala:658)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:655)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsInParens(ScalametaParser.scala:2461)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$scala$meta$internal$parsers$ScalametaParser$$getArgClause$2(ScalametaParser.scala:2447)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$inParensAfterOpenOr(ScalametaParser.scala:253)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$inParensOnOpenOr(ScalametaParser.scala:244)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$scala$meta$internal$parsers$ScalametaParser$$getArgClause$1(ScalametaParser.scala:2448)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$getArgClause(ScalametaParser.scala:2437)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2344)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$3(ScalametaParser.scala:2273)
	at scala.util.Success.map(Try.scala:262)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2273)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2223)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2206)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2081)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:1676)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:322)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1581)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$4(ScalametaParser.scala:4581)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4421)
	at scala.meta.internal.parsers.ScalametaParser.iter$6(ScalametaParser.scala:4581)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$1(ScalametaParser.scala:4598)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$1$adapted(ScalametaParser.scala:4548)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$listBy(ScalametaParser.scala:567)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4548)
	at scala.meta.internal.parsers.ScalametaParser.blockWithinDelims(ScalametaParser.scala:2487)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockInDelims$2(ScalametaParser.scala:2490)
	at scala.meta.internal.parsers.ScalametaParser.indentedOnOpen(ScalametaParser.scala:278)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockOnIndent$1(ScalametaParser.scala:2492)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockInDelims$1(ScalametaParser.scala:2490)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.blockInDelims(ScalametaParser.scala:2490)
	at scala.meta.internal.parsers.ScalametaParser.blockOnIndent(ScalametaParser.scala:2492)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExprOnIndent$2(ScalametaParser.scala:2493)
	at scala.meta.internal.parsers.ScalametaParser.blockExprPartial(ScalametaParser.scala:2483)
	at scala.meta.internal.parsers.ScalametaParser.blockExprOnIndent(ScalametaParser.scala:2493)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2268)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2223)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2206)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2081)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:1676)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:322)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1581)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1480)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:3807)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:368)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:373)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:3769)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:3714)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3544)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3523)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1.applyOrElse(ScalametaParser.scala:4495)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1.applyOrElse(ScalametaParser.scala:4489)
	at scala.PartialFunction.$anonfun$runWith$1(PartialFunction.scala:231)
	at scala.PartialFunction.$anonfun$runWith$1$adapted(PartialFunction.scala:230)
	at scala.meta.internal.parsers.ScalametaParser.statSeqBuf(ScalametaParser.scala:4440)
	at scala.meta.internal.parsers.ScalametaParser.getStats$2(ScalametaParser.scala:4479)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$scala$meta$internal$parsers$ScalametaParser$$templateStatSeq$3(ScalametaParser.scala:4480)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$scala$meta$internal$parsers$ScalametaParser$$templateStatSeq$3$adapted(ScalametaParser.scala:4477)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$listBy(ScalametaParser.scala:567)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$templateStatSeq(ScalametaParser.scala:4477)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$templateStatSeq(ScalametaParser.scala:4469)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4322)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOr(ScalametaParser.scala:260)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:256)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4322)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4326)
	at scala.meta.internal.parsers.ScalametaParser.templateAfterExtends(ScalametaParser.scala:4269)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateOpt$1(ScalametaParser.scala:4317)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4307)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4007)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:368)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:373)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:3999)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:3876)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:3857)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$2.applyOrElse(ScalametaParser.scala:4461)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$2.applyOrElse(ScalametaParser.scala:4449)
	at scala.PartialFunction.$anonfun$runWith$1(PartialFunction.scala:231)
	at scala.PartialFunction.$anonfun$runWith$1$adapted(PartialFunction.scala:230)
	at scala.meta.internal.parsers.ScalametaParser.statSeqBuf(ScalametaParser.scala:4440)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$13(ScalametaParser.scala:4674)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:4674)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4630)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4623)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4623)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4628)
	at scala.meta.internal.parsers.ScalametaParser.parseSourceImpl(ScalametaParser.scala:135)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$1(ScalametaParser.scala:132)
	at scala.meta.internal.parsers.ScalametaParser.parseRuleAfterBOF(ScalametaParser.scala:59)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:54)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:132)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.parsers.Parse$$anon$1.apply(Parse.scala:36)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.parsing.Trees.$anonfun$parse$2(Trees.scala:151)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.parsing.Trees.parse(Trees.scala:142)
	at scala.meta.internal.parsing.Trees.didChange(Trees.scala:101)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$parseTreesAndPublishDiags$2(MetalsLspService.scala:849)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2024.04.07 22:21:36 INFO  compiling bestgame (1 scala source)
2024.04.07 22:21:36 INFO  time: compiled bestgame in 0.65s
2024.04.07 22:21:46 INFO  compiling bestgame (1 scala source)
2024.04.07 22:21:46 INFO  time: compiled bestgame in 0.57s
2024.04.07 22:21:51 INFO  compiling bestgame (1 scala source)
2024.04.07 22:21:54 INFO  time: compiled bestgame in 2.66s
2024.04.07 22:22:49 INFO  compiling bestgame (1 scala source)
2024.04.07 22:22:51 INFO  time: compiled bestgame in 1.98s
2024.04.07 22:23:07 INFO  compiling bestgame (1 scala source)
2024.04.07 22:23:08 INFO  time: compiled bestgame in 1.13s
ΰοπ. 07, 2024 10:23:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4783
2024.04.07 22:24:04 INFO  compiling bestgame (1 scala source)
2024.04.07 22:24:04 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:24:05 INFO  time: compiled bestgame in 1.07s
2024.04.07 22:24:06 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:24:07 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:24:07 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:24:07 INFO  compiling bestgame (1 scala source)
2024.04.07 22:24:07 INFO  time: compiled bestgame in 0.65s
2024.04.07 22:24:08 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:24:14 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:24:15 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:24:16 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:24:17 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:24:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
ΰοπ. 07, 2024 10:24:19 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-07\r_compiler-error_(bestgame)_22-24-19-240.md
2024.04.07 22:24:19 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:24:19 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:24:21 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:24:21 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:24:23 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:24:24 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:24:25 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:25:41 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:25:44 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:25:47 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:25:48 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:25:52 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:25:54 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:25:57 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:04 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:05 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:07 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:07 INFO  compiling bestgame (1 scala source)
2024.04.07 22:26:07 INFO  time: compiled bestgame in 0.34s
2024.04.07 22:26:08 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:11 INFO  compiling bestgame (1 scala source)
2024.04.07 22:26:11 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:11 INFO  time: compiled bestgame in 0.19s
2024.04.07 22:26:12 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:14 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:15 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:17 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:18 INFO  compiling bestgame (1 scala source)
2024.04.07 22:26:18 INFO  time: compiled bestgame in 0.53s
2024.04.07 22:26:19 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:21 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:22 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:24 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:30 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:31 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:33 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:34 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:35 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:37 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:39 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:40 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:51 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:52 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:53 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:54 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:57 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:57 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:26:58 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:27:00 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:27:01 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:27:02 INFO  compiling bestgame (1 scala source)
2024.04.07 22:27:03 INFO  time: compiled bestgame in 1.09s
2024.04.07 22:27:03 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:27:10 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:27:12 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:27:15 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:27:17 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:27:19 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:27:29 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:27:32 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:28:03 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:28:06 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:28:12 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:28:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:28:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:28:19 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:28:20 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:28:22 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:28:23 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:28:28 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:28:31 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:28:33 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:28:33 INFO  compiling bestgame (1 scala source)
2024.04.07 22:28:33 INFO  time: compiled bestgame in 0.33s
2024.04.07 22:28:34 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:28:55 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:12 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:17 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:19 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:20 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:22 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:23 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:29 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:32 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:33 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:34 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:38 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:39 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:43 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:44 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:44 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:44 INFO  compiling bestgame (1 scala source)
2024.04.07 22:29:44 INFO  time: compiled bestgame in 0.21s
2024.04.07 22:29:44 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:49 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:50 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:50 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:51 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:52 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:52 INFO  compiling bestgame (1 scala source)
2024.04.07 22:29:52 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:52 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:29:52 INFO  time: compiled bestgame in 0.24s
2024.04.07 22:29:53 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
ΰοπ. 07, 2024 10:30:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.UnsupportedOperationException: tail of empty list
java.util.concurrent.CompletionException: java.lang.UnsupportedOperationException: tail of empty list
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.UnsupportedOperationException: tail of empty list
	at scala.collection.immutable.Nil$.tail(List.scala:664)
	at scala.collection.immutable.Nil$.tail(List.scala:661)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$endPosOfTree$1(CreateCompanionObjectCodeAction.scala:77)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.endPosOfTree(CreateCompanionObjectCodeAction.scala:75)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$5(CreateCompanionObjectCodeAction.scala:61)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$4(CreateCompanionObjectCodeAction.scala:58)
	at scala.Option$WithFilter.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$2(CreateCompanionObjectCodeAction.scala:56)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.CreateCompanionObjectCodeAction.$anonfun$contribute$1(CreateCompanionObjectCodeAction.scala:55)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2024.04.07 22:30:05 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:07 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:09 INFO  compiling bestgame (1 scala source)
2024.04.07 22:30:09 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:09 INFO  time: compiled bestgame in 0.2s
2024.04.07 22:30:10 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:16 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:16 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:17 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:18 INFO  compiling bestgame (1 scala source)
2024.04.07 22:30:18 INFO  time: compiled bestgame in 0.22s
2024.04.07 22:30:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:22 INFO  compiling bestgame (1 scala source)
2024.04.07 22:30:22 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:22 INFO  time: compiled bestgame in 0.19s
2024.04.07 22:30:23 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:25 INFO  compiling bestgame (1 scala source)
2024.04.07 22:30:25 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:25 INFO  time: compiled bestgame in 0.23s
2024.04.07 22:30:25 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:27 INFO  compiling bestgame (1 scala source)
2024.04.07 22:30:27 INFO  time: compiled bestgame in 0.18s
2024.04.07 22:30:27 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:29 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:38 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:42 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:45 INFO  compiling bestgame (1 scala source)
2024.04.07 22:30:45 INFO  time: compiled bestgame in 0.2s
2024.04.07 22:30:45 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:49 INFO  compiling bestgame (1 scala source)
2024.04.07 22:30:49 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:49 INFO  time: compiled bestgame in 0.47s
2024.04.07 22:30:50 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:51 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:51 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:51 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:51 INFO  compiling bestgame (1 scala source)
2024.04.07 22:30:51 INFO  time: compiled bestgame in 0.19s
2024.04.07 22:30:52 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:55 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:30:55 INFO  compiling bestgame (1 scala source)
2024.04.07 22:30:55 INFO  time: compiled bestgame in 0.19s
2024.04.07 22:30:55 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:32:15 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:32:19 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:32:22 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:32:27 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:32:30 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:32:33 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:32:34 INFO  compiling bestgame (1 scala source)
2024.04.07 22:32:34 INFO  time: compiled bestgame in 0.48s
2024.04.07 22:32:34 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:32:38 INFO  compiling bestgame (1 scala source)
2024.04.07 22:32:38 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:32:38 INFO  time: compiled bestgame in 0.81s
2024.04.07 22:32:39 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:32:42 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:32:42 INFO  compiling bestgame (1 scala source)
2024.04.07 22:32:42 INFO  time: compiled bestgame in 0.49s
2024.04.07 22:32:43 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:32:59 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:32:59 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:33:03 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:33:03 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:33:06 INFO  compiling bestgame (1 scala source)
2024.04.07 22:33:06 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:33:06 INFO  time: compiled bestgame in 0.19s
2024.04.07 22:33:07 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:33:12 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:33:56 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:34:43 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:34:43 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:34:44 WARN  Using indexes to guess the definition of Any
2024.04.07 22:34:44 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:34:49 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:35:42 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:35:44 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:35:46 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:35:47 INFO  compiling bestgame (1 scala source)
2024.04.07 22:35:47 INFO  time: compiled bestgame in 0.81s
2024.04.07 22:35:48 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:35:58 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:36:00 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:36:01 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:36:03 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:36:03 INFO  compiling bestgame (1 scala source)
2024.04.07 22:36:03 INFO  time: compiled bestgame in 0.2s
2024.04.07 22:36:04 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:36:05 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:36:08 INFO  compiling bestgame (1 scala source)
2024.04.07 22:36:08 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:36:08 INFO  time: compiled bestgame in 0.73s
2024.04.07 22:36:09 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:36:15 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:36:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:36:38 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:36:39 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:36:39 INFO  compiling bestgame (1 scala source)
2024.04.07 22:36:43 INFO  time: compiled bestgame in 4.14s
2024.04.07 22:37:04 INFO  compiling bestgame (1 scala source)
2024.04.07 22:37:04 INFO  time: compiled bestgame in 0.34s
ΰοπ. 07, 2024 10:37:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6553
2024.04.07 22:37:50 INFO  compiling bestgame (1 scala source)
2024.04.07 22:37:50 INFO  time: compiled bestgame in 0.21s
2024.04.07 22:37:54 INFO  compiling bestgame (1 scala source)
2024.04.07 22:37:55 INFO  time: compiled bestgame in 1.13s
2024.04.07 22:53:58 INFO  compiling bestgame (1 scala source)
2024.04.07 22:54:05 INFO  time: compiled bestgame in 6.43s
2024.04.07 22:54:05 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:54:35 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:54:35 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:54:36 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:54:37 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:54:38 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:54:39 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:54:46 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:54:48 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:54:48 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:54:49 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:54:49 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:54:49 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:54:49 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:54:49 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:54:49 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:54:49 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:54:49 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:54:49 INFO  compiling bestgame (1 scala source)
2024.04.07 22:54:52 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:54:53 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.07 22:54:54 INFO  time: compiled bestgame in 4.93s
2024.04.07 22:54:54 INFO  compiling bestgame (1 scala source)
2024.04.07 22:54:56 INFO  time: compiled bestgame in 2.36s
2024.04.07 22:55:02 INFO  compiling bestgame (1 scala source)
2024.04.07 22:55:03 INFO  time: compiled bestgame in 1.29s
2024.04.07 22:55:08 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java

Uri: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:906)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:689)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	java.base/java.lang.reflect.Method.invoke(Method.java:568)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	java.base/java.lang.Thread.run(Thread.java:833)
```

ΰοπ. 07, 2024 10:55:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.sql/java/sql/SQLException.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.sql;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n\n/**\n * \u003cP\u003eAn exception that provides information on a database access\n * error or other errors.\n *\n * \u003cP\u003eEach {@code SQLException} provides several kinds of information:\n * \u003cUL\u003e\n *   \u003cLI\u003e a string describing the error.  This is used as the Java Exception\n *       message, available via the method {@code getMessage}.\n *   \u003cLI\u003e a \"SQLstate\" string, which follows either the XOPEN SQLstate conventions\n *        or the SQL:2003 conventions.\n *       The values of the SQLState string are described in the appropriate spec.\n *       The {@code DatabaseMetaData} method {@code getSQLStateType}\n *       can be used to discover whether the driver returns the XOPEN type or\n *       the SQL:2003 type.\n *   \u003cLI\u003e an integer error code that is specific to each vendor.  Normally this will\n *       be the actual error code returned by the underlying database.\n *   \u003cLI\u003e a chain to a next Exception.  This can be used to provide additional\n *       error information.\n *   \u003cLI\u003e the causal relationship, if any for this {@code SQLException}.\n * \u003c/UL\u003e\n *\n * @since 1.1\n */\npublic class SQLException extends java.lang.Exception\n                          implements Iterable\u003cThrowable\u003e {\n\n    /**\n     *  Constructs a {@code SQLException} object with a given\n     * {@code reason}, {@code SQLState}  and\n     * {@code vendorCode}.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method.\n     *\n     * @param reason a description of the exception\n     * @param SQLState an XOPEN or SQL:2003 code identifying the exception\n     * @param vendorCode a database vendor-specific exception code\n     */\n    public SQLException(String reason, String SQLState, int vendorCode) {\n        super(reason);\n        this.SQLState \u003d SQLState;\n        this.vendorCode \u003d vendorCode;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                DriverManager.println(\"SQLState(\" + SQLState +\n                                                \") vendor code(\" + vendorCode + \")\");\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason} and {@code SQLState}.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method. The vendor code\n     * is initialized to 0.\n     *\n     * @param reason a description of the exception\n     * @param SQLState an XOPEN or SQL:2003 code identifying the exception\n     */\n    public SQLException(String reason, String SQLState) {\n        super(reason);\n        this.SQLState \u003d SQLState;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n                DriverManager.println(\"SQLException: SQLState(\" + SQLState + \")\");\n            }\n        }\n    }\n\n    /**\n     *  Constructs a {@code SQLException} object with a given\n     * {@code reason}. The  {@code SQLState}  is initialized to\n     * {@code null} and the vendor code is initialized to 0.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method.\n     *\n     * @param reason a description of the exception\n     */\n    public SQLException(String reason) {\n        super(reason);\n        this.SQLState \u003d null;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object.\n     * The {@code reason}, {@code SQLState} are initialized\n     * to {@code null} and the vendor code is initialized to 0.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method.\n     *\n     */\n    public SQLException() {\n        super();\n        this.SQLState \u003d null;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     *  Constructs a {@code SQLException} object with a given\n     * {@code cause}.\n     * The {@code SQLState} is initialized\n     * to {@code null} and the vendor code is initialized to 0.\n     * The {@code reason}  is initialized to {@code null} if\n     * {@code cause\u003d\u003dnull} or to {@code cause.toString()} if\n     * {@code cause!\u003dnull}.\n     *\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the {@code getCause()} method);\n     * may be null indicating the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(Throwable cause) {\n        super(cause);\n\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason} and  {@code cause}.\n     * The {@code SQLState} is  initialized to {@code null}\n     * and the vendor code is initialized to 0.\n     *\n     * @param reason a description of the exception.\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the {@code getCause()} method);\n     * may be null indicating the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(String reason, Throwable cause) {\n        super(reason,cause);\n\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                    printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason}, {@code SQLState} and  {@code cause}.\n     * The vendor code is initialized to 0.\n     *\n     * @param reason a description of the exception.\n     * @param sqlState an XOPEN or SQL:2003 code identifying the exception\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the\n     * {@code getCause()} method); may be null indicating\n     *     the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(String reason, String sqlState, Throwable cause) {\n        super(reason,cause);\n\n        this.SQLState \u003d sqlState;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n                DriverManager.println(\"SQLState(\" + SQLState + \")\");\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason}, {@code SQLState}, {@code vendorCode}\n     * and  {@code cause}.\n     *\n     * @param reason a description of the exception\n     * @param sqlState an XOPEN or SQL:2003 code identifying the exception\n     * @param vendorCode a database vendor-specific exception code\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the {@code getCause()} method);\n     * may be null indicating the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(String reason, String sqlState, int vendorCode, Throwable cause) {\n        super(reason,cause);\n\n        this.SQLState \u003d sqlState;\n        this.vendorCode \u003d vendorCode;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                DriverManager.println(\"SQLState(\" + SQLState +\n                                                \") vendor code(\" + vendorCode + \")\");\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Retrieves the SQLState for this {@code SQLException} object.\n     *\n     * @return the SQLState value\n     */\n    public String getSQLState() {\n        return (SQLState);\n    }\n\n    /**\n     * Retrieves the vendor-specific exception code\n     * for this {@code SQLException} object.\n     *\n     * @return the vendor\u0027s error code\n     */\n    public int getErrorCode() {\n        return (vendorCode);\n    }\n\n    /**\n     * Retrieves the exception chained to this\n     * {@code SQLException} object by setNextException(SQLException ex).\n     *\n     * @return the next {@code SQLException} object in the chain;\n     *         {@code null} if there are none\n     * @see #setNextException\n     */\n    public SQLException getNextException() {\n        return (next);\n    }\n\n    /**\n     * Adds an {@code SQLException} object to the end of the chain.\n     *\n     * @param ex the new exception that will be added to the end of\n     *            the {@code SQLException} chain\n     * @see #getNextException\n     */\n    public void setNextException(SQLException ex) {\n\n        SQLException current \u003d this;\n        for(;;) {\n            SQLException next\u003dcurrent.next;\n            if (next !\u003d null) {\n                current \u003d next;\n                continue;\n            }\n\n            if (nextUpdater.compareAndSet(current,null,ex)) {\n                return;\n            }\n            current\u003dcurrent.next;\n        }\n    }\n\n    /**\n     * Returns an iterator over the chained SQLExceptions.  The iterator will\n     * be used to iterate over each SQLException and its underlying cause\n     * (if any).\n     *\n     * @return an iterator over the chained SQLExceptions and causes in the proper\n     * order\n     *\n     * @since 1.6\n     */\n    public Iterator\u003cThrowable\u003e iterator() {\n\n       return new Iterator\u003cThrowable\u003e() {\n\n           SQLException firstException \u003d SQLException.this;\n           SQLException nextException \u003d firstException.getNextException();\n           Throwable cause \u003d firstException.getCause();\n\n           public boolean hasNext() {\n               if(firstException !\u003d null || nextException !\u003d null || cause !\u003d null)\n                   return true;\n               return false;\n           }\n\n           public Throwable next() {\n               Throwable throwable \u003d null;\n               if(firstException !\u003d null){\n                   throwable \u003d firstException;\n                   firstException \u003d null;\n               }\n               else if(cause !\u003d null){\n                   throwable \u003d cause;\n                   cause \u003d cause.getCause();\n               }\n               else if(nextException !\u003d null){\n                   throwable \u003d nextException;\n                   cause \u003d nextException.getCause();\n                   nextException \u003d nextException.getNextException();\n               }\n               else\n                   throw new NoSuchElementException();\n               return throwable;\n           }\n\n           public void remove() {\n               throw new UnsupportedOperationException();\n           }\n\n       };\n\n    }\n\n    /**\n         * @serial\n         */\n    private String SQLState;\n\n        /**\n         * @serial\n         */\n    private int vendorCode;\n\n        /**\n         * @serial\n         */\n    private volatile SQLException next;\n\n    private static final AtomicReferenceFieldUpdater\u003cSQLException,SQLException\u003e nextUpdater \u003d\n            AtomicReferenceFieldUpdater.newUpdater(SQLException.class,SQLException.class,\"next\");\n\n    private static final long serialVersionUID \u003d 2135244094396331484L;\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

ΰοπ. 07, 2024 10:55:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-17/lib/src.zip%21/java.sql/java/sql/SQLException.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI.create(URI.java:906)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	... 16 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-17/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI$Parser.fail(URI.java:2974)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3145)
	at java.base/java.net.URI$Parser.parse(URI.java:3181)
	at java.base/java.net.URI.<init>(URI.java:623)
	at java.base/java.net.URI.create(URI.java:904)
	... 24 more

2024.04.07 22:55:08 INFO  compiling bestgame (1 scala source)
2024.04.07 22:55:08 INFO  time: compiled bestgame in 0.93s
2024.04.07 22:55:13 INFO  compiling bestgame (1 scala source)
2024.04.07 22:55:13 INFO  time: compiled bestgame in 0.67s
2024.04.07 22:55:18 INFO  compiling bestgame (1 scala source)
2024.04.07 22:55:19 INFO  time: compiled bestgame in 1.02s
2024.04.07 22:55:26 INFO  compiling bestgame (1 scala source)
2024.04.07 22:55:27 INFO  time: compiled bestgame in 1.04s
2024.04.07 22:55:36 INFO  compiling bestgame (1 scala source)
2024.04.07 22:55:37 INFO  time: compiled bestgame in 1.07s
2024.04.07 22:55:56 INFO  compiling bestgame (1 scala source)
2024.04.07 22:55:56 INFO  time: compiled bestgame in 0.79s
2024.04.07 22:56:01 INFO  compiling bestgame (1 scala source)
2024.04.07 22:56:01 INFO  time: compiled bestgame in 0.73s
2024.04.07 22:56:26 INFO  compiling bestgame (1 scala source)
2024.04.07 22:56:26 INFO  time: compiled bestgame in 0.19s
2024.04.07 22:56:30 INFO  compiling bestgame (1 scala source)
2024.04.07 22:56:30 INFO  time: compiled bestgame in 0.48s
2024.04.07 22:56:35 INFO  compiling bestgame (1 scala source)
2024.04.07 22:56:35 INFO  time: compiled bestgame in 0.17s
2024.04.07 22:56:37 INFO  compiling bestgame (1 scala source)
2024.04.07 22:56:37 INFO  time: compiled bestgame in 0.64s
ΰοπ. 07, 2024 10:56:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7506
2024.04.07 22:57:09 INFO  compiling bestgame (1 scala source)
2024.04.07 22:57:09 INFO  time: compiled bestgame in 0.64s
2024.04.07 22:57:24 INFO  compiling bestgame (1 scala source)
2024.04.07 22:57:27 INFO  time: compiled bestgame in 2.33s
2024.04.07 22:58:32 INFO  compiling bestgame (1 scala source)
2024.04.07 22:58:32 INFO  time: compiled bestgame in 0.34s
2024.04.07 22:58:44 INFO  compiling bestgame (1 scala source)
2024.04.07 22:58:44 INFO  time: compiled bestgame in 98ms
2024.04.07 22:58:55 INFO  compiling bestgame (1 scala source)
2024.04.07 22:58:55 INFO  time: compiled bestgame in 0.71s
2024.04.07 22:59:57 INFO  compiling bestgame (1 scala source)
2024.04.07 22:59:57 INFO  time: compiled bestgame in 0.58s
2024.04.07 23:00:12 INFO  compiling bestgame (1 scala source)
2024.04.07 23:00:12 INFO  time: compiled bestgame in 0.4s
2024.04.07 23:01:12 INFO  compiling bestgame (1 scala source)
2024.04.07 23:01:14 INFO  time: compiled bestgame in 1.73s
ΰοπ. 07, 2024 11:02:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8148
ΰοπ. 07, 2024 11:02:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: org.scalameta.invariants.InvariantFailedException: invariant failed:
when verifying scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable
found that scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable is false
where tpe = false
java.util.concurrent.CompletionException: org.scalameta.invariants.InvariantFailedException: invariant failed:
when verifying scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable
found that scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable is false
where tpe = false
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2162)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:833)
Caused by: org.scalameta.invariants.InvariantFailedException: invariant failed:
when verifying scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable
found that scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable is false
where tpe = false
	at org.scalameta.invariants.InvariantFailedException$.raise(Exceptions.scala:19)
	at scala.meta.Init$.apply(Trees.scala:860)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$initRest$1(ScalametaParser.scala:4146)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:322)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.initRest(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.initInsideTemplate(ScalametaParser.scala:4089)
	at scala.meta.internal.parsers.ScalametaParser.init(ScalametaParser.scala:4231)
	at scala.meta.internal.parsers.ScalametaParser.templateParents(ScalametaParser.scala:4241)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4289)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4277)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$2(ScalametaParser.scala:2257)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2255)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2223)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2206)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2081)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:1676)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:322)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1581)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2434)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsInParens$1(ScalametaParser.scala:2461)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$commaSeparated$1(ScalametaParser.scala:655)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$commaSeparated$1$adapted(ScalametaParser.scala:655)
	at scala.meta.internal.parsers.ScalametaParser.iter$1(ScalametaParser.scala:645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$tokenSeparated$1(ScalametaParser.scala:651)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$tokenSeparated$1$adapted(ScalametaParser.scala:638)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$listBy(ScalametaParser.scala:567)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:638)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparatedWithIndex(ScalametaParser.scala:658)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:655)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsInParens(ScalametaParser.scala:2461)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$scala$meta$internal$parsers$ScalametaParser$$getArgClause$2(ScalametaParser.scala:2447)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$inParensAfterOpenOr(ScalametaParser.scala:253)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$inParensOnOpenOr(ScalametaParser.scala:244)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$scala$meta$internal$parsers$ScalametaParser$$getArgClause$1(ScalametaParser.scala:2448)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$getArgClause(ScalametaParser.scala:2437)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2344)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$3(ScalametaParser.scala:2273)
	at scala.util.Success.map(Try.scala:262)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2273)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2223)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2206)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2081)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:1676)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:322)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1581)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$4(ScalametaParser.scala:4581)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4421)
	at scala.meta.internal.parsers.ScalametaParser.iter$6(ScalametaParser.scala:4581)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$1(ScalametaParser.scala:4598)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$1$adapted(ScalametaParser.scala:4548)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$listBy(ScalametaParser.scala:567)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4548)
	at scala.meta.internal.parsers.ScalametaParser.blockWithinDelims(ScalametaParser.scala:2487)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockInDelims$2(ScalametaParser.scala:2490)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOnOpen(ScalametaParser.scala:264)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockOnBrace$1(ScalametaParser.scala:2496)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockInDelims$1(ScalametaParser.scala:2490)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.blockInDelims(ScalametaParser.scala:2490)
	at scala.meta.internal.parsers.ScalametaParser.blockOnBrace(ScalametaParser.scala:2496)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExprOnBrace$2(ScalametaParser.scala:2499)
	at scala.meta.internal.parsers.ScalametaParser.blockExprPartial(ScalametaParser.scala:2483)
	at scala.meta.internal.parsers.ScalametaParser.blockExprOnBrace(ScalametaParser.scala:2499)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2252)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2223)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2206)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2081)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:1676)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:322)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1581)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1480)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$ifClause$1(ScalametaParser.scala:1541)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:368)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:373)
	at scala.meta.internal.parsers.ScalametaParser.ifClause(ScalametaParser.scala:1530)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:1587)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:322)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1581)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1480)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:3807)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:368)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:373)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:3769)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:3714)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3544)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3523)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1.applyOrElse(ScalametaParser.scala:4495)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1.applyOrElse(ScalametaParser.scala:4489)
	at scala.PartialFunction.$anonfun$runWith$1(PartialFunction.scala:231)
	at scala.PartialFunction.$anonfun$runWith$1$adapted(PartialFunction.scala:230)
	at scala.meta.internal.parsers.ScalametaParser.statSeqBuf(ScalametaParser.scala:4440)
	at scala.meta.internal.parsers.ScalametaParser.getStats$2(ScalametaParser.scala:4479)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$scala$meta$internal$parsers$ScalametaParser$$templateStatSeq$3(ScalametaParser.scala:4480)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$scala$meta$internal$parsers$ScalametaParser$$templateStatSeq$3$adapted(ScalametaParser.scala:4477)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$listBy(ScalametaParser.scala:567)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$templateStatSeq(ScalametaParser.scala:4477)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$templateStatSeq(ScalametaParser.scala:4469)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4322)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOr(ScalametaParser.scala:260)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:256)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4322)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4326)
	at scala.meta.internal.parsers.ScalametaParser.templateAfterExtends(ScalametaParser.scala:4269)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateOpt$1(ScalametaParser.scala:4317)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4307)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4007)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:368)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:373)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:3999)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:3876)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:3857)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$2.applyOrElse(ScalametaParser.scala:4461)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$2.applyOrElse(ScalametaParser.scala:4449)
	at scala.PartialFunction.$anonfun$runWith$1(PartialFunction.scala:231)
	at scala.PartialFunction.$anonfun$runWith$1$adapted(PartialFunction.scala:230)
	at scala.meta.internal.parsers.ScalametaParser.statSeqBuf(ScalametaParser.scala:4440)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$13(ScalametaParser.scala:4674)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:4674)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4630)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4623)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4623)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4628)
	at scala.meta.internal.parsers.ScalametaParser.parseSourceImpl(ScalametaParser.scala:135)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$1(ScalametaParser.scala:132)
	at scala.meta.internal.parsers.ScalametaParser.parseRuleAfterBOF(ScalametaParser.scala:59)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:54)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:132)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.parsers.Parse$$anon$1.apply(Parse.scala:36)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.parsing.Trees.$anonfun$parse$2(Trees.scala:151)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.parsing.Trees.parse(Trees.scala:142)
	at scala.meta.internal.parsing.Trees.didChange(Trees.scala:101)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$parseTreesAndPublishDiags$2(MetalsLspService.scala:849)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

error while checking new User(username, 0, null)
error while checking DataService.addUser(new User(username, 0, null))
error while checking {
  this.games(username) = new Game(username)
  this.usernameSocket(username) = socket
  this.socketUsername(socket) = username
  DataService.addUser(new User(username, 0, null))
}
error while checking if (this.games contains username)
  {
    this.usernameSocket(username) = socket
    this.socketUsername(socket) = username
    true
  }
 else
  {
    this.games(username) = new Game(username)
    this.usernameSocket(username) = socket
    this.socketUsername(socket) = username
    DataService.addUser(new User(username, 0, null))
  }
error while checking def connected(username: String, socket: WebSocketChannel): Boolean =
  if (this.games contains username)
    {
      this.usernameSocket(username) = socket
      this.socketUsername(socket) = username
      true
    }
   else
    {
      this.games(username) = new Game(username)
      this.usernameSocket(username) = socket
      this.socketUsername(socket) = username
      DataService.addUser(new User(username, 0, null))
    }
error while checking  {
  var usernameSocket: scala.collection.mutable.Map[String, WebSocketChannel] =
    scala.collection.mutable.Map.empty
  var socketUsername: scala.collection.mutable.Map[WebSocketChannel, String] =
    scala.collection.mutable.Map.empty
  var games: scala.collection.mutable.Map[String, Game] =
    scala.collection.mutable.Map.empty
  def connected(username: String, socket: WebSocketChannel): Boolean =
    if (this.games contains username)
      {
        this.usernameSocket(username) = socket
        this.socketUsername(socket) = username
        true
      }
     else
      {
        this.games(username) = new Game(username)
        this.usernameSocket(username) = socket
        this.socketUsername(socket) = username
        DataService.addUser(new User(username, 0, null))
      }
  def getState(socket: WebSocketChannel): String =
    {
      DataService.getUsers.provide(DataService.live,
        Quill.Postgres.fromNamingStrategy(SnakeCase),
        Quill.DataSource.fromPrefix("db")).debug("Results").exitCode
      this.games(socketUsername(socket)).toString()
    }
  def plant(socket: WebSocketChannel): Boolean =
    {
      this.games(socketUsername(socket)).plant()
      true
    }
  def collect(socket: WebSocketChannel): Boolean =
    {
      this.games(socketUsername(socket)).collect()
      true
    }
  def matchEvent(socket: WebSocketChannel, event: SocketEvent): Boolean =
    {
      event match
        {
          case Connect(data) =>
            this.connected(data, socket)
          case Plant(data) =>
            this.plant(socket)
          case Collect(data) =>
            this.collect(socket)
          case Unknown(data) =>
            (((1.toString().toInt).+(1.toDouble.toInt).toInt).toInt.toString()).
              toInt
        }
      true
    }
}
error while checking module object App {
  var usernameSocket: scala.collection.mutable.Map[String, WebSocketChannel] =
    scala.collection.mutable.Map.empty
  var socketUsername: scala.collection.mutable.Map[WebSocketChannel, String] =
    scala.collection.mutable.Map.empty
  var games: scala.collection.mutable.Map[String, Game] =
    scala.collection.mutable.Map.empty
  def connected(username: String, socket: WebSocketChannel): Boolean =
    if (this.games contains username)
      {
        this.usernameSocket(username) = socket
        this.socketUsername(socket) = username
        true
      }
     else
      {
        this.games(username) = new Game(username)
        this.usernameSocket(username) = socket
        this.socketUsername(socket) = username
        DataService.addUser(new User(username, 0, null))
      }
  def getState(socket: WebSocketChannel): String =
    {
      DataService.getUsers.provide(DataService.live,
        Quill.Postgres.fromNamingStrategy(SnakeCase),
        Quill.DataSource.fromPrefix("db")).debug("Results").exitCode
      this.games(socketUsername(socket)).toString()
    }
  def plant(socket: WebSocketChannel): Boolean =
    {
      this.games(socketUsername(socket)).plant()
      true
    }
  def collect(socket: WebSocketChannel): Boolean =
    {
      this.games(socketUsername(socket)).collect()
      true
    }
  def matchEvent(socket: WebSocketChannel, event: SocketEvent): Boolean =
    {
      event match
        {
          case Connect(data) =>
            this.connected(data, socket)
          case Plant(data) =>
            this.plant(socket)
          case Collect(data) =>
            this.collect(socket)
          case Unknown(data) =>
            (((1.toString().toInt).+(1.toDouble.toInt).toInt).toInt.toString()).
              toInt
        }
      true
    }
}
error while checking package <empty> {
  import zio.http.*
  import zio.*
  import io.getquill.jdbczio.Quill
  import io.getquill.SnakeCase
  import javax.xml.crypto.Data
  module object App {
    var usernameSocket: scala.collection.mutable.Map[String, WebSocketChannel]
       = scala.collection.mutable.Map.empty
    var socketUsername: scala.collection.mutable.Map[WebSocketChannel, String]
       = scala.collection.mutable.Map.empty
    var games: scala.collection.mutable.Map[String, Game] =
      scala.collection.mutable.Map.empty
    def connected(username: String, socket: WebSocketChannel): Boolean =
      if (this.games contains username)
        {
          this.usernameSocket(username) = socket
          this.socketUsername(socket) = username
          true
        }
       else
        {
          this.games(username) = new Game(username)
          this.usernameSocket(username) = socket
          this.socketUsername(socket) = username
          DataService.addUser(new User(username, 0, null))
        }
    def getState(socket: WebSocketChannel): String =
      {
        DataService.getUsers.provide(DataService.live,
          Quill.Postgres.fromNamingStrategy(SnakeCase),
          Quill.DataSource.fromPrefix("db")).debug("Results").exitCode
        this.games(socketUsername(socket)).toString()
      }
    def plant(socket: WebSocketChannel): Boolean =
      {
        this.games(socketUsername(socket)).plant()
        true
      }
    def collect(socket: WebSocketChannel): Boolean =
      {
        this.games(socketUsername(socket)).collect()
        true
      }
    def matchEvent(socket: WebSocketChannel, event: SocketEvent): Boolean =
      {
        event match
          {
            case Connect(data) =>
              this.connected(data, socket)
            case Plant(data) =>
              this.plant(socket)
            case Collect(data) =>
              this.collect(socket)
            case Unknown(data) =>
              (((1.toString().toInt).+(1.toDouble.toInt).toInt).toInt.toString()
                ).toInt
          }
        true
      }
  }
}
ΰοπ. 07, 2024 11:03:01 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-07\r_compiler-error_(bestgame)_23-03-01-128.md
error while checking new User(username, 0, null)
error while checking DataService.addUser(new User(username, 0, null))
error while checking {
  this.games(username) = new Game(username)
  this.usernameSocket(username) = socket
  this.socketUsername(socket) = username
  DataService.addUser(new User(username, 0, null))
}
error while checking if (this.games contains username)
  {
    this.usernameSocket(username) = socket
    this.socketUsername(socket) = username
    true
  }
 else
  {
    this.games(username) = new Game(username)
    this.usernameSocket(username) = socket
    this.socketUsername(socket) = username
    DataService.addUser(new User(username, 0, null))
  }
error while checking def connected(username: String, socket: WebSocketChannel): Boolean =
  if (this.games contains username)
    {
      this.usernameSocket(username) = socket
      this.socketUsername(socket) = username
      true
    }
   else
    {
      this.games(username) = new Game(username)
      this.usernameSocket(username) = socket
      this.socketUsername(socket) = username
      DataService.addUser(new User(username, 0, null))
    }
error while checking  {
  var usernameSocket: scala.collection.mutable.Map[String, WebSocketChannel] =
    scala.collection.mutable.Map.empty
  var socketUsername: scala.collection.mutable.Map[WebSocketChannel, String] =
    scala.collection.mutable.Map.empty
  var games: scala.collection.mutable.Map[String, Game] =
    scala.collection.mutable.Map.empty
  def connected(username: String, socket: WebSocketChannel): Boolean =
    if (this.games contains username)
      {
        this.usernameSocket(username) = socket
        this.socketUsername(socket) = username
        true
      }
     else
      {
        this.games(username) = new Game(username)
        this.usernameSocket(username) = socket
        this.socketUsername(socket) = username
        DataService.addUser(new User(username, 0, null))
      }
  def getState(socket: WebSocketChannel): String =
    {
      DataService.getUsers.provide(DataService.live,
        Quill.Postgres.fromNamingStrategy(SnakeCase),
        Quill.DataSource.fromPrefix("db")).debug("Results").exitCode
      this.games(socketUsername(socket)).toString()
    }
  def plant(socket: WebSocketChannel): Boolean =
    {
      this.games(socketUsername(socket)).plant()
      true
    }
  def collect(socket: WebSocketChannel): Boolean =
    {
      this.games(socketUsername(socket)).collect()
      true
    }
  def matchEvent(socket: WebSocketChannel, event: SocketEvent): Boolean =
    {
      event match
        {
          case Connect(data) =>
            this.connected(data, socket)
          case Plant(data) =>
            this.plant(socket)
          case Collect(data) =>
            this.collect(socket)
          case Unknown(data) =>
            (((1.toString().toInt).+(1.toDouble.toInt).toInt).toInt.toString()).
              toInt
        }
      true
    }
}
error while checking module object App {
  var usernameSocket: scala.collection.mutable.Map[String, WebSocketChannel] =
    scala.collection.mutable.Map.empty
  var socketUsername: scala.collection.mutable.Map[WebSocketChannel, String] =
    scala.collection.mutable.Map.empty
  var games: scala.collection.mutable.Map[String, Game] =
    scala.collection.mutable.Map.empty
  def connected(username: String, socket: WebSocketChannel): Boolean =
    if (this.games contains username)
      {
        this.usernameSocket(username) = socket
        this.socketUsername(socket) = username
        true
      }
     else
      {
        this.games(username) = new Game(username)
        this.usernameSocket(username) = socket
        this.socketUsername(socket) = username
        DataService.addUser(new User(username, 0, null))
      }
  def getState(socket: WebSocketChannel): String =
    {
      DataService.getUsers.provide(DataService.live,
        Quill.Postgres.fromNamingStrategy(SnakeCase),
        Quill.DataSource.fromPrefix("db")).debug("Results").exitCode
      this.games(socketUsername(socket)).toString()
    }
  def plant(socket: WebSocketChannel): Boolean =
    {
      this.games(socketUsername(socket)).plant()
      true
    }
  def collect(socket: WebSocketChannel): Boolean =
    {
      this.games(socketUsername(socket)).collect()
      true
    }
  def matchEvent(socket: WebSocketChannel, event: SocketEvent): Boolean =
    {
      event match
        {
          case Connect(data) =>
            this.connected(data, socket)
          case Plant(data) =>
            this.plant(socket)
          case Collect(data) =>
            this.collect(socket)
          case Unknown(data) =>
            (((1.toString().toInt).+(1.toDouble.toInt).toInt).toInt.toString()).
              toInt
        }
      true
    }
}
error while checking package <empty> {
  import zio.http.*
  import zio.*
  import io.getquill.jdbczio.Quill
  import io.getquill.SnakeCase
  import javax.xml.crypto.Data
  module object App {
    var usernameSocket: scala.collection.mutable.Map[String, WebSocketChannel]
       = scala.collection.mutable.Map.empty
    var socketUsername: scala.collection.mutable.Map[WebSocketChannel, String]
       = scala.collection.mutable.Map.empty
    var games: scala.collection.mutable.Map[String, Game] =
      scala.collection.mutable.Map.empty
    def connected(username: String, socket: WebSocketChannel): Boolean =
      if (this.games contains username)
        {
          this.usernameSocket(username) = socket
          this.socketUsername(socket) = username
          true
        }
       else
        {
          this.games(username) = new Game(username)
          this.usernameSocket(username) = socket
          this.socketUsername(socket) = username
          DataService.addUser(new User(username, 0, null))
        }
    def getState(socket: WebSocketChannel): String =
      {
        DataService.getUsers.provide(DataService.live,
          Quill.Postgres.fromNamingStrategy(SnakeCase),
          Quill.DataSource.fromPrefix("db")).debug("Results").exitCode
        this.games(socketUsername(socket)).toString()
      }
    def plant(socket: WebSocketChannel): Boolean =
      {
        this.games(socketUsername(socket)).plant()
        true
      }
    def collect(socket: WebSocketChannel): Boolean =
      {
        this.games(socketUsername(socket)).collect()
        true
      }
    def matchEvent(socket: WebSocketChannel, event: SocketEvent): Boolean =
      {
        event match
          {
            case Connect(data) =>
              this.connected(data, socket)
            case Plant(data) =>
              this.plant(socket)
            case Collect(data) =>
              this.collect(socket)
            case Unknown(data) =>
              (((1.toString().toInt).+(1.toDouble.toInt).toInt).toInt.toString()
                ).toInt
          }
        true
      }
  }
}
ΰοπ. 07, 2024 11:03:01 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-07\r_compiler-error_(bestgame)_23-03-01-290.md
error while checking new User(username, 0, null)
error while checking DataService.addUser(new User(username, 0, null))
error while checking {
  this.games(username) = new Game(username)
  this.usernameSocket(username) = socket
  this.socketUsername(socket) = username
  DataService.addUser(new User(username, 0, null))
}
error while checking if (this.games contains username)
  {
    this.usernameSocket(username) = socket
    this.socketUsername(socket) = username
    true
  }
 else
  {
    this.games(username) = new Game(username)
    this.usernameSocket(username) = socket
    this.socketUsername(socket) = username
    DataService.addUser(new User(username, 0, null))
  }
error while checking def connected(username: String, socket: WebSocketChannel): Boolean =
  if (this.games contains username)
    {
      this.usernameSocket(username) = socket
      this.socketUsername(socket) = username
      true
    }
   else
    {
      this.games(username) = new Game(username)
      this.usernameSocket(username) = socket
      this.socketUsername(socket) = username
      DataService.addUser(new User(username, 0, null))
    }
error while checking  {
  var usernameSocket: scala.collection.mutable.Map[String, WebSocketChannel] =
    scala.collection.mutable.Map.empty
  var socketUsername: scala.collection.mutable.Map[WebSocketChannel, String] =
    scala.collection.mutable.Map.empty
  var games: scala.collection.mutable.Map[String, Game] =
    scala.collection.mutable.Map.empty
  def connected(username: String, socket: WebSocketChannel): Boolean =
    if (this.games contains username)
      {
        this.usernameSocket(username) = socket
        this.socketUsername(socket) = username
        true
      }
     else
      {
        this.games(username) = new Game(username)
        this.usernameSocket(username) = socket
        this.socketUsername(socket) = username
        DataService.addUser(new User(username, 0, null))
      }
  def getState(socket: WebSocketChannel): String =
    {
      DataService.getUsers.provide(DataService.live,
        Quill.Postgres.fromNamingStrategy(SnakeCase),
        Quill.DataSource.fromPrefix("db")).debug("Results").exitCode
      this.games(socketUsername(socket)).toString()
    }
  def plant(socket: WebSocketChannel): Boolean =
    {
      this.games(socketUsername(socket)).plant()
      true
    }
  def collect(socket: WebSocketChannel): Boolean =
    {
      this.games(socketUsername(socket)).collect()
      true
    }
  def matchEvent(socket: WebSocketChannel, event: SocketEvent): Boolean =
    {
      event match
        {
          case Connect(data) =>
            this.connected(data, socket)
          case Plant(data) =>
            this.plant(socket)
          case Collect(data) =>
            this.collect(socket)
          case Unknown(data) =>
            (((1.toString().toInt).+(1.toDouble.toInt).toInt).toInt.toString()).
              toInt
        }
      true
    }
}
error while checking module object App {
  var usernameSocket: scala.collection.mutable.Map[String, WebSocketChannel] =
    scala.collection.mutable.Map.empty
  var socketUsername: scala.collection.mutable.Map[WebSocketChannel, String] =
    scala.collection.mutable.Map.empty
  var games: scala.collection.mutable.Map[String, Game] =
    scala.collection.mutable.Map.empty
  def connected(username: String, socket: WebSocketChannel): Boolean =
    if (this.games contains username)
      {
        this.usernameSocket(username) = socket
        this.socketUsername(socket) = username
        true
      }
     else
      {
        this.games(username) = new Game(username)
        this.usernameSocket(username) = socket
        this.socketUsername(socket) = username
        DataService.addUser(new User(username, 0, null))
      }
  def getState(socket: WebSocketChannel): String =
    {
      DataService.getUsers.provide(DataService.live,
        Quill.Postgres.fromNamingStrategy(SnakeCase),
        Quill.DataSource.fromPrefix("db")).debug("Results").exitCode
      this.games(socketUsername(socket)).toString()
    }
  def plant(socket: WebSocketChannel): Boolean =
    {
      this.games(socketUsername(socket)).plant()
      true
    }
  def collect(socket: WebSocketChannel): Boolean =
    {
      this.games(socketUsername(socket)).collect()
      true
    }
  def matchEvent(socket: WebSocketChannel, event: SocketEvent): Boolean =
    {
      event match
        {
          case Connect(data) =>
            this.connected(data, socket)
          case Plant(data) =>
            this.plant(socket)
          case Collect(data) =>
            this.collect(socket)
          case Unknown(data) =>
            (((1.toString().toInt).+(1.toDouble.toInt).toInt).toInt.toString()).
              toInt
        }
      true
    }
}
error while checking package <empty> {
  import zio.http.*
  import zio.*
  import io.getquill.jdbczio.Quill
  import io.getquill.SnakeCase
  import javax.xml.crypto.Data
  module object App {
    var usernameSocket: scala.collection.mutable.Map[String, WebSocketChannel]
       = scala.collection.mutable.Map.empty
    var socketUsername: scala.collection.mutable.Map[WebSocketChannel, String]
       = scala.collection.mutable.Map.empty
    var games: scala.collection.mutable.Map[String, Game] =
      scala.collection.mutable.Map.empty
    def connected(username: String, socket: WebSocketChannel): Boolean =
      if (this.games contains username)
        {
          this.usernameSocket(username) = socket
          this.socketUsername(socket) = username
          true
        }
       else
        {
          this.games(username) = new Game(username)
          this.usernameSocket(username) = socket
          this.socketUsername(socket) = username
          DataService.addUser(new User(username, 0, null))
        }
    def getState(socket: WebSocketChannel): String =
      {
        DataService.getUsers.provide(DataService.live,
          Quill.Postgres.fromNamingStrategy(SnakeCase),
          Quill.DataSource.fromPrefix("db")).debug("Results").exitCode
        this.games(socketUsername(socket)).toString()
      }
    def plant(socket: WebSocketChannel): Boolean =
      {
        this.games(socketUsername(socket)).plant()
        true
      }
    def collect(socket: WebSocketChannel): Boolean =
      {
        this.games(socketUsername(socket)).collect()
        true
      }
    def matchEvent(socket: WebSocketChannel, event: SocketEvent): Boolean =
      {
        event match
          {
            case Connect(data) =>
              this.connected(data, socket)
            case Plant(data) =>
              this.plant(socket)
            case Collect(data) =>
              this.collect(socket)
            case Unknown(data) =>
              (((1.toString().toInt).+(1.toDouble.toInt).toInt).toInt.toString()
                ).toInt
          }
        true
      }
  }
}
ΰοπ. 07, 2024 11:03:01 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-07\r_compiler-error_(bestgame)_23-03-01-440.md
2024.04.07 23:03:01 WARN  Could not find semantic tokens for: file:///D:/bestgame/src/main/scala/App.scala
error while checking new User(username, 0, null)
error while checking DataService.addUser(new User(username, 0, null))
error while checking {
  this.games(username) = new Game(username)
  this.usernameSocket(username) = socket
  this.socketUsername(socket) = username
  DataService.addUser(new User(username, 0, null))
}
error while checking if (this.games contains username)
  {
    this.usernameSocket(username) = socket
    this.socketUsername(socket) = username
    true
  }
 else
  {
    this.games(username) = new Game(username)
    this.usernameSocket(username) = socket
    this.socketUsername(socket) = username
    DataService.addUser(new User(username, 0, null))
  }
error while checking def connected(username: String, socket: WebSocketChannel): Boolean =
  if (this.games contains username)
    {
      this.usernameSocket(username) = socket
      this.socketUsername(socket) = username
      true
    }
   else
    {
      this.games(username) = new Game(username)
      this.usernameSocket(username) = socket
      this.socketUsername(socket) = username
      DataService.addUser(new User(username, 0, null))
    }
error while checking  {
  var usernameSocket: scala.collection.mutable.Map[String, WebSocketChannel] =
    scala.collection.mutable.Map.empty
  var socketUsername: scala.collection.mutable.Map[WebSocketChannel, String] =
    scala.collection.mutable.Map.empty
  var games: scala.collection.mutable.Map[String, Game] =
    scala.collection.mutable.Map.empty
  def connected(username: String, socket: WebSocketChannel): Boolean =
    if (this.games contains username)
      {
        this.usernameSocket(username) = socket
        this.socketUsername(socket) = username
        true
      }
     else
      {
        this.games(username) = new Game(username)
        this.usernameSocket(username) = socket
        this.socketUsername(socket) = username
        DataService.addUser(new User(username, 0, null))
      }
  def getState(socket: WebSocketChannel): String =
    {
      DataService.getUsers.provide(DataService.live,
        Quill.Postgres.fromNamingStrategy(SnakeCase),
        Quill.DataSource.fromPrefix("db")).debug("Results").exitCode
      this.games(socketUsername(socket)).toString()
    }
  def plant(socket: WebSocketChannel): Boolean =
    {
      this.games(socketUsername(socket)).plant()
      true
    }
  def collect(socket: WebSocketChannel): Boolean =
    {
      this.games(socketUsername(socket)).collect()
      true
    }
  def matchEvent(socket: WebSocketChannel, event: SocketEvent): Boolean =
    {
      event match
        {
          case Connect(data) =>
            this.connected(data, socket)
          case Plant(data) =>
            this.plant(socket)
          case Collect(data) =>
            this.collect(socket)
          case Unknown(data) =>
            (((1.toString().toInt).+(1.toDouble.toInt).toInt).toInt.toString()).
              toInt
        }
      true
    }
}
error while checking module object App {
  var usernameSocket: scala.collection.mutable.Map[String, WebSocketChannel] =
    scala.collection.mutable.Map.empty
  var socketUsername: scala.collection.mutable.Map[WebSocketChannel, String] =
    scala.collection.mutable.Map.empty
  var games: scala.collection.mutable.Map[String, Game] =
    scala.collection.mutable.Map.empty
  def connected(username: String, socket: WebSocketChannel): Boolean =
    if (this.games contains username)
      {
        this.usernameSocket(username) = socket
        this.socketUsername(socket) = username
        true
      }
     else
      {
        this.games(username) = new Game(username)
        this.usernameSocket(username) = socket
        this.socketUsername(socket) = username
        DataService.addUser(new User(username, 0, null))
      }
  def getState(socket: WebSocketChannel): String =
    {
      DataService.getUsers.provide(DataService.live,
        Quill.Postgres.fromNamingStrategy(SnakeCase),
        Quill.DataSource.fromPrefix("db")).debug("Results").exitCode
      this.games(socketUsername(socket)).toString()
    }
  def plant(socket: WebSocketChannel): Boolean =
    {
      this.games(socketUsername(socket)).plant()
      true
    }
  def collect(socket: WebSocketChannel): Boolean =
    {
      this.games(socketUsername(socket)).collect()
      true
    }
  def matchEvent(socket: WebSocketChannel, event: SocketEvent): Boolean =
    {
      event match
        {
          case Connect(data) =>
            this.connected(data, socket)
          case Plant(data) =>
            this.plant(socket)
          case Collect(data) =>
            this.collect(socket)
          case Unknown(data) =>
            (((1.toString().toInt).+(1.toDouble.toInt).toInt).toInt.toString()).
              toInt
        }
      true
    }
}
error while checking package <empty> {
  import zio.http.*
  import zio.*
  import io.getquill.jdbczio.Quill
  import io.getquill.SnakeCase
  import javax.xml.crypto.Data
  module object App {
    var usernameSocket: scala.collection.mutable.Map[String, WebSocketChannel]
       = scala.collection.mutable.Map.empty
    var socketUsername: scala.collection.mutable.Map[WebSocketChannel, String]
       = scala.collection.mutable.Map.empty
    var games: scala.collection.mutable.Map[String, Game] =
      scala.collection.mutable.Map.empty
    def connected(username: String, socket: WebSocketChannel): Boolean =
      if (this.games contains username)
        {
          this.usernameSocket(username) = socket
          this.socketUsername(socket) = username
          true
        }
       else
        {
          this.games(username) = new Game(username)
          this.usernameSocket(username) = socket
          this.socketUsername(socket) = username
          DataService.addUser(new User(username, 0, null))
        }
    def getState(socket: WebSocketChannel): String =
      {
        DataService.getUsers.provide(DataService.live,
          Quill.Postgres.fromNamingStrategy(SnakeCase),
          Quill.DataSource.fromPrefix("db")).debug("Results").exitCode
        this.games(socketUsername(socket)).toString()
      }
    def plant(socket: WebSocketChannel): Boolean =
      {
        this.games(socketUsername(socket)).plant()
        true
      }
    def collect(socket: WebSocketChannel): Boolean =
      {
        this.games(socketUsername(socket)).collect()
        true
      }
    def matchEvent(socket: WebSocketChannel, event: SocketEvent): Boolean =
      {
        event match
          {
            case Connect(data) =>
              this.connected(data, socket)
            case Plant(data) =>
              this.plant(socket)
            case Collect(data) =>
              this.collect(socket)
            case Unknown(data) =>
              (((1.toString().toInt).+(1.toDouble.toInt).toInt).toInt.toString()
                ).toInt
          }
        true
      }
  }
}
ΰοπ. 07, 2024 11:03:01 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-07\r_compiler-error_(bestgame)_23-03-01-487.md
2024.04.07 23:03:02 INFO  compiling bestgame (1 scala source)
2024.04.07 23:03:02 INFO  time: compiled bestgame in 0.46s
ΰοπ. 07, 2024 11:11:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8465
ΰοπ. 07, 2024 11:12:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8466
2024.04.07 23:12:11 INFO  running 'C:\Program Files\Java\jdk-17\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals4860207363307745220\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.07 23:12:13 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 17.0.8)
2024.04.07 23:12:14 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.07 23:12:16 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.07 23:12:16 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.07 23:12:17 INFO  [info] loading project definition from D:\bestgame\project
2024.04.07 23:12:19 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.07 23:12:19 INFO  [success] Total time: 2 s, completed 7 Π°ΠΏΡ€. 2024 Π³., 23:12:19
2024.04.07 23:12:23 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.07 23:12:23 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.07 23:12:24 INFO  skipping build import with status 'Started'
2024.04.07 23:12:25 INFO  [success] Generated .bloop\bestgame-test.json
2024.04.07 23:12:25 INFO  [success] Generated .bloop\bestgame.json
2024.04.07 23:12:25 INFO  [success] Total time: 1 s, completed 7 Π°ΠΏΡ€. 2024 Π³., 23:12:25
2024.04.07 23:12:24 INFO  time: ran 'sbt bloopInstall' in 13s
2024.04.07 23:12:25 INFO  Disconnecting from Bloop session...
2024.04.07 23:12:25 INFO  Shut down connection with build server.
2024.04.07 23:12:25 INFO  Shut down connection with build server.
2024.04.07 23:12:25 INFO  Attempting to connect to the build server...
2024.04.07 23:12:25 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 23:12:25 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 23:12:25 INFO  Attempting to connect to the build server...
2024.04.07 23:12:25 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 23:12:25 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 23:12:25 INFO  time: Connected to build server in 0.5s
2024.04.07 23:12:25 INFO  Connected to Build server: Bloop v1.5.15
2024.04.07 23:12:29 INFO  time: indexed workspace in 3.71s
2024.04.07 23:12:30 INFO  compiling bestgame (5 scala sources)
2024.04.07 23:12:43 INFO  time: compiled bestgame in 12s
2024.04.07 23:12:43 INFO  time: code lens generation in 13s
ΰοπ. 07, 2024 11:17:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8538
2024.04.07 23:26:24 INFO  Shutting down server
2024.04.07 23:26:24 INFO  shutting down Metals
2024.04.07 23:26:24 INFO  Shut down connection with build server.
2024.04.07 23:26:25 INFO  Shut down connection with build server.
2024.04.07 23:26:24 INFO  Exiting server
2024.04.07 23:26:37 INFO  Started: Metals version 1.2.2 in folders 'D:\bestgame' for client Visual Studio Code 1.88.0.
23:26:37.596 [pool-1-thread-5] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
23:26:37.597 [pool-1-thread-5] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
23:26:37.597 [pool-1-thread-5] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
23:26:37.599 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
23:26:37.599 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@33909752 ...
23:26:37.599 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
23:26:37.599 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
23:26:37.599 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@33909752 ...
23:26:37.599 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/C:/Users/yidtdr/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
23:26:37.602 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
23:26:37.602 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
23:26:37.603 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
23:26:37.603 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
23:26:37.603 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
23:26:37.603 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
23:26:37.606 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
23:26:37.606 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
23:26:37.606 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
23:26:37.606 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
23:26:37.606 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
23:26:37.702 [pool-1-thread-5] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:D:\bestgame\.metals\metals (H2 2.2)
23:26:37.702 [pool-1-thread-5] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
23:26:37.702 [pool-1-thread-5] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
23:26:37.703 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
23:26:37.703 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
23:26:37.705 [pool-1-thread-5] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
23:26:37.706 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
23:26:37.707 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
23:26:37.710 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
23:26:37.713 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
23:26:37.717 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
23:26:37.717 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
23:26:37.717 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
23:26:37.717 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
23:26:37.717 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
23:26:37.717 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
23:26:37.717 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
23:26:37.717 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
23:26:37.718 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
23:26:37.718 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
23:26:37.725 [pool-1-thread-5] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.014s)
23:26:37.727 [pool-1-thread-5] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
23:26:37.730 [pool-1-thread-5] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
23:26:37.733 [pool-1-thread-5] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
23:26:37.740 [pool-1-thread-5] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 34 of 100M
2024.04.07 23:26:38 INFO  Attempting to connect to the build server...
2024.04.07 23:26:38 INFO  skipping build import with status 'Installed'
2024.04.07 23:26:38 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 23:26:38 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 23:26:38 INFO  Attempting to connect to the build server...
2024.04.07 23:26:38 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.07 23:26:38 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.07 23:26:38 INFO  time: Connected to build server in 0.74s
2024.04.07 23:26:38 INFO  Connected to Build server: Bloop v1.5.15
2024.04.07 23:26:38 INFO  time: Imported build in 0.18s
2024.04.07 23:26:48 INFO  time: indexed workspace in 9.4s
2024.04.07 23:27:49 INFO  time: code lens generation in 2.21s
2024.04.07 23:34:07 INFO  compiling bestgame (1 scala source)
2024.04.07 23:34:14 INFO  time: compiled bestgame in 7.33s
2024.04.07 23:36:36 INFO  compiling bestgame (1 scala source)
Π°ΠΏΡ€. 07, 2024 11:36:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 170
2024.04.07 23:36:41 INFO  time: compiled bestgame in 5.49s
2024.04.07 23:37:35 INFO  compiling bestgame (1 scala source)
2024.04.07 23:37:39 INFO  time: compiled bestgame in 3.8s
2024.04.07 23:38:35 INFO  compiling bestgame (1 scala source)
2024.04.07 23:38:35 INFO  time: compiled bestgame in 0.93s
2024.04.07 23:39:34 INFO  compiling bestgame (1 scala source)
2024.04.07 23:39:34 INFO  time: compiled bestgame in 0.92s
2024.04.07 23:41:02 INFO  compiling bestgame (1 scala source)
2024.04.07 23:41:02 INFO  time: compiled bestgame in 0.6s
2024.04.07 23:41:29 INFO  compiling bestgame (1 scala source)
2024.04.07 23:41:29 INFO  time: compiled bestgame in 0.67s
2024.04.07 23:41:38 INFO  compiling bestgame (1 scala source)
2024.04.07 23:41:38 INFO  time: compiled bestgame in 0.64s
2024.04.07 23:45:32 INFO  compiling bestgame (2 scala sources)
2024.04.07 23:45:33 INFO  time: compiled bestgame in 1.04s
2024.04.07 23:46:59 INFO  compiling bestgame (2 scala sources)
2024.04.07 23:46:59 INFO  time: compiled bestgame in 0.61s
2024.04.07 23:46:59 INFO  compiling bestgame (2 scala sources)
2024.04.07 23:47:00 INFO  time: compiled bestgame in 0.61s
2024.04.07 23:47:02 INFO  compiling bestgame (2 scala sources)
2024.04.07 23:47:06 INFO  time: compiled bestgame in 3.67s
Π°ΠΏΡ€. 07, 2024 11:49:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 665
2024.04.07 23:50:19 INFO  compiling bestgame (1 scala source)
2024.04.07 23:50:20 INFO  time: compiled bestgame in 1.4s
2024.04.07 23:50:31 INFO  compiling bestgame (1 scala source)
2024.04.07 23:50:33 INFO  time: compiled bestgame in 2.23s
2024.04.07 23:51:08 INFO  compiling bestgame (1 scala source)
2024.04.07 23:51:09 INFO  time: compiled bestgame in 1.21s
2024.04.07 23:51:21 INFO  compiling bestgame (1 scala source)
2024.04.07 23:51:21 INFO  time: compiled bestgame in 0.71s
Π°ΠΏΡ€. 07, 2024 11:51:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 916
Π°ΠΏΡ€. 07, 2024 11:51:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 918
2024.04.07 23:51:48 INFO  compiling bestgame (1 scala source)
2024.04.07 23:51:51 INFO  time: compiled bestgame in 2.33s
2024.04.07 23:53:01 INFO  compiling bestgame (1 scala source)
2024.04.07 23:53:01 INFO  time: compiled bestgame in 0.72s
2024.04.07 23:53:11 INFO  compiling bestgame (1 scala source)
2024.04.07 23:53:11 INFO  time: compiled bestgame in 0.15s
Π°ΠΏΡ€. 07, 2024 11:58:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1139
2024.04.08 00:01:40 INFO  compiling bestgame (1 scala source)
2024.04.08 00:01:42 INFO  time: compiled bestgame in 1.79s
2024.04.08 00:02:26 INFO  compiling bestgame (1 scala source)
2024.04.08 00:02:29 INFO  time: compiled bestgame in 2.11s
2024.04.08 00:03:54 INFO  compiling bestgame (1 scala source)
2024.04.08 00:03:54 INFO  time: compiled bestgame in 0.99s
2024.04.08 00:04:36 INFO  compiling bestgame (1 scala source)
2024.04.08 00:04:40 INFO  time: compiled bestgame in 3.99s
Π°ΠΏΡ€. 08, 2024 12:06:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1509
Π°ΠΏΡ€. 08, 2024 12:10:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1586
2024.04.08 00:10:17 INFO  compiling bestgame (1 scala source)
2024.04.08 00:10:20 INFO  time: compiled bestgame in 3.45s
2024.04.08 00:11:28 INFO  compiling bestgame (1 scala source)
2024.04.08 00:11:34 INFO  time: compiled bestgame in 6.12s
2024.04.08 00:14:09 INFO  compiling bestgame (1 scala source)
2024.04.08 00:14:11 INFO  time: compiled bestgame in 1.92s
2024.04.08 00:14:11 INFO  compiling bestgame (1 scala source)
2024.04.08 00:14:13 INFO  time: compiled bestgame in 1.36s
Π°ΠΏΡ€. 08, 2024 12:15:10 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1705
2024.04.08 00:15:43 INFO  compiling bestgame (1 scala source)
2024.04.08 00:15:45 INFO  time: compiled bestgame in 2.35s
Π°ΠΏΡ€. 08, 2024 12:16:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1816
Π°ΠΏΡ€. 08, 2024 12:17:19 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1830
2024.04.08 00:17:33 INFO  compiling bestgame (1 scala source)
2024.04.08 00:17:34 INFO  time: compiled bestgame in 1.07s
2024.04.08 00:17:36 INFO  compiling bestgame (1 scala source)
2024.04.08 00:17:37 INFO  time: compiled bestgame in 1.12s
2024.04.08 00:17:40 INFO  compiling bestgame (1 scala source)
2024.04.08 00:17:40 INFO  time: compiled bestgame in 0.4s
2024.04.08 00:19:13 INFO  compiling bestgame (1 scala source)
2024.04.08 00:19:17 INFO  time: compiled bestgame in 3.99s
2024.04.08 00:20:04 INFO  compiling bestgame (1 scala source)
2024.04.08 00:20:05 INFO  time: compiled bestgame in 1.16s
2024.04.08 21:58:00 INFO  Started: Metals version 1.2.2 in folders 'D:\bestgame' for client Visual Studio Code 1.88.0.
21:58:04.432 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
21:58:04.433 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
21:58:04.433 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
21:58:04.435 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
21:58:04.435 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@33909752 ...
21:58:04.435 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
21:58:04.435 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
21:58:04.435 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@33909752 ...
21:58:04.435 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/C:/Users/yidtdr/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
21:58:04.437 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
21:58:04.438 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
21:58:04.438 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
21:58:04.438 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
21:58:04.438 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
21:58:04.438 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
21:58:04.440 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
21:58:04.440 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
21:58:04.441 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
21:58:04.441 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
21:58:04.441 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
21:58:04.520 [pool-1-thread-1] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:D:\bestgame\.metals\metals (H2 2.2)
21:58:04.520 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
21:58:04.520 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
21:58:04.520 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
21:58:04.521 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
21:58:04.523 [pool-1-thread-1] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
21:58:04.524 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
21:58:04.524 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
21:58:04.528 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
21:58:04.530 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
21:58:04.534 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
21:58:04.534 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
21:58:04.534 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
21:58:04.534 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
21:58:04.534 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
21:58:04.535 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
21:58:04.535 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
21:58:04.535 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
21:58:04.535 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
21:58:04.535 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
21:58:04.541 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.013s)
21:58:04.543 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
21:58:04.546 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
21:58:04.549 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
21:58:04.560 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 35 of 100M
2024.04.08 21:58:05 INFO  Attempting to connect to the build server...
2024.04.08 21:58:05 INFO  skipping build import with status 'Installed'
2024.04.08 21:58:05 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.08 21:58:09 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.08 21:58:09 INFO  Attempting to connect to the build server...
2024.04.08 21:58:09 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.08 21:58:09 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.08 21:58:09 INFO  time: Connected to build server in 4.29s
2024.04.08 21:58:09 INFO  Connected to Build server: Bloop v1.5.15
2024.04.08 21:58:09 INFO  time: Imported build in 0.27s
2024.04.08 21:58:11 INFO  no build target found for D:\bestgame\src\main\scala\App.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.08 21:58:14 INFO  no build target found for D:\bestgame\src\main\scala\App.scala. Using presentation compiler with project's scala-library version: 3.3.1
Π°ΠΏΡ€. 08, 2024 9:58:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12
Π°ΠΏΡ€. 08, 2024 9:58:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14
Π°ΠΏΡ€. 08, 2024 9:58:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16
Π°ΠΏΡ€. 08, 2024 9:58:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 27
2024.04.08 21:58:15 INFO  time: indexed workspace in 3.33s
2024.04.08 21:58:16 INFO  compiling bestgame (1 scala source)
2024.04.08 21:58:23 WARN  Invalid text document uri received from build server: file:///D:/bestgame/src/main/scala/DataBaseManager.scala
2024.04.08 21:58:23 INFO  time: compiled bestgame in 7.57s
2024.04.08 21:58:23 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.2.2' (since 14.339s)
2024.04.08 21:58:23 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.2.2' (since 14.328s)
2024.04.08 21:58:24 INFO  {
  "jsonrpc": "2.0",
  "id": "12",
  "error": {
    "code": -32603,
    "message": "java.nio.file.NoSuchFileException: D:\\bestgame\\.bloop\\bestgame\\bloop-bsp-clients-classes\\classes-Metals-gLEgjcTAT8qBNgdsdWiaBw\u003d\u003d\\DataService$$anon$7.class\r\n\tat java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)\r\n\tat java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)\r\n\tat java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)\r\n\tat java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)\r\n\tat java.base/sun.nio.fs.AbstractFileSystemProvider.delete(AbstractFileSystemProvider.java:105)\r\n\tat java.base/java.nio.file.Files.delete(Files.java:1152)\r\n\tat bloop.Compiler$$anon$2.$anonfun$trigger$10(Compiler.scala:548)\r\n\tat bloop.Compiler$$anon$2.$anonfun$trigger$10$adapted(Compiler.scala:540)\r\n\tat scala.collection.mutable.HashSet.foreach(HashSet.scala:79)\r\n\tat bloop.Compiler$$anon$2.$anonfun$trigger$9(Compiler.scala:540)\r\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\r\n\tat monix.eval.internal.TaskRunLoop$.startFull(TaskRunLoop.scala:81)\r\n\tat monix.eval.internal.TaskRestartCallback.syncOnSuccess(TaskRestartCallback.scala:101)\r\n\tat monix.eval.internal.TaskRestartCallback.onSuccess(TaskRestartCallback.scala:74)\r\n\tat monix.eval.internal.TaskShift$Register$$anon$1.run(TaskShift.scala:65)\r\n\tat monix.execution.internal.InterceptRunnable.run(InterceptRunnable.scala:27)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)\r\n\tat java.base/java.lang.Thread.run(Thread.java:833)\r\n"
  }
}
2024.04.08 21:58:24 INFO  {
  "jsonrpc": "2.0",
  "id": "11",
  "error": {
    "code": -32603,
    "message": "java.nio.file.NoSuchFileException: D:\\bestgame\\.bloop\\bestgame\\bloop-bsp-clients-classes\\classes-Metals-gLEgjcTAT8qBNgdsdWiaBw\u003d\u003d\\DataService$$anon$2.class\r\n\tat java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)\r\n\tat java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)\r\n\tat java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)\r\n\tat java.base/sun.nio.fs.WindowsFileSystemProvider.implDelete(WindowsFileSystemProvider.java:275)\r\n\tat java.base/sun.nio.fs.AbstractFileSystemProvider.delete(AbstractFileSystemProvider.java:105)\r\n\tat java.base/java.nio.file.Files.delete(Files.java:1152)\r\n\tat bloop.Compiler$$anon$2.$anonfun$trigger$10(Compiler.scala:548)\r\n\tat bloop.Compiler$$anon$2.$anonfun$trigger$10$adapted(Compiler.scala:540)\r\n\tat scala.collection.mutable.HashSet.foreach(HashSet.scala:79)\r\n\tat bloop.Compiler$$anon$2.$anonfun$trigger$9(Compiler.scala:540)\r\n\tat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\r\n\tat monix.eval.internal.TaskRunLoop$.startFull(TaskRunLoop.scala:81)\r\n\tat monix.eval.internal.TaskRestartCallback.syncOnSuccess(TaskRestartCallback.scala:101)\r\n\tat monix.eval.internal.TaskRestartCallback.onSuccess(TaskRestartCallback.scala:74)\r\n\tat monix.eval.internal.TaskShift$Register$$anon$1.run(TaskShift.scala:65)\r\n\tat monix.execution.internal.InterceptRunnable.run(InterceptRunnable.scala:27)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)\r\n\tat java.base/java.lang.Thread.run(Thread.java:833)\r\n"
  }
}
2024.04.08 21:58:29 INFO  time: code lens generation in 2.44s
2024.04.08 21:58:34 INFO  running 'C:\Program Files\Java\jdk-22\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals16706770620258519500\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.08 21:58:36 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 22)
2024.04.08 21:58:36 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.08 21:58:38 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.08 21:58:39 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.08 21:58:39 INFO  [info] loading project definition from D:\bestgame\project
2024.04.08 21:58:43 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.08 21:58:43 INFO  [success] Total time: 3 s, completed 8 Π°ΠΏΡ€. 2024β€―Π³., 21:58:43
2024.04.08 21:58:43 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.08 21:58:43 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.08 21:58:46 INFO  [success] Generated .bloop\bestgame.json
2024.04.08 21:58:46 INFO  [success] Generated .bloop\bestgame-test.json
2024.04.08 21:58:46 INFO  [success] Total time: 2 s, completed 8 Π°ΠΏΡ€. 2024β€―Π³., 21:58:46
2024.04.08 21:58:46 INFO  time: ran 'sbt bloopInstall' in 12s
2024.04.08 21:58:46 INFO  Disconnecting from Bloop session...
2024.04.08 21:58:46 INFO  Shut down connection with build server.
2024.04.08 21:58:46 INFO  Shut down connection with build server.
2024.04.08 21:58:46 INFO  Attempting to connect to the build server...
2024.04.08 21:58:46 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.08 21:58:46 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.08 21:58:46 INFO  Attempting to connect to the build server...
2024.04.08 21:58:46 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.08 21:58:46 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.08 21:58:46 INFO  time: Connected to build server in 0.14s
2024.04.08 21:58:46 INFO  Connected to Build server: Bloop v1.5.15
2024.04.08 21:58:48 INFO  time: indexed workspace in 2.16s
2024.04.08 21:58:52 INFO  time: code lens generation in 1.77s
2024.04.08 21:58:52 INFO  time: code lens generation in 3.05s
2024.04.08 22:03:43 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.2.2' (since 4m 56.595s)
2024.04.08 22:03:49 INFO  running 'C:\Program Files\Java\jdk-22\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals14740002133275154392\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.08 22:03:51 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 22)
2024.04.08 22:03:51 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.08 22:03:52 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.08 22:03:52 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.08 22:03:53 INFO  [info] loading project definition from D:\bestgame\project
2024.04.08 22:03:56 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.08 22:03:56 INFO  [success] Total time: 2 s, completed 8 Π°ΠΏΡ€. 2024β€―Π³., 22:03:56
2024.04.08 22:03:59 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.08 22:03:59 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.08 22:04:02 INFO  [success] Generated .bloop\bestgame.json
2024.04.08 22:04:02 INFO  [success] Generated .bloop\bestgame-test.json
2024.04.08 22:04:02 INFO  [success] Total time: 3 s, completed 8 Π°ΠΏΡ€. 2024β€―Π³., 22:04:02
2024.04.08 22:04:02 INFO  time: ran 'sbt bloopInstall' in 13s
2024.04.08 22:04:02 INFO  Disconnecting from Bloop session...
2024.04.08 22:04:02 INFO  Shut down connection with build server.
2024.04.08 22:04:02 INFO  Shut down connection with build server.
2024.04.08 22:04:02 INFO  Attempting to connect to the build server...
2024.04.08 22:04:02 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.08 22:04:02 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.08 22:04:02 INFO  Attempting to connect to the build server...
2024.04.08 22:04:02 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.08 22:04:02 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.08 22:04:02 INFO  time: Connected to build server in 0.12s
2024.04.08 22:04:02 INFO  Connected to Build server: Bloop v1.5.15
2024.04.08 22:04:05 INFO  time: indexed workspace in 2.24s
2024.04.08 22:04:09 INFO  time: code lens generation in 3.9s
2024.04.08 22:08:32 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.2.2' (since 4m 29.312s)
Π°ΠΏΡ€. 08, 2024 10:24:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 127
2024.04.08 22:27:11 INFO  running 'C:\Program Files\Java\jdk-22\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals10628868294332195864\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.08 22:27:12 INFO  sbt thinks that server is already booting because of this exception:
2024.04.08 22:27:12 ERROR sbt.internal.ServerAlreadyBootingException: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-1466779760368203317_lock, error 5
2024.04.08 22:27:12 INFO  Create a new server? y/n (default y)
2024.04.08 22:27:12 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:357)
2024.04.08 22:27:12 ERROR 	at sbt.internal.BootServerSocket.<init>(BootServerSocket.java:296)
2024.04.08 22:27:12 ERROR 	at sbt.xMain$.getSocketOrExit(Main.scala:152)
2024.04.08 22:27:12 ERROR 	at sbt.xMain$.bootServerSocket$lzycompute$1(Main.scala:78)
2024.04.08 22:27:12 ERROR 	at sbt.xMain$.bootServerSocket$1(Main.scala:78)
2024.04.08 22:27:12 ERROR 	at sbt.xMain$.withStreams$1(Main.scala:86)
2024.04.08 22:27:12 ERROR 	at sbt.xMain$.run(Main.scala:123)
2024.04.08 22:27:12 ERROR 	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
2024.04.08 22:27:12 ERROR 	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
2024.04.08 22:27:12 ERROR 	at sbt.internal.XMainConfiguration.run(XMainConfiguration.java:59)
2024.04.08 22:27:12 ERROR 	at sbt.xMain.run(Main.scala:47)
2024.04.08 22:27:12 ERROR 	at xsbt.boot.Launch$.$anonfun$run$1(Launch.scala:149)
2024.04.08 22:27:12 ERROR 	at xsbt.boot.Launch$.withContextLoader(Launch.scala:176)
2024.04.08 22:27:12 ERROR 	at xsbt.boot.Launch$.run(Launch.scala:149)
2024.04.08 22:27:12 ERROR 	at xsbt.boot.Launch$.$anonfun$apply$1(Launch.scala:44)
2024.04.08 22:27:12 ERROR 	at xsbt.boot.Launch$.launch(Launch.scala:159)
2024.04.08 22:27:12 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:44)
2024.04.08 22:27:12 ERROR 	at xsbt.boot.Launch$.apply(Launch.scala:21)
2024.04.08 22:27:12 ERROR 	at xsbt.boot.Boot$.runImpl(Boot.scala:78)
2024.04.08 22:27:12 ERROR 	at xsbt.boot.Boot$.run(Boot.scala:73)
2024.04.08 22:27:12 ERROR 	at xsbt.boot.Boot$.main(Boot.scala:21)
2024.04.08 22:27:12 ERROR 	at xsbt.boot.Boot.main(Boot.scala)
2024.04.08 22:27:12 ERROR Caused by: java.io.IOException: Could not create lock for \\.\pipe\sbt-load-1466779760368203317_lock, error 5
2024.04.08 22:27:12 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:129)
2024.04.08 22:27:12 ERROR 	at org.scalasbt.ipcsocket.Win32NamedPipeServerSocket.<init>(Win32NamedPipeServerSocket.java:48)
2024.04.08 22:27:12 ERROR 	at sbt.internal.BootServerSocket.newSocket(BootServerSocket.java:351)
2024.04.08 22:27:12 ERROR 	... 21 more
2024.04.08 22:27:12 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 22)
2024.04.08 22:27:12 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.08 22:27:13 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.08 22:27:13 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.08 22:27:13 INFO  [info] loading project definition from D:\bestgame\project
2024.04.08 22:27:17 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.08 22:27:17 INFO  [success] Total time: 3 s, completed 8 Π°ΠΏΡ€. 2024β€―Π³., 22:27:17
2024.04.08 22:27:19 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.08 22:27:19 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.08 22:27:22 INFO  [success] Generated .bloop\bestgame.json
2024.04.08 22:27:22 INFO  [success] Generated .bloop\bestgame-test.json
2024.04.08 22:27:22 INFO  [success] Total time: 2 s, completed 8 Π°ΠΏΡ€. 2024β€―Π³., 22:27:22
2024.04.08 22:27:22 INFO  time: ran 'sbt bloopInstall' in 10s
2024.04.08 22:27:22 INFO  Disconnecting from Bloop session...
2024.04.08 22:27:22 INFO  Shut down connection with build server.
2024.04.08 22:27:22 INFO  Shut down connection with build server.
2024.04.08 22:27:22 INFO  Attempting to connect to the build server...
2024.04.08 22:27:22 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.08 22:27:22 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.08 22:27:22 INFO  Attempting to connect to the build server...
2024.04.08 22:27:22 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.08 22:27:22 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.08 22:27:22 INFO  time: Connected to build server in 0.17s
2024.04.08 22:27:22 INFO  Connected to Build server: Bloop v1.5.15
2024.04.08 22:27:23 INFO  time: indexed workspace in 1.52s
2024.04.08 22:27:23 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.2.2' (since 23m 20.955s)
2024.04.08 22:27:28 INFO  time: code lens generation in 4.46s
2024.04.08 22:29:53 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.2.2' (since 25m 50.923s)
2024.04.08 22:29:53 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.2.2' (since 25m 51.643s)
Π°ΠΏΡ€. 08, 2024 10:30:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 208
Π°ΠΏΡ€. 08, 2024 10:32:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 301
2024.04.08 22:32:16 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.2.2' (since 4m 53.675s)
Π°ΠΏΡ€. 08, 2024 10:32:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 317
2024.04.08 22:33:45 WARN  Using indexes to guess the definition of run
2024.04.08 22:33:46 WARN  Using indexes to guess the definition of run
2024.04.08 22:35:55 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.2.2' (since 31m 52.081s)
2024.04.08 22:49:36 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.2.2' (since 45m 33.191s)
2024.04.08 23:27:28 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.2.2' (since 1h 23m 25.096s)
2024.04.08 23:29:59 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.2.2' (since 1h 25m 56.774s)
2024.04.08 23:32:59 WARN  Using indexes to guess the definition of User
Π°ΠΏΡ€. 08, 2024 11:34:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 610
2024.04.08 23:34:26 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.2.2' (since 1h 7m 3.877s)
2024.04.08 23:34:56 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.2.2' (since 1h 7m 33.65s)
2024.04.08 23:44:51 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.2.2' (since 1h 17m 29.512s)
java.lang.AssertionError: assertion failed while typechecking /zio/ZIO.scala
Π°ΠΏΡ€. 08, 2024 11:45:06 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-08\r_compiler-error_(bestgame)_23-45-06-080.md
Π°ΠΏΡ€. 08, 2024 11:45:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1110
Π°ΠΏΡ€. 08, 2024 11:45:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1146
Π°ΠΏΡ€. 08, 2024 11:46:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1432
2024.04.08 23:48:25 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.2.2' (since 1h 21m 2.695s)
2024.04.08 23:49:19 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.2.2' (since 1h 21m 56.984s)
Π°ΠΏΡ€. 08, 2024 11:49:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1695
Π°ΠΏΡ€. 08, 2024 11:52:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1803
2024.04.08 23:55:05 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.2.2' (since 1h 27m 43.352s)
2024.04.09 00:05:10 INFO  Shutting down server
2024.04.09 00:05:10 INFO  shutting down Metals
2024.04.09 00:05:10 INFO  Shut down connection with build server.
2024.04.09 00:05:10 INFO  Shut down connection with build server.
2024.04.09 00:05:10 INFO  Exiting server
2024.04.09 14:03:04 INFO  Started: Metals version 1.2.2 in folders 'D:\bestgame' for client Visual Studio Code 1.88.0.
14:03:05.214 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
14:03:05.217 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
14:03:05.217 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
14:03:05.221 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
14:03:05.221 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@33909752 ...
14:03:05.221 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
14:03:05.221 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
14:03:05.221 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@33909752 ...
14:03:05.221 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/C:/Users/yidtdr/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
14:03:05.225 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
14:03:05.225 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
14:03:05.225 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
14:03:05.225 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
14:03:05.225 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
14:03:05.225 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
14:03:05.229 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
14:03:05.229 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
14:03:05.229 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
14:03:05.229 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
14:03:05.229 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
14:03:05.325 [pool-1-thread-1] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:D:\bestgame\.metals\metals (H2 2.2)
14:03:05.329 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
14:03:05.329 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
14:03:05.329 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
14:03:05.329 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
14:03:05.333 [pool-1-thread-1] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
14:03:05.337 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
14:03:05.337 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
14:03:05.341 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
14:03:05.345 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
14:03:05.349 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
14:03:05.349 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
14:03:05.349 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
14:03:05.349 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
14:03:05.349 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
14:03:05.349 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
14:03:05.349 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
14:03:05.349 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
14:03:05.349 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
14:03:05.349 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
14:03:05.365 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.021s)
14:03:05.365 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
14:03:05.373 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
14:03:05.377 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
14:03:05.385 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 36 of 100M
Π°ΠΏΡ€. 09, 2024 2:03:06 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
Π°ΠΏΡ€. 09, 2024 2:03:06 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
2024.04.09 14:03:07 INFO  Attempting to connect to the build server...
2024.04.09 14:03:07 INFO  skipping build import with status 'Installed'
2024.04.09 14:03:07 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.09 14:03:13 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.09 14:03:13 INFO  Attempting to connect to the build server...
2024.04.09 14:03:13 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.09 14:03:13 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.09 14:03:13 INFO  time: Connected to build server in 7.18s
2024.04.09 14:03:14 INFO  Connected to Build server: Bloop v1.5.15
2024.04.09 14:03:14 INFO  time: Imported build in 0.22s
2024.04.09 14:03:17 INFO  no build target found for D:\bestgame\src\main\scala\App.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.09 14:03:21 INFO  time: indexed workspace in 3.26s
2024.04.09 14:14:59 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 14:14:59 INFO  compiling bestgame (5 scala sources)
2024.04.09 14:15:14 INFO  time: compiled bestgame in 15s
2024.04.09 20:49:39 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.09 20:49:39 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.09 20:49:40 INFO  Connected to Build server: Bloop v1.5.15
2024.04.09 20:49:40 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.09 20:49:40 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
Π°ΠΏΡ€. 09, 2024 10:31:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 44
2024.04.09 22:31:38 INFO  time: code lens generation in 3.22s
Π°ΠΏΡ€. 09, 2024 10:31:53 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-09\r_compiler-error_(bestgame-build)_22-31-53-765.md
2024.04.09 22:31:57 INFO  running 'C:\Program Files\Java\jdk-22\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals14347167243900071477\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.09 22:31:59 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 22)
2024.04.09 22:31:59 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.09 22:32:00 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.09 22:32:01 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.09 22:32:01 INFO  [info] loading project definition from D:\bestgame\project
2024.04.09 22:32:04 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.09 22:32:04 INFO  [success] Total time: 2 s, completed 9 Π°ΠΏΡ€. 2024β€―Π³., 22:32:04
2024.04.09 22:32:06 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.09 22:32:06 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.09 22:32:09 INFO  [success] Generated .bloop\bestgame.json
2024.04.09 22:32:09 INFO  [success] Generated .bloop\bestgame-test.json
2024.04.09 22:32:09 INFO  [success] Total time: 2 s, completed 9 Π°ΠΏΡ€. 2024β€―Π³., 22:32:09
2024.04.09 22:32:09 INFO  time: ran 'sbt bloopInstall' in 11s
2024.04.09 22:32:09 INFO  Disconnecting from Bloop session...
2024.04.09 22:32:09 INFO  Shut down connection with build server.
2024.04.09 22:32:09 INFO  Shut down connection with build server.
Π°ΠΏΡ€. 09, 2024 10:32:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint notify
INFO: Failed to send notification message.
org.eclipse.lsp4j.jsonrpc.JsonRpcException: java.nio.channels.ClosedChannelException
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:72)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.notify(RemoteEndpoint.java:126)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.sendCancelNotification(RemoteEndpoint.java:180)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint$1.cancel(RemoteEndpoint.java:150)
	at scala.meta.internal.metals.utils.RequestRegistry.$anonfun$register$5(RequestRegistry.scala:78)
	at scala.runtime.java8.JFunction0$mcZ$sp.apply(JFunction0$mcZ$sp.scala:17)
	at scala.util.Try$.apply(Try.scala:210)
	at scala.meta.internal.metals.utils.RequestRegistry.$anonfun$register$4(RequestRegistry.scala:78)
	at scala.meta.internal.metals.Cancelable$$anon$1.cancel(Cancelable.scala:18)
	at scala.meta.internal.metals.Cancelable$.$anonfun$cancelAll$1(Cancelable.scala:29)
	at scala.collection.immutable.List.foreach(List.scala:333)
	at scala.meta.internal.metals.Cancelable$.cancelAll(Cancelable.scala:28)
	at scala.meta.internal.metals.MutableCancelable.cancel(MutableCancelable.scala:25)
	at scala.meta.internal.metals.utils.RequestRegistry.cancel(RequestRegistry.scala:94)
	at scala.meta.internal.metals.BuildServerConnection.cancel(BuildServerConnection.scala:396)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$shutdown$1(BuildServerConnection.scala:171)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$shutdown$1$adapted(BuildServerConnection.scala:163)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.nio.channels.ClosedChannelException
	at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:224)
	at java.base/sun.nio.ch.SocketChannelImpl.implWrite(SocketChannelImpl.java:560)
	at java.base/sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:618)
	at java.base/sun.nio.ch.SinkChannelImpl.write(SinkChannelImpl.java:124)
	at java.base/sun.nio.ch.ChannelOutputStream.writeFully(ChannelOutputStream.java:68)
	at java.base/sun.nio.ch.ChannelOutputStream.write(ChannelOutputStream.java:102)
	at java.base/java.io.OutputStream.write(OutputStream.java:124)
	at java.base/sun.nio.ch.ChannelOutputStream.write(ChannelOutputStream.java:79)
	at scala.meta.internal.metals.ClosableOutputStream.write(ClosableOutputStream.scala:26)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:139)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:110)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:67)
	... 20 more

Π°ΠΏΡ€. 09, 2024 10:32:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint notify
INFO: Failed to send notification message.
org.eclipse.lsp4j.jsonrpc.JsonRpcException: java.nio.channels.ClosedChannelException
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:72)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.notify(RemoteEndpoint.java:126)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.sendCancelNotification(RemoteEndpoint.java:180)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint$1.cancel(RemoteEndpoint.java:150)
	at scala.meta.internal.metals.utils.FutureWithTimeout$$anon$1.$anonfun$cancel$1(FutureWithTimeout.scala:37)
	at scala.runtime.java8.JFunction0$mcZ$sp.apply(JFunction0$mcZ$sp.scala:17)
	at scala.util.Try$.apply(Try.scala:210)
	at scala.meta.internal.metals.utils.FutureWithTimeout$$anon$1.cancel(FutureWithTimeout.scala:37)
	at scala.meta.internal.metals.Cancelable$.$anonfun$cancelAll$1(Cancelable.scala:29)
	at scala.collection.immutable.List.foreach(List.scala:333)
	at scala.meta.internal.metals.Cancelable$.cancelAll(Cancelable.scala:28)
	at scala.meta.internal.metals.MutableCancelable.cancel(MutableCancelable.scala:25)
	at scala.meta.internal.metals.utils.RequestRegistry.cancel(RequestRegistry.scala:94)
	at scala.meta.internal.metals.BuildServerConnection.cancel(BuildServerConnection.scala:396)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$shutdown$1(BuildServerConnection.scala:171)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$shutdown$1$adapted(BuildServerConnection.scala:163)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.nio.channels.ClosedChannelException
	at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:224)
	at java.base/sun.nio.ch.SocketChannelImpl.implWrite(SocketChannelImpl.java:560)
	at java.base/sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:618)
	at java.base/sun.nio.ch.SinkChannelImpl.write(SinkChannelImpl.java:124)
	at java.base/sun.nio.ch.ChannelOutputStream.writeFully(ChannelOutputStream.java:68)
	at java.base/sun.nio.ch.ChannelOutputStream.write(ChannelOutputStream.java:102)
	at java.base/java.io.OutputStream.write(OutputStream.java:124)
	at java.base/sun.nio.ch.ChannelOutputStream.write(ChannelOutputStream.java:79)
	at scala.meta.internal.metals.ClosableOutputStream.write(ClosableOutputStream.scala:26)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:139)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:110)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:67)
	... 20 more

2024.04.09 22:32:09 INFO  Failed to run request with params WorkspaceBuildTargetsResult
2024.04.09 22:32:09 INFO  Cancelling compilation on Bloop server
2024.04.09 22:32:09 INFO  Attempting to connect to the build server...
2024.04.09 22:32:09 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.09 22:32:09 WARN  Could not find semantic tokens for: file:///D:/bestgame/build.sbt
2024.04.09 22:32:09 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.09 22:32:09 INFO  Attempting to connect to the build server...
2024.04.09 22:32:09 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.09 22:32:09 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.09 22:32:09 INFO  time: Connected to build server in 0.2s
2024.04.09 22:32:09 INFO  Connected to Build server: Bloop v1.5.15
2024.04.09 22:32:11 INFO  time: indexed workspace in 2.22s
2024.04.09 22:32:11 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 22:32:11 INFO  compiling bestgame (5 scala sources)
2024.04.09 22:32:16 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.2.2' (since 7.086s)
2024.04.09 22:32:16 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 22:32:16 INFO  compiling bestgame (5 scala sources)
2024.04.09 22:32:18 INFO  time: code lens generation in 6.32s
2024.04.09 22:32:20 INFO  time: compiled bestgame in 3.93s
2024.04.09 22:32:20 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 22:32:20 INFO  compiling bestgame (5 scala sources)
2024.04.09 22:32:23 INFO  time: compiled bestgame in 2.25s
2024.04.09 22:32:25 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 22:32:25 INFO  compiling bestgame (5 scala sources)
2024.04.09 22:32:28 INFO  time: compiled bestgame in 2.34s
2024.04.09 22:32:32 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 22:32:32 INFO  compiling bestgame (5 scala sources)
2024.04.09 22:32:33 INFO  time: compiled bestgame in 1.03s
2024.04.09 22:32:41 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 22:32:41 INFO  compiling bestgame (5 scala sources)
2024.04.09 22:32:45 INFO  time: compiled bestgame in 3.42s
2024.04.09 22:33:14 INFO  file:///D:/bestgame/src/main/scala/DataBaseManager.scala:2:8: stale bloop error: value getquill is not a member of io
import io.getquill._
       ^^^^^^^^^^^
2024.04.09 22:33:14 INFO  file:///D:/bestgame/src/main/scala/DataBaseManager.scala:12:19: stale bloop error: DataService.this.quill.ZIO does not take type parameters
    def getUsers: ZIO[Any, SQLException, List[Player]] = run(query[Player])
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2024.04.09 22:33:14 INFO  file:///D:/bestgame/src/main/scala/DataBaseManager.scala:13:38: stale bloop error: DataService.this.quill.ZIO does not take type parameters
    def getUserByName(name: String): ZIO[Any, SQLException, List[Player]] = run(query[Player].filter(_.name == lift(name)))
                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2024.04.09 22:33:14 INFO  file:///D:/bestgame/src/main/scala/DataBaseManager.scala:14:35: stale bloop error: DataService.this.quill.ZIO does not take type parameters
    def addUser(newuser: Player): ZIO[Any, SQLException, Long] =
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2024.04.09 22:33:14 INFO  file:///D:/bestgame/src/main/scala/DataBaseManager.scala:18:35: stale bloop error: DataService.this.quill.ZIO does not take type parameters
    def updateUser(user: Player): ZIO[Any, SQLException, Long] =
                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
2024.04.09 22:33:14 WARN  Could not find semantic tokens for: file:///D:/bestgame/src/main/scala/DataBaseManager.scala
2024.04.09 22:33:14 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 22:33:14 INFO  compiling bestgame (5 scala sources)
2024.04.09 22:33:14 INFO  time: compiled bestgame in 0.26s
2024.04.09 22:33:14 WARN  Could not find semantic tokens for: file:///D:/bestgame/src/main/scala/DataBaseManager.scala
2024.04.09 22:33:18 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 22:33:18 INFO  compiling bestgame (5 scala sources)
2024.04.09 22:33:20 INFO  time: compiled bestgame in 1.14s
2024.04.09 22:52:15 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 22:52:15 INFO  compiling bestgame (1 scala source)
2024.04.09 22:52:16 INFO  time: compiled bestgame in 1.61s
2024.04.09 22:59:31 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 22:59:31 INFO  compiling bestgame (1 scala source)
2024.04.09 22:59:33 INFO  time: compiled bestgame in 1.62s
2024.04.09 23:08:36 WARN  Could not find semantic tokens for: file:///D:/bestgame/src/main/scala/DataBaseManager.scala
2024.04.09 23:08:37 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:08:37 INFO  compiling bestgame (1 scala source)
2024.04.09 23:08:39 INFO  time: compiled bestgame in 1.98s
2024.04.09 23:14:18 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:14:18 INFO  compiling bestgame (1 scala source)
2024.04.09 23:14:18 INFO  time: compiled bestgame in 0.96s
2024.04.09 23:16:08 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\DataBaseManager.scala
scala.meta.tokenizers.TokenizeException: <input>:37: error: unclosed string interpolation
          println(s"[ERROR] Occured while finding player $")
                    ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.09 23:16:11 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:16:11 INFO  compiling bestgame (1 scala source)
2024.04.09 23:16:11 INFO  time: compiled bestgame in 0.65s
2024.04.09 23:16:46 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:16:46 INFO  compiling bestgame (1 scala source)
2024.04.09 23:16:46 INFO  time: compiled bestgame in 0.57s
2024.04.09 23:16:54 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:16:54 INFO  compiling bestgame (1 scala source)
2024.04.09 23:16:54 INFO  time: compiled bestgame in 0.37s
2024.04.09 23:16:58 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:16:58 INFO  compiling bestgame (1 scala source)
2024.04.09 23:16:58 INFO  time: compiled bestgame in 0.36s
Π°ΠΏΡ€. 09, 2024 11:17:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1342
2024.04.09 23:18:00 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:18:00 INFO  compiling bestgame (1 scala source)
2024.04.09 23:18:00 INFO  time: compiled bestgame in 0.32s
2024.04.09 23:18:05 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:18:05 INFO  compiling bestgame (1 scala source)
2024.04.09 23:18:05 INFO  time: compiled bestgame in 0.31s
2024.04.09 23:18:18 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:18:18 INFO  compiling bestgame (1 scala source)
2024.04.09 23:18:18 INFO  time: compiled bestgame in 0.3s
2024.04.09 23:18:23 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:18:23 INFO  compiling bestgame (1 scala source)
2024.04.09 23:18:23 INFO  time: compiled bestgame in 93ms
2024.04.09 23:18:30 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:18:30 INFO  compiling bestgame (1 scala source)
2024.04.09 23:18:30 INFO  time: compiled bestgame in 0.28s
2024.04.09 23:19:11 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:19:11 INFO  compiling bestgame (1 scala source)
2024.04.09 23:19:11 INFO  time: compiled bestgame in 0.43s
Π°ΠΏΡ€. 09, 2024 11:19:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1670
2024.04.09 23:21:47 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:21:47 INFO  compiling bestgame (1 scala source)
2024.04.09 23:21:47 INFO  time: compiled bestgame in 0.39s
2024.04.09 23:21:57 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:21:57 INFO  compiling bestgame (1 scala source)
2024.04.09 23:21:57 INFO  time: compiled bestgame in 0.22s
2024.04.09 23:22:14 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:22:14 INFO  compiling bestgame (1 scala source)
2024.04.09 23:22:14 INFO  time: compiled bestgame in 0.11s
2024.04.09 23:22:15 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.09 23:22:24 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.09 23:22:25 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:22:25 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.09 23:22:25 INFO  compiling bestgame (1 scala source)
2024.04.09 23:22:25 INFO  time: compiled bestgame in 0.22s
Π°ΠΏΡ€. 09, 2024 11:22:39 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-09\r_compiler-error_(bestgame)_23-22-39-774.md
2024.04.09 23:22:41 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:22:41 INFO  compiling bestgame (1 scala source)
2024.04.09 23:22:41 INFO  time: compiled bestgame in 0.13s
2024.04.09 23:22:47 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:22:47 INFO  compiling bestgame (1 scala source)
2024.04.09 23:22:47 INFO  time: compiled bestgame in 0.36s
2024.04.09 23:23:11 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:23:11 INFO  compiling bestgame (1 scala source)
2024.04.09 23:23:11 INFO  time: compiled bestgame in 0.38s
Π°ΠΏΡ€. 09, 2024 11:23:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2117
2024.04.09 23:24:32 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:24:32 INFO  compiling bestgame (1 scala source)
2024.04.09 23:24:32 INFO  time: compiled bestgame in 0.42s
Π°ΠΏΡ€. 09, 2024 11:24:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2371
2024.04.09 23:24:42 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:24:42 INFO  compiling bestgame (1 scala source)
2024.04.09 23:24:42 INFO  time: compiled bestgame in 0.36s
Π°ΠΏΡ€. 09, 2024 11:25:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2481
2024.04.09 23:25:47 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:25:47 INFO  compiling bestgame (1 scala source)
2024.04.09 23:25:47 INFO  time: compiled bestgame in 0.32s
2024.04.09 23:26:06 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\DataBaseManager.scala
scala.meta.tokenizers.TokenizeException: <input>:43: error: `$$', `$'ident, `$'this, `$'BlockExpr`$'_
          println(s"[ERROR] Occured while trying to INSERT player($)")
                    ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:649)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.09 23:26:12 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\DataBaseManager.scala
scala.meta.tokenizers.TokenizeException: <input>:43: error: `$$', `$'ident, `$'this, `$'BlockExpr`$'_
          println(s"[ERROR] Occured while trying to INSERT player(${player.name}, $[])")
                                                                                ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:649)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:249)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.09 23:26:20 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\DataBaseManager.scala
scala.meta.tokenizers.TokenizeException: <input>:43: error: `$$', `$'ident, `$'this, `$'BlockExpr`$'_
          println(s"[ERROR] Occured while trying to INSERT player(${player.name}, ${player.money}, $)")
                                                                                                 ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:649)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:249)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.09 23:26:26 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:26:26 INFO  compiling bestgame (1 scala source)
2024.04.09 23:26:26 INFO  time: compiled bestgame in 0.29s
2024.04.09 23:26:34 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:26:34 INFO  compiling bestgame (1 scala source)
2024.04.09 23:26:34 INFO  time: compiled bestgame in 0.25s
2024.04.09 23:26:50 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:26:50 INFO  compiling bestgame (1 scala source)
2024.04.09 23:26:50 INFO  time: compiled bestgame in 0.27s
2024.04.09 23:27:55 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:27:55 INFO  compiling bestgame (1 scala source)
2024.04.09 23:27:55 INFO  time: compiled bestgame in 0.1s
2024.04.09 23:27:56 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:27:56 INFO  compiling bestgame (1 scala source)
2024.04.09 23:27:56 INFO  time: compiled bestgame in 0.24s
2024.04.09 23:28:01 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:28:01 INFO  compiling bestgame (1 scala source)
2024.04.09 23:28:01 INFO  time: compiled bestgame in 0.19s
Π°ΠΏΡ€. 09, 2024 11:28:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3014
2024.04.09 23:28:47 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\DataBaseManager.scala
scala.meta.tokenizers.TokenizeException: <input>:37: error: `$$', `$'ident, `$'this, `$'BlockExpr`$'_
        val a: Int = sql"INSERT INTO player (name, money, planted) VALUES ('$', 10, true)".update.apply()
                         ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:649)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.09 23:28:47 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\DataBaseManager.scala
scala.meta.tokenizers.TokenizeException: <input>:37: error: `$$', `$'ident, `$'this, `$'BlockExpr`$'_
        val a: Int = sql"INSERT INTO player (name, money, planted) VALUES ('$', 10, true)".update.apply()
                         ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:649)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

Π°ΠΏΡ€. 09, 2024 11:29:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3135
2024.04.09 23:29:13 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\DataBaseManager.scala
scala.meta.tokenizers.TokenizeException: <input>:37: error: `$$', `$'ident, `$'this, `$'BlockExpr`$'_
        val a: Int = sql"INSERT INTO player (name, money, planted) VALUES ('${player.name}', ${player.money}, $)".update.apply()
                                                                                                            ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:649)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:249)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.09 23:29:17 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:29:17 INFO  compiling bestgame (1 scala source)
2024.04.09 23:29:17 INFO  time: compiled bestgame in 0.19s
2024.04.09 23:29:38 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:29:38 INFO  compiling bestgame (1 scala source)
2024.04.09 23:29:38 INFO  time: compiled bestgame in 0.2s
2024.04.09 23:29:59 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:29:59 INFO  compiling bestgame (1 scala source)
2024.04.09 23:29:59 INFO  time: compiled bestgame in 0.13s
2024.04.09 23:30:15 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:30:15 INFO  compiling bestgame (1 scala source)
2024.04.09 23:30:15 INFO  time: compiled bestgame in 94ms
2024.04.09 23:30:47 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:30:47 INFO  compiling bestgame (1 scala source)
2024.04.09 23:30:47 INFO  time: compiled bestgame in 0.45s
2024.04.09 23:31:05 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:31:05 INFO  compiling bestgame (1 scala source)
2024.04.09 23:31:05 INFO  time: compiled bestgame in 97ms
2024.04.09 23:32:10 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\DataBaseManager.scala
scala.meta.tokenizers.TokenizeException: <input>:19: error: unclosed string interpolation
          sql"SELECT * 
              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.09 23:32:17 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\DataBaseManager.scala
scala.meta.tokenizers.TokenizeException: <input>:65: error: unclosed multi-line string interpolation
            println(s"[ERROR] Occured while trying to INSERT player(${player.name}, ${player.money}, ${player.planted})")
                                                                                                                      ^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:657)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:249)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.09 23:33:10 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\DataBaseManager.scala
scala.meta.tokenizers.TokenizeException: <input>:19: error: `$$', `$'ident, `$'this, `$'BlockExpr`$'_
          sql"""SELECT * FROM player WHERE name='$}'"""
                ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:649)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:347)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.09 23:33:11 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:33:11 INFO  compiling bestgame (1 scala source)
2024.04.09 23:33:11 INFO  time: compiled bestgame in 0.15s
2024.04.09 23:33:22 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:33:22 INFO  compiling bestgame (1 scala source)
2024.04.09 23:33:22 INFO  time: compiled bestgame in 0.21s
2024.04.09 23:33:29 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\DataBaseManager.scala
scala.meta.tokenizers.TokenizeException: <input>:66: error: unclosed multi-line string interpolation
            println(s"[ERROR] Occured while trying to INSERT player(${player.name}, ${player.money}, ${player.planted})")
                                                                                                                      ^
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:27)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:26)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter.incompleteInputError$(Reporter.scala:29)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.incompleteInputError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:657)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:249)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.09 23:36:20 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:36:20 INFO  compiling bestgame (1 scala source)
2024.04.09 23:36:22 INFO  time: compiled bestgame in 1.3s
2024.04.09 23:39:59 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:39:59 INFO  compiling bestgame (1 scala source)
2024.04.09 23:40:01 INFO  time: compiled bestgame in 1.32s
2024.04.09 23:40:27 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:40:27 INFO  compiling bestgame (1 scala source)
2024.04.09 23:40:27 INFO  time: compiled bestgame in 0.41s
2024.04.09 23:40:37 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:40:37 INFO  compiling bestgame (1 scala source)
2024.04.09 23:40:37 INFO  time: compiled bestgame in 97ms
2024.04.09 23:40:44 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:40:44 INFO  compiling bestgame (1 scala source)
2024.04.09 23:40:44 INFO  time: compiled bestgame in 0.37s
2024.04.09 23:40:52 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:40:52 INFO  compiling bestgame (1 scala source)
2024.04.09 23:40:52 INFO  time: compiled bestgame in 0.41s
2024.04.09 23:41:15 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:41:15 INFO  compiling bestgame (1 scala source)
2024.04.09 23:41:15 INFO  time: compiled bestgame in 0.32s
Π°ΠΏΡ€. 09, 2024 11:41:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4265
2024.04.09 23:41:35 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:41:35 INFO  compiling bestgame (1 scala source)
2024.04.09 23:41:35 INFO  time: compiled bestgame in 0.29s
2024.04.09 23:41:49 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\DataBaseManager.scala
scala.meta.tokenizers.TokenizeException: <input>:30: error: unclosed string interpolation
            println(s"[ERROR] Occured while updating player $")
                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.09 23:41:53 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:41:53 INFO  compiling bestgame (1 scala source)
2024.04.09 23:41:53 INFO  time: compiled bestgame in 0.27s
2024.04.09 23:42:03 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:42:03 INFO  compiling bestgame (1 scala source)
2024.04.09 23:42:03 INFO  time: compiled bestgame in 0.31s
2024.04.09 23:42:05 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:42:05 INFO  compiling bestgame (1 scala source)
2024.04.09 23:42:05 INFO  time: compiled bestgame in 0.33s
2024.04.09 23:43:07 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:43:07 INFO  compiling bestgame (1 scala source)
2024.04.09 23:43:07 INFO  time: compiled bestgame in 0.34s
2024.04.09 23:43:39 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:43:39 INFO  compiling bestgame (1 scala source)
2024.04.09 23:43:39 INFO  time: compiled bestgame in 0.13s
2024.04.09 23:43:39 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:43:41 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:43:41 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:43:49 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:43:49 INFO  compiling bestgame (1 scala source)
2024.04.09 23:43:49 INFO  time: compiled bestgame in 74ms
2024.04.09 23:44:04 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
Π°ΠΏΡ€. 09, 2024 11:44:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4470
2024.04.09 23:44:11 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:44:12 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
Π°ΠΏΡ€. 09, 2024 11:44:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4499
2024.04.09 23:44:12 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:44:33 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:44:33 INFO  compiling bestgame (1 scala source)
2024.04.09 23:44:33 INFO  time: compiled bestgame in 0.18s
2024.04.09 23:44:51 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:44:51 INFO  compiling bestgame (1 scala source)
2024.04.09 23:44:51 INFO  time: compiled bestgame in 0.2s
Π°ΠΏΡ€. 09, 2024 11:45:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4659
Π°ΠΏΡ€. 09, 2024 11:46:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4684
2024.04.09 23:46:49 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:46:49 INFO  compiling bestgame (1 scala source)
2024.04.09 23:46:49 INFO  time: compiled bestgame in 0.18s
2024.04.09 23:47:00 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:47:00 INFO  compiling bestgame (1 scala source)
2024.04.09 23:47:00 INFO  time: compiled bestgame in 0.22s
2024.04.09 23:47:16 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\App.scala
scala.meta.tokenizers.TokenizeException: <input>:24: error: unclosed string interpolation
        s"$"
          ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

Π°ΠΏΡ€. 09, 2024 11:47:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4921
Π°ΠΏΡ€. 09, 2024 11:47:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4989
2024.04.09 23:47:42 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\App.scala
scala.meta.tokenizers.TokenizeException: <input>:24: error: unclosed string interpolation
        s"${player.name} ${player.money} $"
                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:249)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.09 23:47:48 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:47:48 INFO  compiling bestgame (1 scala source)
2024.04.09 23:47:48 INFO  time: compiled bestgame in 0.89s
Π°ΠΏΡ€. 09, 2024 11:48:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5174
2024.04.09 23:48:19 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:48:19 INFO  compiling bestgame (1 scala source)
2024.04.09 23:48:21 INFO  time: compiled bestgame in 2.28s
2024.04.09 23:49:17 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:49:17 INFO  compiling bestgame (1 scala source)
2024.04.09 23:49:17 INFO  time: compiled bestgame in 0.43s
Π°ΠΏΡ€. 09, 2024 11:49:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5391
Π°ΠΏΡ€. 09, 2024 11:49:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5407
Π°ΠΏΡ€. 09, 2024 11:49:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5425
2024.04.09 23:49:28 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:49:28 INFO  compiling bestgame (1 scala source)
2024.04.09 23:49:28 INFO  time: compiled bestgame in 0.37s
2024.04.09 23:49:32 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:49:32 INFO  compiling bestgame (1 scala source)
2024.04.09 23:49:32 INFO  time: compiled bestgame in 0.35s
2024.04.09 23:49:37 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:49:37 INFO  compiling bestgame (1 scala source)
2024.04.09 23:49:37 INFO  time: compiled bestgame in 0.36s
2024.04.09 23:49:41 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:49:41 INFO  compiling bestgame (1 scala source)
2024.04.09 23:49:41 INFO  time: compiled bestgame in 0.12s
2024.04.09 23:52:25 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\App.scala
scala.meta.tokenizers.TokenizeException: <input>:24: error: unclosed string interpolation
        player.map((p) => s"$")
                            ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.09 23:52:34 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\App.scala
scala.meta.tokenizers.TokenizeException: <input>:24: error: unclosed string interpolation
        player.map((p) => s"${player.name} $")
                                          ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:249)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.09 23:52:40 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\App.scala
scala.meta.tokenizers.TokenizeException: <input>:24: error: unclosed string interpolation
        player.map((p) => s"${player.name} ${player.money} $")
                                                          ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:249)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.09 23:53:04 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:53:04 INFO  compiling bestgame (1 scala source)
2024.04.09 23:53:04 INFO  time: compiled bestgame in 0.36s
2024.04.09 23:54:34 WARN  Using indexes to guess the definition of planted
2024.04.09 23:54:42 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:54:42 INFO  compiling bestgame (1 scala source)
2024.04.09 23:54:42 INFO  time: compiled bestgame in 97ms
2024.04.09 23:54:46 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:54:46 INFO  compiling bestgame (1 scala source)
2024.04.09 23:54:46 INFO  time: compiled bestgame in 0.89s
2024.04.09 23:54:57 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:54:57 INFO  compiling bestgame (1 scala source)
2024.04.09 23:54:59 INFO  time: compiled bestgame in 1.74s
2024.04.09 23:55:00 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:55:00 INFO  compiling bestgame (1 scala source)
2024.04.09 23:55:00 INFO  time: compiled bestgame in 0.83s
2024.04.09 23:55:02 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:55:02 INFO  compiling bestgame (1 scala source)
2024.04.09 23:55:02 INFO  time: compiled bestgame in 0.84s
2024.04.09 23:55:18 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:55:18 INFO  compiling bestgame (1 scala source)
2024.04.09 23:55:18 INFO  time: compiled bestgame in 90ms
2024.04.09 23:55:25 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:55:25 INFO  compiling bestgame (1 scala source)
2024.04.09 23:55:25 INFO  time: compiled bestgame in 0.26s
2024.04.09 23:55:43 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:55:43 INFO  compiling bestgame (1 scala source)
2024.04.09 23:55:43 INFO  time: compiled bestgame in 76ms
2024.04.09 23:55:44 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:55:44 INFO  compiling bestgame (1 scala source)
2024.04.09 23:55:44 INFO  time: compiled bestgame in 74ms
2024.04.09 23:55:57 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:55:57 INFO  compiling bestgame (1 scala source)
2024.04.09 23:55:57 INFO  time: compiled bestgame in 0.66s
2024.04.09 23:55:59 WARN  Using indexes to guess the definition of name
2024.04.09 23:56:02 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:56:02 INFO  compiling bestgame (1 scala source)
2024.04.09 23:56:02 INFO  time: compiled bestgame in 81ms
2024.04.09 23:56:11 WARN  Using indexes to guess the definition of name
2024.04.09 23:56:14 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:56:14 INFO  compiling bestgame (1 scala source)
2024.04.09 23:56:14 INFO  time: compiled bestgame in 83ms
2024.04.09 23:56:42 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:56:42 INFO  compiling bestgame (1 scala source)
2024.04.09 23:56:42 INFO  time: compiled bestgame in 72ms
2024.04.09 23:56:48 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:56:48 INFO  compiling bestgame (1 scala source)
2024.04.09 23:56:48 INFO  time: compiled bestgame in 95ms
2024.04.09 23:56:56 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:56:56 INFO  compiling bestgame (1 scala source)
2024.04.09 23:56:56 INFO  time: compiled bestgame in 71ms
2024.04.09 23:56:59 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:56:59 INFO  compiling bestgame (1 scala source)
2024.04.09 23:57:01 INFO  time: compiled bestgame in 1.66s
2024.04.09 23:57:01 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:57:01 INFO  compiling bestgame (1 scala source)
2024.04.09 23:57:01 INFO  time: compiled bestgame in 0.1s
2024.04.09 23:57:07 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:57:07 INFO  compiling bestgame (1 scala source)
2024.04.09 23:57:07 INFO  time: compiled bestgame in 73ms
2024.04.09 23:57:10 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:57:10 INFO  compiling bestgame (1 scala source)
2024.04.09 23:57:10 INFO  time: compiled bestgame in 66ms
2024.04.09 23:57:14 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:57:14 INFO  compiling bestgame (1 scala source)
2024.04.09 23:57:14 INFO  time: compiled bestgame in 78ms
2024.04.09 23:57:20 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:57:20 INFO  compiling bestgame (1 scala source)
2024.04.09 23:57:20 INFO  time: compiled bestgame in 74ms
2024.04.09 23:57:26 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:57:26 INFO  compiling bestgame (1 scala source)
2024.04.09 23:57:26 INFO  time: compiled bestgame in 94ms
2024.04.09 23:57:46 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:57:46 INFO  compiling bestgame (1 scala source)
2024.04.09 23:57:46 INFO  time: compiled bestgame in 72ms
2024.04.09 23:58:32 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:58:32 INFO  compiling bestgame (1 scala source)
2024.04.09 23:58:32 INFO  time: compiled bestgame in 85ms
2024.04.09 23:58:36 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:58:36 INFO  compiling bestgame (1 scala source)
2024.04.09 23:58:36 INFO  time: compiled bestgame in 74ms
2024.04.09 23:58:36 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:58:36 INFO  compiling bestgame (1 scala source)
2024.04.09 23:58:36 INFO  time: compiled bestgame in 0.1s
2024.04.09 23:58:40 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:58:40 INFO  compiling bestgame (1 scala source)
2024.04.09 23:58:40 INFO  time: compiled bestgame in 72ms
2024.04.09 23:58:44 WARN  Using indexes to guess the definition of money
2024.04.09 23:58:46 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:58:46 INFO  compiling bestgame (1 scala source)
2024.04.09 23:58:46 INFO  time: compiled bestgame in 72ms
2024.04.09 23:58:50 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:58:50 INFO  compiling bestgame (1 scala source)
2024.04.09 23:58:50 INFO  time: compiled bestgame in 68ms
2024.04.09 23:58:53 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:58:53 INFO  compiling bestgame (1 scala source)
2024.04.09 23:58:53 INFO  time: compiled bestgame in 0.12s
2024.04.09 23:59:07 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.09 23:59:07 INFO  compiling bestgame (1 scala source)
2024.04.09 23:59:07 INFO  time: compiled bestgame in 0.29s
2024.04.09 23:59:12 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 00:00:53 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 00:00:53 INFO  compiling bestgame (1 scala source)
2024.04.10 00:00:53 INFO  time: compiled bestgame in 0.26s
2024.04.10 00:02:07 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 00:05:53 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 00:05:53 INFO  compiling bestgame (1 scala source)
2024.04.10 00:05:55 INFO  time: compiled bestgame in 1.75s
2024.04.10 00:07:45 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 00:07:45 INFO  compiling bestgame (1 scala source)
2024.04.10 00:07:47 INFO  time: compiled bestgame in 1.83s
2024.04.10 00:08:38 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 00:08:38 INFO  compiling bestgame (1 scala source)
2024.04.10 00:08:38 INFO  time: compiled bestgame in 0.4s
2024.04.10 00:12:31 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 00:12:31 INFO  compiling bestgame (1 scala source)
2024.04.10 00:12:31 INFO  time: compiled bestgame in 0.68s
2024.04.10 00:12:57 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 00:12:57 INFO  compiling bestgame (1 scala source)
2024.04.10 00:12:57 INFO  time: compiled bestgame in 0.32s
2024.04.10 00:13:02 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 00:13:02 INFO  compiling bestgame (1 scala source)
2024.04.10 00:13:02 INFO  time: compiled bestgame in 0.43s
Π°ΠΏΡ€. 10, 2024 12:13:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7429
2024.04.10 00:13:12 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 00:13:12 INFO  compiling bestgame (1 scala source)
2024.04.10 00:13:12 INFO  time: compiled bestgame in 0.41s
Π°ΠΏΡ€. 10, 2024 12:13:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7464
2024.04.10 00:13:25 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 00:13:25 INFO  compiling bestgame (1 scala source)
2024.04.10 00:13:25 INFO  time: compiled bestgame in 0.65s
Π°ΠΏΡ€. 10, 2024 12:13:52 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7537
2024.04.10 00:13:54 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.sql/java/sql/SQLException.java

Uri: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.sql/java/sql/SQLException.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:689)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1570)
```

2024.04.10 00:13:54 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
Π°ΠΏΡ€. 10, 2024 12:13:54 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.sql/java/sql/SQLException.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.sql;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n\n/**\n * \u003cP\u003eAn exception that provides information on a database access\n * error or other errors.\n *\n * \u003cP\u003eEach {@code SQLException} provides several kinds of information:\n * \u003cUL\u003e\n *   \u003cLI\u003e a string describing the error.  This is used as the Java Exception\n *       message, available via the method {@code getMessage}.\n *   \u003cLI\u003e a \"SQLstate\" string, which follows either the XOPEN SQLstate conventions\n *        or the SQL:2003 conventions.\n *       The values of the SQLState string are described in the appropriate spec.\n *       The {@code DatabaseMetaData} method {@code getSQLStateType}\n *       can be used to discover whether the driver returns the XOPEN type or\n *       the SQL:2003 type.\n *   \u003cLI\u003e an integer error code that is specific to each vendor.  Normally this will\n *       be the actual error code returned by the underlying database.\n *   \u003cLI\u003e a chain to a next Exception.  This can be used to provide additional\n *       error information.\n *   \u003cLI\u003e the causal relationship, if any for this {@code SQLException}.\n * \u003c/UL\u003e\n *\n * @since 1.1\n */\npublic class SQLException extends java.lang.Exception\n                          implements Iterable\u003cThrowable\u003e {\n\n    /**\n     *  Constructs a {@code SQLException} object with a given\n     * {@code reason}, {@code SQLState}  and\n     * {@code vendorCode}.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method.\n     *\n     * @param reason a description of the exception\n     * @param SQLState an XOPEN or SQL:2003 code identifying the exception\n     * @param vendorCode a database vendor-specific exception code\n     */\n    public SQLException(String reason, String SQLState, int vendorCode) {\n        super(reason);\n        this.SQLState \u003d SQLState;\n        this.vendorCode \u003d vendorCode;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                DriverManager.println(\"SQLState(\" + SQLState +\n                                                \") vendor code(\" + vendorCode + \")\");\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason} and {@code SQLState}.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method. The vendor code\n     * is initialized to 0.\n     *\n     * @param reason a description of the exception\n     * @param SQLState an XOPEN or SQL:2003 code identifying the exception\n     */\n    public SQLException(String reason, String SQLState) {\n        super(reason);\n        this.SQLState \u003d SQLState;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n                DriverManager.println(\"SQLException: SQLState(\" + SQLState + \")\");\n            }\n        }\n    }\n\n    /**\n     *  Constructs a {@code SQLException} object with a given\n     * {@code reason}. The  {@code SQLState}  is initialized to\n     * {@code null} and the vendor code is initialized to 0.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method.\n     *\n     * @param reason a description of the exception\n     */\n    public SQLException(String reason) {\n        super(reason);\n        this.SQLState \u003d null;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object.\n     * The {@code reason}, {@code SQLState} are initialized\n     * to {@code null} and the vendor code is initialized to 0.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method.\n     *\n     */\n    public SQLException() {\n        super();\n        this.SQLState \u003d null;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     *  Constructs a {@code SQLException} object with a given\n     * {@code cause}.\n     * The {@code SQLState} is initialized\n     * to {@code null} and the vendor code is initialized to 0.\n     * The {@code reason}  is initialized to {@code null} if\n     * {@code cause\u003d\u003dnull} or to {@code cause.toString()} if\n     * {@code cause!\u003dnull}.\n     *\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the {@code getCause()} method);\n     * may be null indicating the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(Throwable cause) {\n        super(cause);\n\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason} and  {@code cause}.\n     * The {@code SQLState} is  initialized to {@code null}\n     * and the vendor code is initialized to 0.\n     *\n     * @param reason a description of the exception.\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the {@code getCause()} method);\n     * may be null indicating the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(String reason, Throwable cause) {\n        super(reason,cause);\n\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                    printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason}, {@code SQLState} and  {@code cause}.\n     * The vendor code is initialized to 0.\n     *\n     * @param reason a description of the exception.\n     * @param sqlState an XOPEN or SQL:2003 code identifying the exception\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the\n     * {@code getCause()} method); may be null indicating\n     *     the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(String reason, String sqlState, Throwable cause) {\n        super(reason,cause);\n\n        this.SQLState \u003d sqlState;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n                DriverManager.println(\"SQLState(\" + SQLState + \")\");\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason}, {@code SQLState}, {@code vendorCode}\n     * and  {@code cause}.\n     *\n     * @param reason a description of the exception\n     * @param sqlState an XOPEN or SQL:2003 code identifying the exception\n     * @param vendorCode a database vendor-specific exception code\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the {@code getCause()} method);\n     * may be null indicating the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(String reason, String sqlState, int vendorCode, Throwable cause) {\n        super(reason,cause);\n\n        this.SQLState \u003d sqlState;\n        this.vendorCode \u003d vendorCode;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                DriverManager.println(\"SQLState(\" + SQLState +\n                                                \") vendor code(\" + vendorCode + \")\");\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Retrieves the SQLState for this {@code SQLException} object.\n     *\n     * @return the SQLState value\n     */\n    public String getSQLState() {\n        return (SQLState);\n    }\n\n    /**\n     * Retrieves the vendor-specific exception code\n     * for this {@code SQLException} object.\n     *\n     * @return the vendor\u0027s error code\n     */\n    public int getErrorCode() {\n        return (vendorCode);\n    }\n\n    /**\n     * Retrieves the exception chained to this\n     * {@code SQLException} object by setNextException(SQLException ex).\n     *\n     * @return the next {@code SQLException} object in the chain;\n     *         {@code null} if there are none\n     * @see #setNextException\n     */\n    public SQLException getNextException() {\n        return (next);\n    }\n\n    /**\n     * Adds an {@code SQLException} object to the end of the chain.\n     *\n     * @param ex the new exception that will be added to the end of\n     *            the {@code SQLException} chain\n     * @see #getNextException\n     */\n    public void setNextException(SQLException ex) {\n\n        SQLException current \u003d this;\n        for(;;) {\n            SQLException next\u003dcurrent.next;\n            if (next !\u003d null) {\n                current \u003d next;\n                continue;\n            }\n\n            if (nextUpdater.compareAndSet(current,null,ex)) {\n                return;\n            }\n            current\u003dcurrent.next;\n        }\n    }\n\n    /**\n     * Returns an iterator over the chained SQLExceptions.  The iterator will\n     * be used to iterate over each SQLException and its underlying cause\n     * (if any).\n     *\n     * @return an iterator over the chained SQLExceptions and causes in the proper\n     * order\n     *\n     * @since 1.6\n     */\n    public Iterator\u003cThrowable\u003e iterator() {\n\n       return new Iterator\u003cThrowable\u003e() {\n\n           SQLException firstException \u003d SQLException.this;\n           SQLException nextException \u003d firstException.getNextException();\n           Throwable cause \u003d firstException.getCause();\n\n           public boolean hasNext() {\n               if(firstException !\u003d null || nextException !\u003d null || cause !\u003d null)\n                   return true;\n               return false;\n           }\n\n           public Throwable next() {\n               Throwable throwable \u003d null;\n               if(firstException !\u003d null){\n                   throwable \u003d firstException;\n                   firstException \u003d null;\n               }\n               else if(cause !\u003d null){\n                   throwable \u003d cause;\n                   cause \u003d cause.getCause();\n               }\n               else if(nextException !\u003d null){\n                   throwable \u003d nextException;\n                   cause \u003d nextException.getCause();\n                   nextException \u003d nextException.getNextException();\n               }\n               else\n                   throw new NoSuchElementException();\n               return throwable;\n           }\n\n           public void remove() {\n               throw new UnsupportedOperationException();\n           }\n\n       };\n\n    }\n\n    /**\n         * @serial\n         */\n    private String SQLState;\n\n        /**\n         * @serial\n         */\n    private int vendorCode;\n\n        /**\n         * @serial\n         */\n    private volatile SQLException next;\n\n    private static final AtomicReferenceFieldUpdater\u003cSQLException,SQLException\u003e nextUpdater \u003d\n            AtomicReferenceFieldUpdater.newUpdater(SQLException.class,SQLException.class,\"next\");\n\n    private static final long serialVersionUID \u003d 2135244094396331484L;\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

Π°ΠΏΡ€. 10, 2024 12:13:54 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.sql/java/sql/SQLException.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.04.10 00:13:54 INFO  compiling bestgame (1 scala source)
2024.04.10 00:13:54 INFO  time: compiled bestgame in 0.51s
2024.04.10 00:14:19 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 00:14:19 INFO  compiling bestgame (1 scala source)
2024.04.10 00:14:19 INFO  time: compiled bestgame in 0.24s
2024.04.10 00:39:22 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 00:39:27 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 00:40:09 INFO  Shutting down server
2024.04.10 00:40:09 INFO  shutting down Metals
2024.04.10 00:40:09 INFO  Shut down connection with build server.
2024.04.10 00:40:09 INFO  Shut down connection with build server.
2024.04.10 00:40:09 INFO  Exiting server
2024.04.10 12:26:27 INFO  Started: Metals version 1.2.2 in folders 'D:\bestgame' for client Visual Studio Code 1.88.0.
12:26:28.015 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
12:26:28.019 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
12:26:28.019 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
12:26:28.019 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
12:26:28.019 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@33909752 ...
12:26:28.019 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
12:26:28.019 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
12:26:28.019 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@33909752 ...
12:26:28.019 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/C:/Users/yidtdr/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
12:26:28.027 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
12:26:28.027 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
12:26:28.027 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
12:26:28.027 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
12:26:28.027 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
12:26:28.027 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
12:26:28.031 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
12:26:28.031 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
12:26:28.031 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
12:26:28.031 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
12:26:28.031 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
12:26:28.131 [pool-1-thread-1] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:D:\bestgame\.metals\metals (H2 2.2)
12:26:28.131 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
12:26:28.131 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
12:26:28.131 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
12:26:28.131 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
12:26:28.135 [pool-1-thread-1] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
12:26:28.135 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
12:26:28.139 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
12:26:28.144 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
12:26:28.147 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
12:26:28.151 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
12:26:28.151 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
12:26:28.151 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
12:26:28.151 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
12:26:28.151 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
12:26:28.155 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
12:26:28.155 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
12:26:28.155 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
12:26:28.155 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
12:26:28.155 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
12:26:28.167 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.022s)
12:26:28.167 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
12:26:28.171 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
12:26:28.175 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
12:26:28.183 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 35 of 100M
2024.04.10 12:26:29 INFO  Attempting to connect to the build server...
2024.04.10 12:26:30 INFO  skipping build import with status 'Installed'
2024.04.10 12:26:29 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.10 12:26:37 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.10 12:26:37 INFO  Attempting to connect to the build server...
2024.04.10 12:26:37 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.10 12:26:37 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.10 12:26:37 INFO  time: Connected to build server in 8.28s
2024.04.10 12:26:37 INFO  Connected to Build server: Bloop v1.5.15
2024.04.10 12:26:38 INFO  time: Imported build in 0.32s
2024.04.10 12:26:41 INFO  no build target found for D:\bestgame\src\main\scala\DataBaseManager.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.10 12:26:45 INFO  time: indexed workspace in 3.54s
2024.04.10 12:27:32 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 12:27:32 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 12:32:49 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 12:45:16 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 12:45:16 INFO  compiling bestgame (1 scala source)
2024.04.10 12:45:22 INFO  time: compiled bestgame in 5.33s
Π°ΠΏΡ€. 10, 2024 12:46:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 606
Π°ΠΏΡ€. 10, 2024 12:46:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 607
2024.04.10 12:46:20 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
Π°ΠΏΡ€. 10, 2024 12:46:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 646
2024.04.10 12:46:28 INFO  time: code lens generation in 10s
2024.04.10 12:46:39 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 12:46:39 INFO  compiling bestgame (1 scala source)
2024.04.10 12:46:39 INFO  time: compiled bestgame in 0.85s
2024.04.10 12:47:22 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 12:47:22 INFO  compiling bestgame (2 scala sources)
2024.04.10 12:47:22 INFO  time: compiled bestgame in 0.86s
Π°ΠΏΡ€. 10, 2024 12:47:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1080
2024.04.10 12:47:37 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 12:47:37 INFO  compiling bestgame (2 scala sources)
2024.04.10 12:47:39 INFO  time: compiled bestgame in 1.19s
2024.04.10 12:47:40 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 12:47:40 INFO  compiling bestgame (1 scala source)
2024.04.10 12:47:41 INFO  time: compiled bestgame in 1.43s
2024.04.10 12:49:15 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 12:49:15 INFO  compiling bestgame (1 scala source)
2024.04.10 12:49:15 INFO  time: compiled bestgame in 0.83s
2024.04.10 12:53:35 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 12:53:35 INFO  compiling bestgame (1 scala source)
2024.04.10 12:53:37 INFO  time: compiled bestgame in 1.58s
2024.04.10 12:57:35 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 12:57:35 INFO  compiling bestgame (1 scala source)
2024.04.10 12:57:36 INFO  time: compiled bestgame in 1.27s
2024.04.10 13:04:38 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 13:04:38 INFO  compiling bestgame (1 scala source)
2024.04.10 13:04:38 INFO  time: compiled bestgame in 0.43s
2024.04.10 13:05:43 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.10 13:05:43 INFO  compiling bestgame (1 scala source)
2024.04.10 13:05:43 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.10 13:05:43 INFO  time: compiled bestgame in 0.31s
2024.04.10 14:16:06 INFO  Shutting down server
2024.04.10 14:16:06 INFO  shutting down Metals
2024.04.10 14:16:06 INFO  Exiting server
2024.04.12 13:18:10 INFO  Started: Metals version 1.2.2 in folders 'D:\bestgame' for client Visual Studio Code 1.88.0.
13:18:11.145 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
13:18:11.149 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
13:18:11.149 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
13:18:11.153 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
13:18:11.153 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@33909752 ...
13:18:11.153 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
13:18:11.153 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
13:18:11.153 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@33909752 ...
13:18:11.153 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/C:/Users/yidtdr/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
13:18:11.153 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
13:18:11.153 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
13:18:11.157 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
13:18:11.157 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
13:18:11.157 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
13:18:11.157 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
13:18:11.157 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
13:18:11.157 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
13:18:11.157 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
13:18:11.157 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
13:18:11.157 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
13:18:11.275 [pool-1-thread-1] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:D:\bestgame\.metals\metals (H2 2.2)
13:18:11.275 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
13:18:11.275 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
13:18:11.275 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
13:18:11.275 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
13:18:11.279 [pool-1-thread-1] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
13:18:11.279 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
13:18:11.279 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
13:18:11.287 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
13:18:11.287 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
13:18:11.291 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
13:18:11.291 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
13:18:11.291 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
13:18:11.291 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
13:18:11.291 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
13:18:11.295 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
13:18:11.295 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
13:18:11.295 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
13:18:11.295 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
13:18:11.295 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
13:18:11.307 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.020s)
13:18:11.307 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
13:18:11.311 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
13:18:11.319 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
13:18:11.323 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 34 of 100M
2024.04.12 13:18:12 INFO  Attempting to connect to the build server...
2024.04.12 13:18:12 INFO  skipping build import with status 'Installed'
2024.04.12 13:18:12 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.12 13:18:18 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.12 13:18:18 INFO  Attempting to connect to the build server...
2024.04.12 13:18:18 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.12 13:18:18 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.12 13:18:18 INFO  time: Connected to build server in 6.31s
2024.04.12 13:18:18 INFO  Connected to Build server: Bloop v1.5.15
2024.04.12 13:18:19 INFO  time: Imported build in 0.25s
2024.04.12 13:18:22 INFO  no build target found for D:\bestgame\src\main\scala\main.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.12 13:18:27 INFO  time: indexed workspace in 3.95s
2024.04.12 13:18:27 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:18:31 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:18:31 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
Π°ΠΏΡ€. 12, 2024 1:20:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 29
2024.04.12 13:21:33 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:21:33 INFO  compiling bestgame (1 scala source)
2024.04.12 13:21:42 INFO  time: compiled bestgame in 9.11s
2024.04.12 13:21:44 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:21:50 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:21:52 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:21:52 INFO  compiling bestgame (1 scala source)
2024.04.12 13:21:52 INFO  time: compiled bestgame in 0.72s
2024.04.12 13:21:54 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:21:54 INFO  compiling bestgame (1 scala source)
2024.04.12 13:21:58 INFO  time: compiled bestgame in 3.73s
2024.04.12 13:22:11 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:22:11 INFO  compiling bestgame (1 scala source)
2024.04.12 13:22:11 INFO  time: compiled bestgame in 0.32s
2024.04.12 13:22:11 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.12 13:22:16 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.12 13:22:17 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\main.scala
2024.04.12 13:22:17 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:22:27 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:22:27 INFO  compiling bestgame (1 scala source)
2024.04.12 13:22:28 INFO  time: compiled bestgame in 1.15s
2024.04.12 13:22:39 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:22:39 INFO  compiling bestgame (1 scala source)
2024.04.12 13:22:41 INFO  time: compiled bestgame in 1.74s
2024.04.12 13:22:41 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:22:41 INFO  compiling bestgame (1 scala source)
2024.04.12 13:22:43 INFO  time: compiled bestgame in 1.48s
Π°ΠΏΡ€. 12, 2024 1:23:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 271
2024.04.12 13:23:23 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:23:23 INFO  compiling bestgame (1 scala source)
2024.04.12 13:23:23 INFO  time: compiled bestgame in 0.12s
2024.04.12 13:23:23 INFO  compiling bestgame (1 scala source)
2024.04.12 13:23:30 INFO  time: compiled bestgame in 7.14s
2024.04.12 13:23:51 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:23:51 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:23:53 INFO  time: compiled bestgame in 2.1s
2024.04.12 13:24:04 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:24:04 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:24:05 INFO  time: compiled bestgame in 1.01s
2024.04.12 13:24:06 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:24:06 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:24:07 INFO  time: compiled bestgame in 1.03s
2024.04.12 13:24:11 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:24:11 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:24:11 INFO  time: compiled bestgame in 0.64s
2024.04.12 13:24:16 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:24:16 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:24:16 INFO  time: compiled bestgame in 0.27s
2024.04.12 13:24:16 INFO  compiling bestgame (1 scala source)
2024.04.12 13:24:17 INFO  time: compiled bestgame in 1.04s
2024.04.12 13:25:00 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:25:00 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:25:00 INFO  time: compiled bestgame in 0.19s
2024.04.12 13:25:00 INFO  compiling bestgame (1 scala source)
2024.04.12 13:25:00 INFO  time: compiled bestgame in 0.78s
Π°ΠΏΡ€. 12, 2024 1:25:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 534
Π°ΠΏΡ€. 12, 2024 1:29:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 580
2024.04.12 13:29:51 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:29:51 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:29:51 INFO  time: compiled bestgame in 0.26s
2024.04.12 13:29:51 INFO  compiling bestgame (1 scala source)
2024.04.12 13:29:52 INFO  time: compiled bestgame in 0.85s
2024.04.12 13:30:07 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:30:07 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:30:07 INFO  time: compiled bestgame in 0.21s
2024.04.12 13:30:07 INFO  compiling bestgame (1 scala source)
2024.04.12 13:30:08 INFO  time: compiled bestgame in 0.77s
2024.04.12 13:30:15 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\App.scala
scala.meta.tokenizers.TokenizeException: <input>:6: error: Invalid literal number
    var authorizedSockets: scala.collection.mutable.Map[0WebSocketChannel] = scala.collection.mutable.Map.empty
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.checkNoLetter(LegacyScanner.scala:820)
	at scala.meta.internal.tokenizers.LegacyScanner.restOfUncertainToken$1(LegacyScanner.scala:864)
	at scala.meta.internal.tokenizers.LegacyScanner.getNumber(LegacyScanner.scala:872)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchZero$1(LegacyScanner.scala:330)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:332)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.12 13:30:19 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:30:19 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:30:19 INFO  time: compiled bestgame in 0.21s
2024.04.12 13:30:19 INFO  compiling bestgame (1 scala source)
2024.04.12 13:30:19 INFO  time: compiled bestgame in 0.74s
2024.04.12 13:31:32 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:31:32 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:31:32 INFO  time: compiled bestgame in 97ms
Π°ΠΏΡ€. 12, 2024 1:31:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1215
2024.04.12 13:32:02 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:32:02 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:32:02 INFO  time: compiled bestgame in 0.11s
Π°ΠΏΡ€. 12, 2024 1:32:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1272
2024.04.12 13:32:15 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:32:15 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:32:15 INFO  time: compiled bestgame in 0.48s
Π°ΠΏΡ€. 12, 2024 1:32:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1303
Π°ΠΏΡ€. 12, 2024 1:32:30 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-12\r_compiler-error_(bestgame)_13-32-30-890.md
Π°ΠΏΡ€. 12, 2024 1:32:31 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-12\r_compiler-error_(bestgame)_13-32-31-550.md
Π°ΠΏΡ€. 12, 2024 1:32:33 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-12\r_compiler-error_(bestgame)_13-32-33-103.md
2024.04.12 13:32:36 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:32:36 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:32:36 INFO  time: compiled bestgame in 82ms
Π°ΠΏΡ€. 12, 2024 1:32:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1446
2024.04.12 13:32:59 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:32:59 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:32:59 INFO  time: compiled bestgame in 80ms
2024.04.12 13:33:30 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:33:30 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:33:30 INFO  time: compiled bestgame in 0.45s
Π°ΠΏΡ€. 12, 2024 1:33:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1521
Π°ΠΏΡ€. 12, 2024 1:33:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1542
2024.04.12 13:34:29 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:34:29 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:34:29 INFO  time: compiled bestgame in 0.14s
2024.04.12 13:34:31 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\Game.scala
scala.meta.tokenizers.TokenizeException: <input>:4: error: can't use unescaped LF in character literals
    '123'
         ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.12 13:34:31 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:34:31 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:34:31 INFO  time: compiled bestgame in 85ms
2024.04.12 13:34:32 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\Game.scala
scala.meta.tokenizers.TokenizeException: <input>:4: error: can't use unescaped LF in character literals
    '123'
         ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.12 13:34:36 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:34:36 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:34:36 INFO  time: compiled bestgame in 0.16s
2024.04.12 13:34:45 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:34:45 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:34:45 INFO  time: compiled bestgame in 0.2s
2024.04.12 13:40:21 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:40:21 INFO  compiling bestgame (1 scala source)
2024.04.12 13:40:21 INFO  time: compiled bestgame in 0.14s
2024.04.12 13:40:21 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:40:24 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:40:35 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:40:35 INFO  compiling bestgame (1 scala source)
2024.04.12 13:40:35 INFO  time: compiled bestgame in 0.12s
2024.04.12 13:40:40 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:40:40 INFO  compiling bestgame (1 scala source)
2024.04.12 13:40:40 INFO  time: compiled bestgame in 96ms
Π°ΠΏΡ€. 12, 2024 1:40:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1768
Π°ΠΏΡ€. 12, 2024 1:40:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1776
2024.04.12 13:40:56 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:40:56 INFO  compiling bestgame (1 scala source)
2024.04.12 13:40:56 INFO  time: compiled bestgame in 95ms
2024.04.12 13:41:46 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:41:46 INFO  compiling bestgame (1 scala source)
2024.04.12 13:41:46 INFO  time: compiled bestgame in 0.1s
Exception in thread "metals-watch-callback-thread" java.nio.file.FileSystemException: D:\bestgame\src\main\scala\gameClasses\Inventory.scala: ΠΡ€ΠΎΡ†ΠµΡΡ Π½Πµ ΠΌΠΎΠ¶ΠµΡ‚ ΠΏΠΎΠ»ΡƒΡ‡ΠΈΡ‚Ρ Π΄ΠΎΡΡ‚ΡƒΠΏ ΠΊ Ρ„Π°ΠΉΠ»Ρƒ, Ρ‚Π°ΠΊ ΠΊΠ°ΠΊ ΡΡ‚ΠΎΡ‚ Ρ„Π°ΠΉΠ» Π·Π°Π½ΡΡ‚ Π΄Ρ€ΡƒΠ³ΠΈΠΌ ΠΏΡ€ΠΎΡ†ΠµΡΡΠΎΠΌ
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:92)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3273)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$onChange$1(MetalsLspService.scala:1369)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$onChange$1$adapted(MetalsLspService.scala:1368)
	at scala.collection.immutable.List.foreach(List.scala:333)
	at scala.meta.internal.metals.MetalsLspService.onChange(MetalsLspService.scala:1368)
	at scala.meta.internal.metals.MetalsLspService.didChangeWatchedFiles(MetalsLspService.scala:1349)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$fileWatcher$3(MetalsLspService.scala:265)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$fileWatcher$3$adapted(MetalsLspService.scala:264)
	at scala.meta.internal.metals.watcher.FileWatcher$$anon$1.loop(FileWatcher.scala:198)
	at scala.meta.internal.metals.watcher.FileWatcher$$anon$1.run(FileWatcher.scala:202)
2024.04.12 13:42:03 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:42:03 INFO  compiling bestgame (1 scala source)
2024.04.12 13:42:03 INFO  time: compiled bestgame in 0.23s
2024.04.12 13:42:05 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
Π°ΠΏΡ€. 12, 2024 1:42:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1988
2024.04.12 13:42:43 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:42:43 INFO  compiling bestgame (1 scala source)
2024.04.12 13:42:43 INFO  time: compiled bestgame in 33ms
2024.04.12 13:42:44 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
Π°ΠΏΡ€. 12, 2024 1:43:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2092
Π°ΠΏΡ€. 12, 2024 1:43:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2094
Π°ΠΏΡ€. 12, 2024 1:43:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2093
Π°ΠΏΡ€. 12, 2024 1:43:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2091
2024.04.12 13:43:02 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
Π°ΠΏΡ€. 12, 2024 1:43:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2099
2024.04.12 13:43:02 INFO  time: code lens generation in 4.44s
Π°ΠΏΡ€. 12, 2024 1:43:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2122
2024.04.12 13:45:10 INFO  time: code lens generation in 1s
Π°ΠΏΡ€. 12, 2024 1:49:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2174
2024.04.12 13:50:39 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:50:39 INFO  compiling bestgame (1 scala source)
2024.04.12 13:50:39 INFO  time: compiled bestgame in 0.26s
Π°ΠΏΡ€. 12, 2024 1:51:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2356
2024.04.12 13:51:16 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:51:16 INFO  compiling bestgame (1 scala source)
2024.04.12 13:51:16 INFO  time: compiled bestgame in 0.1s
2024.04.12 13:51:17 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:51:17 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:51:17 INFO  compiling bestgame (1 scala source)
2024.04.12 13:51:17 INFO  time: compiled bestgame in 0.14s
2024.04.12 13:51:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:51:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:51:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:51:19 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:51:21 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:51:21 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:51:22 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:51:22 INFO  compiling bestgame (1 scala source)
2024.04.12 13:51:22 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:51:22 INFO  time: compiled bestgame in 49ms
2024.04.12 13:51:22 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:52:50 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:52:50 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:52:50 INFO  time: compiled bestgame in 0.1s
2024.04.12 13:53:01 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:53:01 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:53:01 INFO  time: compiled bestgame in 49ms
Π°ΠΏΡ€. 12, 2024 1:53:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2621
2024.04.12 13:53:21 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:53:21 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:53:21 INFO  time: compiled bestgame in 91ms
2024.04.12 13:53:29 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:53:29 INFO  compiling bestgame (2 scala sources)
2024.04.12 13:53:29 INFO  time: compiled bestgame in 75ms
Π°ΠΏΡ€. 12, 2024 1:53:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2709
2024.04.12 13:54:14 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:54:14 INFO  compiling bestgame (3 scala sources)
2024.04.12 13:54:14 INFO  time: compiled bestgame in 67ms
2024.04.12 13:54:39 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:54:39 INFO  compiling bestgame (3 scala sources)
2024.04.12 13:54:39 INFO  time: compiled bestgame in 55ms
2024.04.12 13:54:49 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:54:49 INFO  compiling bestgame (3 scala sources)
2024.04.12 13:54:49 INFO  time: compiled bestgame in 50ms
Π°ΠΏΡ€. 12, 2024 1:54:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2879
2024.04.12 13:54:58 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:54:59 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:00 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:01 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:07 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:08 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:09 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:10 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:12 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:12 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:23 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:24 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:38 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:41 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:42 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:42 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:43 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
Π°ΠΏΡ€. 12, 2024 1:55:44 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\bestgame\src\main\scala\gameClasses\Inventory.scala
java.nio.file.NoSuchFileException: D:\bestgame\src\main\scala\gameClasses\Inventory.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3273)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:425)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:281)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:292)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$7(SymbolIndexBucket.scala:223)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$7$adapted(SymbolIndexBucket.scala:218)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:576)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:574)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:933)
	at scala.collection.IterableOps$WithFilter.foreach(Iterable.scala:903)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:218)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:180)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.mtags.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:252)
	at scala.meta.internal.pc.CompletionItemResolver$.resolve(CompletionItemResolver.scala:27)
	at scala.meta.internal.pc.ScalaPresentationCompiler.completionItemResolve$$anonfun$1(ScalaPresentationCompiler.scala:215)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:156)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:142)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:245)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)

Π°ΠΏΡ€. 12, 2024 1:55:44 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\bestgame\src\main\scala\gameClasses\Inventory.scala
java.nio.file.NoSuchFileException: D:\bestgame\src\main\scala\gameClasses\Inventory.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3273)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:425)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:67)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:281)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:292)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:303)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$7(SymbolIndexBucket.scala:223)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$7$adapted(SymbolIndexBucket.scala:218)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:576)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:574)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:933)
	at scala.collection.IterableOps$WithFilter.foreach(Iterable.scala:903)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:218)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:180)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:141)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:141)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.mtags.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:252)
	at scala.meta.internal.pc.CompletionItemResolver$.resolve(CompletionItemResolver.scala:27)
	at scala.meta.internal.pc.ScalaPresentationCompiler.completionItemResolve$$anonfun$1(ScalaPresentationCompiler.scala:215)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:156)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:142)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:245)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)

2024.04.12 13:55:44 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:45 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:55:45 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:45 INFO  compiling bestgame (3 scala sources)
2024.04.12 13:55:45 INFO  time: compiled bestgame in 52ms
2024.04.12 13:55:45 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:46 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:46 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:55:46 INFO  compiling bestgame (3 scala sources)
2024.04.12 13:55:46 INFO  time: compiled bestgame in 59ms
2024.04.12 13:55:46 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:53 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:57 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:55:57 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:55:57 INFO  compiling bestgame (3 scala sources)
2024.04.12 13:55:57 INFO  time: compiled bestgame in 0.27s
2024.04.12 13:55:57 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:56:00 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:56:01 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:56:01 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:56:01 INFO  compiling bestgame (3 scala sources)
2024.04.12 13:56:01 INFO  time: compiled bestgame in 0.16s
2024.04.12 13:56:01 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:56:02 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:56:02 INFO  compiling bestgame (3 scala sources)
2024.04.12 13:56:02 INFO  time: compiled bestgame in 0.14s
2024.04.12 13:56:03 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Player.scala
2024.04.12 13:57:18 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 13:57:18 INFO  compiling bestgame (3 scala sources)
2024.04.12 13:57:18 INFO  time: compiled bestgame in 0.15s
2024.04.12 14:01:12 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:01:12 INFO  compiling bestgame (3 scala sources)
2024.04.12 14:01:12 INFO  time: compiled bestgame in 0.28s
Π°ΠΏΡ€. 12, 2024 2:01:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3248
2024.04.12 14:02:14 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:02:14 INFO  compiling bestgame (1 scala source)
2024.04.12 14:02:14 INFO  time: compiled bestgame in 46ms
2024.04.12 14:02:21 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:02:21 INFO  compiling bestgame (1 scala source)
2024.04.12 14:02:21 INFO  time: compiled bestgame in 45ms
2024.04.12 14:02:24 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:02:24 INFO  compiling bestgame (1 scala source)
2024.04.12 14:02:24 INFO  time: compiled bestgame in 66ms
2024.04.12 14:02:24 INFO  compiling bestgame (1 scala source)
2024.04.12 14:02:24 INFO  time: compiled bestgame in 0.11s
2024.04.12 14:02:44 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:02:44 INFO  compiling bestgame (1 scala source)
2024.04.12 14:02:44 INFO  time: compiled bestgame in 0.11s
2024.04.12 14:03:49 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:03:49 INFO  compiling bestgame (1 scala source)
2024.04.12 14:03:49 INFO  time: compiled bestgame in 0.17s
2024.04.12 14:03:49 INFO  compiling bestgame (1 scala source)
2024.04.12 14:03:49 INFO  time: compiled bestgame in 0.11s
2024.04.12 14:03:50 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:03:50 INFO  compiling bestgame (1 scala source)
2024.04.12 14:03:50 INFO  time: compiled bestgame in 0.12s
2024.04.12 14:03:55 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:03:55 INFO  compiling bestgame (1 scala source)
2024.04.12 14:03:55 INFO  time: compiled bestgame in 75ms
2024.04.12 14:04:08 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:04:08 INFO  compiling bestgame (1 scala source)
2024.04.12 14:04:08 INFO  time: compiled bestgame in 67ms
2024.04.12 14:04:11 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:04:11 INFO  compiling bestgame (1 scala source)
2024.04.12 14:04:11 INFO  time: compiled bestgame in 61ms
2024.04.12 14:04:20 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:04:20 INFO  compiling bestgame (1 scala source)
2024.04.12 14:04:20 INFO  time: compiled bestgame in 75ms
2024.04.12 14:04:22 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:04:22 INFO  compiling bestgame (1 scala source)
2024.04.12 14:04:22 INFO  time: compiled bestgame in 47ms
Π°ΠΏΡ€. 12, 2024 2:04:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3880
Π°ΠΏΡ€. 12, 2024 2:04:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3888
Π°ΠΏΡ€. 12, 2024 2:04:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3897
2024.04.12 14:04:33 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:05:36 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:05:36 INFO  compiling bestgame (1 scala source)
2024.04.12 14:05:36 INFO  time: compiled bestgame in 0.13s
2024.04.12 14:05:36 INFO  compiling bestgame (1 scala source)
2024.04.12 14:05:36 INFO  time: compiled bestgame in 0.11s
2024.04.12 14:05:56 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
Π°ΠΏΡ€. 12, 2024 2:06:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4095
Π°ΠΏΡ€. 12, 2024 2:06:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4103
2024.04.12 14:06:27 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
Π°ΠΏΡ€. 12, 2024 2:06:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4122
Π°ΠΏΡ€. 12, 2024 2:06:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4136
2024.04.12 14:06:39 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:08:32 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:08:32 INFO  compiling bestgame (1 scala source)
2024.04.12 14:08:32 INFO  time: compiled bestgame in 0.13s
2024.04.12 14:08:53 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:08:53 INFO  compiling bestgame (1 scala source)
2024.04.12 14:08:53 INFO  time: compiled bestgame in 0.18s
2024.04.12 14:09:39 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:09:39 INFO  compiling bestgame (1 scala source)
2024.04.12 14:09:39 INFO  time: compiled bestgame in 0.14s
2024.04.12 14:09:45 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:09:45 INFO  compiling bestgame (1 scala source)
2024.04.12 14:09:45 INFO  time: compiled bestgame in 0.14s
2024.04.12 14:10:18 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:10:18 INFO  compiling bestgame (1 scala source)
2024.04.12 14:10:18 INFO  time: compiled bestgame in 0.17s
2024.04.12 14:10:23 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:10:23 INFO  compiling bestgame (1 scala source)
2024.04.12 14:10:23 INFO  time: compiled bestgame in 0.13s
2024.04.12 14:10:28 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:10:28 INFO  compiling bestgame (1 scala source)
2024.04.12 14:10:28 INFO  time: compiled bestgame in 0.13s
Π°ΠΏΡ€. 12, 2024 2:12:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5030
2024.04.12 14:12:07 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:12:07 INFO  compiling bestgame (1 scala source)
2024.04.12 14:12:07 INFO  time: compiled bestgame in 0.14s
2024.04.12 14:12:19 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:12:19 INFO  compiling bestgame (1 scala source)
2024.04.12 14:12:19 INFO  time: compiled bestgame in 97ms
2024.04.12 14:12:42 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:12:42 INFO  compiling bestgame (1 scala source)
2024.04.12 14:12:42 INFO  time: compiled bestgame in 0.11s
2024.04.12 14:12:42 INFO  compiling bestgame (1 scala source)
2024.04.12 14:12:42 INFO  time: compiled bestgame in 0.13s
2024.04.12 14:13:33 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:13:33 INFO  compiling bestgame (1 scala source)
2024.04.12 14:13:33 INFO  time: compiled bestgame in 0.12s
2024.04.12 14:13:33 INFO  compiling bestgame (1 scala source)
2024.04.12 14:13:33 INFO  time: compiled bestgame in 0.11s
2024.04.12 14:13:36 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
scala.meta.tokenizers.TokenizeException: <input>:8: error: unclosed character literal
    }''
     ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:407)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:412)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.12 14:13:39 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:13:39 INFO  compiling bestgame (1 scala source)
2024.04.12 14:13:39 INFO  time: compiled bestgame in 0.12s
Π°ΠΏΡ€. 12, 2024 2:24:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5244
Π°ΠΏΡ€. 12, 2024 2:24:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5252
2024.04.12 14:24:33 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:24:33 INFO  compiling bestgame (1 scala source)
2024.04.12 14:24:33 INFO  time: compiled bestgame in 56ms
2024.04.12 14:24:40 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:24:40 INFO  compiling bestgame (1 scala source)
2024.04.12 14:24:40 INFO  time: compiled bestgame in 0.18s
2024.04.12 14:24:59 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:24:59 INFO  compiling bestgame (2 scala sources)
2024.04.12 14:24:59 INFO  time: compiled bestgame in 0.26s
2024.04.12 14:25:01 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:25:01 INFO  compiling bestgame (2 scala sources)
2024.04.12 14:25:01 INFO  time: compiled bestgame in 0.17s
Π°ΠΏΡ€. 12, 2024 2:25:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5485
2024.04.12 14:25:06 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:25:06 INFO  compiling bestgame (2 scala sources)
2024.04.12 14:25:06 INFO  time: compiled bestgame in 0.15s
2024.04.12 14:25:09 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:25:09 INFO  compiling bestgame (2 scala sources)
2024.04.12 14:25:09 INFO  time: compiled bestgame in 0.12s
2024.04.12 14:25:10 WARN  Using indexes to guess the definition of Player
2024.04.12 14:25:11 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:25:11 INFO  compiling bestgame (2 scala sources)
2024.04.12 14:25:11 INFO  time: compiled bestgame in 0.12s
2024.04.12 14:25:12 WARN  Using indexes to guess the definition of Player
2024.04.12 14:25:13 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:25:13 INFO  compiling bestgame (2 scala sources)
2024.04.12 14:25:13 INFO  time: compiled bestgame in 0.11s
2024.04.12 14:25:19 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:25:19 INFO  compiling bestgame (2 scala sources)
2024.04.12 14:25:19 INFO  time: compiled bestgame in 0.1s
2024.04.12 14:25:28 WARN  Could not find semantic tokens for: file:///D:/bestgame/src/main/scala/Game.scala
2024.04.12 14:25:30 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:25:30 INFO  compiling bestgame (2 scala sources)
2024.04.12 14:25:30 INFO  time: compiled bestgame in 0.12s
2024.04.12 14:25:32 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 14:25:32 INFO  compiling bestgame (2 scala sources)
2024.04.12 14:25:32 INFO  time: compiled bestgame in 0.6s
2024.04.12 14:25:56 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
Π°ΠΏΡ€. 12, 2024 7:29:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5659
2024.04.12 19:29:54 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.12 19:29:54 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.12 19:29:54 INFO  Connected to Build server: Bloop v1.5.15
2024.04.12 19:29:54 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.12 19:29:54 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
Π°ΠΏΡ€. 12, 2024 7:30:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5791
Π°ΠΏΡ€. 12, 2024 7:30:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5850
Π°ΠΏΡ€. 12, 2024 7:30:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5851
Π°ΠΏΡ€. 12, 2024 7:30:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5852
Π°ΠΏΡ€. 12, 2024 7:30:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5879
Π°ΠΏΡ€. 12, 2024 7:30:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5934
2024.04.12 19:31:35 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:31:35 INFO  compiling bestgame (3 scala sources)
2024.04.12 19:31:36 INFO  time: compiled bestgame in 1.23s
2024.04.12 19:31:36 INFO  compiling bestgame (1 scala source)
2024.04.12 19:31:36 INFO  time: compiled bestgame in 0.39s
2024.04.12 19:32:00 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:32:26 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:32:26 INFO  compiling bestgame (1 scala source)
2024.04.12 19:32:26 INFO  time: compiled bestgame in 0.26s
Π°ΠΏΡ€. 12, 2024 7:42:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6015
2024.04.12 19:42:38 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:42:41 WARN  Using indexes to guess the definition of Player1
2024.04.12 19:42:42 WARN  Using indexes to guess the definition of Player1
2024.04.12 19:42:42 WARN  Using indexes to guess the definition of Player1
2024.04.12 19:42:56 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:42:56 INFO  compiling bestgame (1 scala source)
2024.04.12 19:42:57 INFO  time: compiled bestgame in 0.98s
2024.04.12 19:43:07 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:43:07 INFO  compiling bestgame (1 scala source)
2024.04.12 19:43:07 INFO  time: compiled bestgame in 0.36s
2024.04.12 19:43:18 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:43:18 INFO  compiling bestgame (1 scala source)
2024.04.12 19:43:18 INFO  time: compiled bestgame in 0.23s
2024.04.12 19:43:42 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:43:42 INFO  compiling bestgame (1 scala source)
2024.04.12 19:43:42 INFO  time: compiled bestgame in 0.12s
2024.04.12 19:43:52 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\DataBaseManager.scala
scala.meta.tokenizers.TokenizeException: <input>:48: error: `$$', `$'ident, `$'this, `$'BlockExpr`$'_
            println(s"[ERROR] Occured while trying to INSERT player($)")
                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:649)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.12 19:43:58 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:43:58 INFO  compiling bestgame (1 scala source)
2024.04.12 19:43:58 INFO  time: compiled bestgame in 0.19s
2024.04.12 19:44:10 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:44:10 INFO  compiling bestgame (1 scala source)
2024.04.12 19:44:10 INFO  time: compiled bestgame in 0.4s
2024.04.12 19:44:25 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:44:25 INFO  compiling bestgame (1 scala source)
2024.04.12 19:44:25 INFO  time: compiled bestgame in 0.27s
2024.04.12 19:44:27 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:44:27 INFO  compiling bestgame (1 scala source)
2024.04.12 19:44:27 INFO  time: compiled bestgame in 0.27s
2024.04.12 19:44:29 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:44:29 INFO  compiling bestgame (1 scala source)
2024.04.12 19:44:29 INFO  time: compiled bestgame in 0.3s
2024.04.12 19:44:44 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:44:44 INFO  compiling bestgame (1 scala source)
2024.04.12 19:44:44 INFO  time: compiled bestgame in 0.16s
2024.04.12 19:44:51 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:44:51 INFO  compiling bestgame (1 scala source)
2024.04.12 19:44:51 INFO  time: compiled bestgame in 0.16s
2024.04.12 19:44:54 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:44:54 INFO  compiling bestgame (1 scala source)
2024.04.12 19:44:54 INFO  time: compiled bestgame in 0.15s
2024.04.12 19:45:19 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:45:19 INFO  compiling bestgame (1 scala source)
2024.04.12 19:45:19 INFO  time: compiled bestgame in 0.2s
2024.04.12 19:47:11 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:47:11 INFO  compiling bestgame (1 scala source)
2024.04.12 19:47:11 INFO  time: compiled bestgame in 96ms
2024.04.12 19:47:13 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:47:20 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:47:20 INFO  compiling bestgame (1 scala source)
2024.04.12 19:47:20 INFO  time: compiled bestgame in 88ms
2024.04.12 19:49:27 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:49:27 INFO  compiling bestgame (1 scala source)
2024.04.12 19:49:27 INFO  time: compiled bestgame in 82ms
2024.04.12 19:49:28 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:49:28 INFO  compiling bestgame (1 scala source)
2024.04.12 19:49:28 INFO  time: compiled bestgame in 0.1s
2024.04.12 19:51:50 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:51:50 INFO  compiling bestgame (1 scala source)
2024.04.12 19:51:50 INFO  time: compiled bestgame in 79ms
2024.04.12 19:52:06 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:52:06 INFO  compiling bestgame (1 scala source)
2024.04.12 19:52:06 INFO  time: compiled bestgame in 57ms
2024.04.12 19:52:12 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:52:12 INFO  compiling bestgame (1 scala source)
2024.04.12 19:52:12 INFO  time: compiled bestgame in 80ms
Π°ΠΏΡ€. 12, 2024 7:52:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6695
2024.04.12 19:52:15 WARN  Using indexes to guess the definition of Serializable
2024.04.12 19:52:16 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:52:16 INFO  compiling bestgame (1 scala source)
2024.04.12 19:52:16 INFO  time: compiled bestgame in 69ms
2024.04.12 19:52:16 INFO  compiling bestgame (2 scala sources)
2024.04.12 19:52:16 INFO  time: compiled bestgame in 0.19s
Π°ΠΏΡ€. 12, 2024 7:52:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6715
Π°ΠΏΡ€. 12, 2024 7:52:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6723
2024.04.12 19:52:21 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:52:21 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/io/ObjectOutputStream.java

Uri: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/io/ObjectOutputStream.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:689)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1570)
```

Π°ΠΏΡ€. 12, 2024 7:52:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/io/ObjectOutputStream.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2023, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.io;\n\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.StringJoiner;\n\nimport jdk.internal.util.ByteArray;\nimport sun.reflect.misc.ReflectUtil;\n\n/**\n * An ObjectOutputStream writes primitive data types and graphs of Java objects\n * to an OutputStream.  The objects can be read (reconstituted) using an\n * ObjectInputStream.  Persistent storage of objects can be accomplished by\n * using a file for the stream.  If the stream is a network socket stream, the\n * objects can be reconstituted on another host or in another process.\n *\n * \u003cp\u003eOnly objects that support the java.io.Serializable interface can be\n * written to streams.  The class of each serializable object is encoded\n * including the class name and signature of the class, the values of the\n * object\u0027s fields and arrays, and the closure of any other objects referenced\n * from the initial objects.\n *\n * \u003cp\u003eThe method writeObject is used to write an object to the stream.  Any\n * object, including Strings and arrays, is written with writeObject. Multiple\n * objects or primitives can be written to the stream.  The objects must be\n * read back from the corresponding ObjectInputstream with the same types and\n * in the same order as they were written.\n *\n * \u003cp\u003ePrimitive data types can also be written to the stream using the\n * appropriate methods from DataOutput. Strings can also be written using the\n * writeUTF method.\n *\n * \u003cp\u003eThe default serialization mechanism for an object writes the class of the\n * object, the class signature, and the values of all non-transient and\n * non-static fields.  References to other objects (except in transient or\n * static fields) cause those objects to be written also. Multiple references\n * to a single object are encoded using a reference sharing mechanism so that\n * graphs of objects can be restored to the same shape as when the original was\n * written.\n *\n * \u003cp\u003eFor example to write an object that can be read by the example in\n * {@link ObjectInputStream}:\n * {@snippet lang\u003d\"java\":\n *      try (FileOutputStream fos \u003d new FileOutputStream(\"t.tmp\");\n *           ObjectOutputStream oos \u003d new ObjectOutputStream(fos)) {\n *          oos.writeObject(\"Today\");\n *          oos.writeObject(LocalDateTime.now());\n *      } catch (Exception ex) {\n *          // handle exception\n *      }\n * }\n *\n * \u003cp\u003eSerializable classes that require special handling during the\n * serialization and deserialization process should implement methods\n * with the following signatures:\n *\n * {@snippet lang\u003d\"java\":\n *     private void readObject(java.io.ObjectInputStream stream)\n *         throws IOException, ClassNotFoundException;\n *     private void writeObject(java.io.ObjectOutputStream stream)\n *         throws IOException;\n *     private void readObjectNoData()\n *         throws ObjectStreamException;\n * }\n *\n * \u003cp\u003eThe method name, modifiers, return type, and number and type of\n * parameters must match exactly for the method to be used by\n * serialization or deserialization. The methods should only be\n * declared to throw checked exceptions consistent with these\n * signatures.\n *\n * \u003cp\u003eThe writeObject method is responsible for writing the state of the object\n * for its particular class so that the corresponding readObject method can\n * restore it.  The method does not need to concern itself with the state\n * belonging to the object\u0027s superclasses or subclasses.  State is saved by\n * writing the individual fields to the ObjectOutputStream using the\n * writeObject method or by using the methods for primitive data types\n * supported by DataOutput.\n *\n * \u003cp\u003eSerialization does not write out the fields of any object that does not\n * implement the java.io.Serializable interface.  Subclasses of Objects that\n * are not serializable can be serializable. In this case the non-serializable\n * class must have a no-arg constructor to allow its fields to be initialized.\n * In this case it is the responsibility of the subclass to save and restore\n * the state of the non-serializable class. It is frequently the case that the\n * fields of that class are accessible (public, package, or protected) or that\n * there are get and set methods that can be used to restore the state.\n *\n * \u003cp\u003eSerialization of an object can be prevented by implementing writeObject\n * and readObject methods that throw the NotSerializableException.  The\n * exception will be caught by the ObjectOutputStream and abort the\n * serialization process.\n *\n * \u003cp\u003eImplementing the Externalizable interface allows the object to assume\n * complete control over the contents and format of the object\u0027s serialized\n * form.  The methods of the Externalizable interface, writeExternal and\n * readExternal, are called to save and restore the objects state.  When\n * implemented by a class they can write and read their own state using all of\n * the methods of ObjectOutput and ObjectInput.  It is the responsibility of\n * the objects to handle any versioning that occurs.\n *\n * \u003cp\u003eEnum constants are serialized differently than ordinary serializable or\n * externalizable objects.  The serialized form of an enum constant consists\n * solely of its name; field values of the constant are not transmitted.  To\n * serialize an enum constant, ObjectOutputStream writes the string returned by\n * the constant\u0027s name method.  Like other serializable or externalizable\n * objects, enum constants can function as the targets of back references\n * appearing subsequently in the serialization stream.  The process by which\n * enum constants are serialized cannot be customized; any class-specific\n * writeObject and writeReplace methods defined by enum types are ignored\n * during serialization.  Similarly, any serialPersistentFields or\n * serialVersionUID field declarations are also ignored--all enum types have a\n * fixed serialVersionUID of 0L.\n *\n * \u003cp\u003ePrimitive data, excluding serializable fields and externalizable data, is\n * written to the ObjectOutputStream in block-data records. A block data record\n * is composed of a header and data. The block data header consists of a marker\n * and the number of bytes to follow the header.  Consecutive primitive data\n * writes are merged into one block-data record.  The blocking factor used for\n * a block-data record will be 1024 bytes.  Each block-data record will be\n * filled up to 1024 bytes, or be written whenever there is a termination of\n * block-data mode.  Calls to the ObjectOutputStream methods writeObject,\n * defaultWriteObject and writeFields initially terminate any existing\n * block-data record.\n *\n * \u003cp\u003eRecords are serialized differently than ordinary serializable or externalizable\n * objects, see \u003ca href\u003d\"ObjectInputStream.html#record-serialization\"\u003erecord serialization\u003c/a\u003e.\n *\n * @spec serialization/index.html Java Object Serialization Specification\n * @author      Mike Warres\n * @author      Roger Riggs\n * @see java.io.DataOutput\n * @see java.io.ObjectInputStream\n * @see java.io.Serializable\n * @see java.io.Externalizable\n * @see \u003ca href\u003d\"{@docRoot}/../specs/serialization/output.html\"\u003e\n *      \u003ccite\u003eJava Object Serialization Specification,\u003c/cite\u003e Section 2, \"Object Output Classes\"\u003c/a\u003e\n * @since       1.1\n */\npublic class ObjectOutputStream\n    extends OutputStream implements ObjectOutput, ObjectStreamConstants\n{\n\n    private static class Caches {\n        /** cache of subclass security audit results */\n        static final ClassValue\u003cBoolean\u003e subclassAudits \u003d\n            new ClassValue\u003c\u003e() {\n                @Override\n                protected Boolean computeValue(Class\u003c?\u003e type) {\n                    return auditSubclass(type);\n                }\n            };\n    }\n\n    /** filter stream for handling block data conversion */\n    private final BlockDataOutputStream bout;\n    /** obj -\u003e wire handle map */\n    private final HandleTable handles;\n    /** obj -\u003e replacement obj map */\n    private final ReplaceTable subs;\n    /** stream protocol version */\n    private int protocol \u003d PROTOCOL_VERSION_2;\n    /** recursion depth */\n    private int depth;\n\n    /** buffer for writing primitive field values */\n    private byte[] primVals;\n\n    /** if true, invoke writeObjectOverride() instead of writeObject() */\n    private final boolean enableOverride;\n    /** if true, invoke replaceObject() */\n    private boolean enableReplace;\n\n    // values below valid only during upcalls to writeObject()/writeExternal()\n    /**\n     * Context during upcalls to class-defined writeObject methods; holds\n     * object currently being serialized and descriptor for current class.\n     * Null when not during writeObject upcall.\n     */\n    private SerialCallbackContext curContext;\n    /** current PutField object */\n    private PutFieldImpl curPut;\n\n    /** custom storage for debug trace info */\n    private final DebugTraceInfoStack debugInfoStack;\n\n    /**\n     * value of \"sun.io.serialization.extendedDebugInfo\" property,\n     * as true or false for extended information about exception\u0027s place\n     */\n    @SuppressWarnings(\"removal\")\n    private static final boolean extendedDebugInfo \u003d\n        java.security.AccessController.doPrivileged(\n            new sun.security.action.GetBooleanAction(\n                \"sun.io.serialization.extendedDebugInfo\")).booleanValue();\n\n    /**\n     * Creates an ObjectOutputStream that writes to the specified OutputStream.\n     * This constructor writes the serialization stream header to the\n     * underlying stream; callers may wish to flush the stream immediately to\n     * ensure that constructors for receiving ObjectInputStreams will not block\n     * when reading the header.\n     *\n     * \u003cp\u003eIf a security manager is installed, this constructor will check for\n     * the \"enableSubclassImplementation\" SerializablePermission when invoked\n     * directly or indirectly by the constructor of a subclass which overrides\n     * the ObjectOutputStream.putFields or ObjectOutputStream.writeUnshared\n     * methods.\n     *\n     * @param   out output stream to write to\n     * @throws  IOException if an I/O error occurs while writing stream header\n     * @throws  SecurityException if untrusted subclass illegally overrides\n     *          security-sensitive methods\n     * @throws  NullPointerException if {@code out} is {@code null}\n     * @since   1.4\n     * @see     ObjectOutputStream#ObjectOutputStream()\n     * @see     ObjectOutputStream#putFields()\n     * @see     ObjectInputStream#ObjectInputStream(InputStream)\n     */\n    public ObjectOutputStream(OutputStream out) throws IOException {\n        verifySubclass();\n        bout \u003d new BlockDataOutputStream(out);\n        handles \u003d new HandleTable(10, (float) 3.00);\n        subs \u003d new ReplaceTable(10, (float) 3.00);\n        enableOverride \u003d false;\n        writeStreamHeader();\n        bout.setBlockDataMode(true);\n        if (extendedDebugInfo) {\n            debugInfoStack \u003d new DebugTraceInfoStack();\n        } else {\n            debugInfoStack \u003d null;\n        }\n    }\n\n    /**\n     * Provide a way for subclasses that are completely reimplementing\n     * ObjectOutputStream to not have to allocate private data just used by\n     * this implementation of ObjectOutputStream.\n     *\n     * \u003cp\u003eIf there is a security manager installed, this method first calls the\n     * security manager\u0027s {@code checkPermission} method with a\n     * {@code SerializablePermission(\"enableSubclassImplementation\")}\n     * permission to ensure it\u0027s ok to enable subclassing.\n     *\n     * @throws  SecurityException if a security manager exists and its\n     *          {@code checkPermission} method denies enabling\n     *          subclassing.\n     * @throws  IOException if an I/O error occurs while creating this stream\n     * @see SecurityManager#checkPermission\n     * @see java.io.SerializablePermission\n     */\n    protected ObjectOutputStream() throws IOException, SecurityException {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d System.getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);\n        }\n        bout \u003d null;\n        handles \u003d null;\n        subs \u003d null;\n        enableOverride \u003d true;\n        debugInfoStack \u003d null;\n    }\n\n    /**\n     * Specify stream protocol version to use when writing the stream.\n     *\n     * \u003cp\u003eThis routine provides a hook to enable the current version of\n     * Serialization to write in a format that is backwards compatible to a\n     * previous version of the stream format.\n     *\n     * \u003cp\u003eEvery effort will be made to avoid introducing additional\n     * backwards incompatibilities; however, sometimes there is no\n     * other alternative.\n     *\n     * @param   version use ProtocolVersion from java.io.ObjectStreamConstants.\n     * @throws  IllegalStateException if called after any objects\n     *          have been serialized.\n     * @throws  IllegalArgumentException if invalid version is passed in.\n     * @throws  IOException if I/O errors occur\n     * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_1\n     * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_2\n     * @since   1.2\n     */\n    public void useProtocolVersion(int version) throws IOException {\n        if (handles.size() !\u003d 0) {\n            // REMIND: implement better check for pristine stream?\n            throw new IllegalStateException(\"stream non-empty\");\n        }\n        switch (version) {\n            case PROTOCOL_VERSION_1:\n            case PROTOCOL_VERSION_2:\n                protocol \u003d version;\n                break;\n\n            default:\n                throw new IllegalArgumentException(\n                    \"unknown version: \" + version);\n        }\n    }\n\n    /**\n     * Write the specified object to the ObjectOutputStream.  The class of the\n     * object, the signature of the class, and the values of the non-transient\n     * and non-static fields of the class and all of its supertypes are\n     * written.  Default serialization for a class can be overridden using the\n     * writeObject and the readObject methods.  Objects referenced by this\n     * object are written transitively so that a complete equivalent graph of\n     * objects can be reconstructed by an ObjectInputStream.\n     *\n     * \u003cp\u003eExceptions are thrown for problems with the OutputStream and for\n     * classes that should not be serialized.  All exceptions are fatal to the\n     * OutputStream, which is left in an indeterminate state, and it is up to\n     * the caller to ignore or recover the stream state.\n     *\n     * @throws  InvalidClassException Something is wrong with a class used by\n     *          serialization.\n     * @throws  NotSerializableException Some object to be serialized does not\n     *          implement the java.io.Serializable interface.\n     * @throws  IOException Any exception thrown by the underlying\n     *          OutputStream.\n     */\n    public final void writeObject(Object obj) throws IOException {\n        if (enableOverride) {\n            writeObjectOverride(obj);\n            return;\n        }\n        try {\n            writeObject0(obj, false);\n        } catch (IOException ex) {\n            if (depth \u003d\u003d 0) {\n                writeFatalException(ex);\n            }\n            throw ex;\n        }\n    }\n\n    /**\n     * Method used by subclasses to override the default writeObject method.\n     * This method is called by trusted subclasses of ObjectOutputStream that\n     * constructed ObjectOutputStream using the protected no-arg constructor.\n     * The subclass is expected to provide an override method with the modifier\n     * \"final\".\n     *\n     * @param   obj object to be written to the underlying stream\n     * @throws  IOException if there are I/O errors while writing to the\n     *          underlying stream\n     * @see #ObjectOutputStream()\n     * @see #writeObject(Object)\n     * @since 1.2\n     */\n    protected void writeObjectOverride(Object obj) throws IOException {\n    }\n\n    /**\n     * Writes an \"unshared\" object to the ObjectOutputStream.  This method is\n     * identical to writeObject, except that it always writes the given object\n     * as a new, unique object in the stream (as opposed to a back-reference\n     * pointing to a previously serialized instance).  Specifically:\n     * \u003cul\u003e\n     *   \u003cli\u003eAn object written via writeUnshared is always serialized in the\n     *       same manner as a newly appearing object (an object that has not\n     *       been written to the stream yet), regardless of whether or not the\n     *       object has been written previously.\n     *\n     *   \u003cli\u003eIf writeObject is used to write an object that has been previously\n     *       written with writeUnshared, the previous writeUnshared operation\n     *       is treated as if it were a write of a separate object.  In other\n     *       words, ObjectOutputStream will never generate back-references to\n     *       object data written by calls to writeUnshared.\n     * \u003c/ul\u003e\n     * While writing an object via writeUnshared does not in itself guarantee a\n     * unique reference to the object when it is deserialized, it allows a\n     * single object to be defined multiple times in a stream, so that multiple\n     * calls to readUnshared by the receiver will not conflict.  Note that the\n     * rules described above only apply to the base-level object written with\n     * writeUnshared, and not to any transitively referenced sub-objects in the\n     * object graph to be serialized.\n     *\n     * \u003cp\u003eObjectOutputStream subclasses which override this method can only be\n     * constructed in security contexts possessing the\n     * \"enableSubclassImplementation\" SerializablePermission; any attempt to\n     * instantiate such a subclass without this permission will cause a\n     * SecurityException to be thrown.\n     *\n     * @param   obj object to write to stream\n     * @throws  NotSerializableException if an object in the graph to be\n     *          serialized does not implement the Serializable interface\n     * @throws  InvalidClassException if a problem exists with the class of an\n     *          object to be serialized\n     * @throws  IOException if an I/O error occurs during serialization\n     * @since 1.4\n     */\n    public void writeUnshared(Object obj) throws IOException {\n        try {\n            writeObject0(obj, true);\n        } catch (IOException ex) {\n            if (depth \u003d\u003d 0) {\n                writeFatalException(ex);\n            }\n            throw ex;\n        }\n    }\n\n    /**\n     * Write the non-static and non-transient fields of the current class to\n     * this stream.  This may only be called from the writeObject method of the\n     * class being serialized. It will throw the NotActiveException if it is\n     * called otherwise.\n     *\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          {@code OutputStream}\n     */\n    public void defaultWriteObject() throws IOException {\n        SerialCallbackContext ctx \u003d curContext;\n        if (ctx \u003d\u003d null) {\n            throw new NotActiveException(\"not in call to writeObject\");\n        }\n        Object curObj \u003d ctx.getObj();\n        ObjectStreamClass curDesc \u003d ctx.getDesc();\n        bout.setBlockDataMode(false);\n        defaultWriteFields(curObj, curDesc);\n        bout.setBlockDataMode(true);\n    }\n\n    /**\n     * Retrieve the object used to buffer persistent fields to be written to\n     * the stream.  The fields will be written to the stream when writeFields\n     * method is called.\n     *\n     * @return  an instance of the class Putfield that holds the serializable\n     *          fields\n     * @throws  IOException if I/O errors occur\n     * @since 1.2\n     */\n    public ObjectOutputStream.PutField putFields() throws IOException {\n        if (curPut \u003d\u003d null) {\n            SerialCallbackContext ctx \u003d curContext;\n            if (ctx \u003d\u003d null) {\n                throw new NotActiveException(\"not in call to writeObject\");\n            }\n            ctx.checkAndSetUsed();\n            ObjectStreamClass curDesc \u003d ctx.getDesc();\n            curPut \u003d new PutFieldImpl(curDesc);\n        }\n        return curPut;\n    }\n\n    /**\n     * Write the buffered fields to the stream.\n     *\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     * @throws  NotActiveException Called when a classes writeObject method was\n     *          not called to write the state of the object.\n     * @since 1.2\n     */\n    public void writeFields() throws IOException {\n        if (curPut \u003d\u003d null) {\n            throw new NotActiveException(\"no current PutField object\");\n        }\n        bout.setBlockDataMode(false);\n        curPut.writeFields();\n        bout.setBlockDataMode(true);\n    }\n\n    /**\n     * Reset will disregard the state of any objects already written to the\n     * stream.  The state is reset to be the same as a new ObjectOutputStream.\n     * The current point in the stream is marked as reset so the corresponding\n     * ObjectInputStream will be reset at the same point.  Objects previously\n     * written to the stream will not be referred to as already being in the\n     * stream.  They will be written to the stream again.\n     *\n     * @throws  IOException if reset() is invoked while serializing an object.\n     */\n    public void reset() throws IOException {\n        if (depth !\u003d 0) {\n            throw new IOException(\"stream active\");\n        }\n        bout.setBlockDataMode(false);\n        bout.writeByte(TC_RESET);\n        clear();\n        bout.setBlockDataMode(true);\n    }\n\n    /**\n     * Subclasses may implement this method to allow class data to be stored in\n     * the stream. By default this method does nothing.  The corresponding\n     * method in ObjectInputStream is resolveClass.  This method is called\n     * exactly once for each unique class in the stream.  The class name and\n     * signature will have already been written to the stream.  This method may\n     * make free use of the ObjectOutputStream to save any representation of\n     * the class it deems suitable (for example, the bytes of the class file).\n     * The resolveClass method in the corresponding subclass of\n     * ObjectInputStream must read and use any data or objects written by\n     * annotateClass.\n     *\n     * @param   cl the class to annotate custom data for\n     * @throws  IOException Any exception thrown by the underlying\n     *          OutputStream.\n     */\n    protected void annotateClass(Class\u003c?\u003e cl) throws IOException {\n    }\n\n    /**\n     * Subclasses may implement this method to store custom data in the stream\n     * along with descriptors for dynamic proxy classes.\n     *\n     * \u003cp\u003eThis method is called exactly once for each unique proxy class\n     * descriptor in the stream.  The default implementation of this method in\n     * {@code ObjectOutputStream} does nothing.\n     *\n     * \u003cp\u003eThe corresponding method in {@code ObjectInputStream} is\n     * {@code resolveProxyClass}.  For a given subclass of\n     * {@code ObjectOutputStream} that overrides this method, the\n     * {@code resolveProxyClass} method in the corresponding subclass of\n     * {@code ObjectInputStream} must read any data or objects written by\n     * {@code annotateProxyClass}.\n     *\n     * @param   cl the proxy class to annotate custom data for\n     * @throws  IOException any exception thrown by the underlying\n     *          {@code OutputStream}\n     * @see ObjectInputStream#resolveProxyClass(String[])\n     * @since   1.3\n     */\n    protected void annotateProxyClass(Class\u003c?\u003e cl) throws IOException {\n    }\n\n    /**\n     * This method will allow trusted subclasses of ObjectOutputStream to\n     * substitute one object for another during serialization. Replacing\n     * objects is disabled until enableReplaceObject is called. The\n     * enableReplaceObject method checks that the stream requesting to do\n     * replacement can be trusted.  The first occurrence of each object written\n     * into the serialization stream is passed to replaceObject.  Subsequent\n     * references to the object are replaced by the object returned by the\n     * original call to replaceObject.  To ensure that the private state of\n     * objects is not unintentionally exposed, only trusted streams may use\n     * replaceObject.\n     *\n     * \u003cp\u003eThe ObjectOutputStream.writeObject method takes a parameter of type\n     * Object (as opposed to type Serializable) to allow for cases where\n     * non-serializable objects are replaced by serializable ones.\n     *\n     * \u003cp\u003eWhen a subclass is replacing objects it must ensure that either a\n     * complementary substitution must be made during deserialization or that\n     * the substituted object is compatible with every field where the\n     * reference will be stored.  Objects whose type is not a subclass of the\n     * type of the field or array element abort the serialization by raising an\n     * exception and the object is not be stored.\n     *\n     * \u003cp\u003eThis method is called only once when each object is first\n     * encountered.  All subsequent references to the object will be redirected\n     * to the new object. This method should return the object to be\n     * substituted or the original object.\n     *\n     * \u003cp\u003eNull can be returned as the object to be substituted, but may cause\n     * {@link NullPointerException} in classes that contain references to the\n     * original object since they may be expecting an object instead of\n     * null.\n     *\n     * @param   obj the object to be replaced\n     * @return  the alternate object that replaced the specified one\n     * @throws  IOException Any exception thrown by the underlying\n     *          OutputStream.\n     */\n    protected Object replaceObject(Object obj) throws IOException {\n        return obj;\n    }\n\n    /**\n     * Enables the stream to do replacement of objects written to the stream.  When\n     * enabled, the {@link #replaceObject} method is called for every object being\n     * serialized.\n     *\n     * \u003cp\u003eIf object replacement is currently not enabled, and\n     * {@code enable} is true, and there is a security manager installed,\n     * this method first calls the security manager\u0027s\n     * {@code checkPermission} method with the\n     * {@code SerializablePermission(\"enableSubstitution\")} permission to\n     * ensure that the caller is permitted to enable the stream to do replacement\n     * of objects written to the stream.\n     *\n     * @param   enable true for enabling use of {@code replaceObject} for\n     *          every object being serialized\n     * @return  the previous setting before this method was invoked\n     * @throws  SecurityException if a security manager exists and its\n     *          {@code checkPermission} method denies enabling the stream\n     *          to do replacement of objects written to the stream.\n     * @see SecurityManager#checkPermission\n     * @see java.io.SerializablePermission\n     */\n    protected boolean enableReplaceObject(boolean enable)\n        throws SecurityException\n    {\n        if (enable \u003d\u003d enableReplace) {\n            return enable;\n        }\n        if (enable) {\n            @SuppressWarnings(\"removal\")\n            SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(SUBSTITUTION_PERMISSION);\n            }\n        }\n        enableReplace \u003d enable;\n        return !enableReplace;\n    }\n\n    /**\n     * The writeStreamHeader method is provided so subclasses can append or\n     * prepend their own header to the stream.  It writes the magic number and\n     * version to the stream.\n     *\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    protected void writeStreamHeader() throws IOException {\n        bout.writeShort(STREAM_MAGIC);\n        bout.writeShort(STREAM_VERSION);\n    }\n\n    /**\n     * Write the specified class descriptor to the ObjectOutputStream.  Class\n     * descriptors are used to identify the classes of objects written to the\n     * stream.  Subclasses of ObjectOutputStream may override this method to\n     * customize the way in which class descriptors are written to the\n     * serialization stream.  The corresponding method in ObjectInputStream,\n     * {@link ObjectInputStream#readClassDescriptor readClassDescriptor}, should then be overridden to\n     * reconstitute the class descriptor from its custom stream representation.\n     * By default, this method writes class descriptors according to the format\n     * defined in the \u003ca href\u003d\"{@docRoot}/../specs/serialization/index.html\"\u003e\n     * \u003ccite\u003eJava Object Serialization Specification\u003c/cite\u003e\u003c/a\u003e.\n     *\n     * \u003cp\u003eNote that this method will only be called if the ObjectOutputStream\n     * is not using the old serialization stream format (set by calling\n     * ObjectOutputStream\u0027s {@code useProtocolVersion} method).  If this\n     * serialization stream is using the old format\n     * ({@code PROTOCOL_VERSION_1}), the class descriptor will be written\n     * internally in a manner that cannot be overridden or customized.\n     *\n     * @param   desc class descriptor to write to the stream\n     * @throws  IOException If an I/O error has occurred.\n     * @spec serialization/index.html Java Object Serialization Specification\n     * @see java.io.ObjectInputStream#readClassDescriptor()\n     * @see #useProtocolVersion(int)\n     * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_1\n     * @since 1.3\n     */\n    protected void writeClassDescriptor(ObjectStreamClass desc)\n        throws IOException\n    {\n        desc.writeNonProxy(this);\n    }\n\n    /**\n     * Writes a byte. This method will block until the byte is actually\n     * written.\n     *\n     * @param   val the byte to be written to the stream\n     * @throws  IOException If an I/O error has occurred.\n     */\n    @Override\n    public void write(int val) throws IOException {\n        bout.write(val);\n    }\n\n    /**\n     * Writes an array of bytes. This method will block until the bytes are\n     * actually written.\n     *\n     * @param   buf the data to be written\n     * @throws  IOException If an I/O error has occurred.\n     */\n    @Override\n    public void write(byte[] buf) throws IOException {\n        bout.write(buf, 0, buf.length, false);\n    }\n\n    /**\n     * Writes a sub array of bytes.\n     *\n     * @param   buf the data to be written\n     * @param   off the start offset in the data\n     * @param   len the number of bytes that are written\n     * @throws  IOException {@inheritDoc}\n     * @throws  IndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public void write(byte[] buf, int off, int len) throws IOException {\n        if (buf \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        Objects.checkFromIndexSize(off, len, buf.length);\n        bout.write(buf, off, len, false);\n    }\n\n    /**\n     * Flushes the stream. This will write any buffered output bytes and flush\n     * through to the underlying stream.\n     *\n     * @throws  IOException {@inheritDoc}\n     */\n    @Override\n    public void flush() throws IOException {\n        bout.flush();\n    }\n\n    /**\n     * Drain any buffered data in ObjectOutputStream.  Similar to flush but\n     * does not propagate the flush to the underlying stream.\n     *\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    protected void drain() throws IOException {\n        bout.drain();\n    }\n\n    /**\n     * Closes the stream. This method must be called to release any resources\n     * associated with the stream.\n     *\n     * @throws  IOException If an I/O error has occurred.\n     */\n    @Override\n    public void close() throws IOException {\n        flush();\n        clear();\n        bout.close();\n    }\n\n    /**\n     * Writes a boolean.\n     *\n     * @param   val the boolean to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeBoolean(boolean val) throws IOException {\n        bout.writeBoolean(val);\n    }\n\n    /**\n     * Writes an 8-bit byte.\n     *\n     * @param   val the byte value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeByte(int val) throws IOException  {\n        bout.writeByte(val);\n    }\n\n    /**\n     * Writes a 16-bit short.\n     *\n     * @param   val the short value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeShort(int val)  throws IOException {\n        bout.writeShort(val);\n    }\n\n    /**\n     * Writes a 16-bit char.\n     *\n     * @param   val the char value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeChar(int val)  throws IOException {\n        bout.writeChar(val);\n    }\n\n    /**\n     * Writes a 32-bit int.\n     *\n     * @param   val the integer value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeInt(int val)  throws IOException {\n        bout.writeInt(val);\n    }\n\n    /**\n     * Writes a 64-bit long.\n     *\n     * @param   val the long value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeLong(long val)  throws IOException {\n        bout.writeLong(val);\n    }\n\n    /**\n     * Writes a 32-bit float.\n     *\n     * @param   val the float value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeFloat(float val) throws IOException {\n        bout.writeFloat(val);\n    }\n\n    /**\n     * Writes a 64-bit double.\n     *\n     * @param   val the double value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeDouble(double val) throws IOException {\n        bout.writeDouble(val);\n    }\n\n    /**\n     * Writes a String as a sequence of bytes.\n     *\n     * @param   str the String of bytes to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeBytes(String str) throws IOException {\n        bout.writeBytes(str);\n    }\n\n    /**\n     * Writes a String as a sequence of chars.\n     *\n     * @param   str the String of chars to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeChars(String str) throws IOException {\n        bout.writeChars(str);\n    }\n\n    /**\n     * Primitive data write of this String in\n     * \u003ca href\u003d\"DataInput.html#modified-utf-8\"\u003emodified UTF-8\u003c/a\u003e\n     * format.  Note that there is a\n     * significant difference between writing a String into the stream as\n     * primitive data or as an Object. A String instance written by writeObject\n     * is written into the stream as a String initially. Future writeObject()\n     * calls write references to the string into the stream.\n     *\n     * @param   str the String to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeUTF(String str) throws IOException {\n        bout.writeUTF(str);\n    }\n\n    /**\n     * Provide programmatic access to the persistent fields to be written\n     * to ObjectOutput.\n     *\n     * @since 1.2\n     */\n    public abstract static class PutField {\n        /**\n         * Constructor for subclasses to call.\n         */\n        public PutField() {}\n\n        /**\n         * Put the value of the named boolean field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code boolean}\n         */\n        public abstract void put(String name, boolean val);\n\n        /**\n         * Put the value of the named byte field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code byte}\n         */\n        public abstract void put(String name, byte val);\n\n        /**\n         * Put the value of the named char field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code char}\n         */\n        public abstract void put(String name, char val);\n\n        /**\n         * Put the value of the named short field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code short}\n         */\n        public abstract void put(String name, short val);\n\n        /**\n         * Put the value of the named int field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code int}\n         */\n        public abstract void put(String name, int val);\n\n        /**\n         * Put the value of the named long field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code long}\n         */\n        public abstract void put(String name, long val);\n\n        /**\n         * Put the value of the named float field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code float}\n         */\n        public abstract void put(String name, float val);\n\n        /**\n         * Put the value of the named double field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code double}\n         */\n        public abstract void put(String name, double val);\n\n        /**\n         * Put the value of the named Object field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         *         (which may be {@code null})\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not a\n         * reference type\n         */\n        public abstract void put(String name, Object val);\n\n        /**\n         * Write the data and fields to the specified ObjectOutput stream,\n         * which must be the same stream that produced this\n         * {@code PutField} object.\n         *\n         * @param  out the stream to write the data and fields to\n         * @throws IOException if I/O errors occur while writing to the\n         *         underlying stream\n         * @throws IllegalArgumentException if the specified stream is not\n         *         the same stream that produced this {@code PutField}\n         *         object\n         * @deprecated This method does not write the values contained by this\n         *         {@code PutField} object in a proper format, and may\n         *         result in corruption of the serialization stream.  The\n         *         correct way to write {@code PutField} data is by\n         *         calling the {@link java.io.ObjectOutputStream#writeFields()}\n         *         method.\n         */\n        @Deprecated\n        public abstract void write(ObjectOutput out) throws IOException;\n    }\n\n\n    /**\n     * Returns protocol version in use.\n     */\n    int getProtocolVersion() {\n        return protocol;\n    }\n\n    /**\n     * Writes string without allowing it to be replaced in stream.  Used by\n     * ObjectStreamClass to write class descriptor type strings.\n     */\n    void writeTypeString(String str) throws IOException {\n        int handle;\n        if (str \u003d\u003d null) {\n            writeNull();\n        } else if ((handle \u003d handles.lookup(str)) !\u003d -1) {\n            writeHandle(handle);\n        } else {\n            writeString(str, false);\n        }\n    }\n\n    /**\n     * Verifies that this (possibly subclass) instance can be constructed\n     * without violating security constraints: the subclass must not override\n     * security-sensitive non-final methods, or else the\n     * \"enableSubclassImplementation\" SerializablePermission is checked.\n     */\n    private void verifySubclass() {\n        Class\u003c?\u003e cl \u003d getClass();\n        if (cl \u003d\u003d ObjectOutputStream.class) {\n            return;\n        }\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d System.getSecurityManager();\n        if (sm \u003d\u003d null) {\n            return;\n        }\n        boolean result \u003d Caches.subclassAudits.get(cl);\n        if (!result) {\n            sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);\n        }\n    }\n\n    /**\n     * Performs reflective checks on given subclass to verify that it doesn\u0027t\n     * override security-sensitive non-final methods.  Returns TRUE if subclass\n     * is \"safe\", FALSE otherwise.\n     */\n    @SuppressWarnings(\"removal\")\n    private static Boolean auditSubclass(Class\u003c?\u003e subcl) {\n        return AccessController.doPrivileged(\n            new PrivilegedAction\u003c\u003e() {\n                public Boolean run() {\n                    for (Class\u003c?\u003e cl \u003d subcl;\n                         cl !\u003d ObjectOutputStream.class;\n                         cl \u003d cl.getSuperclass())\n                    {\n                        try {\n                            cl.getDeclaredMethod(\n                                \"writeUnshared\", new Class\u003c?\u003e[] { Object.class });\n                            return Boolean.FALSE;\n                        } catch (NoSuchMethodException ex) {\n                        }\n                        try {\n                            cl.getDeclaredMethod(\"putFields\", (Class\u003c?\u003e[]) null);\n                            return Boolean.FALSE;\n                        } catch (NoSuchMethodException ex) {\n                        }\n                    }\n                    return Boolean.TRUE;\n                }\n            }\n        );\n    }\n\n    /**\n     * Clears internal data structures.\n     */\n    private void clear() {\n        subs.clear();\n        handles.clear();\n    }\n\n    /**\n     * Underlying writeObject/writeUnshared implementation.\n     */\n    private void writeObject0(Object obj, boolean unshared)\n        throws IOException\n    {\n        boolean oldMode \u003d bout.setBlockDataMode(false);\n        depth++;\n        try {\n            // handle previously written and non-replaceable objects\n            int h;\n            if ((obj \u003d subs.lookup(obj)) \u003d\u003d null) {\n                writeNull();\n                return;\n            } else if (!unshared \u0026\u0026 (h \u003d handles.lookup(obj)) !\u003d -1) {\n                writeHandle(h);\n                return;\n            } else if (obj instanceof Class) {\n                writeClass((Class) obj, unshared);\n                return;\n            } else if (obj instanceof ObjectStreamClass) {\n                writeClassDesc((ObjectStreamClass) obj, unshared);\n                return;\n            }\n\n            // check for replacement object\n            Object orig \u003d obj;\n            Class\u003c?\u003e cl \u003d obj.getClass();\n            ObjectStreamClass desc;\n            for (;;) {\n                // REMIND: skip this check for strings/arrays?\n                Class\u003c?\u003e repCl;\n                desc \u003d ObjectStreamClass.lookup(cl, true);\n                if (!desc.hasWriteReplaceMethod() ||\n                    (obj \u003d desc.invokeWriteReplace(obj)) \u003d\u003d null ||\n                    (repCl \u003d obj.getClass()) \u003d\u003d cl)\n                {\n                    break;\n                }\n                cl \u003d repCl;\n            }\n            if (enableReplace) {\n                Object rep \u003d replaceObject(obj);\n                if (rep !\u003d obj \u0026\u0026 rep !\u003d null) {\n                    cl \u003d rep.getClass();\n                    desc \u003d ObjectStreamClass.lookup(cl, true);\n                }\n                obj \u003d rep;\n            }\n\n            // if object replaced, run through original checks a second time\n            if (obj !\u003d orig) {\n                subs.assign(orig, obj);\n                if (obj \u003d\u003d null) {\n                    writeNull();\n                    return;\n                } else if (!unshared \u0026\u0026 (h \u003d handles.lookup(obj)) !\u003d -1) {\n                    writeHandle(h);\n                    return;\n                } else if (obj instanceof Class) {\n                    writeClass((Class) obj, unshared);\n                    return;\n                } else if (obj instanceof ObjectStreamClass) {\n                    writeClassDesc((ObjectStreamClass) obj, unshared);\n                    return;\n                }\n            }\n\n            // remaining cases\n            if (obj instanceof String) {\n                writeString((String) obj, unshared);\n            } else if (cl.isArray()) {\n                writeArray(obj, desc, unshared);\n            } else if (obj instanceof Enum) {\n                writeEnum((Enum\u003c?\u003e) obj, desc, unshared);\n            } else if (obj instanceof Serializable) {\n                writeOrdinaryObject(obj, desc, unshared);\n            } else {\n                if (extendedDebugInfo) {\n                    throw new NotSerializableException(\n                        cl.getName() + \"\\n\" + debugInfoStack.toString());\n                } else {\n                    throw new NotSerializableException(cl.getName());\n                }\n            }\n        } finally {\n            depth--;\n            bout.setBlockDataMode(oldMode);\n        }\n    }\n\n    /**\n     * Writes null code to stream.\n     */\n    private void writeNull() throws IOException {\n        bout.writeByte(TC_NULL);\n    }\n\n    /**\n     * Writes given object handle to stream.\n     */\n    private void writeHandle(int handle) throws IOException {\n        bout.writeByte(TC_REFERENCE);\n        bout.writeInt(baseWireHandle + handle);\n    }\n\n    /**\n     * Writes representation of given class to stream.\n     */\n    private void writeClass(Class\u003c?\u003e cl, boolean unshared) throws IOException {\n        bout.writeByte(TC_CLASS);\n        writeClassDesc(ObjectStreamClass.lookup(cl, true), false);\n        handles.assign(unshared ? null : cl);\n    }\n\n    /**\n     * Writes representation of given class descriptor to stream.\n     */\n    private void writeClassDesc(ObjectStreamClass desc, boolean unshared)\n        throws IOException\n    {\n        int handle;\n        if (desc \u003d\u003d null) {\n            writeNull();\n        } else if (!unshared \u0026\u0026 (handle \u003d handles.lookup(desc)) !\u003d -1) {\n            writeHandle(handle);\n        } else if (desc.isProxy()) {\n            writeProxyDesc(desc, unshared);\n        } else {\n            writeNonProxyDesc(desc, unshared);\n        }\n    }\n\n    private boolean isCustomSubclass() {\n        // Return true if this class is a custom subclass of ObjectOutputStream\n        return getClass().getClassLoader()\n                   !\u003d ObjectOutputStream.class.getClassLoader();\n    }\n\n    /**\n     * Writes class descriptor representing a dynamic proxy class to stream.\n     */\n    private void writeProxyDesc(ObjectStreamClass desc, boolean unshared)\n        throws IOException\n    {\n        bout.writeByte(TC_PROXYCLASSDESC);\n        handles.assign(unshared ? null : desc);\n\n        Class\u003c?\u003e cl \u003d desc.forClass();\n        Class\u003c?\u003e[] ifaces \u003d cl.getInterfaces();\n        bout.writeInt(ifaces.length);\n        for (int i \u003d 0; i \u003c ifaces.length; i++) {\n            bout.writeUTF(ifaces[i].getName());\n        }\n\n        bout.setBlockDataMode(true);\n        if (cl !\u003d null \u0026\u0026 isCustomSubclass()) {\n            ReflectUtil.checkPackageAccess(cl);\n        }\n        annotateProxyClass(cl);\n        bout.setBlockDataMode(false);\n        bout.writeByte(TC_ENDBLOCKDATA);\n\n        writeClassDesc(desc.getSuperDesc(), false);\n    }\n\n    /**\n     * Writes class descriptor representing a standard (i.e., not a dynamic\n     * proxy) class to stream.\n     */\n    private void writeNonProxyDesc(ObjectStreamClass desc, boolean unshared)\n        throws IOException\n    {\n        bout.writeByte(TC_CLASSDESC);\n        handles.assign(unshared ? null : desc);\n\n        if (protocol \u003d\u003d PROTOCOL_VERSION_1) {\n            // do not invoke class descriptor write hook with old protocol\n            desc.writeNonProxy(this);\n        } else {\n            writeClassDescriptor(desc);\n        }\n\n        Class\u003c?\u003e cl \u003d desc.forClass();\n        bout.setBlockDataMode(true);\n        if (cl !\u003d null \u0026\u0026 isCustomSubclass()) {\n            ReflectUtil.checkPackageAccess(cl);\n        }\n        annotateClass(cl);\n        bout.setBlockDataMode(false);\n        bout.writeByte(TC_ENDBLOCKDATA);\n\n        writeClassDesc(desc.getSuperDesc(), false);\n    }\n\n    /**\n     * Writes given string to stream, using standard or long UTF format\n     * depending on string length.\n     */\n    private void writeString(String str, boolean unshared) throws IOException {\n        handles.assign(unshared ? null : str);\n        long utflen \u003d bout.getUTFLength(str);\n        if (utflen \u003c\u003d 0xFFFF) {\n            bout.writeByte(TC_STRING);\n            bout.writeUTF(str, utflen);\n        } else {\n            bout.writeByte(TC_LONGSTRING);\n            bout.writeLongUTF(str, utflen);\n        }\n    }\n\n    /**\n     * Writes given array object to stream.\n     */\n    private void writeArray(Object array,\n                            ObjectStreamClass desc,\n                            boolean unshared)\n        throws IOException\n    {\n        bout.writeByte(TC_ARRAY);\n        writeClassDesc(desc, false);\n        handles.assign(unshared ? null : array);\n\n        Class\u003c?\u003e ccl \u003d desc.forClass().getComponentType();\n        if (ccl.isPrimitive()) {\n            if (ccl \u003d\u003d Integer.TYPE) {\n                int[] ia \u003d (int[]) array;\n                bout.writeInt(ia.length);\n                bout.writeInts(ia, 0, ia.length);\n            } else if (ccl \u003d\u003d Byte.TYPE) {\n                byte[] ba \u003d (byte[]) array;\n                bout.writeInt(ba.length);\n                bout.write(ba, 0, ba.length, true);\n            } else if (ccl \u003d\u003d Long.TYPE) {\n                long[] ja \u003d (long[]) array;\n                bout.writeInt(ja.length);\n                bout.writeLongs(ja, 0, ja.length);\n            } else if (ccl \u003d\u003d Float.TYPE) {\n                float[] fa \u003d (float[]) array;\n                bout.writeInt(fa.length);\n                bout.writeFloats(fa, 0, fa.length);\n            } else if (ccl \u003d\u003d Double.TYPE) {\n                double[] da \u003d (double[]) array;\n                bout.writeInt(da.length);\n                bout.writeDoubles(da, 0, da.length);\n            } else if (ccl \u003d\u003d Short.TYPE) {\n                short[] sa \u003d (short[]) array;\n                bout.writeInt(sa.length);\n                bout.writeShorts(sa, 0, sa.length);\n            } else if (ccl \u003d\u003d Character.TYPE) {\n                char[] ca \u003d (char[]) array;\n                bout.writeInt(ca.length);\n                bout.writeChars(ca, 0, ca.length);\n            } else if (ccl \u003d\u003d Boolean.TYPE) {\n                boolean[] za \u003d (boolean[]) array;\n                bout.writeInt(za.length);\n                bout.writeBooleans(za, 0, za.length);\n            } else {\n                throw new InternalError();\n            }\n        } else {\n            Object[] objs \u003d (Object[]) array;\n            int len \u003d objs.length;\n            bout.writeInt(len);\n            if (extendedDebugInfo) {\n                debugInfoStack.push(\n                    \"array (class \\\"\" + array.getClass().getName() +\n                    \"\\\", size: \" + len  + \")\");\n            }\n            try {\n                for (int i \u003d 0; i \u003c len; i++) {\n                    if (extendedDebugInfo) {\n                        debugInfoStack.push(\n                            \"element of array (index: \" + i + \")\");\n                    }\n                    try {\n                        writeObject0(objs[i], false);\n                    } finally {\n                        if (extendedDebugInfo) {\n                            debugInfoStack.pop();\n                        }\n                    }\n                }\n            } finally {\n                if (extendedDebugInfo) {\n                    debugInfoStack.pop();\n                }\n            }\n        }\n    }\n\n    /**\n     * Writes given enum constant to stream.\n     */\n    private void writeEnum(Enum\u003c?\u003e en,\n                           ObjectStreamClass desc,\n                           boolean unshared)\n        throws IOException\n    {\n        bout.writeByte(TC_ENUM);\n        ObjectStreamClass sdesc \u003d desc.getSuperDesc();\n        writeClassDesc((sdesc.forClass() \u003d\u003d Enum.class) ? desc : sdesc, false);\n        handles.assign(unshared ? null : en);\n        writeString(en.name(), false);\n    }\n\n    /**\n     * Writes representation of an \"ordinary\" (i.e., not a String, Class,\n     * ObjectStreamClass, array, or enum constant) serializable object to the\n     * stream.\n     */\n    private void writeOrdinaryObject(Object obj,\n                                     ObjectStreamClass desc,\n                                     boolean unshared)\n        throws IOException\n    {\n        if (extendedDebugInfo) {\n            debugInfoStack.push(\n                (depth \u003d\u003d 1 ? \"root \" : \"\") + \"object (class \\\"\" +\n                obj.getClass().getName() + \"\\\", \" + obj.toString() + \")\");\n        }\n        try {\n            desc.checkSerialize();\n\n            bout.writeByte(TC_OBJECT);\n            writeClassDesc(desc, false);\n            handles.assign(unshared ? null : obj);\n\n            if (desc.isRecord()) {\n                writeRecordData(obj, desc);\n            } else if (desc.isExternalizable() \u0026\u0026 !desc.isProxy()) {\n                writeExternalData((Externalizable) obj);\n            } else {\n                writeSerialData(obj, desc);\n            }\n        } finally {\n            if (extendedDebugInfo) {\n                debugInfoStack.pop();\n            }\n        }\n    }\n\n    /**\n     * Writes externalizable data of given object by invoking its\n     * writeExternal() method.\n     */\n    private void writeExternalData(Externalizable obj) throws IOException {\n        PutFieldImpl oldPut \u003d curPut;\n        curPut \u003d null;\n\n        if (extendedDebugInfo) {\n            debugInfoStack.push(\"writeExternal data\");\n        }\n        SerialCallbackContext oldContext \u003d curContext;\n        try {\n            curContext \u003d null;\n            if (protocol \u003d\u003d PROTOCOL_VERSION_1) {\n                obj.writeExternal(this);\n            } else {\n                bout.setBlockDataMode(true);\n                obj.writeExternal(this);\n                bout.setBlockDataMode(false);\n                bout.writeByte(TC_ENDBLOCKDATA);\n            }\n        } finally {\n            curContext \u003d oldContext;\n            if (extendedDebugInfo) {\n                debugInfoStack.pop();\n            }\n        }\n\n        curPut \u003d oldPut;\n    }\n\n    /** Writes the record component values for the given record object. */\n    private void writeRecordData(Object obj, ObjectStreamClass desc)\n        throws IOException\n    {\n        assert obj.getClass().isRecord();\n        ObjectStreamClass.ClassDataSlot[] slots \u003d desc.getClassDataLayout();\n        if (slots.length !\u003d 1) {\n            throw new InvalidClassException(\n                    \"expected a single record slot length, but found: \" + slots.length);\n        }\n\n        defaultWriteFields(obj, desc);  // #### seems unnecessary to use the accessors\n    }\n\n    /**\n     * Writes instance data for each serializable class of given object, from\n     * superclass to subclass.\n     */\n    private void writeSerialData(Object obj, ObjectStreamClass desc)\n        throws IOException\n    {\n        ObjectStreamClass.ClassDataSlot[] slots \u003d desc.getClassDataLayout();\n        for (int i \u003d 0; i \u003c slots.length; i++) {\n            ObjectStreamClass slotDesc \u003d slots[i].desc;\n            if (slotDesc.hasWriteObjectMethod()) {\n                PutFieldImpl oldPut \u003d curPut;\n                curPut \u003d null;\n                SerialCallbackContext oldContext \u003d curContext;\n\n                if (extendedDebugInfo) {\n                    debugInfoStack.push(\n                        \"custom writeObject data (class \\\"\" +\n                        slotDesc.getName() + \"\\\")\");\n                }\n                try {\n                    curContext \u003d new SerialCallbackContext(obj, slotDesc);\n                    bout.setBlockDataMode(true);\n                    slotDesc.invokeWriteObject(obj, this);\n                    bout.setBlockDataMode(false);\n                    bout.writeByte(TC_ENDBLOCKDATA);\n                } finally {\n                    curContext.setUsed();\n                    curContext \u003d oldContext;\n                    if (extendedDebugInfo) {\n                        debugInfoStack.pop();\n                    }\n                }\n\n                curPut \u003d oldPut;\n            } else {\n                defaultWriteFields(obj, slotDesc);\n            }\n        }\n    }\n\n    /**\n     * Fetches and writes values of serializable fields of given object to\n     * stream.  The given class descriptor specifies which field values to\n     * write, and in which order they should be written.\n     */\n    private void defaultWriteFields(Object obj, ObjectStreamClass desc)\n        throws IOException\n    {\n        Class\u003c?\u003e cl \u003d desc.forClass();\n        if (cl !\u003d null \u0026\u0026 obj !\u003d null \u0026\u0026 !cl.isInstance(obj)) {\n            throw new ClassCastException();\n        }\n\n        desc.checkDefaultSerialize();\n\n        int primDataSize \u003d desc.getPrimDataSize();\n        if (primDataSize \u003e 0) {\n            if (primVals \u003d\u003d null || primVals.length \u003c primDataSize) {\n                primVals \u003d new byte[primDataSize];\n            }\n            desc.getPrimFieldValues(obj, primVals);\n            bout.write(primVals, 0, primDataSize, false);\n        }\n\n        int numObjFields \u003d desc.getNumObjFields();\n        if (numObjFields \u003e 0) {\n            ObjectStreamField[] fields \u003d desc.getFields(false);\n            Object[] objVals \u003d new Object[numObjFields];\n            int numPrimFields \u003d fields.length - objVals.length;\n            desc.getObjFieldValues(obj, objVals);\n            for (int i \u003d 0; i \u003c objVals.length; i++) {\n                if (extendedDebugInfo) {\n                    debugInfoStack.push(\n                        \"field (class \\\"\" + desc.getName() + \"\\\", name: \\\"\" +\n                        fields[numPrimFields + i].getName() + \"\\\", type: \\\"\" +\n                        fields[numPrimFields + i].getType() + \"\\\")\");\n                }\n                try {\n                    writeObject0(objVals[i],\n                                 fields[numPrimFields + i].isUnshared());\n                } finally {\n                    if (extendedDebugInfo) {\n                        debugInfoStack.pop();\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Attempts to write to stream fatal IOException that has caused\n     * serialization to abort.\n     */\n    private void writeFatalException(IOException ex) throws IOException {\n        /*\n         * Note: the serialization specification states that if a second\n         * IOException occurs while attempting to serialize the original fatal\n         * exception to the stream, then a StreamCorruptedException should be\n         * thrown (section 2.1).  However, due to a bug in previous\n         * implementations of serialization, StreamCorruptedExceptions were\n         * rarely (if ever) actually thrown--the \"root\" exceptions from\n         * underlying streams were thrown instead.  This historical behavior is\n         * followed here for consistency.\n         */\n        clear();\n        boolean oldMode \u003d bout.setBlockDataMode(false);\n        try {\n            bout.writeByte(TC_EXCEPTION);\n            writeObject0(ex, false);\n            clear();\n        } finally {\n            bout.setBlockDataMode(oldMode);\n        }\n    }\n\n    /**\n     * Default PutField implementation.\n     */\n    private class PutFieldImpl extends PutField {\n\n        /** class descriptor describing serializable fields */\n        private final ObjectStreamClass desc;\n        /** primitive field values */\n        private final byte[] primVals;\n        /** object field values */\n        private final Object[] objVals;\n\n        /**\n         * Creates PutFieldImpl object for writing fields defined in given\n         * class descriptor.\n         */\n        PutFieldImpl(ObjectStreamClass desc) {\n            this.desc \u003d desc;\n            primVals \u003d new byte[desc.getPrimDataSize()];\n            objVals \u003d new Object[desc.getNumObjFields()];\n        }\n\n        public void put(String name, boolean val) {\n            ByteArray.setBoolean(primVals, getFieldOffset(name, Boolean.TYPE), val);\n        }\n\n        public void put(String name, byte val) {\n            primVals[getFieldOffset(name, Byte.TYPE)] \u003d val;\n        }\n\n        public void put(String name, char val) {\n            ByteArray.setChar(primVals, getFieldOffset(name, Character.TYPE), val);\n        }\n\n        public void put(String name, short val) {\n            ByteArray.setShort(primVals, getFieldOffset(name, Short.TYPE), val);\n        }\n\n        public void put(String name, int val) {\n            ByteArray.setInt(primVals, getFieldOffset(name, Integer.TYPE), val);\n        }\n\n        public void put(String name, float val) {\n            ByteArray.setFloat(primVals, getFieldOffset(name, Float.TYPE), val);\n        }\n\n        public void put(String name, long val) {\n            ByteArray.setLong(primVals, getFieldOffset(name, Long.TYPE), val);\n        }\n\n        public void put(String name, double val) {\n            ByteArray.setDouble(primVals, getFieldOffset(name, Double.TYPE), val);\n        }\n\n        public void put(String name, Object val) {\n            objVals[getFieldOffset(name, Object.class)] \u003d val;\n        }\n\n        // deprecated in ObjectOutputStream.PutField\n        public void write(ObjectOutput out) throws IOException {\n            /*\n             * Applications should *not* use this method to write PutField\n             * data, as it will lead to stream corruption if the PutField\n             * object writes any primitive data (since block data mode is not\n             * unset/set properly, as is done in OOS.writeFields()).  This\n             * broken implementation is being retained solely for behavioral\n             * compatibility, in order to support applications which use\n             * OOS.PutField.write() for writing only non-primitive data.\n             *\n             * Serialization of unshared objects is not implemented here since\n             * it is not necessary for backwards compatibility; also, unshared\n             * semantics may not be supported by the given ObjectOutput\n             * instance.  Applications which write unshared objects using the\n             * PutField API must use OOS.writeFields().\n             */\n            if (ObjectOutputStream.this !\u003d out) {\n                throw new IllegalArgumentException(\"wrong stream\");\n            }\n            out.write(primVals, 0, primVals.length);\n\n            ObjectStreamField[] fields \u003d desc.getFields(false);\n            int numPrimFields \u003d fields.length - objVals.length;\n            // REMIND: warn if numPrimFields \u003e 0?\n            for (int i \u003d 0; i \u003c objVals.length; i++) {\n                if (fields[numPrimFields + i].isUnshared()) {\n                    throw new IOException(\"cannot write unshared object\");\n                }\n                out.writeObject(objVals[i]);\n            }\n        }\n\n        /**\n         * Writes buffered primitive data and object fields to stream.\n         */\n        void writeFields() throws IOException {\n            bout.write(primVals, 0, primVals.length, false);\n\n            ObjectStreamField[] fields \u003d desc.getFields(false);\n            int numPrimFields \u003d fields.length - objVals.length;\n            for (int i \u003d 0; i \u003c objVals.length; i++) {\n                if (extendedDebugInfo) {\n                    debugInfoStack.push(\n                        \"field (class \\\"\" + desc.getName() + \"\\\", name: \\\"\" +\n                        fields[numPrimFields + i].getName() + \"\\\", type: \\\"\" +\n                        fields[numPrimFields + i].getType() + \"\\\")\");\n                }\n                try {\n                    writeObject0(objVals[i],\n                                 fields[numPrimFields + i].isUnshared());\n                } finally {\n                    if (extendedDebugInfo) {\n                        debugInfoStack.pop();\n                    }\n                }\n            }\n        }\n\n        /**\n         * Returns offset of field with given name and type.  A specified type\n         * of null matches all types, Object.class matches all non-primitive\n         * types, and any other non-null type matches assignable types only.\n         * Throws IllegalArgumentException if no matching field found.\n         */\n        private int getFieldOffset(String name, Class\u003c?\u003e type) {\n            ObjectStreamField field \u003d desc.getField(name, type);\n            if (field \u003d\u003d null) {\n                throw new IllegalArgumentException(\"no such field \" + name +\n                                                   \" with type \" + type);\n            }\n            return field.getOffset();\n        }\n    }\n\n    /**\n     * Buffered output stream with two modes: in default mode, outputs data in\n     * same format as DataOutputStream; in \"block data\" mode, outputs data\n     * bracketed by block data markers (see object serialization specification\n     * for details).\n     */\n    private static final class BlockDataOutputStream\n        extends OutputStream implements DataOutput\n    {\n        /** maximum data block length */\n        private static final int MAX_BLOCK_SIZE \u003d 1024;\n        /** maximum data block header length */\n        private static final int MAX_HEADER_SIZE \u003d 5;\n        /** (tunable) length of char buffer (for writing strings) */\n        private static final int CHAR_BUF_SIZE \u003d 256;\n\n        /** buffer for writing general/block data */\n        private final byte[] buf \u003d new byte[MAX_BLOCK_SIZE];\n        /** buffer for writing block data headers */\n        private final byte[] hbuf \u003d new byte[MAX_HEADER_SIZE];\n        /** char buffer for fast string writes */\n        private final char[] cbuf \u003d new char[CHAR_BUF_SIZE];\n\n        /** block data mode */\n        private boolean blkmode \u003d false;\n        /** current offset into buf */\n        private int pos \u003d 0;\n\n        /** underlying output stream */\n        private final OutputStream out;\n        /** loopback stream (for data writes that span data blocks) */\n        private final DataOutputStream dout;\n\n        /**\n         * Creates new BlockDataOutputStream on top of given underlying stream.\n         * Block data mode is turned off by default.\n         */\n        BlockDataOutputStream(OutputStream out) {\n            this.out \u003d out;\n            dout \u003d new DataOutputStream(this);\n        }\n\n        /**\n         * Sets block data mode to the given mode (true \u003d\u003d on, false \u003d\u003d off)\n         * and returns the previous mode value.  If the new mode is the same as\n         * the old mode, no action is taken.  If the new mode differs from the\n         * old mode, any buffered data is flushed before switching to the new\n         * mode.\n         */\n        boolean setBlockDataMode(boolean mode) throws IOException {\n            if (blkmode \u003d\u003d mode) {\n                return blkmode;\n            }\n            drain();\n            blkmode \u003d mode;\n            return !blkmode;\n        }\n\n        /**\n         * Returns true if the stream is currently in block data mode, false\n         * otherwise.\n         */\n        boolean getBlockDataMode() {\n            return blkmode;\n        }\n\n        /* ----------------- generic output stream methods ----------------- */\n        /*\n         * The following methods are equivalent to their counterparts in\n         * OutputStream, except that they partition written data into data\n         * blocks when in block data mode.\n         */\n\n        public void write(int b) throws IOException {\n            if (pos \u003e\u003d MAX_BLOCK_SIZE) {\n                drain();\n            }\n            buf[pos++] \u003d (byte) b;\n        }\n\n        public void write(byte[] b) throws IOException {\n            write(b, 0, b.length, false);\n        }\n\n        public void write(byte[] b, int off, int len) throws IOException {\n            write(b, off, len, false);\n        }\n\n        public void flush() throws IOException {\n            drain();\n            out.flush();\n        }\n\n        public void close() throws IOException {\n            flush();\n            out.close();\n        }\n\n        /**\n         * Writes specified span of byte values from given array.  If copy is\n         * true, copies the values to an intermediate buffer before writing\n         * them to underlying stream (to avoid exposing a reference to the\n         * original byte array).\n         */\n        void write(byte[] b, int off, int len, boolean copy)\n            throws IOException\n        {\n            if (!(copy || blkmode)) {           // write directly\n                drain();\n                out.write(b, off, len);\n                return;\n            }\n\n            while (len \u003e 0) {\n                if (pos \u003e\u003d MAX_BLOCK_SIZE) {\n                    drain();\n                }\n                if (len \u003e\u003d MAX_BLOCK_SIZE \u0026\u0026 !copy \u0026\u0026 pos \u003d\u003d 0) {\n                    // avoid unnecessary copy\n                    writeBlockHeader(MAX_BLOCK_SIZE);\n                    out.write(b, off, MAX_BLOCK_SIZE);\n                    off +\u003d MAX_BLOCK_SIZE;\n                    len -\u003d MAX_BLOCK_SIZE;\n                } else {\n                    int wlen \u003d Math.min(len, MAX_BLOCK_SIZE - pos);\n                    System.arraycopy(b, off, buf, pos, wlen);\n                    pos +\u003d wlen;\n                    off +\u003d wlen;\n                    len -\u003d wlen;\n                }\n            }\n        }\n\n        /**\n         * Writes all buffered data from this stream to the underlying stream,\n         * but does not flush underlying stream.\n         */\n        void drain() throws IOException {\n            if (pos \u003d\u003d 0) {\n                return;\n            }\n            if (blkmode) {\n                writeBlockHeader(pos);\n            }\n            out.write(buf, 0, pos);\n            pos \u003d 0;\n        }\n\n        /**\n         * Writes block data header.  Data blocks shorter than 256 bytes are\n         * prefixed with a 2-byte header; all others start with a 5-byte\n         * header.\n         */\n        private void writeBlockHeader(int len) throws IOException {\n            if (len \u003c\u003d 0xFF) {\n                hbuf[0] \u003d TC_BLOCKDATA;\n                hbuf[1] \u003d (byte) len;\n                out.write(hbuf, 0, 2);\n            } else {\n                hbuf[0] \u003d TC_BLOCKDATALONG;\n                ByteArray.setInt(hbuf, 1, len);\n                out.write(hbuf, 0, 5);\n            }\n        }\n\n\n        /* ----------------- primitive data output methods ----------------- */\n        /*\n         * The following methods are equivalent to their counterparts in\n         * DataOutputStream, except that they partition written data into data\n         * blocks when in block data mode.\n         */\n\n        public void writeBoolean(boolean v) throws IOException {\n            if (pos \u003e\u003d MAX_BLOCK_SIZE) {\n                drain();\n            }\n            ByteArray.setBoolean(buf, pos++, v);\n        }\n\n        public void writeByte(int v) throws IOException {\n            if (pos \u003e\u003d MAX_BLOCK_SIZE) {\n                drain();\n            }\n            buf[pos++] \u003d (byte) v;\n        }\n\n        public void writeChar(int v) throws IOException {\n            if (pos + 2 \u003c\u003d MAX_BLOCK_SIZE) {\n                ByteArray.setChar(buf, pos, (char) v);\n                pos +\u003d 2;\n            } else {\n                dout.writeChar(v);\n            }\n        }\n\n        public void writeShort(int v) throws IOException {\n            if (pos + 2 \u003c\u003d MAX_BLOCK_SIZE) {\n                ByteArray.setShort(buf, pos, (short) v);\n                pos +\u003d 2;\n            } else {\n                dout.writeShort(v);\n            }\n        }\n\n        public void writeInt(int v) throws IOException {\n            if (pos + 4 \u003c\u003d MAX_BLOCK_SIZE) {\n                ByteArray.setInt(buf, pos, v);\n                pos +\u003d 4;\n            } else {\n                dout.writeInt(v);\n            }\n        }\n\n        public void writeFloat(float v) throws IOException {\n            if (pos + 4 \u003c\u003d MAX_BLOCK_SIZE) {\n                ByteArray.setFloat(buf, pos, v);\n                pos +\u003d 4;\n            } else {\n                dout.writeFloat(v);\n            }\n        }\n\n        public void writeLong(long v) throws IOException {\n            if (pos + 8 \u003c\u003d MAX_BLOCK_SIZE) {\n                ByteArray.setLong(buf, pos, v);\n                pos +\u003d 8;\n            } else {\n                dout.writeLong(v);\n            }\n        }\n\n        public void writeDouble(double v) throws IOException {\n            if (pos + 8 \u003c\u003d MAX_BLOCK_SIZE) {\n                ByteArray.setDouble(buf, pos, v);\n                pos +\u003d 8;\n            } else {\n                dout.writeDouble(v);\n            }\n        }\n\n        public void writeBytes(String s) throws IOException {\n            int endoff \u003d s.length();\n            int cpos \u003d 0;\n            int csize \u003d 0;\n            for (int off \u003d 0; off \u003c endoff; ) {\n                if (cpos \u003e\u003d csize) {\n                    cpos \u003d 0;\n                    csize \u003d Math.min(endoff - off, CHAR_BUF_SIZE);\n                    s.getChars(off, off + csize, cbuf, 0);\n                }\n                if (pos \u003e\u003d MAX_BLOCK_SIZE) {\n                    drain();\n                }\n                int n \u003d Math.min(csize - cpos, MAX_BLOCK_SIZE - pos);\n                int stop \u003d pos + n;\n                while (pos \u003c stop) {\n                    buf[pos++] \u003d (byte) cbuf[cpos++];\n                }\n                off +\u003d n;\n            }\n        }\n\n        public void writeChars(String s) throws IOException {\n            int endoff \u003d s.length();\n            for (int off \u003d 0; off \u003c endoff; ) {\n                int csize \u003d Math.min(endoff - off, CHAR_BUF_SIZE);\n                s.getChars(off, off + csize, cbuf, 0);\n                writeChars(cbuf, 0, csize);\n                off +\u003d csize;\n            }\n        }\n\n        public void writeUTF(String s) throws IOException {\n            writeUTF(s, getUTFLength(s));\n        }\n\n\n        /* -------------- primitive data array output methods -------------- */\n        /*\n         * The following methods write out spans of primitive data values.\n         * Though equivalent to calling the corresponding primitive write\n         * methods repeatedly, these methods are optimized for writing groups\n         * of primitive data values more efficiently.\n         */\n\n        void writeBooleans(boolean[] v, int off, int len) throws IOException {\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003e\u003d MAX_BLOCK_SIZE) {\n                    drain();\n                }\n                int stop \u003d Math.min(endoff, off + (MAX_BLOCK_SIZE - pos));\n                while (off \u003c stop) {\n                    ByteArray.setBoolean(buf, pos++, v[off++]);\n                }\n            }\n        }\n\n        void writeChars(char[] v, int off, int len) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 2;\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003c\u003d limit) {\n                    int avail \u003d (MAX_BLOCK_SIZE - pos) \u003e\u003e 1;\n                    int stop \u003d Math.min(endoff, off + avail);\n                    while (off \u003c stop) {\n                        ByteArray.setChar(buf, pos, v[off++]);\n                        pos +\u003d 2;\n                    }\n                } else {\n                    dout.writeChar(v[off++]);\n                }\n            }\n        }\n\n        void writeShorts(short[] v, int off, int len) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 2;\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003c\u003d limit) {\n                    int avail \u003d (MAX_BLOCK_SIZE - pos) \u003e\u003e 1;\n                    int stop \u003d Math.min(endoff, off + avail);\n                    while (off \u003c stop) {\n                        ByteArray.setShort(buf, pos, v[off++]);\n                        pos +\u003d 2;\n                    }\n                } else {\n                    dout.writeShort(v[off++]);\n                }\n            }\n        }\n\n        void writeInts(int[] v, int off, int len) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 4;\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003c\u003d limit) {\n                    int avail \u003d (MAX_BLOCK_SIZE - pos) \u003e\u003e 2;\n                    int stop \u003d Math.min(endoff, off + avail);\n                    while (off \u003c stop) {\n                        ByteArray.setInt(buf, pos, v[off++]);\n                        pos +\u003d 4;\n                    }\n                } else {\n                    dout.writeInt(v[off++]);\n                }\n            }\n        }\n\n        void writeFloats(float[] v, int off, int len) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 4;\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003c\u003d limit) {\n                    int avail \u003d (MAX_BLOCK_SIZE - pos) \u003e\u003e 2;\n                    int stop \u003d Math.min(endoff, off + avail);\n                    while (off \u003c stop) {\n                        ByteArray.setFloat(buf, pos, v[off++]);\n                        pos +\u003d 4;\n                    }\n                } else {\n                    dout.writeFloat(v[off++]);\n                }\n            }\n        }\n\n        void writeLongs(long[] v, int off, int len) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 8;\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003c\u003d limit) {\n                    int avail \u003d (MAX_BLOCK_SIZE - pos) \u003e\u003e 3;\n                    int stop \u003d Math.min(endoff, off + avail);\n                    while (off \u003c stop) {\n                        ByteArray.setLong(buf, pos, v[off++]);\n                        pos +\u003d 8;\n                    }\n                } else {\n                    dout.writeLong(v[off++]);\n                }\n            }\n        }\n\n        void writeDoubles(double[] v, int off, int len) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 8;\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003c\u003d limit) {\n                    int avail \u003d (MAX_BLOCK_SIZE - pos) \u003e\u003e 3;\n                    int stop \u003d Math.min(endoff, off + avail);\n                    while (off \u003c stop) {\n                        ByteArray.setDouble(buf, pos, v[off++]);\n                        pos +\u003d 8;\n                    }\n                } else {\n                    dout.writeDouble(v[off++]);\n                }\n            }\n        }\n\n        /**\n         * Returns the length in bytes of the UTF encoding of the given string.\n         */\n        long getUTFLength(String s) {\n            int len \u003d s.length();\n            long utflen \u003d 0;\n            for (int off \u003d 0; off \u003c len; ) {\n                int csize \u003d Math.min(len - off, CHAR_BUF_SIZE);\n                s.getChars(off, off + csize, cbuf, 0);\n                for (int cpos \u003d 0; cpos \u003c csize; cpos++) {\n                    char c \u003d cbuf[cpos];\n                    if (c \u003e\u003d 0x0001 \u0026\u0026 c \u003c\u003d 0x007F) {\n                        utflen++;\n                    } else if (c \u003e 0x07FF) {\n                        utflen +\u003d 3;\n                    } else {\n                        utflen +\u003d 2;\n                    }\n                }\n                off +\u003d csize;\n            }\n            return utflen;\n        }\n\n        /**\n         * Writes the given string in UTF format.  This method is used in\n         * situations where the UTF encoding length of the string is already\n         * known; specifying it explicitly avoids a prescan of the string to\n         * determine its UTF length.\n         */\n        void writeUTF(String s, long utflen) throws IOException {\n            if (utflen \u003e 0xFFFFL) {\n                throw new UTFDataFormatException();\n            }\n            writeShort((int) utflen);\n            if (utflen \u003d\u003d (long) s.length()) {\n                writeBytes(s);\n            } else {\n                writeUTFBody(s);\n            }\n        }\n\n        /**\n         * Writes given string in \"long\" UTF format.  \"Long\" UTF format is\n         * identical to standard UTF, except that it uses an 8 byte header\n         * (instead of the standard 2 bytes) to convey the UTF encoding length.\n         */\n        void writeLongUTF(String s) throws IOException {\n            writeLongUTF(s, getUTFLength(s));\n        }\n\n        /**\n         * Writes given string in \"long\" UTF format, where the UTF encoding\n         * length of the string is already known.\n         */\n        void writeLongUTF(String s, long utflen) throws IOException {\n            writeLong(utflen);\n            if (utflen \u003d\u003d (long) s.length()) {\n                writeBytes(s);\n            } else {\n                writeUTFBody(s);\n            }\n        }\n\n        /**\n         * Writes the \"body\" (i.e., the UTF representation minus the 2-byte or\n         * 8-byte length header) of the UTF encoding for the given string.\n         */\n        private void writeUTFBody(String s) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 3;\n            int len \u003d s.length();\n            for (int off \u003d 0; off \u003c len; ) {\n                int csize \u003d Math.min(len - off, CHAR_BUF_SIZE);\n                s.getChars(off, off + csize, cbuf, 0);\n                for (int cpos \u003d 0; cpos \u003c csize; cpos++) {\n                    char c \u003d cbuf[cpos];\n                    if (pos \u003c\u003d limit) {\n                        if (c \u003c\u003d 0x007F \u0026\u0026 c !\u003d 0) {\n                            buf[pos++] \u003d (byte) c;\n                        } else if (c \u003e 0x07FF) {\n                            buf[pos + 2] \u003d (byte) (0x80 | ((c \u003e\u003e 0) \u0026 0x3F));\n                            buf[pos + 1] \u003d (byte) (0x80 | ((c \u003e\u003e 6) \u0026 0x3F));\n                            buf[pos + 0] \u003d (byte) (0xE0 | ((c \u003e\u003e 12) \u0026 0x0F));\n                            pos +\u003d 3;\n                        } else {\n                            buf[pos + 1] \u003d (byte) (0x80 | ((c \u003e\u003e 0) \u0026 0x3F));\n                            buf[pos + 0] \u003d (byte) (0xC0 | ((c \u003e\u003e 6) \u0026 0x1F));\n                            pos +\u003d 2;\n                        }\n                    } else {    // write one byte at a time to normalize block\n                        if (c \u003c\u003d 0x007F \u0026\u0026 c !\u003d 0) {\n                            write(c);\n                        } else if (c \u003e 0x07FF) {\n                            write(0xE0 | ((c \u003e\u003e 12) \u0026 0x0F));\n                            write(0x80 | ((c \u003e\u003e 6) \u0026 0x3F));\n                            write(0x80 | ((c \u003e\u003e 0) \u0026 0x3F));\n                        } else {\n                            write(0xC0 | ((c \u003e\u003e 6) \u0026 0x1F));\n                            write(0x80 | ((c \u003e\u003e 0) \u0026 0x3F));\n                        }\n                    }\n                }\n                off +\u003d csize;\n            }\n        }\n    }\n\n    /**\n     * Lightweight identity hash table which maps objects to integer handles,\n     * assigned in ascending order.\n     */\n    private static final class HandleTable {\n\n        /* number of mappings in table/next available handle */\n        private int size;\n        /* size threshold determining when to expand hash spine */\n        private int threshold;\n        /* factor for computing size threshold */\n        private final float loadFactor;\n        /* maps hash value -\u003e candidate handle value */\n        private int[] spine;\n        /* maps handle value -\u003e next candidate handle value */\n        private int[] next;\n        /* maps handle value -\u003e associated object */\n        private Object[] objs;\n\n        /**\n         * Creates new HandleTable with given capacity and load factor.\n         */\n        HandleTable(int initialCapacity, float loadFactor) {\n            this.loadFactor \u003d loadFactor;\n            spine \u003d new int[initialCapacity];\n            next \u003d new int[initialCapacity];\n            objs \u003d new Object[initialCapacity];\n            threshold \u003d (int) (initialCapacity * loadFactor);\n            clear();\n        }\n\n        /**\n         * Assigns next available handle to given object, and returns handle\n         * value.  Handles are assigned in ascending order starting at 0.\n         */\n        int assign(Object obj) {\n            if (size \u003e\u003d next.length) {\n                growEntries();\n            }\n            if (size \u003e\u003d threshold) {\n                growSpine();\n            }\n            insert(obj, size);\n            return size++;\n        }\n\n        /**\n         * Looks up and returns handle associated with given object, or -1 if\n         * no mapping found.\n         */\n        int lookup(Object obj) {\n            if (size \u003d\u003d 0) {\n                return -1;\n            }\n            int index \u003d hash(obj) % spine.length;\n            for (int i \u003d spine[index]; i \u003e\u003d 0; i \u003d next[i]) {\n                if (objs[i] \u003d\u003d obj) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n\n        /**\n         * Resets table to its initial (empty) state.\n         */\n        void clear() {\n            Arrays.fill(spine, -1);\n            Arrays.fill(objs, 0, size, null);\n            size \u003d 0;\n        }\n\n        /**\n         * Returns the number of mappings currently in table.\n         */\n        int size() {\n            return size;\n        }\n\n        /**\n         * Inserts mapping object -\u003e handle mapping into table.  Assumes table\n         * is large enough to accommodate new mapping.\n         */\n        private void insert(Object obj, int handle) {\n            int index \u003d hash(obj) % spine.length;\n            objs[handle] \u003d obj;\n            next[handle] \u003d spine[index];\n            spine[index] \u003d handle;\n        }\n\n        /**\n         * Expands the hash \"spine\" -- equivalent to increasing the number of\n         * buckets in a conventional hash table.\n         */\n        private void growSpine() {\n            spine \u003d new int[(spine.length \u003c\u003c 1) + 1];\n            threshold \u003d (int) (spine.length * loadFactor);\n            Arrays.fill(spine, -1);\n            for (int i \u003d 0; i \u003c size; i++) {\n                insert(objs[i], i);\n            }\n        }\n\n        /**\n         * Increases hash table capacity by lengthening entry arrays.\n         */\n        private void growEntries() {\n            int newLength \u003d (next.length \u003c\u003c 1) + 1;\n            int[] newNext \u003d new int[newLength];\n            System.arraycopy(next, 0, newNext, 0, size);\n            next \u003d newNext;\n\n            Object[] newObjs \u003d new Object[newLength];\n            System.arraycopy(objs, 0, newObjs, 0, size);\n            objs \u003d newObjs;\n        }\n\n        /**\n         * Returns hash value for given object.\n         */\n        private int hash(Object obj) {\n            return System.identityHashCode(obj) \u0026 0x7FFFFFFF;\n        }\n    }\n\n    /**\n     * Lightweight identity hash table which maps objects to replacement\n     * objects.\n     */\n    private static final class ReplaceTable {\n\n        /* maps object -\u003e index */\n        private final HandleTable htab;\n        /* maps index -\u003e replacement object */\n        private Object[] reps;\n\n        /**\n         * Creates new ReplaceTable with given capacity and load factor.\n         */\n        ReplaceTable(int initialCapacity, float loadFactor) {\n            htab \u003d new HandleTable(initialCapacity, loadFactor);\n            reps \u003d new Object[initialCapacity];\n        }\n\n        /**\n         * Enters mapping from object to replacement object.\n         */\n        void assign(Object obj, Object rep) {\n            int index \u003d htab.assign(obj);\n            while (index \u003e\u003d reps.length) {\n                grow();\n            }\n            reps[index] \u003d rep;\n        }\n\n        /**\n         * Looks up and returns replacement for given object.  If no\n         * replacement is found, returns the lookup object itself.\n         */\n        Object lookup(Object obj) {\n            int index \u003d htab.lookup(obj);\n            return (index \u003e\u003d 0) ? reps[index] : obj;\n        }\n\n        /**\n         * Resets table to its initial (empty) state.\n         */\n        void clear() {\n            Arrays.fill(reps, 0, htab.size(), null);\n            htab.clear();\n        }\n\n        /**\n         * Returns the number of mappings currently in table.\n         */\n        int size() {\n            return htab.size();\n        }\n\n        /**\n         * Increases table capacity.\n         */\n        private void grow() {\n            Object[] newReps \u003d new Object[(reps.length \u003c\u003c 1) + 1];\n            System.arraycopy(reps, 0, newReps, 0, reps.length);\n            reps \u003d newReps;\n        }\n    }\n\n    /**\n     * Stack to keep debug information about the state of the\n     * serialization process, for embedding in exception messages.\n     */\n    private static final class DebugTraceInfoStack {\n        private final List\u003cString\u003e stack;\n\n        DebugTraceInfoStack() {\n            stack \u003d new ArrayList\u003c\u003e();\n        }\n\n        /**\n         * Removes all of the elements from enclosed list.\n         */\n        void clear() {\n            stack.clear();\n        }\n\n        /**\n         * Removes the object at the top of enclosed list.\n         */\n        void pop() {\n            stack.remove(stack.size()-1);\n        }\n\n        /**\n         * Pushes a String onto the top of enclosed list.\n         */\n        void push(String entry) {\n            stack.add(\"\\t- \" + entry);\n        }\n\n        /**\n         * Returns a string representation of this object\n         */\n        public String toString() {\n            StringJoiner sj \u003d new StringJoiner(\"\\n\");\n            for (int i \u003d stack.size() - 1; i \u003e\u003d 0; i--) {\n                sj.add(stack.get(i));\n            }\n            return sj.toString();\n        }\n    }\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/io/ObjectOutputStream.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/io/ObjectOutputStream.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

Π°ΠΏΡ€. 12, 2024 7:52:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/io/ObjectOutputStream.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/io/ObjectOutputStream.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/io/ObjectOutputStream.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.04.12 19:52:22 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
Π°ΠΏΡ€. 12, 2024 7:52:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6739
2024.04.12 19:52:26 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:52:26 INFO  compiling bestgame (1 scala source)
2024.04.12 19:52:26 INFO  time: compiled bestgame in 62ms
2024.04.12 19:52:26 INFO  compiling bestgame (2 scala sources)
2024.04.12 19:52:26 INFO  time: compiled bestgame in 0.15s
2024.04.12 19:52:26 WARN  Using indexes to guess the definition of Serializable
2024.04.12 19:54:58 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 19:54:58 INFO  compiling bestgame (1 scala source)
2024.04.12 19:54:58 INFO  time: compiled bestgame in 71ms
2024.04.12 19:54:58 INFO  compiling bestgame (2 scala sources)
2024.04.12 19:54:58 INFO  time: compiled bestgame in 0.14s
2024.04.12 20:00:38 WARN  Using indexes to guess the definition of Player
2024.04.12 20:00:38 WARN  Using indexes to guess the definition of Player
Π°ΠΏΡ€. 12, 2024 8:00:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6805
2024.04.12 20:00:39 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:00:39 INFO  compiling bestgame (1 scala source)
2024.04.12 20:00:39 INFO  time: compiled bestgame in 81ms
2024.04.12 20:00:39 INFO  compiling bestgame (2 scala sources)
2024.04.12 20:00:39 INFO  time: compiled bestgame in 0.19s
Π°ΠΏΡ€. 12, 2024 8:00:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6818
2024.04.12 20:10:27 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:10:27 INFO  compiling bestgame (1 scala source)
2024.04.12 20:10:27 INFO  time: compiled bestgame in 89ms
2024.04.12 20:10:41 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:10:41 INFO  compiling bestgame (1 scala source)
2024.04.12 20:10:41 INFO  time: compiled bestgame in 79ms
Π°ΠΏΡ€. 12, 2024 8:10:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7009
Π°ΠΏΡ€. 12, 2024 8:10:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7010
Π°ΠΏΡ€. 12, 2024 8:10:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7093
Π°ΠΏΡ€. 12, 2024 8:10:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7113
2024.04.12 20:11:33 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/io/ObjectOutputStream.java

Uri: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/io/ObjectOutputStream.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:689)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1570)
```

Π°ΠΏΡ€. 12, 2024 8:11:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/io/ObjectOutputStream.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2023, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.io;\n\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.StringJoiner;\n\nimport jdk.internal.util.ByteArray;\nimport sun.reflect.misc.ReflectUtil;\n\n/**\n * An ObjectOutputStream writes primitive data types and graphs of Java objects\n * to an OutputStream.  The objects can be read (reconstituted) using an\n * ObjectInputStream.  Persistent storage of objects can be accomplished by\n * using a file for the stream.  If the stream is a network socket stream, the\n * objects can be reconstituted on another host or in another process.\n *\n * \u003cp\u003eOnly objects that support the java.io.Serializable interface can be\n * written to streams.  The class of each serializable object is encoded\n * including the class name and signature of the class, the values of the\n * object\u0027s fields and arrays, and the closure of any other objects referenced\n * from the initial objects.\n *\n * \u003cp\u003eThe method writeObject is used to write an object to the stream.  Any\n * object, including Strings and arrays, is written with writeObject. Multiple\n * objects or primitives can be written to the stream.  The objects must be\n * read back from the corresponding ObjectInputstream with the same types and\n * in the same order as they were written.\n *\n * \u003cp\u003ePrimitive data types can also be written to the stream using the\n * appropriate methods from DataOutput. Strings can also be written using the\n * writeUTF method.\n *\n * \u003cp\u003eThe default serialization mechanism for an object writes the class of the\n * object, the class signature, and the values of all non-transient and\n * non-static fields.  References to other objects (except in transient or\n * static fields) cause those objects to be written also. Multiple references\n * to a single object are encoded using a reference sharing mechanism so that\n * graphs of objects can be restored to the same shape as when the original was\n * written.\n *\n * \u003cp\u003eFor example to write an object that can be read by the example in\n * {@link ObjectInputStream}:\n * {@snippet lang\u003d\"java\":\n *      try (FileOutputStream fos \u003d new FileOutputStream(\"t.tmp\");\n *           ObjectOutputStream oos \u003d new ObjectOutputStream(fos)) {\n *          oos.writeObject(\"Today\");\n *          oos.writeObject(LocalDateTime.now());\n *      } catch (Exception ex) {\n *          // handle exception\n *      }\n * }\n *\n * \u003cp\u003eSerializable classes that require special handling during the\n * serialization and deserialization process should implement methods\n * with the following signatures:\n *\n * {@snippet lang\u003d\"java\":\n *     private void readObject(java.io.ObjectInputStream stream)\n *         throws IOException, ClassNotFoundException;\n *     private void writeObject(java.io.ObjectOutputStream stream)\n *         throws IOException;\n *     private void readObjectNoData()\n *         throws ObjectStreamException;\n * }\n *\n * \u003cp\u003eThe method name, modifiers, return type, and number and type of\n * parameters must match exactly for the method to be used by\n * serialization or deserialization. The methods should only be\n * declared to throw checked exceptions consistent with these\n * signatures.\n *\n * \u003cp\u003eThe writeObject method is responsible for writing the state of the object\n * for its particular class so that the corresponding readObject method can\n * restore it.  The method does not need to concern itself with the state\n * belonging to the object\u0027s superclasses or subclasses.  State is saved by\n * writing the individual fields to the ObjectOutputStream using the\n * writeObject method or by using the methods for primitive data types\n * supported by DataOutput.\n *\n * \u003cp\u003eSerialization does not write out the fields of any object that does not\n * implement the java.io.Serializable interface.  Subclasses of Objects that\n * are not serializable can be serializable. In this case the non-serializable\n * class must have a no-arg constructor to allow its fields to be initialized.\n * In this case it is the responsibility of the subclass to save and restore\n * the state of the non-serializable class. It is frequently the case that the\n * fields of that class are accessible (public, package, or protected) or that\n * there are get and set methods that can be used to restore the state.\n *\n * \u003cp\u003eSerialization of an object can be prevented by implementing writeObject\n * and readObject methods that throw the NotSerializableException.  The\n * exception will be caught by the ObjectOutputStream and abort the\n * serialization process.\n *\n * \u003cp\u003eImplementing the Externalizable interface allows the object to assume\n * complete control over the contents and format of the object\u0027s serialized\n * form.  The methods of the Externalizable interface, writeExternal and\n * readExternal, are called to save and restore the objects state.  When\n * implemented by a class they can write and read their own state using all of\n * the methods of ObjectOutput and ObjectInput.  It is the responsibility of\n * the objects to handle any versioning that occurs.\n *\n * \u003cp\u003eEnum constants are serialized differently than ordinary serializable or\n * externalizable objects.  The serialized form of an enum constant consists\n * solely of its name; field values of the constant are not transmitted.  To\n * serialize an enum constant, ObjectOutputStream writes the string returned by\n * the constant\u0027s name method.  Like other serializable or externalizable\n * objects, enum constants can function as the targets of back references\n * appearing subsequently in the serialization stream.  The process by which\n * enum constants are serialized cannot be customized; any class-specific\n * writeObject and writeReplace methods defined by enum types are ignored\n * during serialization.  Similarly, any serialPersistentFields or\n * serialVersionUID field declarations are also ignored--all enum types have a\n * fixed serialVersionUID of 0L.\n *\n * \u003cp\u003ePrimitive data, excluding serializable fields and externalizable data, is\n * written to the ObjectOutputStream in block-data records. A block data record\n * is composed of a header and data. The block data header consists of a marker\n * and the number of bytes to follow the header.  Consecutive primitive data\n * writes are merged into one block-data record.  The blocking factor used for\n * a block-data record will be 1024 bytes.  Each block-data record will be\n * filled up to 1024 bytes, or be written whenever there is a termination of\n * block-data mode.  Calls to the ObjectOutputStream methods writeObject,\n * defaultWriteObject and writeFields initially terminate any existing\n * block-data record.\n *\n * \u003cp\u003eRecords are serialized differently than ordinary serializable or externalizable\n * objects, see \u003ca href\u003d\"ObjectInputStream.html#record-serialization\"\u003erecord serialization\u003c/a\u003e.\n *\n * @spec serialization/index.html Java Object Serialization Specification\n * @author      Mike Warres\n * @author      Roger Riggs\n * @see java.io.DataOutput\n * @see java.io.ObjectInputStream\n * @see java.io.Serializable\n * @see java.io.Externalizable\n * @see \u003ca href\u003d\"{@docRoot}/../specs/serialization/output.html\"\u003e\n *      \u003ccite\u003eJava Object Serialization Specification,\u003c/cite\u003e Section 2, \"Object Output Classes\"\u003c/a\u003e\n * @since       1.1\n */\npublic class ObjectOutputStream\n    extends OutputStream implements ObjectOutput, ObjectStreamConstants\n{\n\n    private static class Caches {\n        /** cache of subclass security audit results */\n        static final ClassValue\u003cBoolean\u003e subclassAudits \u003d\n            new ClassValue\u003c\u003e() {\n                @Override\n                protected Boolean computeValue(Class\u003c?\u003e type) {\n                    return auditSubclass(type);\n                }\n            };\n    }\n\n    /** filter stream for handling block data conversion */\n    private final BlockDataOutputStream bout;\n    /** obj -\u003e wire handle map */\n    private final HandleTable handles;\n    /** obj -\u003e replacement obj map */\n    private final ReplaceTable subs;\n    /** stream protocol version */\n    private int protocol \u003d PROTOCOL_VERSION_2;\n    /** recursion depth */\n    private int depth;\n\n    /** buffer for writing primitive field values */\n    private byte[] primVals;\n\n    /** if true, invoke writeObjectOverride() instead of writeObject() */\n    private final boolean enableOverride;\n    /** if true, invoke replaceObject() */\n    private boolean enableReplace;\n\n    // values below valid only during upcalls to writeObject()/writeExternal()\n    /**\n     * Context during upcalls to class-defined writeObject methods; holds\n     * object currently being serialized and descriptor for current class.\n     * Null when not during writeObject upcall.\n     */\n    private SerialCallbackContext curContext;\n    /** current PutField object */\n    private PutFieldImpl curPut;\n\n    /** custom storage for debug trace info */\n    private final DebugTraceInfoStack debugInfoStack;\n\n    /**\n     * value of \"sun.io.serialization.extendedDebugInfo\" property,\n     * as true or false for extended information about exception\u0027s place\n     */\n    @SuppressWarnings(\"removal\")\n    private static final boolean extendedDebugInfo \u003d\n        java.security.AccessController.doPrivileged(\n            new sun.security.action.GetBooleanAction(\n                \"sun.io.serialization.extendedDebugInfo\")).booleanValue();\n\n    /**\n     * Creates an ObjectOutputStream that writes to the specified OutputStream.\n     * This constructor writes the serialization stream header to the\n     * underlying stream; callers may wish to flush the stream immediately to\n     * ensure that constructors for receiving ObjectInputStreams will not block\n     * when reading the header.\n     *\n     * \u003cp\u003eIf a security manager is installed, this constructor will check for\n     * the \"enableSubclassImplementation\" SerializablePermission when invoked\n     * directly or indirectly by the constructor of a subclass which overrides\n     * the ObjectOutputStream.putFields or ObjectOutputStream.writeUnshared\n     * methods.\n     *\n     * @param   out output stream to write to\n     * @throws  IOException if an I/O error occurs while writing stream header\n     * @throws  SecurityException if untrusted subclass illegally overrides\n     *          security-sensitive methods\n     * @throws  NullPointerException if {@code out} is {@code null}\n     * @since   1.4\n     * @see     ObjectOutputStream#ObjectOutputStream()\n     * @see     ObjectOutputStream#putFields()\n     * @see     ObjectInputStream#ObjectInputStream(InputStream)\n     */\n    public ObjectOutputStream(OutputStream out) throws IOException {\n        verifySubclass();\n        bout \u003d new BlockDataOutputStream(out);\n        handles \u003d new HandleTable(10, (float) 3.00);\n        subs \u003d new ReplaceTable(10, (float) 3.00);\n        enableOverride \u003d false;\n        writeStreamHeader();\n        bout.setBlockDataMode(true);\n        if (extendedDebugInfo) {\n            debugInfoStack \u003d new DebugTraceInfoStack();\n        } else {\n            debugInfoStack \u003d null;\n        }\n    }\n\n    /**\n     * Provide a way for subclasses that are completely reimplementing\n     * ObjectOutputStream to not have to allocate private data just used by\n     * this implementation of ObjectOutputStream.\n     *\n     * \u003cp\u003eIf there is a security manager installed, this method first calls the\n     * security manager\u0027s {@code checkPermission} method with a\n     * {@code SerializablePermission(\"enableSubclassImplementation\")}\n     * permission to ensure it\u0027s ok to enable subclassing.\n     *\n     * @throws  SecurityException if a security manager exists and its\n     *          {@code checkPermission} method denies enabling\n     *          subclassing.\n     * @throws  IOException if an I/O error occurs while creating this stream\n     * @see SecurityManager#checkPermission\n     * @see java.io.SerializablePermission\n     */\n    protected ObjectOutputStream() throws IOException, SecurityException {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d System.getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);\n        }\n        bout \u003d null;\n        handles \u003d null;\n        subs \u003d null;\n        enableOverride \u003d true;\n        debugInfoStack \u003d null;\n    }\n\n    /**\n     * Specify stream protocol version to use when writing the stream.\n     *\n     * \u003cp\u003eThis routine provides a hook to enable the current version of\n     * Serialization to write in a format that is backwards compatible to a\n     * previous version of the stream format.\n     *\n     * \u003cp\u003eEvery effort will be made to avoid introducing additional\n     * backwards incompatibilities; however, sometimes there is no\n     * other alternative.\n     *\n     * @param   version use ProtocolVersion from java.io.ObjectStreamConstants.\n     * @throws  IllegalStateException if called after any objects\n     *          have been serialized.\n     * @throws  IllegalArgumentException if invalid version is passed in.\n     * @throws  IOException if I/O errors occur\n     * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_1\n     * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_2\n     * @since   1.2\n     */\n    public void useProtocolVersion(int version) throws IOException {\n        if (handles.size() !\u003d 0) {\n            // REMIND: implement better check for pristine stream?\n            throw new IllegalStateException(\"stream non-empty\");\n        }\n        switch (version) {\n            case PROTOCOL_VERSION_1:\n            case PROTOCOL_VERSION_2:\n                protocol \u003d version;\n                break;\n\n            default:\n                throw new IllegalArgumentException(\n                    \"unknown version: \" + version);\n        }\n    }\n\n    /**\n     * Write the specified object to the ObjectOutputStream.  The class of the\n     * object, the signature of the class, and the values of the non-transient\n     * and non-static fields of the class and all of its supertypes are\n     * written.  Default serialization for a class can be overridden using the\n     * writeObject and the readObject methods.  Objects referenced by this\n     * object are written transitively so that a complete equivalent graph of\n     * objects can be reconstructed by an ObjectInputStream.\n     *\n     * \u003cp\u003eExceptions are thrown for problems with the OutputStream and for\n     * classes that should not be serialized.  All exceptions are fatal to the\n     * OutputStream, which is left in an indeterminate state, and it is up to\n     * the caller to ignore or recover the stream state.\n     *\n     * @throws  InvalidClassException Something is wrong with a class used by\n     *          serialization.\n     * @throws  NotSerializableException Some object to be serialized does not\n     *          implement the java.io.Serializable interface.\n     * @throws  IOException Any exception thrown by the underlying\n     *          OutputStream.\n     */\n    public final void writeObject(Object obj) throws IOException {\n        if (enableOverride) {\n            writeObjectOverride(obj);\n            return;\n        }\n        try {\n            writeObject0(obj, false);\n        } catch (IOException ex) {\n            if (depth \u003d\u003d 0) {\n                writeFatalException(ex);\n            }\n            throw ex;\n        }\n    }\n\n    /**\n     * Method used by subclasses to override the default writeObject method.\n     * This method is called by trusted subclasses of ObjectOutputStream that\n     * constructed ObjectOutputStream using the protected no-arg constructor.\n     * The subclass is expected to provide an override method with the modifier\n     * \"final\".\n     *\n     * @param   obj object to be written to the underlying stream\n     * @throws  IOException if there are I/O errors while writing to the\n     *          underlying stream\n     * @see #ObjectOutputStream()\n     * @see #writeObject(Object)\n     * @since 1.2\n     */\n    protected void writeObjectOverride(Object obj) throws IOException {\n    }\n\n    /**\n     * Writes an \"unshared\" object to the ObjectOutputStream.  This method is\n     * identical to writeObject, except that it always writes the given object\n     * as a new, unique object in the stream (as opposed to a back-reference\n     * pointing to a previously serialized instance).  Specifically:\n     * \u003cul\u003e\n     *   \u003cli\u003eAn object written via writeUnshared is always serialized in the\n     *       same manner as a newly appearing object (an object that has not\n     *       been written to the stream yet), regardless of whether or not the\n     *       object has been written previously.\n     *\n     *   \u003cli\u003eIf writeObject is used to write an object that has been previously\n     *       written with writeUnshared, the previous writeUnshared operation\n     *       is treated as if it were a write of a separate object.  In other\n     *       words, ObjectOutputStream will never generate back-references to\n     *       object data written by calls to writeUnshared.\n     * \u003c/ul\u003e\n     * While writing an object via writeUnshared does not in itself guarantee a\n     * unique reference to the object when it is deserialized, it allows a\n     * single object to be defined multiple times in a stream, so that multiple\n     * calls to readUnshared by the receiver will not conflict.  Note that the\n     * rules described above only apply to the base-level object written with\n     * writeUnshared, and not to any transitively referenced sub-objects in the\n     * object graph to be serialized.\n     *\n     * \u003cp\u003eObjectOutputStream subclasses which override this method can only be\n     * constructed in security contexts possessing the\n     * \"enableSubclassImplementation\" SerializablePermission; any attempt to\n     * instantiate such a subclass without this permission will cause a\n     * SecurityException to be thrown.\n     *\n     * @param   obj object to write to stream\n     * @throws  NotSerializableException if an object in the graph to be\n     *          serialized does not implement the Serializable interface\n     * @throws  InvalidClassException if a problem exists with the class of an\n     *          object to be serialized\n     * @throws  IOException if an I/O error occurs during serialization\n     * @since 1.4\n     */\n    public void writeUnshared(Object obj) throws IOException {\n        try {\n            writeObject0(obj, true);\n        } catch (IOException ex) {\n            if (depth \u003d\u003d 0) {\n                writeFatalException(ex);\n            }\n            throw ex;\n        }\n    }\n\n    /**\n     * Write the non-static and non-transient fields of the current class to\n     * this stream.  This may only be called from the writeObject method of the\n     * class being serialized. It will throw the NotActiveException if it is\n     * called otherwise.\n     *\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          {@code OutputStream}\n     */\n    public void defaultWriteObject() throws IOException {\n        SerialCallbackContext ctx \u003d curContext;\n        if (ctx \u003d\u003d null) {\n            throw new NotActiveException(\"not in call to writeObject\");\n        }\n        Object curObj \u003d ctx.getObj();\n        ObjectStreamClass curDesc \u003d ctx.getDesc();\n        bout.setBlockDataMode(false);\n        defaultWriteFields(curObj, curDesc);\n        bout.setBlockDataMode(true);\n    }\n\n    /**\n     * Retrieve the object used to buffer persistent fields to be written to\n     * the stream.  The fields will be written to the stream when writeFields\n     * method is called.\n     *\n     * @return  an instance of the class Putfield that holds the serializable\n     *          fields\n     * @throws  IOException if I/O errors occur\n     * @since 1.2\n     */\n    public ObjectOutputStream.PutField putFields() throws IOException {\n        if (curPut \u003d\u003d null) {\n            SerialCallbackContext ctx \u003d curContext;\n            if (ctx \u003d\u003d null) {\n                throw new NotActiveException(\"not in call to writeObject\");\n            }\n            ctx.checkAndSetUsed();\n            ObjectStreamClass curDesc \u003d ctx.getDesc();\n            curPut \u003d new PutFieldImpl(curDesc);\n        }\n        return curPut;\n    }\n\n    /**\n     * Write the buffered fields to the stream.\n     *\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     * @throws  NotActiveException Called when a classes writeObject method was\n     *          not called to write the state of the object.\n     * @since 1.2\n     */\n    public void writeFields() throws IOException {\n        if (curPut \u003d\u003d null) {\n            throw new NotActiveException(\"no current PutField object\");\n        }\n        bout.setBlockDataMode(false);\n        curPut.writeFields();\n        bout.setBlockDataMode(true);\n    }\n\n    /**\n     * Reset will disregard the state of any objects already written to the\n     * stream.  The state is reset to be the same as a new ObjectOutputStream.\n     * The current point in the stream is marked as reset so the corresponding\n     * ObjectInputStream will be reset at the same point.  Objects previously\n     * written to the stream will not be referred to as already being in the\n     * stream.  They will be written to the stream again.\n     *\n     * @throws  IOException if reset() is invoked while serializing an object.\n     */\n    public void reset() throws IOException {\n        if (depth !\u003d 0) {\n            throw new IOException(\"stream active\");\n        }\n        bout.setBlockDataMode(false);\n        bout.writeByte(TC_RESET);\n        clear();\n        bout.setBlockDataMode(true);\n    }\n\n    /**\n     * Subclasses may implement this method to allow class data to be stored in\n     * the stream. By default this method does nothing.  The corresponding\n     * method in ObjectInputStream is resolveClass.  This method is called\n     * exactly once for each unique class in the stream.  The class name and\n     * signature will have already been written to the stream.  This method may\n     * make free use of the ObjectOutputStream to save any representation of\n     * the class it deems suitable (for example, the bytes of the class file).\n     * The resolveClass method in the corresponding subclass of\n     * ObjectInputStream must read and use any data or objects written by\n     * annotateClass.\n     *\n     * @param   cl the class to annotate custom data for\n     * @throws  IOException Any exception thrown by the underlying\n     *          OutputStream.\n     */\n    protected void annotateClass(Class\u003c?\u003e cl) throws IOException {\n    }\n\n    /**\n     * Subclasses may implement this method to store custom data in the stream\n     * along with descriptors for dynamic proxy classes.\n     *\n     * \u003cp\u003eThis method is called exactly once for each unique proxy class\n     * descriptor in the stream.  The default implementation of this method in\n     * {@code ObjectOutputStream} does nothing.\n     *\n     * \u003cp\u003eThe corresponding method in {@code ObjectInputStream} is\n     * {@code resolveProxyClass}.  For a given subclass of\n     * {@code ObjectOutputStream} that overrides this method, the\n     * {@code resolveProxyClass} method in the corresponding subclass of\n     * {@code ObjectInputStream} must read any data or objects written by\n     * {@code annotateProxyClass}.\n     *\n     * @param   cl the proxy class to annotate custom data for\n     * @throws  IOException any exception thrown by the underlying\n     *          {@code OutputStream}\n     * @see ObjectInputStream#resolveProxyClass(String[])\n     * @since   1.3\n     */\n    protected void annotateProxyClass(Class\u003c?\u003e cl) throws IOException {\n    }\n\n    /**\n     * This method will allow trusted subclasses of ObjectOutputStream to\n     * substitute one object for another during serialization. Replacing\n     * objects is disabled until enableReplaceObject is called. The\n     * enableReplaceObject method checks that the stream requesting to do\n     * replacement can be trusted.  The first occurrence of each object written\n     * into the serialization stream is passed to replaceObject.  Subsequent\n     * references to the object are replaced by the object returned by the\n     * original call to replaceObject.  To ensure that the private state of\n     * objects is not unintentionally exposed, only trusted streams may use\n     * replaceObject.\n     *\n     * \u003cp\u003eThe ObjectOutputStream.writeObject method takes a parameter of type\n     * Object (as opposed to type Serializable) to allow for cases where\n     * non-serializable objects are replaced by serializable ones.\n     *\n     * \u003cp\u003eWhen a subclass is replacing objects it must ensure that either a\n     * complementary substitution must be made during deserialization or that\n     * the substituted object is compatible with every field where the\n     * reference will be stored.  Objects whose type is not a subclass of the\n     * type of the field or array element abort the serialization by raising an\n     * exception and the object is not be stored.\n     *\n     * \u003cp\u003eThis method is called only once when each object is first\n     * encountered.  All subsequent references to the object will be redirected\n     * to the new object. This method should return the object to be\n     * substituted or the original object.\n     *\n     * \u003cp\u003eNull can be returned as the object to be substituted, but may cause\n     * {@link NullPointerException} in classes that contain references to the\n     * original object since they may be expecting an object instead of\n     * null.\n     *\n     * @param   obj the object to be replaced\n     * @return  the alternate object that replaced the specified one\n     * @throws  IOException Any exception thrown by the underlying\n     *          OutputStream.\n     */\n    protected Object replaceObject(Object obj) throws IOException {\n        return obj;\n    }\n\n    /**\n     * Enables the stream to do replacement of objects written to the stream.  When\n     * enabled, the {@link #replaceObject} method is called for every object being\n     * serialized.\n     *\n     * \u003cp\u003eIf object replacement is currently not enabled, and\n     * {@code enable} is true, and there is a security manager installed,\n     * this method first calls the security manager\u0027s\n     * {@code checkPermission} method with the\n     * {@code SerializablePermission(\"enableSubstitution\")} permission to\n     * ensure that the caller is permitted to enable the stream to do replacement\n     * of objects written to the stream.\n     *\n     * @param   enable true for enabling use of {@code replaceObject} for\n     *          every object being serialized\n     * @return  the previous setting before this method was invoked\n     * @throws  SecurityException if a security manager exists and its\n     *          {@code checkPermission} method denies enabling the stream\n     *          to do replacement of objects written to the stream.\n     * @see SecurityManager#checkPermission\n     * @see java.io.SerializablePermission\n     */\n    protected boolean enableReplaceObject(boolean enable)\n        throws SecurityException\n    {\n        if (enable \u003d\u003d enableReplace) {\n            return enable;\n        }\n        if (enable) {\n            @SuppressWarnings(\"removal\")\n            SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(SUBSTITUTION_PERMISSION);\n            }\n        }\n        enableReplace \u003d enable;\n        return !enableReplace;\n    }\n\n    /**\n     * The writeStreamHeader method is provided so subclasses can append or\n     * prepend their own header to the stream.  It writes the magic number and\n     * version to the stream.\n     *\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    protected void writeStreamHeader() throws IOException {\n        bout.writeShort(STREAM_MAGIC);\n        bout.writeShort(STREAM_VERSION);\n    }\n\n    /**\n     * Write the specified class descriptor to the ObjectOutputStream.  Class\n     * descriptors are used to identify the classes of objects written to the\n     * stream.  Subclasses of ObjectOutputStream may override this method to\n     * customize the way in which class descriptors are written to the\n     * serialization stream.  The corresponding method in ObjectInputStream,\n     * {@link ObjectInputStream#readClassDescriptor readClassDescriptor}, should then be overridden to\n     * reconstitute the class descriptor from its custom stream representation.\n     * By default, this method writes class descriptors according to the format\n     * defined in the \u003ca href\u003d\"{@docRoot}/../specs/serialization/index.html\"\u003e\n     * \u003ccite\u003eJava Object Serialization Specification\u003c/cite\u003e\u003c/a\u003e.\n     *\n     * \u003cp\u003eNote that this method will only be called if the ObjectOutputStream\n     * is not using the old serialization stream format (set by calling\n     * ObjectOutputStream\u0027s {@code useProtocolVersion} method).  If this\n     * serialization stream is using the old format\n     * ({@code PROTOCOL_VERSION_1}), the class descriptor will be written\n     * internally in a manner that cannot be overridden or customized.\n     *\n     * @param   desc class descriptor to write to the stream\n     * @throws  IOException If an I/O error has occurred.\n     * @spec serialization/index.html Java Object Serialization Specification\n     * @see java.io.ObjectInputStream#readClassDescriptor()\n     * @see #useProtocolVersion(int)\n     * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_1\n     * @since 1.3\n     */\n    protected void writeClassDescriptor(ObjectStreamClass desc)\n        throws IOException\n    {\n        desc.writeNonProxy(this);\n    }\n\n    /**\n     * Writes a byte. This method will block until the byte is actually\n     * written.\n     *\n     * @param   val the byte to be written to the stream\n     * @throws  IOException If an I/O error has occurred.\n     */\n    @Override\n    public void write(int val) throws IOException {\n        bout.write(val);\n    }\n\n    /**\n     * Writes an array of bytes. This method will block until the bytes are\n     * actually written.\n     *\n     * @param   buf the data to be written\n     * @throws  IOException If an I/O error has occurred.\n     */\n    @Override\n    public void write(byte[] buf) throws IOException {\n        bout.write(buf, 0, buf.length, false);\n    }\n\n    /**\n     * Writes a sub array of bytes.\n     *\n     * @param   buf the data to be written\n     * @param   off the start offset in the data\n     * @param   len the number of bytes that are written\n     * @throws  IOException {@inheritDoc}\n     * @throws  IndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public void write(byte[] buf, int off, int len) throws IOException {\n        if (buf \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        Objects.checkFromIndexSize(off, len, buf.length);\n        bout.write(buf, off, len, false);\n    }\n\n    /**\n     * Flushes the stream. This will write any buffered output bytes and flush\n     * through to the underlying stream.\n     *\n     * @throws  IOException {@inheritDoc}\n     */\n    @Override\n    public void flush() throws IOException {\n        bout.flush();\n    }\n\n    /**\n     * Drain any buffered data in ObjectOutputStream.  Similar to flush but\n     * does not propagate the flush to the underlying stream.\n     *\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    protected void drain() throws IOException {\n        bout.drain();\n    }\n\n    /**\n     * Closes the stream. This method must be called to release any resources\n     * associated with the stream.\n     *\n     * @throws  IOException If an I/O error has occurred.\n     */\n    @Override\n    public void close() throws IOException {\n        flush();\n        clear();\n        bout.close();\n    }\n\n    /**\n     * Writes a boolean.\n     *\n     * @param   val the boolean to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeBoolean(boolean val) throws IOException {\n        bout.writeBoolean(val);\n    }\n\n    /**\n     * Writes an 8-bit byte.\n     *\n     * @param   val the byte value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeByte(int val) throws IOException  {\n        bout.writeByte(val);\n    }\n\n    /**\n     * Writes a 16-bit short.\n     *\n     * @param   val the short value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeShort(int val)  throws IOException {\n        bout.writeShort(val);\n    }\n\n    /**\n     * Writes a 16-bit char.\n     *\n     * @param   val the char value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeChar(int val)  throws IOException {\n        bout.writeChar(val);\n    }\n\n    /**\n     * Writes a 32-bit int.\n     *\n     * @param   val the integer value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeInt(int val)  throws IOException {\n        bout.writeInt(val);\n    }\n\n    /**\n     * Writes a 64-bit long.\n     *\n     * @param   val the long value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeLong(long val)  throws IOException {\n        bout.writeLong(val);\n    }\n\n    /**\n     * Writes a 32-bit float.\n     *\n     * @param   val the float value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeFloat(float val) throws IOException {\n        bout.writeFloat(val);\n    }\n\n    /**\n     * Writes a 64-bit double.\n     *\n     * @param   val the double value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeDouble(double val) throws IOException {\n        bout.writeDouble(val);\n    }\n\n    /**\n     * Writes a String as a sequence of bytes.\n     *\n     * @param   str the String of bytes to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeBytes(String str) throws IOException {\n        bout.writeBytes(str);\n    }\n\n    /**\n     * Writes a String as a sequence of chars.\n     *\n     * @param   str the String of chars to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeChars(String str) throws IOException {\n        bout.writeChars(str);\n    }\n\n    /**\n     * Primitive data write of this String in\n     * \u003ca href\u003d\"DataInput.html#modified-utf-8\"\u003emodified UTF-8\u003c/a\u003e\n     * format.  Note that there is a\n     * significant difference between writing a String into the stream as\n     * primitive data or as an Object. A String instance written by writeObject\n     * is written into the stream as a String initially. Future writeObject()\n     * calls write references to the string into the stream.\n     *\n     * @param   str the String to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeUTF(String str) throws IOException {\n        bout.writeUTF(str);\n    }\n\n    /**\n     * Provide programmatic access to the persistent fields to be written\n     * to ObjectOutput.\n     *\n     * @since 1.2\n     */\n    public abstract static class PutField {\n        /**\n         * Constructor for subclasses to call.\n         */\n        public PutField() {}\n\n        /**\n         * Put the value of the named boolean field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code boolean}\n         */\n        public abstract void put(String name, boolean val);\n\n        /**\n         * Put the value of the named byte field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code byte}\n         */\n        public abstract void put(String name, byte val);\n\n        /**\n         * Put the value of the named char field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code char}\n         */\n        public abstract void put(String name, char val);\n\n        /**\n         * Put the value of the named short field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code short}\n         */\n        public abstract void put(String name, short val);\n\n        /**\n         * Put the value of the named int field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code int}\n         */\n        public abstract void put(String name, int val);\n\n        /**\n         * Put the value of the named long field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code long}\n         */\n        public abstract void put(String name, long val);\n\n        /**\n         * Put the value of the named float field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code float}\n         */\n        public abstract void put(String name, float val);\n\n        /**\n         * Put the value of the named double field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code double}\n         */\n        public abstract void put(String name, double val);\n\n        /**\n         * Put the value of the named Object field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         *         (which may be {@code null})\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not a\n         * reference type\n         */\n        public abstract void put(String name, Object val);\n\n        /**\n         * Write the data and fields to the specified ObjectOutput stream,\n         * which must be the same stream that produced this\n         * {@code PutField} object.\n         *\n         * @param  out the stream to write the data and fields to\n         * @throws IOException if I/O errors occur while writing to the\n         *         underlying stream\n         * @throws IllegalArgumentException if the specified stream is not\n         *         the same stream that produced this {@code PutField}\n         *         object\n         * @deprecated This method does not write the values contained by this\n         *         {@code PutField} object in a proper format, and may\n         *         result in corruption of the serialization stream.  The\n         *         correct way to write {@code PutField} data is by\n         *         calling the {@link java.io.ObjectOutputStream#writeFields()}\n         *         method.\n         */\n        @Deprecated\n        public abstract void write(ObjectOutput out) throws IOException;\n    }\n\n\n    /**\n     * Returns protocol version in use.\n     */\n    int getProtocolVersion() {\n        return protocol;\n    }\n\n    /**\n     * Writes string without allowing it to be replaced in stream.  Used by\n     * ObjectStreamClass to write class descriptor type strings.\n     */\n    void writeTypeString(String str) throws IOException {\n        int handle;\n        if (str \u003d\u003d null) {\n            writeNull();\n        } else if ((handle \u003d handles.lookup(str)) !\u003d -1) {\n            writeHandle(handle);\n        } else {\n            writeString(str, false);\n        }\n    }\n\n    /**\n     * Verifies that this (possibly subclass) instance can be constructed\n     * without violating security constraints: the subclass must not override\n     * security-sensitive non-final methods, or else the\n     * \"enableSubclassImplementation\" SerializablePermission is checked.\n     */\n    private void verifySubclass() {\n        Class\u003c?\u003e cl \u003d getClass();\n        if (cl \u003d\u003d ObjectOutputStream.class) {\n            return;\n        }\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d System.getSecurityManager();\n        if (sm \u003d\u003d null) {\n            return;\n        }\n        boolean result \u003d Caches.subclassAudits.get(cl);\n        if (!result) {\n            sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);\n        }\n    }\n\n    /**\n     * Performs reflective checks on given subclass to verify that it doesn\u0027t\n     * override security-sensitive non-final methods.  Returns TRUE if subclass\n     * is \"safe\", FALSE otherwise.\n     */\n    @SuppressWarnings(\"removal\")\n    private static Boolean auditSubclass(Class\u003c?\u003e subcl) {\n        return AccessController.doPrivileged(\n            new PrivilegedAction\u003c\u003e() {\n                public Boolean run() {\n                    for (Class\u003c?\u003e cl \u003d subcl;\n                         cl !\u003d ObjectOutputStream.class;\n                         cl \u003d cl.getSuperclass())\n                    {\n                        try {\n                            cl.getDeclaredMethod(\n                                \"writeUnshared\", new Class\u003c?\u003e[] { Object.class });\n                            return Boolean.FALSE;\n                        } catch (NoSuchMethodException ex) {\n                        }\n                        try {\n                            cl.getDeclaredMethod(\"putFields\", (Class\u003c?\u003e[]) null);\n                            return Boolean.FALSE;\n                        } catch (NoSuchMethodException ex) {\n                        }\n                    }\n                    return Boolean.TRUE;\n                }\n            }\n        );\n    }\n\n    /**\n     * Clears internal data structures.\n     */\n    private void clear() {\n        subs.clear();\n        handles.clear();\n    }\n\n    /**\n     * Underlying writeObject/writeUnshared implementation.\n     */\n    private void writeObject0(Object obj, boolean unshared)\n        throws IOException\n    {\n        boolean oldMode \u003d bout.setBlockDataMode(false);\n        depth++;\n        try {\n            // handle previously written and non-replaceable objects\n            int h;\n            if ((obj \u003d subs.lookup(obj)) \u003d\u003d null) {\n                writeNull();\n                return;\n            } else if (!unshared \u0026\u0026 (h \u003d handles.lookup(obj)) !\u003d -1) {\n                writeHandle(h);\n                return;\n            } else if (obj instanceof Class) {\n                writeClass((Class) obj, unshared);\n                return;\n            } else if (obj instanceof ObjectStreamClass) {\n                writeClassDesc((ObjectStreamClass) obj, unshared);\n                return;\n            }\n\n            // check for replacement object\n            Object orig \u003d obj;\n            Class\u003c?\u003e cl \u003d obj.getClass();\n            ObjectStreamClass desc;\n            for (;;) {\n                // REMIND: skip this check for strings/arrays?\n                Class\u003c?\u003e repCl;\n                desc \u003d ObjectStreamClass.lookup(cl, true);\n                if (!desc.hasWriteReplaceMethod() ||\n                    (obj \u003d desc.invokeWriteReplace(obj)) \u003d\u003d null ||\n                    (repCl \u003d obj.getClass()) \u003d\u003d cl)\n                {\n                    break;\n                }\n                cl \u003d repCl;\n            }\n            if (enableReplace) {\n                Object rep \u003d replaceObject(obj);\n                if (rep !\u003d obj \u0026\u0026 rep !\u003d null) {\n                    cl \u003d rep.getClass();\n                    desc \u003d ObjectStreamClass.lookup(cl, true);\n                }\n                obj \u003d rep;\n            }\n\n            // if object replaced, run through original checks a second time\n            if (obj !\u003d orig) {\n                subs.assign(orig, obj);\n                if (obj \u003d\u003d null) {\n                    writeNull();\n                    return;\n                } else if (!unshared \u0026\u0026 (h \u003d handles.lookup(obj)) !\u003d -1) {\n                    writeHandle(h);\n                    return;\n                } else if (obj instanceof Class) {\n                    writeClass((Class) obj, unshared);\n                    return;\n                } else if (obj instanceof ObjectStreamClass) {\n                    writeClassDesc((ObjectStreamClass) obj, unshared);\n                    return;\n                }\n            }\n\n            // remaining cases\n            if (obj instanceof String) {\n                writeString((String) obj, unshared);\n            } else if (cl.isArray()) {\n                writeArray(obj, desc, unshared);\n            } else if (obj instanceof Enum) {\n                writeEnum((Enum\u003c?\u003e) obj, desc, unshared);\n            } else if (obj instanceof Serializable) {\n                writeOrdinaryObject(obj, desc, unshared);\n            } else {\n                if (extendedDebugInfo) {\n                    throw new NotSerializableException(\n                        cl.getName() + \"\\n\" + debugInfoStack.toString());\n                } else {\n                    throw new NotSerializableException(cl.getName());\n                }\n            }\n        } finally {\n            depth--;\n            bout.setBlockDataMode(oldMode);\n        }\n    }\n\n    /**\n     * Writes null code to stream.\n     */\n    private void writeNull() throws IOException {\n        bout.writeByte(TC_NULL);\n    }\n\n    /**\n     * Writes given object handle to stream.\n     */\n    private void writeHandle(int handle) throws IOException {\n        bout.writeByte(TC_REFERENCE);\n        bout.writeInt(baseWireHandle + handle);\n    }\n\n    /**\n     * Writes representation of given class to stream.\n     */\n    private void writeClass(Class\u003c?\u003e cl, boolean unshared) throws IOException {\n        bout.writeByte(TC_CLASS);\n        writeClassDesc(ObjectStreamClass.lookup(cl, true), false);\n        handles.assign(unshared ? null : cl);\n    }\n\n    /**\n     * Writes representation of given class descriptor to stream.\n     */\n    private void writeClassDesc(ObjectStreamClass desc, boolean unshared)\n        throws IOException\n    {\n        int handle;\n        if (desc \u003d\u003d null) {\n            writeNull();\n        } else if (!unshared \u0026\u0026 (handle \u003d handles.lookup(desc)) !\u003d -1) {\n            writeHandle(handle);\n        } else if (desc.isProxy()) {\n            writeProxyDesc(desc, unshared);\n        } else {\n            writeNonProxyDesc(desc, unshared);\n        }\n    }\n\n    private boolean isCustomSubclass() {\n        // Return true if this class is a custom subclass of ObjectOutputStream\n        return getClass().getClassLoader()\n                   !\u003d ObjectOutputStream.class.getClassLoader();\n    }\n\n    /**\n     * Writes class descriptor representing a dynamic proxy class to stream.\n     */\n    private void writeProxyDesc(ObjectStreamClass desc, boolean unshared)\n        throws IOException\n    {\n        bout.writeByte(TC_PROXYCLASSDESC);\n        handles.assign(unshared ? null : desc);\n\n        Class\u003c?\u003e cl \u003d desc.forClass();\n        Class\u003c?\u003e[] ifaces \u003d cl.getInterfaces();\n        bout.writeInt(ifaces.length);\n        for (int i \u003d 0; i \u003c ifaces.length; i++) {\n            bout.writeUTF(ifaces[i].getName());\n        }\n\n        bout.setBlockDataMode(true);\n        if (cl !\u003d null \u0026\u0026 isCustomSubclass()) {\n            ReflectUtil.checkPackageAccess(cl);\n        }\n        annotateProxyClass(cl);\n        bout.setBlockDataMode(false);\n        bout.writeByte(TC_ENDBLOCKDATA);\n\n        writeClassDesc(desc.getSuperDesc(), false);\n    }\n\n    /**\n     * Writes class descriptor representing a standard (i.e., not a dynamic\n     * proxy) class to stream.\n     */\n    private void writeNonProxyDesc(ObjectStreamClass desc, boolean unshared)\n        throws IOException\n    {\n        bout.writeByte(TC_CLASSDESC);\n        handles.assign(unshared ? null : desc);\n\n        if (protocol \u003d\u003d PROTOCOL_VERSION_1) {\n            // do not invoke class descriptor write hook with old protocol\n            desc.writeNonProxy(this);\n        } else {\n            writeClassDescriptor(desc);\n        }\n\n        Class\u003c?\u003e cl \u003d desc.forClass();\n        bout.setBlockDataMode(true);\n        if (cl !\u003d null \u0026\u0026 isCustomSubclass()) {\n            ReflectUtil.checkPackageAccess(cl);\n        }\n        annotateClass(cl);\n        bout.setBlockDataMode(false);\n        bout.writeByte(TC_ENDBLOCKDATA);\n\n        writeClassDesc(desc.getSuperDesc(), false);\n    }\n\n    /**\n     * Writes given string to stream, using standard or long UTF format\n     * depending on string length.\n     */\n    private void writeString(String str, boolean unshared) throws IOException {\n        handles.assign(unshared ? null : str);\n        long utflen \u003d bout.getUTFLength(str);\n        if (utflen \u003c\u003d 0xFFFF) {\n            bout.writeByte(TC_STRING);\n            bout.writeUTF(str, utflen);\n        } else {\n            bout.writeByte(TC_LONGSTRING);\n            bout.writeLongUTF(str, utflen);\n        }\n    }\n\n    /**\n     * Writes given array object to stream.\n     */\n    private void writeArray(Object array,\n                            ObjectStreamClass desc,\n                            boolean unshared)\n        throws IOException\n    {\n        bout.writeByte(TC_ARRAY);\n        writeClassDesc(desc, false);\n        handles.assign(unshared ? null : array);\n\n        Class\u003c?\u003e ccl \u003d desc.forClass().getComponentType();\n        if (ccl.isPrimitive()) {\n            if (ccl \u003d\u003d Integer.TYPE) {\n                int[] ia \u003d (int[]) array;\n                bout.writeInt(ia.length);\n                bout.writeInts(ia, 0, ia.length);\n            } else if (ccl \u003d\u003d Byte.TYPE) {\n                byte[] ba \u003d (byte[]) array;\n                bout.writeInt(ba.length);\n                bout.write(ba, 0, ba.length, true);\n            } else if (ccl \u003d\u003d Long.TYPE) {\n                long[] ja \u003d (long[]) array;\n                bout.writeInt(ja.length);\n                bout.writeLongs(ja, 0, ja.length);\n            } else if (ccl \u003d\u003d Float.TYPE) {\n                float[] fa \u003d (float[]) array;\n                bout.writeInt(fa.length);\n                bout.writeFloats(fa, 0, fa.length);\n            } else if (ccl \u003d\u003d Double.TYPE) {\n                double[] da \u003d (double[]) array;\n                bout.writeInt(da.length);\n                bout.writeDoubles(da, 0, da.length);\n            } else if (ccl \u003d\u003d Short.TYPE) {\n                short[] sa \u003d (short[]) array;\n                bout.writeInt(sa.length);\n                bout.writeShorts(sa, 0, sa.length);\n            } else if (ccl \u003d\u003d Character.TYPE) {\n                char[] ca \u003d (char[]) array;\n                bout.writeInt(ca.length);\n                bout.writeChars(ca, 0, ca.length);\n            } else if (ccl \u003d\u003d Boolean.TYPE) {\n                boolean[] za \u003d (boolean[]) array;\n                bout.writeInt(za.length);\n                bout.writeBooleans(za, 0, za.length);\n            } else {\n                throw new InternalError();\n            }\n        } else {\n            Object[] objs \u003d (Object[]) array;\n            int len \u003d objs.length;\n            bout.writeInt(len);\n            if (extendedDebugInfo) {\n                debugInfoStack.push(\n                    \"array (class \\\"\" + array.getClass().getName() +\n                    \"\\\", size: \" + len  + \")\");\n            }\n            try {\n                for (int i \u003d 0; i \u003c len; i++) {\n                    if (extendedDebugInfo) {\n                        debugInfoStack.push(\n                            \"element of array (index: \" + i + \")\");\n                    }\n                    try {\n                        writeObject0(objs[i], false);\n                    } finally {\n                        if (extendedDebugInfo) {\n                            debugInfoStack.pop();\n                        }\n                    }\n                }\n            } finally {\n                if (extendedDebugInfo) {\n                    debugInfoStack.pop();\n                }\n            }\n        }\n    }\n\n    /**\n     * Writes given enum constant to stream.\n     */\n    private void writeEnum(Enum\u003c?\u003e en,\n                           ObjectStreamClass desc,\n                           boolean unshared)\n        throws IOException\n    {\n        bout.writeByte(TC_ENUM);\n        ObjectStreamClass sdesc \u003d desc.getSuperDesc();\n        writeClassDesc((sdesc.forClass() \u003d\u003d Enum.class) ? desc : sdesc, false);\n        handles.assign(unshared ? null : en);\n        writeString(en.name(), false);\n    }\n\n    /**\n     * Writes representation of an \"ordinary\" (i.e., not a String, Class,\n     * ObjectStreamClass, array, or enum constant) serializable object to the\n     * stream.\n     */\n    private void writeOrdinaryObject(Object obj,\n                                     ObjectStreamClass desc,\n                                     boolean unshared)\n        throws IOException\n    {\n        if (extendedDebugInfo) {\n            debugInfoStack.push(\n                (depth \u003d\u003d 1 ? \"root \" : \"\") + \"object (class \\\"\" +\n                obj.getClass().getName() + \"\\\", \" + obj.toString() + \")\");\n        }\n        try {\n            desc.checkSerialize();\n\n            bout.writeByte(TC_OBJECT);\n            writeClassDesc(desc, false);\n            handles.assign(unshared ? null : obj);\n\n            if (desc.isRecord()) {\n                writeRecordData(obj, desc);\n            } else if (desc.isExternalizable() \u0026\u0026 !desc.isProxy()) {\n                writeExternalData((Externalizable) obj);\n            } else {\n                writeSerialData(obj, desc);\n            }\n        } finally {\n            if (extendedDebugInfo) {\n                debugInfoStack.pop();\n            }\n        }\n    }\n\n    /**\n     * Writes externalizable data of given object by invoking its\n     * writeExternal() method.\n     */\n    private void writeExternalData(Externalizable obj) throws IOException {\n        PutFieldImpl oldPut \u003d curPut;\n        curPut \u003d null;\n\n        if (extendedDebugInfo) {\n            debugInfoStack.push(\"writeExternal data\");\n        }\n        SerialCallbackContext oldContext \u003d curContext;\n        try {\n            curContext \u003d null;\n            if (protocol \u003d\u003d PROTOCOL_VERSION_1) {\n                obj.writeExternal(this);\n            } else {\n                bout.setBlockDataMode(true);\n                obj.writeExternal(this);\n                bout.setBlockDataMode(false);\n                bout.writeByte(TC_ENDBLOCKDATA);\n            }\n        } finally {\n            curContext \u003d oldContext;\n            if (extendedDebugInfo) {\n                debugInfoStack.pop();\n            }\n        }\n\n        curPut \u003d oldPut;\n    }\n\n    /** Writes the record component values for the given record object. */\n    private void writeRecordData(Object obj, ObjectStreamClass desc)\n        throws IOException\n    {\n        assert obj.getClass().isRecord();\n        ObjectStreamClass.ClassDataSlot[] slots \u003d desc.getClassDataLayout();\n        if (slots.length !\u003d 1) {\n            throw new InvalidClassException(\n                    \"expected a single record slot length, but found: \" + slots.length);\n        }\n\n        defaultWriteFields(obj, desc);  // #### seems unnecessary to use the accessors\n    }\n\n    /**\n     * Writes instance data for each serializable class of given object, from\n     * superclass to subclass.\n     */\n    private void writeSerialData(Object obj, ObjectStreamClass desc)\n        throws IOException\n    {\n        ObjectStreamClass.ClassDataSlot[] slots \u003d desc.getClassDataLayout();\n        for (int i \u003d 0; i \u003c slots.length; i++) {\n            ObjectStreamClass slotDesc \u003d slots[i].desc;\n            if (slotDesc.hasWriteObjectMethod()) {\n                PutFieldImpl oldPut \u003d curPut;\n                curPut \u003d null;\n                SerialCallbackContext oldContext \u003d curContext;\n\n                if (extendedDebugInfo) {\n                    debugInfoStack.push(\n                        \"custom writeObject data (class \\\"\" +\n                        slotDesc.getName() + \"\\\")\");\n                }\n                try {\n                    curContext \u003d new SerialCallbackContext(obj, slotDesc);\n                    bout.setBlockDataMode(true);\n                    slotDesc.invokeWriteObject(obj, this);\n                    bout.setBlockDataMode(false);\n                    bout.writeByte(TC_ENDBLOCKDATA);\n                } finally {\n                    curContext.setUsed();\n                    curContext \u003d oldContext;\n                    if (extendedDebugInfo) {\n                        debugInfoStack.pop();\n                    }\n                }\n\n                curPut \u003d oldPut;\n            } else {\n                defaultWriteFields(obj, slotDesc);\n            }\n        }\n    }\n\n    /**\n     * Fetches and writes values of serializable fields of given object to\n     * stream.  The given class descriptor specifies which field values to\n     * write, and in which order they should be written.\n     */\n    private void defaultWriteFields(Object obj, ObjectStreamClass desc)\n        throws IOException\n    {\n        Class\u003c?\u003e cl \u003d desc.forClass();\n        if (cl !\u003d null \u0026\u0026 obj !\u003d null \u0026\u0026 !cl.isInstance(obj)) {\n            throw new ClassCastException();\n        }\n\n        desc.checkDefaultSerialize();\n\n        int primDataSize \u003d desc.getPrimDataSize();\n        if (primDataSize \u003e 0) {\n            if (primVals \u003d\u003d null || primVals.length \u003c primDataSize) {\n                primVals \u003d new byte[primDataSize];\n            }\n            desc.getPrimFieldValues(obj, primVals);\n            bout.write(primVals, 0, primDataSize, false);\n        }\n\n        int numObjFields \u003d desc.getNumObjFields();\n        if (numObjFields \u003e 0) {\n            ObjectStreamField[] fields \u003d desc.getFields(false);\n            Object[] objVals \u003d new Object[numObjFields];\n            int numPrimFields \u003d fields.length - objVals.length;\n            desc.getObjFieldValues(obj, objVals);\n            for (int i \u003d 0; i \u003c objVals.length; i++) {\n                if (extendedDebugInfo) {\n                    debugInfoStack.push(\n                        \"field (class \\\"\" + desc.getName() + \"\\\", name: \\\"\" +\n                        fields[numPrimFields + i].getName() + \"\\\", type: \\\"\" +\n                        fields[numPrimFields + i].getType() + \"\\\")\");\n                }\n                try {\n                    writeObject0(objVals[i],\n                                 fields[numPrimFields + i].isUnshared());\n                } finally {\n                    if (extendedDebugInfo) {\n                        debugInfoStack.pop();\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Attempts to write to stream fatal IOException that has caused\n     * serialization to abort.\n     */\n    private void writeFatalException(IOException ex) throws IOException {\n        /*\n         * Note: the serialization specification states that if a second\n         * IOException occurs while attempting to serialize the original fatal\n         * exception to the stream, then a StreamCorruptedException should be\n         * thrown (section 2.1).  However, due to a bug in previous\n         * implementations of serialization, StreamCorruptedExceptions were\n         * rarely (if ever) actually thrown--the \"root\" exceptions from\n         * underlying streams were thrown instead.  This historical behavior is\n         * followed here for consistency.\n         */\n        clear();\n        boolean oldMode \u003d bout.setBlockDataMode(false);\n        try {\n            bout.writeByte(TC_EXCEPTION);\n            writeObject0(ex, false);\n            clear();\n        } finally {\n            bout.setBlockDataMode(oldMode);\n        }\n    }\n\n    /**\n     * Default PutField implementation.\n     */\n    private class PutFieldImpl extends PutField {\n\n        /** class descriptor describing serializable fields */\n        private final ObjectStreamClass desc;\n        /** primitive field values */\n        private final byte[] primVals;\n        /** object field values */\n        private final Object[] objVals;\n\n        /**\n         * Creates PutFieldImpl object for writing fields defined in given\n         * class descriptor.\n         */\n        PutFieldImpl(ObjectStreamClass desc) {\n            this.desc \u003d desc;\n            primVals \u003d new byte[desc.getPrimDataSize()];\n            objVals \u003d new Object[desc.getNumObjFields()];\n        }\n\n        public void put(String name, boolean val) {\n            ByteArray.setBoolean(primVals, getFieldOffset(name, Boolean.TYPE), val);\n        }\n\n        public void put(String name, byte val) {\n            primVals[getFieldOffset(name, Byte.TYPE)] \u003d val;\n        }\n\n        public void put(String name, char val) {\n            ByteArray.setChar(primVals, getFieldOffset(name, Character.TYPE), val);\n        }\n\n        public void put(String name, short val) {\n            ByteArray.setShort(primVals, getFieldOffset(name, Short.TYPE), val);\n        }\n\n        public void put(String name, int val) {\n            ByteArray.setInt(primVals, getFieldOffset(name, Integer.TYPE), val);\n        }\n\n        public void put(String name, float val) {\n            ByteArray.setFloat(primVals, getFieldOffset(name, Float.TYPE), val);\n        }\n\n        public void put(String name, long val) {\n            ByteArray.setLong(primVals, getFieldOffset(name, Long.TYPE), val);\n        }\n\n        public void put(String name, double val) {\n            ByteArray.setDouble(primVals, getFieldOffset(name, Double.TYPE), val);\n        }\n\n        public void put(String name, Object val) {\n            objVals[getFieldOffset(name, Object.class)] \u003d val;\n        }\n\n        // deprecated in ObjectOutputStream.PutField\n        public void write(ObjectOutput out) throws IOException {\n            /*\n             * Applications should *not* use this method to write PutField\n             * data, as it will lead to stream corruption if the PutField\n             * object writes any primitive data (since block data mode is not\n             * unset/set properly, as is done in OOS.writeFields()).  This\n             * broken implementation is being retained solely for behavioral\n             * compatibility, in order to support applications which use\n             * OOS.PutField.write() for writing only non-primitive data.\n             *\n             * Serialization of unshared objects is not implemented here since\n             * it is not necessary for backwards compatibility; also, unshared\n             * semantics may not be supported by the given ObjectOutput\n             * instance.  Applications which write unshared objects using the\n             * PutField API must use OOS.writeFields().\n             */\n            if (ObjectOutputStream.this !\u003d out) {\n                throw new IllegalArgumentException(\"wrong stream\");\n            }\n            out.write(primVals, 0, primVals.length);\n\n            ObjectStreamField[] fields \u003d desc.getFields(false);\n            int numPrimFields \u003d fields.length - objVals.length;\n            // REMIND: warn if numPrimFields \u003e 0?\n            for (int i \u003d 0; i \u003c objVals.length; i++) {\n                if (fields[numPrimFields + i].isUnshared()) {\n                    throw new IOException(\"cannot write unshared object\");\n                }\n                out.writeObject(objVals[i]);\n            }\n        }\n\n        /**\n         * Writes buffered primitive data and object fields to stream.\n         */\n        void writeFields() throws IOException {\n            bout.write(primVals, 0, primVals.length, false);\n\n            ObjectStreamField[] fields \u003d desc.getFields(false);\n            int numPrimFields \u003d fields.length - objVals.length;\n            for (int i \u003d 0; i \u003c objVals.length; i++) {\n                if (extendedDebugInfo) {\n                    debugInfoStack.push(\n                        \"field (class \\\"\" + desc.getName() + \"\\\", name: \\\"\" +\n                        fields[numPrimFields + i].getName() + \"\\\", type: \\\"\" +\n                        fields[numPrimFields + i].getType() + \"\\\")\");\n                }\n                try {\n                    writeObject0(objVals[i],\n                                 fields[numPrimFields + i].isUnshared());\n                } finally {\n                    if (extendedDebugInfo) {\n                        debugInfoStack.pop();\n                    }\n                }\n            }\n        }\n\n        /**\n         * Returns offset of field with given name and type.  A specified type\n         * of null matches all types, Object.class matches all non-primitive\n         * types, and any other non-null type matches assignable types only.\n         * Throws IllegalArgumentException if no matching field found.\n         */\n        private int getFieldOffset(String name, Class\u003c?\u003e type) {\n            ObjectStreamField field \u003d desc.getField(name, type);\n            if (field \u003d\u003d null) {\n                throw new IllegalArgumentException(\"no such field \" + name +\n                                                   \" with type \" + type);\n            }\n            return field.getOffset();\n        }\n    }\n\n    /**\n     * Buffered output stream with two modes: in default mode, outputs data in\n     * same format as DataOutputStream; in \"block data\" mode, outputs data\n     * bracketed by block data markers (see object serialization specification\n     * for details).\n     */\n    private static final class BlockDataOutputStream\n        extends OutputStream implements DataOutput\n    {\n        /** maximum data block length */\n        private static final int MAX_BLOCK_SIZE \u003d 1024;\n        /** maximum data block header length */\n        private static final int MAX_HEADER_SIZE \u003d 5;\n        /** (tunable) length of char buffer (for writing strings) */\n        private static final int CHAR_BUF_SIZE \u003d 256;\n\n        /** buffer for writing general/block data */\n        private final byte[] buf \u003d new byte[MAX_BLOCK_SIZE];\n        /** buffer for writing block data headers */\n        private final byte[] hbuf \u003d new byte[MAX_HEADER_SIZE];\n        /** char buffer for fast string writes */\n        private final char[] cbuf \u003d new char[CHAR_BUF_SIZE];\n\n        /** block data mode */\n        private boolean blkmode \u003d false;\n        /** current offset into buf */\n        private int pos \u003d 0;\n\n        /** underlying output stream */\n        private final OutputStream out;\n        /** loopback stream (for data writes that span data blocks) */\n        private final DataOutputStream dout;\n\n        /**\n         * Creates new BlockDataOutputStream on top of given underlying stream.\n         * Block data mode is turned off by default.\n         */\n        BlockDataOutputStream(OutputStream out) {\n            this.out \u003d out;\n            dout \u003d new DataOutputStream(this);\n        }\n\n        /**\n         * Sets block data mode to the given mode (true \u003d\u003d on, false \u003d\u003d off)\n         * and returns the previous mode value.  If the new mode is the same as\n         * the old mode, no action is taken.  If the new mode differs from the\n         * old mode, any buffered data is flushed before switching to the new\n         * mode.\n         */\n        boolean setBlockDataMode(boolean mode) throws IOException {\n            if (blkmode \u003d\u003d mode) {\n                return blkmode;\n            }\n            drain();\n            blkmode \u003d mode;\n            return !blkmode;\n        }\n\n        /**\n         * Returns true if the stream is currently in block data mode, false\n         * otherwise.\n         */\n        boolean getBlockDataMode() {\n            return blkmode;\n        }\n\n        /* ----------------- generic output stream methods ----------------- */\n        /*\n         * The following methods are equivalent to their counterparts in\n         * OutputStream, except that they partition written data into data\n         * blocks when in block data mode.\n         */\n\n        public void write(int b) throws IOException {\n            if (pos \u003e\u003d MAX_BLOCK_SIZE) {\n                drain();\n            }\n            buf[pos++] \u003d (byte) b;\n        }\n\n        public void write(byte[] b) throws IOException {\n            write(b, 0, b.length, false);\n        }\n\n        public void write(byte[] b, int off, int len) throws IOException {\n            write(b, off, len, false);\n        }\n\n        public void flush() throws IOException {\n            drain();\n            out.flush();\n        }\n\n        public void close() throws IOException {\n            flush();\n            out.close();\n        }\n\n        /**\n         * Writes specified span of byte values from given array.  If copy is\n         * true, copies the values to an intermediate buffer before writing\n         * them to underlying stream (to avoid exposing a reference to the\n         * original byte array).\n         */\n        void write(byte[] b, int off, int len, boolean copy)\n            throws IOException\n        {\n            if (!(copy || blkmode)) {           // write directly\n                drain();\n                out.write(b, off, len);\n                return;\n            }\n\n            while (len \u003e 0) {\n                if (pos \u003e\u003d MAX_BLOCK_SIZE) {\n                    drain();\n                }\n                if (len \u003e\u003d MAX_BLOCK_SIZE \u0026\u0026 !copy \u0026\u0026 pos \u003d\u003d 0) {\n                    // avoid unnecessary copy\n                    writeBlockHeader(MAX_BLOCK_SIZE);\n                    out.write(b, off, MAX_BLOCK_SIZE);\n                    off +\u003d MAX_BLOCK_SIZE;\n                    len -\u003d MAX_BLOCK_SIZE;\n                } else {\n                    int wlen \u003d Math.min(len, MAX_BLOCK_SIZE - pos);\n                    System.arraycopy(b, off, buf, pos, wlen);\n                    pos +\u003d wlen;\n                    off +\u003d wlen;\n                    len -\u003d wlen;\n                }\n            }\n        }\n\n        /**\n         * Writes all buffered data from this stream to the underlying stream,\n         * but does not flush underlying stream.\n         */\n        void drain() throws IOException {\n            if (pos \u003d\u003d 0) {\n                return;\n            }\n            if (blkmode) {\n                writeBlockHeader(pos);\n            }\n            out.write(buf, 0, pos);\n            pos \u003d 0;\n        }\n\n        /**\n         * Writes block data header.  Data blocks shorter than 256 bytes are\n         * prefixed with a 2-byte header; all others start with a 5-byte\n         * header.\n         */\n        private void writeBlockHeader(int len) throws IOException {\n            if (len \u003c\u003d 0xFF) {\n                hbuf[0] \u003d TC_BLOCKDATA;\n                hbuf[1] \u003d (byte) len;\n                out.write(hbuf, 0, 2);\n            } else {\n                hbuf[0] \u003d TC_BLOCKDATALONG;\n                ByteArray.setInt(hbuf, 1, len);\n                out.write(hbuf, 0, 5);\n            }\n        }\n\n\n        /* ----------------- primitive data output methods ----------------- */\n        /*\n         * The following methods are equivalent to their counterparts in\n         * DataOutputStream, except that they partition written data into data\n         * blocks when in block data mode.\n         */\n\n        public void writeBoolean(boolean v) throws IOException {\n            if (pos \u003e\u003d MAX_BLOCK_SIZE) {\n                drain();\n            }\n            ByteArray.setBoolean(buf, pos++, v);\n        }\n\n        public void writeByte(int v) throws IOException {\n            if (pos \u003e\u003d MAX_BLOCK_SIZE) {\n                drain();\n            }\n            buf[pos++] \u003d (byte) v;\n        }\n\n        public void writeChar(int v) throws IOException {\n            if (pos + 2 \u003c\u003d MAX_BLOCK_SIZE) {\n                ByteArray.setChar(buf, pos, (char) v);\n                pos +\u003d 2;\n            } else {\n                dout.writeChar(v);\n            }\n        }\n\n        public void writeShort(int v) throws IOException {\n            if (pos + 2 \u003c\u003d MAX_BLOCK_SIZE) {\n                ByteArray.setShort(buf, pos, (short) v);\n                pos +\u003d 2;\n            } else {\n                dout.writeShort(v);\n            }\n        }\n\n        public void writeInt(int v) throws IOException {\n            if (pos + 4 \u003c\u003d MAX_BLOCK_SIZE) {\n                ByteArray.setInt(buf, pos, v);\n                pos +\u003d 4;\n            } else {\n                dout.writeInt(v);\n            }\n        }\n\n        public void writeFloat(float v) throws IOException {\n            if (pos + 4 \u003c\u003d MAX_BLOCK_SIZE) {\n                ByteArray.setFloat(buf, pos, v);\n                pos +\u003d 4;\n            } else {\n                dout.writeFloat(v);\n            }\n        }\n\n        public void writeLong(long v) throws IOException {\n            if (pos + 8 \u003c\u003d MAX_BLOCK_SIZE) {\n                ByteArray.setLong(buf, pos, v);\n                pos +\u003d 8;\n            } else {\n                dout.writeLong(v);\n            }\n        }\n\n        public void writeDouble(double v) throws IOException {\n            if (pos + 8 \u003c\u003d MAX_BLOCK_SIZE) {\n                ByteArray.setDouble(buf, pos, v);\n                pos +\u003d 8;\n            } else {\n                dout.writeDouble(v);\n            }\n        }\n\n        public void writeBytes(String s) throws IOException {\n            int endoff \u003d s.length();\n            int cpos \u003d 0;\n            int csize \u003d 0;\n            for (int off \u003d 0; off \u003c endoff; ) {\n                if (cpos \u003e\u003d csize) {\n                    cpos \u003d 0;\n                    csize \u003d Math.min(endoff - off, CHAR_BUF_SIZE);\n                    s.getChars(off, off + csize, cbuf, 0);\n                }\n                if (pos \u003e\u003d MAX_BLOCK_SIZE) {\n                    drain();\n                }\n                int n \u003d Math.min(csize - cpos, MAX_BLOCK_SIZE - pos);\n                int stop \u003d pos + n;\n                while (pos \u003c stop) {\n                    buf[pos++] \u003d (byte) cbuf[cpos++];\n                }\n                off +\u003d n;\n            }\n        }\n\n        public void writeChars(String s) throws IOException {\n            int endoff \u003d s.length();\n            for (int off \u003d 0; off \u003c endoff; ) {\n                int csize \u003d Math.min(endoff - off, CHAR_BUF_SIZE);\n                s.getChars(off, off + csize, cbuf, 0);\n                writeChars(cbuf, 0, csize);\n                off +\u003d csize;\n            }\n        }\n\n        public void writeUTF(String s) throws IOException {\n            writeUTF(s, getUTFLength(s));\n        }\n\n\n        /* -------------- primitive data array output methods -------------- */\n        /*\n         * The following methods write out spans of primitive data values.\n         * Though equivalent to calling the corresponding primitive write\n         * methods repeatedly, these methods are optimized for writing groups\n         * of primitive data values more efficiently.\n         */\n\n        void writeBooleans(boolean[] v, int off, int len) throws IOException {\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003e\u003d MAX_BLOCK_SIZE) {\n                    drain();\n                }\n                int stop \u003d Math.min(endoff, off + (MAX_BLOCK_SIZE - pos));\n                while (off \u003c stop) {\n                    ByteArray.setBoolean(buf, pos++, v[off++]);\n                }\n            }\n        }\n\n        void writeChars(char[] v, int off, int len) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 2;\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003c\u003d limit) {\n                    int avail \u003d (MAX_BLOCK_SIZE - pos) \u003e\u003e 1;\n                    int stop \u003d Math.min(endoff, off + avail);\n                    while (off \u003c stop) {\n                        ByteArray.setChar(buf, pos, v[off++]);\n                        pos +\u003d 2;\n                    }\n                } else {\n                    dout.writeChar(v[off++]);\n                }\n            }\n        }\n\n        void writeShorts(short[] v, int off, int len) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 2;\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003c\u003d limit) {\n                    int avail \u003d (MAX_BLOCK_SIZE - pos) \u003e\u003e 1;\n                    int stop \u003d Math.min(endoff, off + avail);\n                    while (off \u003c stop) {\n                        ByteArray.setShort(buf, pos, v[off++]);\n                        pos +\u003d 2;\n                    }\n                } else {\n                    dout.writeShort(v[off++]);\n                }\n            }\n        }\n\n        void writeInts(int[] v, int off, int len) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 4;\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003c\u003d limit) {\n                    int avail \u003d (MAX_BLOCK_SIZE - pos) \u003e\u003e 2;\n                    int stop \u003d Math.min(endoff, off + avail);\n                    while (off \u003c stop) {\n                        ByteArray.setInt(buf, pos, v[off++]);\n                        pos +\u003d 4;\n                    }\n                } else {\n                    dout.writeInt(v[off++]);\n                }\n            }\n        }\n\n        void writeFloats(float[] v, int off, int len) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 4;\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003c\u003d limit) {\n                    int avail \u003d (MAX_BLOCK_SIZE - pos) \u003e\u003e 2;\n                    int stop \u003d Math.min(endoff, off + avail);\n                    while (off \u003c stop) {\n                        ByteArray.setFloat(buf, pos, v[off++]);\n                        pos +\u003d 4;\n                    }\n                } else {\n                    dout.writeFloat(v[off++]);\n                }\n            }\n        }\n\n        void writeLongs(long[] v, int off, int len) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 8;\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003c\u003d limit) {\n                    int avail \u003d (MAX_BLOCK_SIZE - pos) \u003e\u003e 3;\n                    int stop \u003d Math.min(endoff, off + avail);\n                    while (off \u003c stop) {\n                        ByteArray.setLong(buf, pos, v[off++]);\n                        pos +\u003d 8;\n                    }\n                } else {\n                    dout.writeLong(v[off++]);\n                }\n            }\n        }\n\n        void writeDoubles(double[] v, int off, int len) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 8;\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003c\u003d limit) {\n                    int avail \u003d (MAX_BLOCK_SIZE - pos) \u003e\u003e 3;\n                    int stop \u003d Math.min(endoff, off + avail);\n                    while (off \u003c stop) {\n                        ByteArray.setDouble(buf, pos, v[off++]);\n                        pos +\u003d 8;\n                    }\n                } else {\n                    dout.writeDouble(v[off++]);\n                }\n            }\n        }\n\n        /**\n         * Returns the length in bytes of the UTF encoding of the given string.\n         */\n        long getUTFLength(String s) {\n            int len \u003d s.length();\n            long utflen \u003d 0;\n            for (int off \u003d 0; off \u003c len; ) {\n                int csize \u003d Math.min(len - off, CHAR_BUF_SIZE);\n                s.getChars(off, off + csize, cbuf, 0);\n                for (int cpos \u003d 0; cpos \u003c csize; cpos++) {\n                    char c \u003d cbuf[cpos];\n                    if (c \u003e\u003d 0x0001 \u0026\u0026 c \u003c\u003d 0x007F) {\n                        utflen++;\n                    } else if (c \u003e 0x07FF) {\n                        utflen +\u003d 3;\n                    } else {\n                        utflen +\u003d 2;\n                    }\n                }\n                off +\u003d csize;\n            }\n            return utflen;\n        }\n\n        /**\n         * Writes the given string in UTF format.  This method is used in\n         * situations where the UTF encoding length of the string is already\n         * known; specifying it explicitly avoids a prescan of the string to\n         * determine its UTF length.\n         */\n        void writeUTF(String s, long utflen) throws IOException {\n            if (utflen \u003e 0xFFFFL) {\n                throw new UTFDataFormatException();\n            }\n            writeShort((int) utflen);\n            if (utflen \u003d\u003d (long) s.length()) {\n                writeBytes(s);\n            } else {\n                writeUTFBody(s);\n            }\n        }\n\n        /**\n         * Writes given string in \"long\" UTF format.  \"Long\" UTF format is\n         * identical to standard UTF, except that it uses an 8 byte header\n         * (instead of the standard 2 bytes) to convey the UTF encoding length.\n         */\n        void writeLongUTF(String s) throws IOException {\n            writeLongUTF(s, getUTFLength(s));\n        }\n\n        /**\n         * Writes given string in \"long\" UTF format, where the UTF encoding\n         * length of the string is already known.\n         */\n        void writeLongUTF(String s, long utflen) throws IOException {\n            writeLong(utflen);\n            if (utflen \u003d\u003d (long) s.length()) {\n                writeBytes(s);\n            } else {\n                writeUTFBody(s);\n            }\n        }\n\n        /**\n         * Writes the \"body\" (i.e., the UTF representation minus the 2-byte or\n         * 8-byte length header) of the UTF encoding for the given string.\n         */\n        private void writeUTFBody(String s) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 3;\n            int len \u003d s.length();\n            for (int off \u003d 0; off \u003c len; ) {\n                int csize \u003d Math.min(len - off, CHAR_BUF_SIZE);\n                s.getChars(off, off + csize, cbuf, 0);\n                for (int cpos \u003d 0; cpos \u003c csize; cpos++) {\n                    char c \u003d cbuf[cpos];\n                    if (pos \u003c\u003d limit) {\n                        if (c \u003c\u003d 0x007F \u0026\u0026 c !\u003d 0) {\n                            buf[pos++] \u003d (byte) c;\n                        } else if (c \u003e 0x07FF) {\n                            buf[pos + 2] \u003d (byte) (0x80 | ((c \u003e\u003e 0) \u0026 0x3F));\n                            buf[pos + 1] \u003d (byte) (0x80 | ((c \u003e\u003e 6) \u0026 0x3F));\n                            buf[pos + 0] \u003d (byte) (0xE0 | ((c \u003e\u003e 12) \u0026 0x0F));\n                            pos +\u003d 3;\n                        } else {\n                            buf[pos + 1] \u003d (byte) (0x80 | ((c \u003e\u003e 0) \u0026 0x3F));\n                            buf[pos + 0] \u003d (byte) (0xC0 | ((c \u003e\u003e 6) \u0026 0x1F));\n                            pos +\u003d 2;\n                        }\n                    } else {    // write one byte at a time to normalize block\n                        if (c \u003c\u003d 0x007F \u0026\u0026 c !\u003d 0) {\n                            write(c);\n                        } else if (c \u003e 0x07FF) {\n                            write(0xE0 | ((c \u003e\u003e 12) \u0026 0x0F));\n                            write(0x80 | ((c \u003e\u003e 6) \u0026 0x3F));\n                            write(0x80 | ((c \u003e\u003e 0) \u0026 0x3F));\n                        } else {\n                            write(0xC0 | ((c \u003e\u003e 6) \u0026 0x1F));\n                            write(0x80 | ((c \u003e\u003e 0) \u0026 0x3F));\n                        }\n                    }\n                }\n                off +\u003d csize;\n            }\n        }\n    }\n\n    /**\n     * Lightweight identity hash table which maps objects to integer handles,\n     * assigned in ascending order.\n     */\n    private static final class HandleTable {\n\n        /* number of mappings in table/next available handle */\n        private int size;\n        /* size threshold determining when to expand hash spine */\n        private int threshold;\n        /* factor for computing size threshold */\n        private final float loadFactor;\n        /* maps hash value -\u003e candidate handle value */\n        private int[] spine;\n        /* maps handle value -\u003e next candidate handle value */\n        private int[] next;\n        /* maps handle value -\u003e associated object */\n        private Object[] objs;\n\n        /**\n         * Creates new HandleTable with given capacity and load factor.\n         */\n        HandleTable(int initialCapacity, float loadFactor) {\n            this.loadFactor \u003d loadFactor;\n            spine \u003d new int[initialCapacity];\n            next \u003d new int[initialCapacity];\n            objs \u003d new Object[initialCapacity];\n            threshold \u003d (int) (initialCapacity * loadFactor);\n            clear();\n        }\n\n        /**\n         * Assigns next available handle to given object, and returns handle\n         * value.  Handles are assigned in ascending order starting at 0.\n         */\n        int assign(Object obj) {\n            if (size \u003e\u003d next.length) {\n                growEntries();\n            }\n            if (size \u003e\u003d threshold) {\n                growSpine();\n            }\n            insert(obj, size);\n            return size++;\n        }\n\n        /**\n         * Looks up and returns handle associated with given object, or -1 if\n         * no mapping found.\n         */\n        int lookup(Object obj) {\n            if (size \u003d\u003d 0) {\n                return -1;\n            }\n            int index \u003d hash(obj) % spine.length;\n            for (int i \u003d spine[index]; i \u003e\u003d 0; i \u003d next[i]) {\n                if (objs[i] \u003d\u003d obj) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n\n        /**\n         * Resets table to its initial (empty) state.\n         */\n        void clear() {\n            Arrays.fill(spine, -1);\n            Arrays.fill(objs, 0, size, null);\n            size \u003d 0;\n        }\n\n        /**\n         * Returns the number of mappings currently in table.\n         */\n        int size() {\n            return size;\n        }\n\n        /**\n         * Inserts mapping object -\u003e handle mapping into table.  Assumes table\n         * is large enough to accommodate new mapping.\n         */\n        private void insert(Object obj, int handle) {\n            int index \u003d hash(obj) % spine.length;\n            objs[handle] \u003d obj;\n            next[handle] \u003d spine[index];\n            spine[index] \u003d handle;\n        }\n\n        /**\n         * Expands the hash \"spine\" -- equivalent to increasing the number of\n         * buckets in a conventional hash table.\n         */\n        private void growSpine() {\n            spine \u003d new int[(spine.length \u003c\u003c 1) + 1];\n            threshold \u003d (int) (spine.length * loadFactor);\n            Arrays.fill(spine, -1);\n            for (int i \u003d 0; i \u003c size; i++) {\n                insert(objs[i], i);\n            }\n        }\n\n        /**\n         * Increases hash table capacity by lengthening entry arrays.\n         */\n        private void growEntries() {\n            int newLength \u003d (next.length \u003c\u003c 1) + 1;\n            int[] newNext \u003d new int[newLength];\n            System.arraycopy(next, 0, newNext, 0, size);\n            next \u003d newNext;\n\n            Object[] newObjs \u003d new Object[newLength];\n            System.arraycopy(objs, 0, newObjs, 0, size);\n            objs \u003d newObjs;\n        }\n\n        /**\n         * Returns hash value for given object.\n         */\n        private int hash(Object obj) {\n            return System.identityHashCode(obj) \u0026 0x7FFFFFFF;\n        }\n    }\n\n    /**\n     * Lightweight identity hash table which maps objects to replacement\n     * objects.\n     */\n    private static final class ReplaceTable {\n\n        /* maps object -\u003e index */\n        private final HandleTable htab;\n        /* maps index -\u003e replacement object */\n        private Object[] reps;\n\n        /**\n         * Creates new ReplaceTable with given capacity and load factor.\n         */\n        ReplaceTable(int initialCapacity, float loadFactor) {\n            htab \u003d new HandleTable(initialCapacity, loadFactor);\n            reps \u003d new Object[initialCapacity];\n        }\n\n        /**\n         * Enters mapping from object to replacement object.\n         */\n        void assign(Object obj, Object rep) {\n            int index \u003d htab.assign(obj);\n            while (index \u003e\u003d reps.length) {\n                grow();\n            }\n            reps[index] \u003d rep;\n        }\n\n        /**\n         * Looks up and returns replacement for given object.  If no\n         * replacement is found, returns the lookup object itself.\n         */\n        Object lookup(Object obj) {\n            int index \u003d htab.lookup(obj);\n            return (index \u003e\u003d 0) ? reps[index] : obj;\n        }\n\n        /**\n         * Resets table to its initial (empty) state.\n         */\n        void clear() {\n            Arrays.fill(reps, 0, htab.size(), null);\n            htab.clear();\n        }\n\n        /**\n         * Returns the number of mappings currently in table.\n         */\n        int size() {\n            return htab.size();\n        }\n\n        /**\n         * Increases table capacity.\n         */\n        private void grow() {\n            Object[] newReps \u003d new Object[(reps.length \u003c\u003c 1) + 1];\n            System.arraycopy(reps, 0, newReps, 0, reps.length);\n            reps \u003d newReps;\n        }\n    }\n\n    /**\n     * Stack to keep debug information about the state of the\n     * serialization process, for embedding in exception messages.\n     */\n    private static final class DebugTraceInfoStack {\n        private final List\u003cString\u003e stack;\n\n        DebugTraceInfoStack() {\n            stack \u003d new ArrayList\u003c\u003e();\n        }\n\n        /**\n         * Removes all of the elements from enclosed list.\n         */\n        void clear() {\n            stack.clear();\n        }\n\n        /**\n         * Removes the object at the top of enclosed list.\n         */\n        void pop() {\n            stack.remove(stack.size()-1);\n        }\n\n        /**\n         * Pushes a String onto the top of enclosed list.\n         */\n        void push(String entry) {\n            stack.add(\"\\t- \" + entry);\n        }\n\n        /**\n         * Returns a string representation of this object\n         */\n        public String toString() {\n            StringJoiner sj \u003d new StringJoiner(\"\\n\");\n            for (int i \u003d stack.size() - 1; i \u003e\u003d 0; i--) {\n                sj.add(stack.get(i));\n            }\n            return sj.toString();\n        }\n    }\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/io/ObjectOutputStream.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/io/ObjectOutputStream.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

Π°ΠΏΡ€. 12, 2024 8:11:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/io/ObjectOutputStream.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/io/ObjectOutputStream.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/io/ObjectOutputStream.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.04.12 20:11:33 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/io/ObjectOutputStream.java

Uri: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/io/ObjectOutputStream.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:689)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:703)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1570)
```

Π°ΠΏΡ€. 12, 2024 8:11:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/io/ObjectOutputStream.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2023, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.io;\n\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.StringJoiner;\n\nimport jdk.internal.util.ByteArray;\nimport sun.reflect.misc.ReflectUtil;\n\n/**\n * An ObjectOutputStream writes primitive data types and graphs of Java objects\n * to an OutputStream.  The objects can be read (reconstituted) using an\n * ObjectInputStream.  Persistent storage of objects can be accomplished by\n * using a file for the stream.  If the stream is a network socket stream, the\n * objects can be reconstituted on another host or in another process.\n *\n * \u003cp\u003eOnly objects that support the java.io.Serializable interface can be\n * written to streams.  The class of each serializable object is encoded\n * including the class name and signature of the class, the values of the\n * object\u0027s fields and arrays, and the closure of any other objects referenced\n * from the initial objects.\n *\n * \u003cp\u003eThe method writeObject is used to write an object to the stream.  Any\n * object, including Strings and arrays, is written with writeObject. Multiple\n * objects or primitives can be written to the stream.  The objects must be\n * read back from the corresponding ObjectInputstream with the same types and\n * in the same order as they were written.\n *\n * \u003cp\u003ePrimitive data types can also be written to the stream using the\n * appropriate methods from DataOutput. Strings can also be written using the\n * writeUTF method.\n *\n * \u003cp\u003eThe default serialization mechanism for an object writes the class of the\n * object, the class signature, and the values of all non-transient and\n * non-static fields.  References to other objects (except in transient or\n * static fields) cause those objects to be written also. Multiple references\n * to a single object are encoded using a reference sharing mechanism so that\n * graphs of objects can be restored to the same shape as when the original was\n * written.\n *\n * \u003cp\u003eFor example to write an object that can be read by the example in\n * {@link ObjectInputStream}:\n * {@snippet lang\u003d\"java\":\n *      try (FileOutputStream fos \u003d new FileOutputStream(\"t.tmp\");\n *           ObjectOutputStream oos \u003d new ObjectOutputStream(fos)) {\n *          oos.writeObject(\"Today\");\n *          oos.writeObject(LocalDateTime.now());\n *      } catch (Exception ex) {\n *          // handle exception\n *      }\n * }\n *\n * \u003cp\u003eSerializable classes that require special handling during the\n * serialization and deserialization process should implement methods\n * with the following signatures:\n *\n * {@snippet lang\u003d\"java\":\n *     private void readObject(java.io.ObjectInputStream stream)\n *         throws IOException, ClassNotFoundException;\n *     private void writeObject(java.io.ObjectOutputStream stream)\n *         throws IOException;\n *     private void readObjectNoData()\n *         throws ObjectStreamException;\n * }\n *\n * \u003cp\u003eThe method name, modifiers, return type, and number and type of\n * parameters must match exactly for the method to be used by\n * serialization or deserialization. The methods should only be\n * declared to throw checked exceptions consistent with these\n * signatures.\n *\n * \u003cp\u003eThe writeObject method is responsible for writing the state of the object\n * for its particular class so that the corresponding readObject method can\n * restore it.  The method does not need to concern itself with the state\n * belonging to the object\u0027s superclasses or subclasses.  State is saved by\n * writing the individual fields to the ObjectOutputStream using the\n * writeObject method or by using the methods for primitive data types\n * supported by DataOutput.\n *\n * \u003cp\u003eSerialization does not write out the fields of any object that does not\n * implement the java.io.Serializable interface.  Subclasses of Objects that\n * are not serializable can be serializable. In this case the non-serializable\n * class must have a no-arg constructor to allow its fields to be initialized.\n * In this case it is the responsibility of the subclass to save and restore\n * the state of the non-serializable class. It is frequently the case that the\n * fields of that class are accessible (public, package, or protected) or that\n * there are get and set methods that can be used to restore the state.\n *\n * \u003cp\u003eSerialization of an object can be prevented by implementing writeObject\n * and readObject methods that throw the NotSerializableException.  The\n * exception will be caught by the ObjectOutputStream and abort the\n * serialization process.\n *\n * \u003cp\u003eImplementing the Externalizable interface allows the object to assume\n * complete control over the contents and format of the object\u0027s serialized\n * form.  The methods of the Externalizable interface, writeExternal and\n * readExternal, are called to save and restore the objects state.  When\n * implemented by a class they can write and read their own state using all of\n * the methods of ObjectOutput and ObjectInput.  It is the responsibility of\n * the objects to handle any versioning that occurs.\n *\n * \u003cp\u003eEnum constants are serialized differently than ordinary serializable or\n * externalizable objects.  The serialized form of an enum constant consists\n * solely of its name; field values of the constant are not transmitted.  To\n * serialize an enum constant, ObjectOutputStream writes the string returned by\n * the constant\u0027s name method.  Like other serializable or externalizable\n * objects, enum constants can function as the targets of back references\n * appearing subsequently in the serialization stream.  The process by which\n * enum constants are serialized cannot be customized; any class-specific\n * writeObject and writeReplace methods defined by enum types are ignored\n * during serialization.  Similarly, any serialPersistentFields or\n * serialVersionUID field declarations are also ignored--all enum types have a\n * fixed serialVersionUID of 0L.\n *\n * \u003cp\u003ePrimitive data, excluding serializable fields and externalizable data, is\n * written to the ObjectOutputStream in block-data records. A block data record\n * is composed of a header and data. The block data header consists of a marker\n * and the number of bytes to follow the header.  Consecutive primitive data\n * writes are merged into one block-data record.  The blocking factor used for\n * a block-data record will be 1024 bytes.  Each block-data record will be\n * filled up to 1024 bytes, or be written whenever there is a termination of\n * block-data mode.  Calls to the ObjectOutputStream methods writeObject,\n * defaultWriteObject and writeFields initially terminate any existing\n * block-data record.\n *\n * \u003cp\u003eRecords are serialized differently than ordinary serializable or externalizable\n * objects, see \u003ca href\u003d\"ObjectInputStream.html#record-serialization\"\u003erecord serialization\u003c/a\u003e.\n *\n * @spec serialization/index.html Java Object Serialization Specification\n * @author      Mike Warres\n * @author      Roger Riggs\n * @see java.io.DataOutput\n * @see java.io.ObjectInputStream\n * @see java.io.Serializable\n * @see java.io.Externalizable\n * @see \u003ca href\u003d\"{@docRoot}/../specs/serialization/output.html\"\u003e\n *      \u003ccite\u003eJava Object Serialization Specification,\u003c/cite\u003e Section 2, \"Object Output Classes\"\u003c/a\u003e\n * @since       1.1\n */\npublic class ObjectOutputStream\n    extends OutputStream implements ObjectOutput, ObjectStreamConstants\n{\n\n    private static class Caches {\n        /** cache of subclass security audit results */\n        static final ClassValue\u003cBoolean\u003e subclassAudits \u003d\n            new ClassValue\u003c\u003e() {\n                @Override\n                protected Boolean computeValue(Class\u003c?\u003e type) {\n                    return auditSubclass(type);\n                }\n            };\n    }\n\n    /** filter stream for handling block data conversion */\n    private final BlockDataOutputStream bout;\n    /** obj -\u003e wire handle map */\n    private final HandleTable handles;\n    /** obj -\u003e replacement obj map */\n    private final ReplaceTable subs;\n    /** stream protocol version */\n    private int protocol \u003d PROTOCOL_VERSION_2;\n    /** recursion depth */\n    private int depth;\n\n    /** buffer for writing primitive field values */\n    private byte[] primVals;\n\n    /** if true, invoke writeObjectOverride() instead of writeObject() */\n    private final boolean enableOverride;\n    /** if true, invoke replaceObject() */\n    private boolean enableReplace;\n\n    // values below valid only during upcalls to writeObject()/writeExternal()\n    /**\n     * Context during upcalls to class-defined writeObject methods; holds\n     * object currently being serialized and descriptor for current class.\n     * Null when not during writeObject upcall.\n     */\n    private SerialCallbackContext curContext;\n    /** current PutField object */\n    private PutFieldImpl curPut;\n\n    /** custom storage for debug trace info */\n    private final DebugTraceInfoStack debugInfoStack;\n\n    /**\n     * value of \"sun.io.serialization.extendedDebugInfo\" property,\n     * as true or false for extended information about exception\u0027s place\n     */\n    @SuppressWarnings(\"removal\")\n    private static final boolean extendedDebugInfo \u003d\n        java.security.AccessController.doPrivileged(\n            new sun.security.action.GetBooleanAction(\n                \"sun.io.serialization.extendedDebugInfo\")).booleanValue();\n\n    /**\n     * Creates an ObjectOutputStream that writes to the specified OutputStream.\n     * This constructor writes the serialization stream header to the\n     * underlying stream; callers may wish to flush the stream immediately to\n     * ensure that constructors for receiving ObjectInputStreams will not block\n     * when reading the header.\n     *\n     * \u003cp\u003eIf a security manager is installed, this constructor will check for\n     * the \"enableSubclassImplementation\" SerializablePermission when invoked\n     * directly or indirectly by the constructor of a subclass which overrides\n     * the ObjectOutputStream.putFields or ObjectOutputStream.writeUnshared\n     * methods.\n     *\n     * @param   out output stream to write to\n     * @throws  IOException if an I/O error occurs while writing stream header\n     * @throws  SecurityException if untrusted subclass illegally overrides\n     *          security-sensitive methods\n     * @throws  NullPointerException if {@code out} is {@code null}\n     * @since   1.4\n     * @see     ObjectOutputStream#ObjectOutputStream()\n     * @see     ObjectOutputStream#putFields()\n     * @see     ObjectInputStream#ObjectInputStream(InputStream)\n     */\n    public ObjectOutputStream(OutputStream out) throws IOException {\n        verifySubclass();\n        bout \u003d new BlockDataOutputStream(out);\n        handles \u003d new HandleTable(10, (float) 3.00);\n        subs \u003d new ReplaceTable(10, (float) 3.00);\n        enableOverride \u003d false;\n        writeStreamHeader();\n        bout.setBlockDataMode(true);\n        if (extendedDebugInfo) {\n            debugInfoStack \u003d new DebugTraceInfoStack();\n        } else {\n            debugInfoStack \u003d null;\n        }\n    }\n\n    /**\n     * Provide a way for subclasses that are completely reimplementing\n     * ObjectOutputStream to not have to allocate private data just used by\n     * this implementation of ObjectOutputStream.\n     *\n     * \u003cp\u003eIf there is a security manager installed, this method first calls the\n     * security manager\u0027s {@code checkPermission} method with a\n     * {@code SerializablePermission(\"enableSubclassImplementation\")}\n     * permission to ensure it\u0027s ok to enable subclassing.\n     *\n     * @throws  SecurityException if a security manager exists and its\n     *          {@code checkPermission} method denies enabling\n     *          subclassing.\n     * @throws  IOException if an I/O error occurs while creating this stream\n     * @see SecurityManager#checkPermission\n     * @see java.io.SerializablePermission\n     */\n    protected ObjectOutputStream() throws IOException, SecurityException {\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d System.getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);\n        }\n        bout \u003d null;\n        handles \u003d null;\n        subs \u003d null;\n        enableOverride \u003d true;\n        debugInfoStack \u003d null;\n    }\n\n    /**\n     * Specify stream protocol version to use when writing the stream.\n     *\n     * \u003cp\u003eThis routine provides a hook to enable the current version of\n     * Serialization to write in a format that is backwards compatible to a\n     * previous version of the stream format.\n     *\n     * \u003cp\u003eEvery effort will be made to avoid introducing additional\n     * backwards incompatibilities; however, sometimes there is no\n     * other alternative.\n     *\n     * @param   version use ProtocolVersion from java.io.ObjectStreamConstants.\n     * @throws  IllegalStateException if called after any objects\n     *          have been serialized.\n     * @throws  IllegalArgumentException if invalid version is passed in.\n     * @throws  IOException if I/O errors occur\n     * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_1\n     * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_2\n     * @since   1.2\n     */\n    public void useProtocolVersion(int version) throws IOException {\n        if (handles.size() !\u003d 0) {\n            // REMIND: implement better check for pristine stream?\n            throw new IllegalStateException(\"stream non-empty\");\n        }\n        switch (version) {\n            case PROTOCOL_VERSION_1:\n            case PROTOCOL_VERSION_2:\n                protocol \u003d version;\n                break;\n\n            default:\n                throw new IllegalArgumentException(\n                    \"unknown version: \" + version);\n        }\n    }\n\n    /**\n     * Write the specified object to the ObjectOutputStream.  The class of the\n     * object, the signature of the class, and the values of the non-transient\n     * and non-static fields of the class and all of its supertypes are\n     * written.  Default serialization for a class can be overridden using the\n     * writeObject and the readObject methods.  Objects referenced by this\n     * object are written transitively so that a complete equivalent graph of\n     * objects can be reconstructed by an ObjectInputStream.\n     *\n     * \u003cp\u003eExceptions are thrown for problems with the OutputStream and for\n     * classes that should not be serialized.  All exceptions are fatal to the\n     * OutputStream, which is left in an indeterminate state, and it is up to\n     * the caller to ignore or recover the stream state.\n     *\n     * @throws  InvalidClassException Something is wrong with a class used by\n     *          serialization.\n     * @throws  NotSerializableException Some object to be serialized does not\n     *          implement the java.io.Serializable interface.\n     * @throws  IOException Any exception thrown by the underlying\n     *          OutputStream.\n     */\n    public final void writeObject(Object obj) throws IOException {\n        if (enableOverride) {\n            writeObjectOverride(obj);\n            return;\n        }\n        try {\n            writeObject0(obj, false);\n        } catch (IOException ex) {\n            if (depth \u003d\u003d 0) {\n                writeFatalException(ex);\n            }\n            throw ex;\n        }\n    }\n\n    /**\n     * Method used by subclasses to override the default writeObject method.\n     * This method is called by trusted subclasses of ObjectOutputStream that\n     * constructed ObjectOutputStream using the protected no-arg constructor.\n     * The subclass is expected to provide an override method with the modifier\n     * \"final\".\n     *\n     * @param   obj object to be written to the underlying stream\n     * @throws  IOException if there are I/O errors while writing to the\n     *          underlying stream\n     * @see #ObjectOutputStream()\n     * @see #writeObject(Object)\n     * @since 1.2\n     */\n    protected void writeObjectOverride(Object obj) throws IOException {\n    }\n\n    /**\n     * Writes an \"unshared\" object to the ObjectOutputStream.  This method is\n     * identical to writeObject, except that it always writes the given object\n     * as a new, unique object in the stream (as opposed to a back-reference\n     * pointing to a previously serialized instance).  Specifically:\n     * \u003cul\u003e\n     *   \u003cli\u003eAn object written via writeUnshared is always serialized in the\n     *       same manner as a newly appearing object (an object that has not\n     *       been written to the stream yet), regardless of whether or not the\n     *       object has been written previously.\n     *\n     *   \u003cli\u003eIf writeObject is used to write an object that has been previously\n     *       written with writeUnshared, the previous writeUnshared operation\n     *       is treated as if it were a write of a separate object.  In other\n     *       words, ObjectOutputStream will never generate back-references to\n     *       object data written by calls to writeUnshared.\n     * \u003c/ul\u003e\n     * While writing an object via writeUnshared does not in itself guarantee a\n     * unique reference to the object when it is deserialized, it allows a\n     * single object to be defined multiple times in a stream, so that multiple\n     * calls to readUnshared by the receiver will not conflict.  Note that the\n     * rules described above only apply to the base-level object written with\n     * writeUnshared, and not to any transitively referenced sub-objects in the\n     * object graph to be serialized.\n     *\n     * \u003cp\u003eObjectOutputStream subclasses which override this method can only be\n     * constructed in security contexts possessing the\n     * \"enableSubclassImplementation\" SerializablePermission; any attempt to\n     * instantiate such a subclass without this permission will cause a\n     * SecurityException to be thrown.\n     *\n     * @param   obj object to write to stream\n     * @throws  NotSerializableException if an object in the graph to be\n     *          serialized does not implement the Serializable interface\n     * @throws  InvalidClassException if a problem exists with the class of an\n     *          object to be serialized\n     * @throws  IOException if an I/O error occurs during serialization\n     * @since 1.4\n     */\n    public void writeUnshared(Object obj) throws IOException {\n        try {\n            writeObject0(obj, true);\n        } catch (IOException ex) {\n            if (depth \u003d\u003d 0) {\n                writeFatalException(ex);\n            }\n            throw ex;\n        }\n    }\n\n    /**\n     * Write the non-static and non-transient fields of the current class to\n     * this stream.  This may only be called from the writeObject method of the\n     * class being serialized. It will throw the NotActiveException if it is\n     * called otherwise.\n     *\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          {@code OutputStream}\n     */\n    public void defaultWriteObject() throws IOException {\n        SerialCallbackContext ctx \u003d curContext;\n        if (ctx \u003d\u003d null) {\n            throw new NotActiveException(\"not in call to writeObject\");\n        }\n        Object curObj \u003d ctx.getObj();\n        ObjectStreamClass curDesc \u003d ctx.getDesc();\n        bout.setBlockDataMode(false);\n        defaultWriteFields(curObj, curDesc);\n        bout.setBlockDataMode(true);\n    }\n\n    /**\n     * Retrieve the object used to buffer persistent fields to be written to\n     * the stream.  The fields will be written to the stream when writeFields\n     * method is called.\n     *\n     * @return  an instance of the class Putfield that holds the serializable\n     *          fields\n     * @throws  IOException if I/O errors occur\n     * @since 1.2\n     */\n    public ObjectOutputStream.PutField putFields() throws IOException {\n        if (curPut \u003d\u003d null) {\n            SerialCallbackContext ctx \u003d curContext;\n            if (ctx \u003d\u003d null) {\n                throw new NotActiveException(\"not in call to writeObject\");\n            }\n            ctx.checkAndSetUsed();\n            ObjectStreamClass curDesc \u003d ctx.getDesc();\n            curPut \u003d new PutFieldImpl(curDesc);\n        }\n        return curPut;\n    }\n\n    /**\n     * Write the buffered fields to the stream.\n     *\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     * @throws  NotActiveException Called when a classes writeObject method was\n     *          not called to write the state of the object.\n     * @since 1.2\n     */\n    public void writeFields() throws IOException {\n        if (curPut \u003d\u003d null) {\n            throw new NotActiveException(\"no current PutField object\");\n        }\n        bout.setBlockDataMode(false);\n        curPut.writeFields();\n        bout.setBlockDataMode(true);\n    }\n\n    /**\n     * Reset will disregard the state of any objects already written to the\n     * stream.  The state is reset to be the same as a new ObjectOutputStream.\n     * The current point in the stream is marked as reset so the corresponding\n     * ObjectInputStream will be reset at the same point.  Objects previously\n     * written to the stream will not be referred to as already being in the\n     * stream.  They will be written to the stream again.\n     *\n     * @throws  IOException if reset() is invoked while serializing an object.\n     */\n    public void reset() throws IOException {\n        if (depth !\u003d 0) {\n            throw new IOException(\"stream active\");\n        }\n        bout.setBlockDataMode(false);\n        bout.writeByte(TC_RESET);\n        clear();\n        bout.setBlockDataMode(true);\n    }\n\n    /**\n     * Subclasses may implement this method to allow class data to be stored in\n     * the stream. By default this method does nothing.  The corresponding\n     * method in ObjectInputStream is resolveClass.  This method is called\n     * exactly once for each unique class in the stream.  The class name and\n     * signature will have already been written to the stream.  This method may\n     * make free use of the ObjectOutputStream to save any representation of\n     * the class it deems suitable (for example, the bytes of the class file).\n     * The resolveClass method in the corresponding subclass of\n     * ObjectInputStream must read and use any data or objects written by\n     * annotateClass.\n     *\n     * @param   cl the class to annotate custom data for\n     * @throws  IOException Any exception thrown by the underlying\n     *          OutputStream.\n     */\n    protected void annotateClass(Class\u003c?\u003e cl) throws IOException {\n    }\n\n    /**\n     * Subclasses may implement this method to store custom data in the stream\n     * along with descriptors for dynamic proxy classes.\n     *\n     * \u003cp\u003eThis method is called exactly once for each unique proxy class\n     * descriptor in the stream.  The default implementation of this method in\n     * {@code ObjectOutputStream} does nothing.\n     *\n     * \u003cp\u003eThe corresponding method in {@code ObjectInputStream} is\n     * {@code resolveProxyClass}.  For a given subclass of\n     * {@code ObjectOutputStream} that overrides this method, the\n     * {@code resolveProxyClass} method in the corresponding subclass of\n     * {@code ObjectInputStream} must read any data or objects written by\n     * {@code annotateProxyClass}.\n     *\n     * @param   cl the proxy class to annotate custom data for\n     * @throws  IOException any exception thrown by the underlying\n     *          {@code OutputStream}\n     * @see ObjectInputStream#resolveProxyClass(String[])\n     * @since   1.3\n     */\n    protected void annotateProxyClass(Class\u003c?\u003e cl) throws IOException {\n    }\n\n    /**\n     * This method will allow trusted subclasses of ObjectOutputStream to\n     * substitute one object for another during serialization. Replacing\n     * objects is disabled until enableReplaceObject is called. The\n     * enableReplaceObject method checks that the stream requesting to do\n     * replacement can be trusted.  The first occurrence of each object written\n     * into the serialization stream is passed to replaceObject.  Subsequent\n     * references to the object are replaced by the object returned by the\n     * original call to replaceObject.  To ensure that the private state of\n     * objects is not unintentionally exposed, only trusted streams may use\n     * replaceObject.\n     *\n     * \u003cp\u003eThe ObjectOutputStream.writeObject method takes a parameter of type\n     * Object (as opposed to type Serializable) to allow for cases where\n     * non-serializable objects are replaced by serializable ones.\n     *\n     * \u003cp\u003eWhen a subclass is replacing objects it must ensure that either a\n     * complementary substitution must be made during deserialization or that\n     * the substituted object is compatible with every field where the\n     * reference will be stored.  Objects whose type is not a subclass of the\n     * type of the field or array element abort the serialization by raising an\n     * exception and the object is not be stored.\n     *\n     * \u003cp\u003eThis method is called only once when each object is first\n     * encountered.  All subsequent references to the object will be redirected\n     * to the new object. This method should return the object to be\n     * substituted or the original object.\n     *\n     * \u003cp\u003eNull can be returned as the object to be substituted, but may cause\n     * {@link NullPointerException} in classes that contain references to the\n     * original object since they may be expecting an object instead of\n     * null.\n     *\n     * @param   obj the object to be replaced\n     * @return  the alternate object that replaced the specified one\n     * @throws  IOException Any exception thrown by the underlying\n     *          OutputStream.\n     */\n    protected Object replaceObject(Object obj) throws IOException {\n        return obj;\n    }\n\n    /**\n     * Enables the stream to do replacement of objects written to the stream.  When\n     * enabled, the {@link #replaceObject} method is called for every object being\n     * serialized.\n     *\n     * \u003cp\u003eIf object replacement is currently not enabled, and\n     * {@code enable} is true, and there is a security manager installed,\n     * this method first calls the security manager\u0027s\n     * {@code checkPermission} method with the\n     * {@code SerializablePermission(\"enableSubstitution\")} permission to\n     * ensure that the caller is permitted to enable the stream to do replacement\n     * of objects written to the stream.\n     *\n     * @param   enable true for enabling use of {@code replaceObject} for\n     *          every object being serialized\n     * @return  the previous setting before this method was invoked\n     * @throws  SecurityException if a security manager exists and its\n     *          {@code checkPermission} method denies enabling the stream\n     *          to do replacement of objects written to the stream.\n     * @see SecurityManager#checkPermission\n     * @see java.io.SerializablePermission\n     */\n    protected boolean enableReplaceObject(boolean enable)\n        throws SecurityException\n    {\n        if (enable \u003d\u003d enableReplace) {\n            return enable;\n        }\n        if (enable) {\n            @SuppressWarnings(\"removal\")\n            SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(SUBSTITUTION_PERMISSION);\n            }\n        }\n        enableReplace \u003d enable;\n        return !enableReplace;\n    }\n\n    /**\n     * The writeStreamHeader method is provided so subclasses can append or\n     * prepend their own header to the stream.  It writes the magic number and\n     * version to the stream.\n     *\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    protected void writeStreamHeader() throws IOException {\n        bout.writeShort(STREAM_MAGIC);\n        bout.writeShort(STREAM_VERSION);\n    }\n\n    /**\n     * Write the specified class descriptor to the ObjectOutputStream.  Class\n     * descriptors are used to identify the classes of objects written to the\n     * stream.  Subclasses of ObjectOutputStream may override this method to\n     * customize the way in which class descriptors are written to the\n     * serialization stream.  The corresponding method in ObjectInputStream,\n     * {@link ObjectInputStream#readClassDescriptor readClassDescriptor}, should then be overridden to\n     * reconstitute the class descriptor from its custom stream representation.\n     * By default, this method writes class descriptors according to the format\n     * defined in the \u003ca href\u003d\"{@docRoot}/../specs/serialization/index.html\"\u003e\n     * \u003ccite\u003eJava Object Serialization Specification\u003c/cite\u003e\u003c/a\u003e.\n     *\n     * \u003cp\u003eNote that this method will only be called if the ObjectOutputStream\n     * is not using the old serialization stream format (set by calling\n     * ObjectOutputStream\u0027s {@code useProtocolVersion} method).  If this\n     * serialization stream is using the old format\n     * ({@code PROTOCOL_VERSION_1}), the class descriptor will be written\n     * internally in a manner that cannot be overridden or customized.\n     *\n     * @param   desc class descriptor to write to the stream\n     * @throws  IOException If an I/O error has occurred.\n     * @spec serialization/index.html Java Object Serialization Specification\n     * @see java.io.ObjectInputStream#readClassDescriptor()\n     * @see #useProtocolVersion(int)\n     * @see java.io.ObjectStreamConstants#PROTOCOL_VERSION_1\n     * @since 1.3\n     */\n    protected void writeClassDescriptor(ObjectStreamClass desc)\n        throws IOException\n    {\n        desc.writeNonProxy(this);\n    }\n\n    /**\n     * Writes a byte. This method will block until the byte is actually\n     * written.\n     *\n     * @param   val the byte to be written to the stream\n     * @throws  IOException If an I/O error has occurred.\n     */\n    @Override\n    public void write(int val) throws IOException {\n        bout.write(val);\n    }\n\n    /**\n     * Writes an array of bytes. This method will block until the bytes are\n     * actually written.\n     *\n     * @param   buf the data to be written\n     * @throws  IOException If an I/O error has occurred.\n     */\n    @Override\n    public void write(byte[] buf) throws IOException {\n        bout.write(buf, 0, buf.length, false);\n    }\n\n    /**\n     * Writes a sub array of bytes.\n     *\n     * @param   buf the data to be written\n     * @param   off the start offset in the data\n     * @param   len the number of bytes that are written\n     * @throws  IOException {@inheritDoc}\n     * @throws  IndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public void write(byte[] buf, int off, int len) throws IOException {\n        if (buf \u003d\u003d null) {\n            throw new NullPointerException();\n        }\n        Objects.checkFromIndexSize(off, len, buf.length);\n        bout.write(buf, off, len, false);\n    }\n\n    /**\n     * Flushes the stream. This will write any buffered output bytes and flush\n     * through to the underlying stream.\n     *\n     * @throws  IOException {@inheritDoc}\n     */\n    @Override\n    public void flush() throws IOException {\n        bout.flush();\n    }\n\n    /**\n     * Drain any buffered data in ObjectOutputStream.  Similar to flush but\n     * does not propagate the flush to the underlying stream.\n     *\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    protected void drain() throws IOException {\n        bout.drain();\n    }\n\n    /**\n     * Closes the stream. This method must be called to release any resources\n     * associated with the stream.\n     *\n     * @throws  IOException If an I/O error has occurred.\n     */\n    @Override\n    public void close() throws IOException {\n        flush();\n        clear();\n        bout.close();\n    }\n\n    /**\n     * Writes a boolean.\n     *\n     * @param   val the boolean to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeBoolean(boolean val) throws IOException {\n        bout.writeBoolean(val);\n    }\n\n    /**\n     * Writes an 8-bit byte.\n     *\n     * @param   val the byte value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeByte(int val) throws IOException  {\n        bout.writeByte(val);\n    }\n\n    /**\n     * Writes a 16-bit short.\n     *\n     * @param   val the short value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeShort(int val)  throws IOException {\n        bout.writeShort(val);\n    }\n\n    /**\n     * Writes a 16-bit char.\n     *\n     * @param   val the char value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeChar(int val)  throws IOException {\n        bout.writeChar(val);\n    }\n\n    /**\n     * Writes a 32-bit int.\n     *\n     * @param   val the integer value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeInt(int val)  throws IOException {\n        bout.writeInt(val);\n    }\n\n    /**\n     * Writes a 64-bit long.\n     *\n     * @param   val the long value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeLong(long val)  throws IOException {\n        bout.writeLong(val);\n    }\n\n    /**\n     * Writes a 32-bit float.\n     *\n     * @param   val the float value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeFloat(float val) throws IOException {\n        bout.writeFloat(val);\n    }\n\n    /**\n     * Writes a 64-bit double.\n     *\n     * @param   val the double value to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeDouble(double val) throws IOException {\n        bout.writeDouble(val);\n    }\n\n    /**\n     * Writes a String as a sequence of bytes.\n     *\n     * @param   str the String of bytes to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeBytes(String str) throws IOException {\n        bout.writeBytes(str);\n    }\n\n    /**\n     * Writes a String as a sequence of chars.\n     *\n     * @param   str the String of chars to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeChars(String str) throws IOException {\n        bout.writeChars(str);\n    }\n\n    /**\n     * Primitive data write of this String in\n     * \u003ca href\u003d\"DataInput.html#modified-utf-8\"\u003emodified UTF-8\u003c/a\u003e\n     * format.  Note that there is a\n     * significant difference between writing a String into the stream as\n     * primitive data or as an Object. A String instance written by writeObject\n     * is written into the stream as a String initially. Future writeObject()\n     * calls write references to the string into the stream.\n     *\n     * @param   str the String to be written\n     * @throws  IOException if I/O errors occur while writing to the underlying\n     *          stream\n     */\n    public void writeUTF(String str) throws IOException {\n        bout.writeUTF(str);\n    }\n\n    /**\n     * Provide programmatic access to the persistent fields to be written\n     * to ObjectOutput.\n     *\n     * @since 1.2\n     */\n    public abstract static class PutField {\n        /**\n         * Constructor for subclasses to call.\n         */\n        public PutField() {}\n\n        /**\n         * Put the value of the named boolean field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code boolean}\n         */\n        public abstract void put(String name, boolean val);\n\n        /**\n         * Put the value of the named byte field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code byte}\n         */\n        public abstract void put(String name, byte val);\n\n        /**\n         * Put the value of the named char field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code char}\n         */\n        public abstract void put(String name, char val);\n\n        /**\n         * Put the value of the named short field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code short}\n         */\n        public abstract void put(String name, short val);\n\n        /**\n         * Put the value of the named int field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code int}\n         */\n        public abstract void put(String name, int val);\n\n        /**\n         * Put the value of the named long field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code long}\n         */\n        public abstract void put(String name, long val);\n\n        /**\n         * Put the value of the named float field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code float}\n         */\n        public abstract void put(String name, float val);\n\n        /**\n         * Put the value of the named double field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not\n         * {@code double}\n         */\n        public abstract void put(String name, double val);\n\n        /**\n         * Put the value of the named Object field into the persistent field.\n         *\n         * @param  name the name of the serializable field\n         * @param  val the value to assign to the field\n         *         (which may be {@code null})\n         * @throws IllegalArgumentException if {@code name} does not\n         * match the name of a serializable field for the class whose fields\n         * are being written, or if the type of the named field is not a\n         * reference type\n         */\n        public abstract void put(String name, Object val);\n\n        /**\n         * Write the data and fields to the specified ObjectOutput stream,\n         * which must be the same stream that produced this\n         * {@code PutField} object.\n         *\n         * @param  out the stream to write the data and fields to\n         * @throws IOException if I/O errors occur while writing to the\n         *         underlying stream\n         * @throws IllegalArgumentException if the specified stream is not\n         *         the same stream that produced this {@code PutField}\n         *         object\n         * @deprecated This method does not write the values contained by this\n         *         {@code PutField} object in a proper format, and may\n         *         result in corruption of the serialization stream.  The\n         *         correct way to write {@code PutField} data is by\n         *         calling the {@link java.io.ObjectOutputStream#writeFields()}\n         *         method.\n         */\n        @Deprecated\n        public abstract void write(ObjectOutput out) throws IOException;\n    }\n\n\n    /**\n     * Returns protocol version in use.\n     */\n    int getProtocolVersion() {\n        return protocol;\n    }\n\n    /**\n     * Writes string without allowing it to be replaced in stream.  Used by\n     * ObjectStreamClass to write class descriptor type strings.\n     */\n    void writeTypeString(String str) throws IOException {\n        int handle;\n        if (str \u003d\u003d null) {\n            writeNull();\n        } else if ((handle \u003d handles.lookup(str)) !\u003d -1) {\n            writeHandle(handle);\n        } else {\n            writeString(str, false);\n        }\n    }\n\n    /**\n     * Verifies that this (possibly subclass) instance can be constructed\n     * without violating security constraints: the subclass must not override\n     * security-sensitive non-final methods, or else the\n     * \"enableSubclassImplementation\" SerializablePermission is checked.\n     */\n    private void verifySubclass() {\n        Class\u003c?\u003e cl \u003d getClass();\n        if (cl \u003d\u003d ObjectOutputStream.class) {\n            return;\n        }\n        @SuppressWarnings(\"removal\")\n        SecurityManager sm \u003d System.getSecurityManager();\n        if (sm \u003d\u003d null) {\n            return;\n        }\n        boolean result \u003d Caches.subclassAudits.get(cl);\n        if (!result) {\n            sm.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);\n        }\n    }\n\n    /**\n     * Performs reflective checks on given subclass to verify that it doesn\u0027t\n     * override security-sensitive non-final methods.  Returns TRUE if subclass\n     * is \"safe\", FALSE otherwise.\n     */\n    @SuppressWarnings(\"removal\")\n    private static Boolean auditSubclass(Class\u003c?\u003e subcl) {\n        return AccessController.doPrivileged(\n            new PrivilegedAction\u003c\u003e() {\n                public Boolean run() {\n                    for (Class\u003c?\u003e cl \u003d subcl;\n                         cl !\u003d ObjectOutputStream.class;\n                         cl \u003d cl.getSuperclass())\n                    {\n                        try {\n                            cl.getDeclaredMethod(\n                                \"writeUnshared\", new Class\u003c?\u003e[] { Object.class });\n                            return Boolean.FALSE;\n                        } catch (NoSuchMethodException ex) {\n                        }\n                        try {\n                            cl.getDeclaredMethod(\"putFields\", (Class\u003c?\u003e[]) null);\n                            return Boolean.FALSE;\n                        } catch (NoSuchMethodException ex) {\n                        }\n                    }\n                    return Boolean.TRUE;\n                }\n            }\n        );\n    }\n\n    /**\n     * Clears internal data structures.\n     */\n    private void clear() {\n        subs.clear();\n        handles.clear();\n    }\n\n    /**\n     * Underlying writeObject/writeUnshared implementation.\n     */\n    private void writeObject0(Object obj, boolean unshared)\n        throws IOException\n    {\n        boolean oldMode \u003d bout.setBlockDataMode(false);\n        depth++;\n        try {\n            // handle previously written and non-replaceable objects\n            int h;\n            if ((obj \u003d subs.lookup(obj)) \u003d\u003d null) {\n                writeNull();\n                return;\n            } else if (!unshared \u0026\u0026 (h \u003d handles.lookup(obj)) !\u003d -1) {\n                writeHandle(h);\n                return;\n            } else if (obj instanceof Class) {\n                writeClass((Class) obj, unshared);\n                return;\n            } else if (obj instanceof ObjectStreamClass) {\n                writeClassDesc((ObjectStreamClass) obj, unshared);\n                return;\n            }\n\n            // check for replacement object\n            Object orig \u003d obj;\n            Class\u003c?\u003e cl \u003d obj.getClass();\n            ObjectStreamClass desc;\n            for (;;) {\n                // REMIND: skip this check for strings/arrays?\n                Class\u003c?\u003e repCl;\n                desc \u003d ObjectStreamClass.lookup(cl, true);\n                if (!desc.hasWriteReplaceMethod() ||\n                    (obj \u003d desc.invokeWriteReplace(obj)) \u003d\u003d null ||\n                    (repCl \u003d obj.getClass()) \u003d\u003d cl)\n                {\n                    break;\n                }\n                cl \u003d repCl;\n            }\n            if (enableReplace) {\n                Object rep \u003d replaceObject(obj);\n                if (rep !\u003d obj \u0026\u0026 rep !\u003d null) {\n                    cl \u003d rep.getClass();\n                    desc \u003d ObjectStreamClass.lookup(cl, true);\n                }\n                obj \u003d rep;\n            }\n\n            // if object replaced, run through original checks a second time\n            if (obj !\u003d orig) {\n                subs.assign(orig, obj);\n                if (obj \u003d\u003d null) {\n                    writeNull();\n                    return;\n                } else if (!unshared \u0026\u0026 (h \u003d handles.lookup(obj)) !\u003d -1) {\n                    writeHandle(h);\n                    return;\n                } else if (obj instanceof Class) {\n                    writeClass((Class) obj, unshared);\n                    return;\n                } else if (obj instanceof ObjectStreamClass) {\n                    writeClassDesc((ObjectStreamClass) obj, unshared);\n                    return;\n                }\n            }\n\n            // remaining cases\n            if (obj instanceof String) {\n                writeString((String) obj, unshared);\n            } else if (cl.isArray()) {\n                writeArray(obj, desc, unshared);\n            } else if (obj instanceof Enum) {\n                writeEnum((Enum\u003c?\u003e) obj, desc, unshared);\n            } else if (obj instanceof Serializable) {\n                writeOrdinaryObject(obj, desc, unshared);\n            } else {\n                if (extendedDebugInfo) {\n                    throw new NotSerializableException(\n                        cl.getName() + \"\\n\" + debugInfoStack.toString());\n                } else {\n                    throw new NotSerializableException(cl.getName());\n                }\n            }\n        } finally {\n            depth--;\n            bout.setBlockDataMode(oldMode);\n        }\n    }\n\n    /**\n     * Writes null code to stream.\n     */\n    private void writeNull() throws IOException {\n        bout.writeByte(TC_NULL);\n    }\n\n    /**\n     * Writes given object handle to stream.\n     */\n    private void writeHandle(int handle) throws IOException {\n        bout.writeByte(TC_REFERENCE);\n        bout.writeInt(baseWireHandle + handle);\n    }\n\n    /**\n     * Writes representation of given class to stream.\n     */\n    private void writeClass(Class\u003c?\u003e cl, boolean unshared) throws IOException {\n        bout.writeByte(TC_CLASS);\n        writeClassDesc(ObjectStreamClass.lookup(cl, true), false);\n        handles.assign(unshared ? null : cl);\n    }\n\n    /**\n     * Writes representation of given class descriptor to stream.\n     */\n    private void writeClassDesc(ObjectStreamClass desc, boolean unshared)\n        throws IOException\n    {\n        int handle;\n        if (desc \u003d\u003d null) {\n            writeNull();\n        } else if (!unshared \u0026\u0026 (handle \u003d handles.lookup(desc)) !\u003d -1) {\n            writeHandle(handle);\n        } else if (desc.isProxy()) {\n            writeProxyDesc(desc, unshared);\n        } else {\n            writeNonProxyDesc(desc, unshared);\n        }\n    }\n\n    private boolean isCustomSubclass() {\n        // Return true if this class is a custom subclass of ObjectOutputStream\n        return getClass().getClassLoader()\n                   !\u003d ObjectOutputStream.class.getClassLoader();\n    }\n\n    /**\n     * Writes class descriptor representing a dynamic proxy class to stream.\n     */\n    private void writeProxyDesc(ObjectStreamClass desc, boolean unshared)\n        throws IOException\n    {\n        bout.writeByte(TC_PROXYCLASSDESC);\n        handles.assign(unshared ? null : desc);\n\n        Class\u003c?\u003e cl \u003d desc.forClass();\n        Class\u003c?\u003e[] ifaces \u003d cl.getInterfaces();\n        bout.writeInt(ifaces.length);\n        for (int i \u003d 0; i \u003c ifaces.length; i++) {\n            bout.writeUTF(ifaces[i].getName());\n        }\n\n        bout.setBlockDataMode(true);\n        if (cl !\u003d null \u0026\u0026 isCustomSubclass()) {\n            ReflectUtil.checkPackageAccess(cl);\n        }\n        annotateProxyClass(cl);\n        bout.setBlockDataMode(false);\n        bout.writeByte(TC_ENDBLOCKDATA);\n\n        writeClassDesc(desc.getSuperDesc(), false);\n    }\n\n    /**\n     * Writes class descriptor representing a standard (i.e., not a dynamic\n     * proxy) class to stream.\n     */\n    private void writeNonProxyDesc(ObjectStreamClass desc, boolean unshared)\n        throws IOException\n    {\n        bout.writeByte(TC_CLASSDESC);\n        handles.assign(unshared ? null : desc);\n\n        if (protocol \u003d\u003d PROTOCOL_VERSION_1) {\n            // do not invoke class descriptor write hook with old protocol\n            desc.writeNonProxy(this);\n        } else {\n            writeClassDescriptor(desc);\n        }\n\n        Class\u003c?\u003e cl \u003d desc.forClass();\n        bout.setBlockDataMode(true);\n        if (cl !\u003d null \u0026\u0026 isCustomSubclass()) {\n            ReflectUtil.checkPackageAccess(cl);\n        }\n        annotateClass(cl);\n        bout.setBlockDataMode(false);\n        bout.writeByte(TC_ENDBLOCKDATA);\n\n        writeClassDesc(desc.getSuperDesc(), false);\n    }\n\n    /**\n     * Writes given string to stream, using standard or long UTF format\n     * depending on string length.\n     */\n    private void writeString(String str, boolean unshared) throws IOException {\n        handles.assign(unshared ? null : str);\n        long utflen \u003d bout.getUTFLength(str);\n        if (utflen \u003c\u003d 0xFFFF) {\n            bout.writeByte(TC_STRING);\n            bout.writeUTF(str, utflen);\n        } else {\n            bout.writeByte(TC_LONGSTRING);\n            bout.writeLongUTF(str, utflen);\n        }\n    }\n\n    /**\n     * Writes given array object to stream.\n     */\n    private void writeArray(Object array,\n                            ObjectStreamClass desc,\n                            boolean unshared)\n        throws IOException\n    {\n        bout.writeByte(TC_ARRAY);\n        writeClassDesc(desc, false);\n        handles.assign(unshared ? null : array);\n\n        Class\u003c?\u003e ccl \u003d desc.forClass().getComponentType();\n        if (ccl.isPrimitive()) {\n            if (ccl \u003d\u003d Integer.TYPE) {\n                int[] ia \u003d (int[]) array;\n                bout.writeInt(ia.length);\n                bout.writeInts(ia, 0, ia.length);\n            } else if (ccl \u003d\u003d Byte.TYPE) {\n                byte[] ba \u003d (byte[]) array;\n                bout.writeInt(ba.length);\n                bout.write(ba, 0, ba.length, true);\n            } else if (ccl \u003d\u003d Long.TYPE) {\n                long[] ja \u003d (long[]) array;\n                bout.writeInt(ja.length);\n                bout.writeLongs(ja, 0, ja.length);\n            } else if (ccl \u003d\u003d Float.TYPE) {\n                float[] fa \u003d (float[]) array;\n                bout.writeInt(fa.length);\n                bout.writeFloats(fa, 0, fa.length);\n            } else if (ccl \u003d\u003d Double.TYPE) {\n                double[] da \u003d (double[]) array;\n                bout.writeInt(da.length);\n                bout.writeDoubles(da, 0, da.length);\n            } else if (ccl \u003d\u003d Short.TYPE) {\n                short[] sa \u003d (short[]) array;\n                bout.writeInt(sa.length);\n                bout.writeShorts(sa, 0, sa.length);\n            } else if (ccl \u003d\u003d Character.TYPE) {\n                char[] ca \u003d (char[]) array;\n                bout.writeInt(ca.length);\n                bout.writeChars(ca, 0, ca.length);\n            } else if (ccl \u003d\u003d Boolean.TYPE) {\n                boolean[] za \u003d (boolean[]) array;\n                bout.writeInt(za.length);\n                bout.writeBooleans(za, 0, za.length);\n            } else {\n                throw new InternalError();\n            }\n        } else {\n            Object[] objs \u003d (Object[]) array;\n            int len \u003d objs.length;\n            bout.writeInt(len);\n            if (extendedDebugInfo) {\n                debugInfoStack.push(\n                    \"array (class \\\"\" + array.getClass().getName() +\n                    \"\\\", size: \" + len  + \")\");\n            }\n            try {\n                for (int i \u003d 0; i \u003c len; i++) {\n                    if (extendedDebugInfo) {\n                        debugInfoStack.push(\n                            \"element of array (index: \" + i + \")\");\n                    }\n                    try {\n                        writeObject0(objs[i], false);\n                    } finally {\n                        if (extendedDebugInfo) {\n                            debugInfoStack.pop();\n                        }\n                    }\n                }\n            } finally {\n                if (extendedDebugInfo) {\n                    debugInfoStack.pop();\n                }\n            }\n        }\n    }\n\n    /**\n     * Writes given enum constant to stream.\n     */\n    private void writeEnum(Enum\u003c?\u003e en,\n                           ObjectStreamClass desc,\n                           boolean unshared)\n        throws IOException\n    {\n        bout.writeByte(TC_ENUM);\n        ObjectStreamClass sdesc \u003d desc.getSuperDesc();\n        writeClassDesc((sdesc.forClass() \u003d\u003d Enum.class) ? desc : sdesc, false);\n        handles.assign(unshared ? null : en);\n        writeString(en.name(), false);\n    }\n\n    /**\n     * Writes representation of an \"ordinary\" (i.e., not a String, Class,\n     * ObjectStreamClass, array, or enum constant) serializable object to the\n     * stream.\n     */\n    private void writeOrdinaryObject(Object obj,\n                                     ObjectStreamClass desc,\n                                     boolean unshared)\n        throws IOException\n    {\n        if (extendedDebugInfo) {\n            debugInfoStack.push(\n                (depth \u003d\u003d 1 ? \"root \" : \"\") + \"object (class \\\"\" +\n                obj.getClass().getName() + \"\\\", \" + obj.toString() + \")\");\n        }\n        try {\n            desc.checkSerialize();\n\n            bout.writeByte(TC_OBJECT);\n            writeClassDesc(desc, false);\n            handles.assign(unshared ? null : obj);\n\n            if (desc.isRecord()) {\n                writeRecordData(obj, desc);\n            } else if (desc.isExternalizable() \u0026\u0026 !desc.isProxy()) {\n                writeExternalData((Externalizable) obj);\n            } else {\n                writeSerialData(obj, desc);\n            }\n        } finally {\n            if (extendedDebugInfo) {\n                debugInfoStack.pop();\n            }\n        }\n    }\n\n    /**\n     * Writes externalizable data of given object by invoking its\n     * writeExternal() method.\n     */\n    private void writeExternalData(Externalizable obj) throws IOException {\n        PutFieldImpl oldPut \u003d curPut;\n        curPut \u003d null;\n\n        if (extendedDebugInfo) {\n            debugInfoStack.push(\"writeExternal data\");\n        }\n        SerialCallbackContext oldContext \u003d curContext;\n        try {\n            curContext \u003d null;\n            if (protocol \u003d\u003d PROTOCOL_VERSION_1) {\n                obj.writeExternal(this);\n            } else {\n                bout.setBlockDataMode(true);\n                obj.writeExternal(this);\n                bout.setBlockDataMode(false);\n                bout.writeByte(TC_ENDBLOCKDATA);\n            }\n        } finally {\n            curContext \u003d oldContext;\n            if (extendedDebugInfo) {\n                debugInfoStack.pop();\n            }\n        }\n\n        curPut \u003d oldPut;\n    }\n\n    /** Writes the record component values for the given record object. */\n    private void writeRecordData(Object obj, ObjectStreamClass desc)\n        throws IOException\n    {\n        assert obj.getClass().isRecord();\n        ObjectStreamClass.ClassDataSlot[] slots \u003d desc.getClassDataLayout();\n        if (slots.length !\u003d 1) {\n            throw new InvalidClassException(\n                    \"expected a single record slot length, but found: \" + slots.length);\n        }\n\n        defaultWriteFields(obj, desc);  // #### seems unnecessary to use the accessors\n    }\n\n    /**\n     * Writes instance data for each serializable class of given object, from\n     * superclass to subclass.\n     */\n    private void writeSerialData(Object obj, ObjectStreamClass desc)\n        throws IOException\n    {\n        ObjectStreamClass.ClassDataSlot[] slots \u003d desc.getClassDataLayout();\n        for (int i \u003d 0; i \u003c slots.length; i++) {\n            ObjectStreamClass slotDesc \u003d slots[i].desc;\n            if (slotDesc.hasWriteObjectMethod()) {\n                PutFieldImpl oldPut \u003d curPut;\n                curPut \u003d null;\n                SerialCallbackContext oldContext \u003d curContext;\n\n                if (extendedDebugInfo) {\n                    debugInfoStack.push(\n                        \"custom writeObject data (class \\\"\" +\n                        slotDesc.getName() + \"\\\")\");\n                }\n                try {\n                    curContext \u003d new SerialCallbackContext(obj, slotDesc);\n                    bout.setBlockDataMode(true);\n                    slotDesc.invokeWriteObject(obj, this);\n                    bout.setBlockDataMode(false);\n                    bout.writeByte(TC_ENDBLOCKDATA);\n                } finally {\n                    curContext.setUsed();\n                    curContext \u003d oldContext;\n                    if (extendedDebugInfo) {\n                        debugInfoStack.pop();\n                    }\n                }\n\n                curPut \u003d oldPut;\n            } else {\n                defaultWriteFields(obj, slotDesc);\n            }\n        }\n    }\n\n    /**\n     * Fetches and writes values of serializable fields of given object to\n     * stream.  The given class descriptor specifies which field values to\n     * write, and in which order they should be written.\n     */\n    private void defaultWriteFields(Object obj, ObjectStreamClass desc)\n        throws IOException\n    {\n        Class\u003c?\u003e cl \u003d desc.forClass();\n        if (cl !\u003d null \u0026\u0026 obj !\u003d null \u0026\u0026 !cl.isInstance(obj)) {\n            throw new ClassCastException();\n        }\n\n        desc.checkDefaultSerialize();\n\n        int primDataSize \u003d desc.getPrimDataSize();\n        if (primDataSize \u003e 0) {\n            if (primVals \u003d\u003d null || primVals.length \u003c primDataSize) {\n                primVals \u003d new byte[primDataSize];\n            }\n            desc.getPrimFieldValues(obj, primVals);\n            bout.write(primVals, 0, primDataSize, false);\n        }\n\n        int numObjFields \u003d desc.getNumObjFields();\n        if (numObjFields \u003e 0) {\n            ObjectStreamField[] fields \u003d desc.getFields(false);\n            Object[] objVals \u003d new Object[numObjFields];\n            int numPrimFields \u003d fields.length - objVals.length;\n            desc.getObjFieldValues(obj, objVals);\n            for (int i \u003d 0; i \u003c objVals.length; i++) {\n                if (extendedDebugInfo) {\n                    debugInfoStack.push(\n                        \"field (class \\\"\" + desc.getName() + \"\\\", name: \\\"\" +\n                        fields[numPrimFields + i].getName() + \"\\\", type: \\\"\" +\n                        fields[numPrimFields + i].getType() + \"\\\")\");\n                }\n                try {\n                    writeObject0(objVals[i],\n                                 fields[numPrimFields + i].isUnshared());\n                } finally {\n                    if (extendedDebugInfo) {\n                        debugInfoStack.pop();\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Attempts to write to stream fatal IOException that has caused\n     * serialization to abort.\n     */\n    private void writeFatalException(IOException ex) throws IOException {\n        /*\n         * Note: the serialization specification states that if a second\n         * IOException occurs while attempting to serialize the original fatal\n         * exception to the stream, then a StreamCorruptedException should be\n         * thrown (section 2.1).  However, due to a bug in previous\n         * implementations of serialization, StreamCorruptedExceptions were\n         * rarely (if ever) actually thrown--the \"root\" exceptions from\n         * underlying streams were thrown instead.  This historical behavior is\n         * followed here for consistency.\n         */\n        clear();\n        boolean oldMode \u003d bout.setBlockDataMode(false);\n        try {\n            bout.writeByte(TC_EXCEPTION);\n            writeObject0(ex, false);\n            clear();\n        } finally {\n            bout.setBlockDataMode(oldMode);\n        }\n    }\n\n    /**\n     * Default PutField implementation.\n     */\n    private class PutFieldImpl extends PutField {\n\n        /** class descriptor describing serializable fields */\n        private final ObjectStreamClass desc;\n        /** primitive field values */\n        private final byte[] primVals;\n        /** object field values */\n        private final Object[] objVals;\n\n        /**\n         * Creates PutFieldImpl object for writing fields defined in given\n         * class descriptor.\n         */\n        PutFieldImpl(ObjectStreamClass desc) {\n            this.desc \u003d desc;\n            primVals \u003d new byte[desc.getPrimDataSize()];\n            objVals \u003d new Object[desc.getNumObjFields()];\n        }\n\n        public void put(String name, boolean val) {\n            ByteArray.setBoolean(primVals, getFieldOffset(name, Boolean.TYPE), val);\n        }\n\n        public void put(String name, byte val) {\n            primVals[getFieldOffset(name, Byte.TYPE)] \u003d val;\n        }\n\n        public void put(String name, char val) {\n            ByteArray.setChar(primVals, getFieldOffset(name, Character.TYPE), val);\n        }\n\n        public void put(String name, short val) {\n            ByteArray.setShort(primVals, getFieldOffset(name, Short.TYPE), val);\n        }\n\n        public void put(String name, int val) {\n            ByteArray.setInt(primVals, getFieldOffset(name, Integer.TYPE), val);\n        }\n\n        public void put(String name, float val) {\n            ByteArray.setFloat(primVals, getFieldOffset(name, Float.TYPE), val);\n        }\n\n        public void put(String name, long val) {\n            ByteArray.setLong(primVals, getFieldOffset(name, Long.TYPE), val);\n        }\n\n        public void put(String name, double val) {\n            ByteArray.setDouble(primVals, getFieldOffset(name, Double.TYPE), val);\n        }\n\n        public void put(String name, Object val) {\n            objVals[getFieldOffset(name, Object.class)] \u003d val;\n        }\n\n        // deprecated in ObjectOutputStream.PutField\n        public void write(ObjectOutput out) throws IOException {\n            /*\n             * Applications should *not* use this method to write PutField\n             * data, as it will lead to stream corruption if the PutField\n             * object writes any primitive data (since block data mode is not\n             * unset/set properly, as is done in OOS.writeFields()).  This\n             * broken implementation is being retained solely for behavioral\n             * compatibility, in order to support applications which use\n             * OOS.PutField.write() for writing only non-primitive data.\n             *\n             * Serialization of unshared objects is not implemented here since\n             * it is not necessary for backwards compatibility; also, unshared\n             * semantics may not be supported by the given ObjectOutput\n             * instance.  Applications which write unshared objects using the\n             * PutField API must use OOS.writeFields().\n             */\n            if (ObjectOutputStream.this !\u003d out) {\n                throw new IllegalArgumentException(\"wrong stream\");\n            }\n            out.write(primVals, 0, primVals.length);\n\n            ObjectStreamField[] fields \u003d desc.getFields(false);\n            int numPrimFields \u003d fields.length - objVals.length;\n            // REMIND: warn if numPrimFields \u003e 0?\n            for (int i \u003d 0; i \u003c objVals.length; i++) {\n                if (fields[numPrimFields + i].isUnshared()) {\n                    throw new IOException(\"cannot write unshared object\");\n                }\n                out.writeObject(objVals[i]);\n            }\n        }\n\n        /**\n         * Writes buffered primitive data and object fields to stream.\n         */\n        void writeFields() throws IOException {\n            bout.write(primVals, 0, primVals.length, false);\n\n            ObjectStreamField[] fields \u003d desc.getFields(false);\n            int numPrimFields \u003d fields.length - objVals.length;\n            for (int i \u003d 0; i \u003c objVals.length; i++) {\n                if (extendedDebugInfo) {\n                    debugInfoStack.push(\n                        \"field (class \\\"\" + desc.getName() + \"\\\", name: \\\"\" +\n                        fields[numPrimFields + i].getName() + \"\\\", type: \\\"\" +\n                        fields[numPrimFields + i].getType() + \"\\\")\");\n                }\n                try {\n                    writeObject0(objVals[i],\n                                 fields[numPrimFields + i].isUnshared());\n                } finally {\n                    if (extendedDebugInfo) {\n                        debugInfoStack.pop();\n                    }\n                }\n            }\n        }\n\n        /**\n         * Returns offset of field with given name and type.  A specified type\n         * of null matches all types, Object.class matches all non-primitive\n         * types, and any other non-null type matches assignable types only.\n         * Throws IllegalArgumentException if no matching field found.\n         */\n        private int getFieldOffset(String name, Class\u003c?\u003e type) {\n            ObjectStreamField field \u003d desc.getField(name, type);\n            if (field \u003d\u003d null) {\n                throw new IllegalArgumentException(\"no such field \" + name +\n                                                   \" with type \" + type);\n            }\n            return field.getOffset();\n        }\n    }\n\n    /**\n     * Buffered output stream with two modes: in default mode, outputs data in\n     * same format as DataOutputStream; in \"block data\" mode, outputs data\n     * bracketed by block data markers (see object serialization specification\n     * for details).\n     */\n    private static final class BlockDataOutputStream\n        extends OutputStream implements DataOutput\n    {\n        /** maximum data block length */\n        private static final int MAX_BLOCK_SIZE \u003d 1024;\n        /** maximum data block header length */\n        private static final int MAX_HEADER_SIZE \u003d 5;\n        /** (tunable) length of char buffer (for writing strings) */\n        private static final int CHAR_BUF_SIZE \u003d 256;\n\n        /** buffer for writing general/block data */\n        private final byte[] buf \u003d new byte[MAX_BLOCK_SIZE];\n        /** buffer for writing block data headers */\n        private final byte[] hbuf \u003d new byte[MAX_HEADER_SIZE];\n        /** char buffer for fast string writes */\n        private final char[] cbuf \u003d new char[CHAR_BUF_SIZE];\n\n        /** block data mode */\n        private boolean blkmode \u003d false;\n        /** current offset into buf */\n        private int pos \u003d 0;\n\n        /** underlying output stream */\n        private final OutputStream out;\n        /** loopback stream (for data writes that span data blocks) */\n        private final DataOutputStream dout;\n\n        /**\n         * Creates new BlockDataOutputStream on top of given underlying stream.\n         * Block data mode is turned off by default.\n         */\n        BlockDataOutputStream(OutputStream out) {\n            this.out \u003d out;\n            dout \u003d new DataOutputStream(this);\n        }\n\n        /**\n         * Sets block data mode to the given mode (true \u003d\u003d on, false \u003d\u003d off)\n         * and returns the previous mode value.  If the new mode is the same as\n         * the old mode, no action is taken.  If the new mode differs from the\n         * old mode, any buffered data is flushed before switching to the new\n         * mode.\n         */\n        boolean setBlockDataMode(boolean mode) throws IOException {\n            if (blkmode \u003d\u003d mode) {\n                return blkmode;\n            }\n            drain();\n            blkmode \u003d mode;\n            return !blkmode;\n        }\n\n        /**\n         * Returns true if the stream is currently in block data mode, false\n         * otherwise.\n         */\n        boolean getBlockDataMode() {\n            return blkmode;\n        }\n\n        /* ----------------- generic output stream methods ----------------- */\n        /*\n         * The following methods are equivalent to their counterparts in\n         * OutputStream, except that they partition written data into data\n         * blocks when in block data mode.\n         */\n\n        public void write(int b) throws IOException {\n            if (pos \u003e\u003d MAX_BLOCK_SIZE) {\n                drain();\n            }\n            buf[pos++] \u003d (byte) b;\n        }\n\n        public void write(byte[] b) throws IOException {\n            write(b, 0, b.length, false);\n        }\n\n        public void write(byte[] b, int off, int len) throws IOException {\n            write(b, off, len, false);\n        }\n\n        public void flush() throws IOException {\n            drain();\n            out.flush();\n        }\n\n        public void close() throws IOException {\n            flush();\n            out.close();\n        }\n\n        /**\n         * Writes specified span of byte values from given array.  If copy is\n         * true, copies the values to an intermediate buffer before writing\n         * them to underlying stream (to avoid exposing a reference to the\n         * original byte array).\n         */\n        void write(byte[] b, int off, int len, boolean copy)\n            throws IOException\n        {\n            if (!(copy || blkmode)) {           // write directly\n                drain();\n                out.write(b, off, len);\n                return;\n            }\n\n            while (len \u003e 0) {\n                if (pos \u003e\u003d MAX_BLOCK_SIZE) {\n                    drain();\n                }\n                if (len \u003e\u003d MAX_BLOCK_SIZE \u0026\u0026 !copy \u0026\u0026 pos \u003d\u003d 0) {\n                    // avoid unnecessary copy\n                    writeBlockHeader(MAX_BLOCK_SIZE);\n                    out.write(b, off, MAX_BLOCK_SIZE);\n                    off +\u003d MAX_BLOCK_SIZE;\n                    len -\u003d MAX_BLOCK_SIZE;\n                } else {\n                    int wlen \u003d Math.min(len, MAX_BLOCK_SIZE - pos);\n                    System.arraycopy(b, off, buf, pos, wlen);\n                    pos +\u003d wlen;\n                    off +\u003d wlen;\n                    len -\u003d wlen;\n                }\n            }\n        }\n\n        /**\n         * Writes all buffered data from this stream to the underlying stream,\n         * but does not flush underlying stream.\n         */\n        void drain() throws IOException {\n            if (pos \u003d\u003d 0) {\n                return;\n            }\n            if (blkmode) {\n                writeBlockHeader(pos);\n            }\n            out.write(buf, 0, pos);\n            pos \u003d 0;\n        }\n\n        /**\n         * Writes block data header.  Data blocks shorter than 256 bytes are\n         * prefixed with a 2-byte header; all others start with a 5-byte\n         * header.\n         */\n        private void writeBlockHeader(int len) throws IOException {\n            if (len \u003c\u003d 0xFF) {\n                hbuf[0] \u003d TC_BLOCKDATA;\n                hbuf[1] \u003d (byte) len;\n                out.write(hbuf, 0, 2);\n            } else {\n                hbuf[0] \u003d TC_BLOCKDATALONG;\n                ByteArray.setInt(hbuf, 1, len);\n                out.write(hbuf, 0, 5);\n            }\n        }\n\n\n        /* ----------------- primitive data output methods ----------------- */\n        /*\n         * The following methods are equivalent to their counterparts in\n         * DataOutputStream, except that they partition written data into data\n         * blocks when in block data mode.\n         */\n\n        public void writeBoolean(boolean v) throws IOException {\n            if (pos \u003e\u003d MAX_BLOCK_SIZE) {\n                drain();\n            }\n            ByteArray.setBoolean(buf, pos++, v);\n        }\n\n        public void writeByte(int v) throws IOException {\n            if (pos \u003e\u003d MAX_BLOCK_SIZE) {\n                drain();\n            }\n            buf[pos++] \u003d (byte) v;\n        }\n\n        public void writeChar(int v) throws IOException {\n            if (pos + 2 \u003c\u003d MAX_BLOCK_SIZE) {\n                ByteArray.setChar(buf, pos, (char) v);\n                pos +\u003d 2;\n            } else {\n                dout.writeChar(v);\n            }\n        }\n\n        public void writeShort(int v) throws IOException {\n            if (pos + 2 \u003c\u003d MAX_BLOCK_SIZE) {\n                ByteArray.setShort(buf, pos, (short) v);\n                pos +\u003d 2;\n            } else {\n                dout.writeShort(v);\n            }\n        }\n\n        public void writeInt(int v) throws IOException {\n            if (pos + 4 \u003c\u003d MAX_BLOCK_SIZE) {\n                ByteArray.setInt(buf, pos, v);\n                pos +\u003d 4;\n            } else {\n                dout.writeInt(v);\n            }\n        }\n\n        public void writeFloat(float v) throws IOException {\n            if (pos + 4 \u003c\u003d MAX_BLOCK_SIZE) {\n                ByteArray.setFloat(buf, pos, v);\n                pos +\u003d 4;\n            } else {\n                dout.writeFloat(v);\n            }\n        }\n\n        public void writeLong(long v) throws IOException {\n            if (pos + 8 \u003c\u003d MAX_BLOCK_SIZE) {\n                ByteArray.setLong(buf, pos, v);\n                pos +\u003d 8;\n            } else {\n                dout.writeLong(v);\n            }\n        }\n\n        public void writeDouble(double v) throws IOException {\n            if (pos + 8 \u003c\u003d MAX_BLOCK_SIZE) {\n                ByteArray.setDouble(buf, pos, v);\n                pos +\u003d 8;\n            } else {\n                dout.writeDouble(v);\n            }\n        }\n\n        public void writeBytes(String s) throws IOException {\n            int endoff \u003d s.length();\n            int cpos \u003d 0;\n            int csize \u003d 0;\n            for (int off \u003d 0; off \u003c endoff; ) {\n                if (cpos \u003e\u003d csize) {\n                    cpos \u003d 0;\n                    csize \u003d Math.min(endoff - off, CHAR_BUF_SIZE);\n                    s.getChars(off, off + csize, cbuf, 0);\n                }\n                if (pos \u003e\u003d MAX_BLOCK_SIZE) {\n                    drain();\n                }\n                int n \u003d Math.min(csize - cpos, MAX_BLOCK_SIZE - pos);\n                int stop \u003d pos + n;\n                while (pos \u003c stop) {\n                    buf[pos++] \u003d (byte) cbuf[cpos++];\n                }\n                off +\u003d n;\n            }\n        }\n\n        public void writeChars(String s) throws IOException {\n            int endoff \u003d s.length();\n            for (int off \u003d 0; off \u003c endoff; ) {\n                int csize \u003d Math.min(endoff - off, CHAR_BUF_SIZE);\n                s.getChars(off, off + csize, cbuf, 0);\n                writeChars(cbuf, 0, csize);\n                off +\u003d csize;\n            }\n        }\n\n        public void writeUTF(String s) throws IOException {\n            writeUTF(s, getUTFLength(s));\n        }\n\n\n        /* -------------- primitive data array output methods -------------- */\n        /*\n         * The following methods write out spans of primitive data values.\n         * Though equivalent to calling the corresponding primitive write\n         * methods repeatedly, these methods are optimized for writing groups\n         * of primitive data values more efficiently.\n         */\n\n        void writeBooleans(boolean[] v, int off, int len) throws IOException {\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003e\u003d MAX_BLOCK_SIZE) {\n                    drain();\n                }\n                int stop \u003d Math.min(endoff, off + (MAX_BLOCK_SIZE - pos));\n                while (off \u003c stop) {\n                    ByteArray.setBoolean(buf, pos++, v[off++]);\n                }\n            }\n        }\n\n        void writeChars(char[] v, int off, int len) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 2;\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003c\u003d limit) {\n                    int avail \u003d (MAX_BLOCK_SIZE - pos) \u003e\u003e 1;\n                    int stop \u003d Math.min(endoff, off + avail);\n                    while (off \u003c stop) {\n                        ByteArray.setChar(buf, pos, v[off++]);\n                        pos +\u003d 2;\n                    }\n                } else {\n                    dout.writeChar(v[off++]);\n                }\n            }\n        }\n\n        void writeShorts(short[] v, int off, int len) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 2;\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003c\u003d limit) {\n                    int avail \u003d (MAX_BLOCK_SIZE - pos) \u003e\u003e 1;\n                    int stop \u003d Math.min(endoff, off + avail);\n                    while (off \u003c stop) {\n                        ByteArray.setShort(buf, pos, v[off++]);\n                        pos +\u003d 2;\n                    }\n                } else {\n                    dout.writeShort(v[off++]);\n                }\n            }\n        }\n\n        void writeInts(int[] v, int off, int len) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 4;\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003c\u003d limit) {\n                    int avail \u003d (MAX_BLOCK_SIZE - pos) \u003e\u003e 2;\n                    int stop \u003d Math.min(endoff, off + avail);\n                    while (off \u003c stop) {\n                        ByteArray.setInt(buf, pos, v[off++]);\n                        pos +\u003d 4;\n                    }\n                } else {\n                    dout.writeInt(v[off++]);\n                }\n            }\n        }\n\n        void writeFloats(float[] v, int off, int len) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 4;\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003c\u003d limit) {\n                    int avail \u003d (MAX_BLOCK_SIZE - pos) \u003e\u003e 2;\n                    int stop \u003d Math.min(endoff, off + avail);\n                    while (off \u003c stop) {\n                        ByteArray.setFloat(buf, pos, v[off++]);\n                        pos +\u003d 4;\n                    }\n                } else {\n                    dout.writeFloat(v[off++]);\n                }\n            }\n        }\n\n        void writeLongs(long[] v, int off, int len) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 8;\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003c\u003d limit) {\n                    int avail \u003d (MAX_BLOCK_SIZE - pos) \u003e\u003e 3;\n                    int stop \u003d Math.min(endoff, off + avail);\n                    while (off \u003c stop) {\n                        ByteArray.setLong(buf, pos, v[off++]);\n                        pos +\u003d 8;\n                    }\n                } else {\n                    dout.writeLong(v[off++]);\n                }\n            }\n        }\n\n        void writeDoubles(double[] v, int off, int len) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 8;\n            int endoff \u003d off + len;\n            while (off \u003c endoff) {\n                if (pos \u003c\u003d limit) {\n                    int avail \u003d (MAX_BLOCK_SIZE - pos) \u003e\u003e 3;\n                    int stop \u003d Math.min(endoff, off + avail);\n                    while (off \u003c stop) {\n                        ByteArray.setDouble(buf, pos, v[off++]);\n                        pos +\u003d 8;\n                    }\n                } else {\n                    dout.writeDouble(v[off++]);\n                }\n            }\n        }\n\n        /**\n         * Returns the length in bytes of the UTF encoding of the given string.\n         */\n        long getUTFLength(String s) {\n            int len \u003d s.length();\n            long utflen \u003d 0;\n            for (int off \u003d 0; off \u003c len; ) {\n                int csize \u003d Math.min(len - off, CHAR_BUF_SIZE);\n                s.getChars(off, off + csize, cbuf, 0);\n                for (int cpos \u003d 0; cpos \u003c csize; cpos++) {\n                    char c \u003d cbuf[cpos];\n                    if (c \u003e\u003d 0x0001 \u0026\u0026 c \u003c\u003d 0x007F) {\n                        utflen++;\n                    } else if (c \u003e 0x07FF) {\n                        utflen +\u003d 3;\n                    } else {\n                        utflen +\u003d 2;\n                    }\n                }\n                off +\u003d csize;\n            }\n            return utflen;\n        }\n\n        /**\n         * Writes the given string in UTF format.  This method is used in\n         * situations where the UTF encoding length of the string is already\n         * known; specifying it explicitly avoids a prescan of the string to\n         * determine its UTF length.\n         */\n        void writeUTF(String s, long utflen) throws IOException {\n            if (utflen \u003e 0xFFFFL) {\n                throw new UTFDataFormatException();\n            }\n            writeShort((int) utflen);\n            if (utflen \u003d\u003d (long) s.length()) {\n                writeBytes(s);\n            } else {\n                writeUTFBody(s);\n            }\n        }\n\n        /**\n         * Writes given string in \"long\" UTF format.  \"Long\" UTF format is\n         * identical to standard UTF, except that it uses an 8 byte header\n         * (instead of the standard 2 bytes) to convey the UTF encoding length.\n         */\n        void writeLongUTF(String s) throws IOException {\n            writeLongUTF(s, getUTFLength(s));\n        }\n\n        /**\n         * Writes given string in \"long\" UTF format, where the UTF encoding\n         * length of the string is already known.\n         */\n        void writeLongUTF(String s, long utflen) throws IOException {\n            writeLong(utflen);\n            if (utflen \u003d\u003d (long) s.length()) {\n                writeBytes(s);\n            } else {\n                writeUTFBody(s);\n            }\n        }\n\n        /**\n         * Writes the \"body\" (i.e., the UTF representation minus the 2-byte or\n         * 8-byte length header) of the UTF encoding for the given string.\n         */\n        private void writeUTFBody(String s) throws IOException {\n            int limit \u003d MAX_BLOCK_SIZE - 3;\n            int len \u003d s.length();\n            for (int off \u003d 0; off \u003c len; ) {\n                int csize \u003d Math.min(len - off, CHAR_BUF_SIZE);\n                s.getChars(off, off + csize, cbuf, 0);\n                for (int cpos \u003d 0; cpos \u003c csize; cpos++) {\n                    char c \u003d cbuf[cpos];\n                    if (pos \u003c\u003d limit) {\n                        if (c \u003c\u003d 0x007F \u0026\u0026 c !\u003d 0) {\n                            buf[pos++] \u003d (byte) c;\n                        } else if (c \u003e 0x07FF) {\n                            buf[pos + 2] \u003d (byte) (0x80 | ((c \u003e\u003e 0) \u0026 0x3F));\n                            buf[pos + 1] \u003d (byte) (0x80 | ((c \u003e\u003e 6) \u0026 0x3F));\n                            buf[pos + 0] \u003d (byte) (0xE0 | ((c \u003e\u003e 12) \u0026 0x0F));\n                            pos +\u003d 3;\n                        } else {\n                            buf[pos + 1] \u003d (byte) (0x80 | ((c \u003e\u003e 0) \u0026 0x3F));\n                            buf[pos + 0] \u003d (byte) (0xC0 | ((c \u003e\u003e 6) \u0026 0x1F));\n                            pos +\u003d 2;\n                        }\n                    } else {    // write one byte at a time to normalize block\n                        if (c \u003c\u003d 0x007F \u0026\u0026 c !\u003d 0) {\n                            write(c);\n                        } else if (c \u003e 0x07FF) {\n                            write(0xE0 | ((c \u003e\u003e 12) \u0026 0x0F));\n                            write(0x80 | ((c \u003e\u003e 6) \u0026 0x3F));\n                            write(0x80 | ((c \u003e\u003e 0) \u0026 0x3F));\n                        } else {\n                            write(0xC0 | ((c \u003e\u003e 6) \u0026 0x1F));\n                            write(0x80 | ((c \u003e\u003e 0) \u0026 0x3F));\n                        }\n                    }\n                }\n                off +\u003d csize;\n            }\n        }\n    }\n\n    /**\n     * Lightweight identity hash table which maps objects to integer handles,\n     * assigned in ascending order.\n     */\n    private static final class HandleTable {\n\n        /* number of mappings in table/next available handle */\n        private int size;\n        /* size threshold determining when to expand hash spine */\n        private int threshold;\n        /* factor for computing size threshold */\n        private final float loadFactor;\n        /* maps hash value -\u003e candidate handle value */\n        private int[] spine;\n        /* maps handle value -\u003e next candidate handle value */\n        private int[] next;\n        /* maps handle value -\u003e associated object */\n        private Object[] objs;\n\n        /**\n         * Creates new HandleTable with given capacity and load factor.\n         */\n        HandleTable(int initialCapacity, float loadFactor) {\n            this.loadFactor \u003d loadFactor;\n            spine \u003d new int[initialCapacity];\n            next \u003d new int[initialCapacity];\n            objs \u003d new Object[initialCapacity];\n            threshold \u003d (int) (initialCapacity * loadFactor);\n            clear();\n        }\n\n        /**\n         * Assigns next available handle to given object, and returns handle\n         * value.  Handles are assigned in ascending order starting at 0.\n         */\n        int assign(Object obj) {\n            if (size \u003e\u003d next.length) {\n                growEntries();\n            }\n            if (size \u003e\u003d threshold) {\n                growSpine();\n            }\n            insert(obj, size);\n            return size++;\n        }\n\n        /**\n         * Looks up and returns handle associated with given object, or -1 if\n         * no mapping found.\n         */\n        int lookup(Object obj) {\n            if (size \u003d\u003d 0) {\n                return -1;\n            }\n            int index \u003d hash(obj) % spine.length;\n            for (int i \u003d spine[index]; i \u003e\u003d 0; i \u003d next[i]) {\n                if (objs[i] \u003d\u003d obj) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n\n        /**\n         * Resets table to its initial (empty) state.\n         */\n        void clear() {\n            Arrays.fill(spine, -1);\n            Arrays.fill(objs, 0, size, null);\n            size \u003d 0;\n        }\n\n        /**\n         * Returns the number of mappings currently in table.\n         */\n        int size() {\n            return size;\n        }\n\n        /**\n         * Inserts mapping object -\u003e handle mapping into table.  Assumes table\n         * is large enough to accommodate new mapping.\n         */\n        private void insert(Object obj, int handle) {\n            int index \u003d hash(obj) % spine.length;\n            objs[handle] \u003d obj;\n            next[handle] \u003d spine[index];\n            spine[index] \u003d handle;\n        }\n\n        /**\n         * Expands the hash \"spine\" -- equivalent to increasing the number of\n         * buckets in a conventional hash table.\n         */\n        private void growSpine() {\n            spine \u003d new int[(spine.length \u003c\u003c 1) + 1];\n            threshold \u003d (int) (spine.length * loadFactor);\n            Arrays.fill(spine, -1);\n            for (int i \u003d 0; i \u003c size; i++) {\n                insert(objs[i], i);\n            }\n        }\n\n        /**\n         * Increases hash table capacity by lengthening entry arrays.\n         */\n        private void growEntries() {\n            int newLength \u003d (next.length \u003c\u003c 1) + 1;\n            int[] newNext \u003d new int[newLength];\n            System.arraycopy(next, 0, newNext, 0, size);\n            next \u003d newNext;\n\n            Object[] newObjs \u003d new Object[newLength];\n            System.arraycopy(objs, 0, newObjs, 0, size);\n            objs \u003d newObjs;\n        }\n\n        /**\n         * Returns hash value for given object.\n         */\n        private int hash(Object obj) {\n            return System.identityHashCode(obj) \u0026 0x7FFFFFFF;\n        }\n    }\n\n    /**\n     * Lightweight identity hash table which maps objects to replacement\n     * objects.\n     */\n    private static final class ReplaceTable {\n\n        /* maps object -\u003e index */\n        private final HandleTable htab;\n        /* maps index -\u003e replacement object */\n        private Object[] reps;\n\n        /**\n         * Creates new ReplaceTable with given capacity and load factor.\n         */\n        ReplaceTable(int initialCapacity, float loadFactor) {\n            htab \u003d new HandleTable(initialCapacity, loadFactor);\n            reps \u003d new Object[initialCapacity];\n        }\n\n        /**\n         * Enters mapping from object to replacement object.\n         */\n        void assign(Object obj, Object rep) {\n            int index \u003d htab.assign(obj);\n            while (index \u003e\u003d reps.length) {\n                grow();\n            }\n            reps[index] \u003d rep;\n        }\n\n        /**\n         * Looks up and returns replacement for given object.  If no\n         * replacement is found, returns the lookup object itself.\n         */\n        Object lookup(Object obj) {\n            int index \u003d htab.lookup(obj);\n            return (index \u003e\u003d 0) ? reps[index] : obj;\n        }\n\n        /**\n         * Resets table to its initial (empty) state.\n         */\n        void clear() {\n            Arrays.fill(reps, 0, htab.size(), null);\n            htab.clear();\n        }\n\n        /**\n         * Returns the number of mappings currently in table.\n         */\n        int size() {\n            return htab.size();\n        }\n\n        /**\n         * Increases table capacity.\n         */\n        private void grow() {\n            Object[] newReps \u003d new Object[(reps.length \u003c\u003c 1) + 1];\n            System.arraycopy(reps, 0, newReps, 0, reps.length);\n            reps \u003d newReps;\n        }\n    }\n\n    /**\n     * Stack to keep debug information about the state of the\n     * serialization process, for embedding in exception messages.\n     */\n    private static final class DebugTraceInfoStack {\n        private final List\u003cString\u003e stack;\n\n        DebugTraceInfoStack() {\n            stack \u003d new ArrayList\u003c\u003e();\n        }\n\n        /**\n         * Removes all of the elements from enclosed list.\n         */\n        void clear() {\n            stack.clear();\n        }\n\n        /**\n         * Removes the object at the top of enclosed list.\n         */\n        void pop() {\n            stack.remove(stack.size()-1);\n        }\n\n        /**\n         * Pushes a String onto the top of enclosed list.\n         */\n        void push(String entry) {\n            stack.add(\"\\t- \" + entry);\n        }\n\n        /**\n         * Returns a string representation of this object\n         */\n        public String toString() {\n            StringJoiner sj \u003d new StringJoiner(\"\\n\");\n            for (int i \u003d stack.size() - 1; i \u003e\u003d 0; i--) {\n                sj.add(stack.get(i));\n            }\n            return sj.toString();\n        }\n    }\n\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/io/ObjectOutputStream.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/io/ObjectOutputStream.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

Π°ΠΏΡ€. 12, 2024 8:11:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/io/ObjectOutputStream.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/io/ObjectOutputStream.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:706)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:703)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/io/ObjectOutputStream.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.04.12 20:11:40 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:11:40 INFO  compiling bestgame (1 scala source)
2024.04.12 20:11:40 INFO  time: compiled bestgame in 89ms
2024.04.12 20:11:48 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:11:48 INFO  compiling bestgame (1 scala source)
2024.04.12 20:11:48 INFO  time: compiled bestgame in 0.39s
2024.04.12 20:11:50 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
Π°ΠΏΡ€. 12, 2024 8:14:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7293
2024.04.12 20:15:30 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
Π°ΠΏΡ€. 12, 2024 8:15:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7419
2024.04.12 20:15:46 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:15:46 INFO  compiling bestgame (1 scala source)
2024.04.12 20:15:46 INFO  time: compiled bestgame in 0.12s
Π°ΠΏΡ€. 12, 2024 8:15:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7447
Π°ΠΏΡ€. 12, 2024 8:15:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7455
2024.04.12 20:16:22 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:16:22 INFO  compiling bestgame (1 scala source)
2024.04.12 20:16:22 INFO  time: compiled bestgame in 75ms
2024.04.12 20:16:24 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:16:24 INFO  compiling bestgame (1 scala source)
2024.04.12 20:16:24 INFO  time: compiled bestgame in 0.16s
Π°ΠΏΡ€. 12, 2024 8:17:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7751
2024.04.12 20:17:05 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:17:26 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:17:26 INFO  compiling bestgame (1 scala source)
2024.04.12 20:17:26 INFO  time: compiled bestgame in 0.45s
2024.04.12 20:17:35 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:17:35 INFO  compiling bestgame (1 scala source)
2024.04.12 20:17:35 INFO  time: compiled bestgame in 0.37s
Π°ΠΏΡ€. 12, 2024 8:17:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7984
2024.04.12 20:18:01 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:18:01 INFO  compiling bestgame (1 scala source)
2024.04.12 20:18:01 INFO  time: compiled bestgame in 0.39s
Π°ΠΏΡ€. 12, 2024 8:18:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8058
2024.04.12 20:18:34 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:18:34 INFO  compiling bestgame (1 scala source)
2024.04.12 20:18:34 INFO  time: compiled bestgame in 0.36s
2024.04.12 20:18:57 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:18:57 INFO  compiling bestgame (1 scala source)
2024.04.12 20:18:57 INFO  time: compiled bestgame in 0.34s
2024.04.12 20:19:10 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:19:10 INFO  compiling bestgame (1 scala source)
2024.04.12 20:19:10 INFO  time: compiled bestgame in 0.35s
2024.04.12 20:19:17 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:19:17 INFO  compiling bestgame (1 scala source)
2024.04.12 20:19:17 INFO  time: compiled bestgame in 0.33s
2024.04.12 20:19:42 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:19:42 INFO  compiling bestgame (1 scala source)
2024.04.12 20:19:42 INFO  time: compiled bestgame in 81ms
2024.04.12 20:20:06 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:20:06 INFO  compiling bestgame (1 scala source)
2024.04.12 20:20:06 INFO  time: compiled bestgame in 70ms
2024.04.12 20:20:10 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:20:10 INFO  compiling bestgame (1 scala source)
2024.04.12 20:20:10 INFO  time: compiled bestgame in 0.17s
Π°ΠΏΡ€. 12, 2024 8:20:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8432
2024.04.12 20:20:37 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:20:37 INFO  compiling bestgame (1 scala source)
2024.04.12 20:20:37 INFO  time: compiled bestgame in 0.27s
Π°ΠΏΡ€. 12, 2024 8:20:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8471
2024.04.12 20:20:44 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:20:44 INFO  compiling bestgame (1 scala source)
2024.04.12 20:20:44 INFO  time: compiled bestgame in 0.86s
2024.04.12 20:21:12 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:21:12 INFO  compiling bestgame (1 scala source)
2024.04.12 20:21:13 INFO  time: compiled bestgame in 1.42s
2024.04.12 20:21:13 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:21:13 INFO  compiling bestgame (1 scala source)
2024.04.12 20:21:14 INFO  time: compiled bestgame in 0.69s
2024.04.12 20:21:22 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:21:22 INFO  compiling bestgame (1 scala source)
2024.04.12 20:21:22 INFO  time: compiled bestgame in 86ms
Π°ΠΏΡ€. 12, 2024 8:21:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8804
2024.04.12 20:22:00 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:22:00 INFO  compiling bestgame (1 scala source)
2024.04.12 20:22:00 INFO  time: compiled bestgame in 0.21s
2024.04.12 20:22:05 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:22:05 INFO  compiling bestgame (1 scala source)
2024.04.12 20:22:05 INFO  time: compiled bestgame in 0.14s
Π°ΠΏΡ€. 12, 2024 8:22:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8873
2024.04.12 20:22:29 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:22:29 INFO  compiling bestgame (1 scala source)
2024.04.12 20:22:29 INFO  time: compiled bestgame in 71ms
Π°ΠΏΡ€. 12, 2024 8:22:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9055
2024.04.12 20:23:01 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:23:01 INFO  compiling bestgame (1 scala source)
2024.04.12 20:23:01 INFO  time: compiled bestgame in 0.1s
2024.04.12 20:23:17 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:23:17 INFO  compiling bestgame (1 scala source)
2024.04.12 20:23:17 INFO  time: compiled bestgame in 0.11s
2024.04.12 20:23:21 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:23:21 INFO  compiling bestgame (1 scala source)
2024.04.12 20:23:21 INFO  time: compiled bestgame in 0.16s
2024.04.12 20:24:08 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:24:29 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:24:29 INFO  compiling bestgame (1 scala source)
2024.04.12 20:24:29 INFO  time: compiled bestgame in 0.17s
2024.04.12 20:24:58 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:24:58 INFO  compiling bestgame (1 scala source)
2024.04.12 20:24:58 INFO  time: compiled bestgame in 0.16s
Π°ΠΏΡ€. 12, 2024 8:25:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9455
2024.04.12 20:25:38 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:25:38 INFO  compiling bestgame (1 scala source)
2024.04.12 20:25:38 INFO  time: compiled bestgame in 67ms
2024.04.12 20:25:54 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:25:54 INFO  compiling bestgame (1 scala source)
2024.04.12 20:25:54 INFO  time: compiled bestgame in 76ms
2024.04.12 20:25:59 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:25:59 INFO  compiling bestgame (1 scala source)
2024.04.12 20:25:59 INFO  time: compiled bestgame in 0.13s
2024.04.12 20:26:15 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:26:15 INFO  compiling bestgame (1 scala source)
2024.04.12 20:26:15 INFO  time: compiled bestgame in 0.37s
Π°ΠΏΡ€. 12, 2024 8:26:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9823
2024.04.12 20:27:04 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:27:04 INFO  compiling bestgame (2 scala sources)
2024.04.12 20:27:04 INFO  time: compiled bestgame in 0.17s
Π°ΠΏΡ€. 12, 2024 8:27:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9855
2024.04.12 20:27:20 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:27:20 INFO  compiling bestgame (1 scala source)
2024.04.12 20:27:20 INFO  time: compiled bestgame in 82ms
2024.04.12 20:27:20 INFO  compiling bestgame (1 scala source)
2024.04.12 20:27:20 INFO  time: compiled bestgame in 0.36s
Π°ΠΏΡ€. 12, 2024 8:27:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9902
2024.04.12 20:27:36 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:27:36 INFO  compiling bestgame (2 scala sources)
2024.04.12 20:27:36 INFO  time: compiled bestgame in 42ms
2024.04.12 20:27:39 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:27:39 INFO  compiling bestgame (2 scala sources)
2024.04.12 20:27:39 INFO  time: compiled bestgame in 97ms
2024.04.12 20:27:39 INFO  compiling bestgame (1 scala source)
2024.04.12 20:27:39 INFO  time: compiled bestgame in 0.32s
2024.04.12 20:27:50 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:27:50 INFO  compiling bestgame (2 scala sources)
2024.04.12 20:27:50 INFO  time: compiled bestgame in 0.28s
2024.04.12 20:27:50 INFO  compiling bestgame (1 scala source)
2024.04.12 20:27:50 INFO  time: compiled bestgame in 0.47s
2024.04.12 20:27:52 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:27:52 INFO  compiling bestgame (2 scala sources)
2024.04.12 20:27:52 INFO  time: compiled bestgame in 85ms
2024.04.12 20:27:52 INFO  compiling bestgame (1 scala source)
2024.04.12 20:27:52 INFO  time: compiled bestgame in 0.38s
2024.04.12 20:27:59 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:27:59 INFO  compiling bestgame (3 scala sources)
2024.04.12 20:27:59 INFO  time: compiled bestgame in 0.15s
2024.04.12 20:28:15 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:28:15 INFO  compiling bestgame (1 scala source)
2024.04.12 20:28:15 INFO  time: compiled bestgame in 0.15s
2024.04.12 20:28:24 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:28:24 INFO  compiling bestgame (1 scala source)
2024.04.12 20:28:24 INFO  time: compiled bestgame in 71ms
2024.04.12 20:28:28 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:28:28 INFO  compiling bestgame (1 scala source)
2024.04.12 20:28:28 INFO  time: compiled bestgame in 56ms
2024.04.12 20:28:31 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:28:31 INFO  compiling bestgame (1 scala source)
2024.04.12 20:28:31 INFO  time: compiled bestgame in 0.15s
2024.04.12 20:28:40 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:28:40 INFO  compiling bestgame (1 scala source)
2024.04.12 20:28:40 INFO  time: compiled bestgame in 0.39s
2024.04.12 20:28:46 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:28:46 INFO  compiling bestgame (1 scala source)
2024.04.12 20:28:46 INFO  time: compiled bestgame in 0.33s
Π°ΠΏΡ€. 12, 2024 8:28:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10312
2024.04.12 20:29:06 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:29:06 INFO  compiling bestgame (2 scala sources)
2024.04.12 20:29:06 INFO  time: compiled bestgame in 0.31s
2024.04.12 20:29:35 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:29:35 INFO  compiling bestgame (3 scala sources)
2024.04.12 20:29:35 INFO  time: compiled bestgame in 0.16s
2024.04.12 20:29:55 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:29:55 INFO  compiling bestgame (1 scala source)
2024.04.12 20:29:55 INFO  time: compiled bestgame in 33ms
2024.04.12 20:30:04 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:30:04 INFO  compiling bestgame (1 scala source)
2024.04.12 20:30:04 INFO  time: compiled bestgame in 45ms
2024.04.12 20:30:06 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:30:06 INFO  compiling bestgame (1 scala source)
2024.04.12 20:30:06 INFO  time: compiled bestgame in 45ms
2024.04.12 20:30:13 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:30:13 INFO  compiling bestgame (1 scala source)
2024.04.12 20:30:13 INFO  time: compiled bestgame in 43ms
2024.04.12 20:30:33 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:30:33 INFO  compiling bestgame (1 scala source)
2024.04.12 20:30:33 INFO  time: compiled bestgame in 42ms
2024.04.12 20:30:39 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:30:39 INFO  compiling bestgame (1 scala source)
2024.04.12 20:30:39 INFO  time: compiled bestgame in 44ms
2024.04.12 20:30:43 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:30:43 INFO  compiling bestgame (1 scala source)
2024.04.12 20:30:43 INFO  time: compiled bestgame in 43ms
2024.04.12 20:30:44 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:30:44 INFO  compiling bestgame (1 scala source)
2024.04.12 20:30:44 INFO  time: compiled bestgame in 43ms
2024.04.12 20:30:50 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:30:50 INFO  compiling bestgame (1 scala source)
2024.04.12 20:30:50 INFO  time: compiled bestgame in 45ms
2024.04.12 20:30:54 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:30:54 INFO  compiling bestgame (1 scala source)
2024.04.12 20:30:54 INFO  time: compiled bestgame in 42ms
2024.04.12 20:31:01 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:31:01 INFO  compiling bestgame (1 scala source)
2024.04.12 20:31:01 INFO  time: compiled bestgame in 41ms
2024.04.12 20:31:13 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:31:13 INFO  compiling bestgame (1 scala source)
2024.04.12 20:31:13 INFO  time: compiled bestgame in 46ms
2024.04.12 20:31:17 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:31:17 INFO  compiling bestgame (1 scala source)
2024.04.12 20:31:17 INFO  time: compiled bestgame in 41ms
2024.04.12 20:31:24 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:31:24 INFO  compiling bestgame (1 scala source)
2024.04.12 20:31:24 INFO  time: compiled bestgame in 44ms
2024.04.12 20:31:31 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:31:31 INFO  compiling bestgame (1 scala source)
2024.04.12 20:31:31 INFO  time: compiled bestgame in 42ms
2024.04.12 20:31:35 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:31:35 INFO  compiling bestgame (1 scala source)
2024.04.12 20:31:35 INFO  time: compiled bestgame in 45ms
2024.04.12 20:31:38 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:31:38 INFO  compiling bestgame (1 scala source)
2024.04.12 20:31:38 INFO  time: compiled bestgame in 46ms
2024.04.12 20:31:41 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:31:41 INFO  compiling bestgame (1 scala source)
2024.04.12 20:31:41 INFO  time: compiled bestgame in 51ms
2024.04.12 20:31:47 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:31:47 INFO  compiling bestgame (1 scala source)
2024.04.12 20:31:47 INFO  time: compiled bestgame in 46ms
2024.04.12 20:31:50 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:31:50 INFO  compiling bestgame (1 scala source)
2024.04.12 20:31:50 INFO  time: compiled bestgame in 48ms
2024.04.12 20:31:53 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:31:53 INFO  compiling bestgame (1 scala source)
2024.04.12 20:31:53 INFO  time: compiled bestgame in 49ms
2024.04.12 20:31:57 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:31:57 INFO  compiling bestgame (1 scala source)
2024.04.12 20:31:57 INFO  time: compiled bestgame in 90ms
Π°ΠΏΡ€. 12, 2024 8:32:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11054
Π°ΠΏΡ€. 12, 2024 8:32:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11062
2024.04.12 20:32:31 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:32:31 INFO  compiling bestgame (1 scala source)
2024.04.12 20:32:31 INFO  time: compiled bestgame in 77ms
Π°ΠΏΡ€. 12, 2024 8:32:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11164
2024.04.12 20:32:47 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:32:47 INFO  compiling bestgame (1 scala source)
2024.04.12 20:32:47 INFO  time: compiled bestgame in 0.14s
2024.04.12 20:32:48 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:32:48 INFO  compiling bestgame (1 scala source)
2024.04.12 20:32:48 INFO  time: compiled bestgame in 0.12s
Π°ΠΏΡ€. 12, 2024 8:32:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11246
Π°ΠΏΡ€. 12, 2024 8:33:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11260
Π°ΠΏΡ€. 12, 2024 8:33:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11384
Π°ΠΏΡ€. 12, 2024 8:33:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11392
Π°ΠΏΡ€. 12, 2024 8:33:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11431
2024.04.12 20:33:59 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:33:59 INFO  compiling bestgame (1 scala source)
2024.04.12 20:33:59 INFO  time: compiled bestgame in 0.11s
2024.04.12 20:34:12 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:34:12 INFO  compiling bestgame (1 scala source)
2024.04.12 20:34:12 INFO  time: compiled bestgame in 0.14s
2024.04.12 20:34:14 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:34:14 INFO  compiling bestgame (1 scala source)
2024.04.12 20:34:14 INFO  time: compiled bestgame in 0.14s
2024.04.12 20:35:08 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:35:28 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:35:28 INFO  compiling bestgame (1 scala source)
2024.04.12 20:35:28 INFO  time: compiled bestgame in 0.79s
2024.04.12 20:35:28 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:38:30 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:38:30 INFO  compiling bestgame (1 scala source)
2024.04.12 20:38:30 INFO  time: compiled bestgame in 0.44s
2024.04.12 20:38:50 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:38:50 INFO  compiling bestgame (1 scala source)
2024.04.12 20:38:50 INFO  time: compiled bestgame in 0.41s
2024.04.12 20:41:07 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:41:07 INFO  compiling bestgame (1 scala source)
2024.04.12 20:41:07 INFO  time: compiled bestgame in 0.45s
2024.04.12 20:41:48 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:41:48 INFO  compiling bestgame (1 scala source)
2024.04.12 20:41:48 INFO  time: compiled bestgame in 0.39s
Π°ΠΏΡ€. 12, 2024 8:42:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11901
2024.04.12 20:42:39 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:42:39 INFO  compiling bestgame (1 scala source)
2024.04.12 20:42:39 INFO  time: compiled bestgame in 0.36s
2024.04.12 20:42:56 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:42:56 INFO  compiling bestgame (1 scala source)
2024.04.12 20:42:56 INFO  time: compiled bestgame in 0.3s
Π°ΠΏΡ€. 12, 2024 8:44:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12012
2024.04.12 20:46:21 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:46:21 INFO  compiling bestgame (1 scala source)
2024.04.12 20:46:21 INFO  time: compiled bestgame in 0.3s
2024.04.12 20:46:33 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:46:33 INFO  compiling bestgame (1 scala source)
2024.04.12 20:46:33 INFO  time: compiled bestgame in 0.12s
2024.04.12 20:47:54 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:47:54 INFO  compiling bestgame (1 scala source)
2024.04.12 20:47:54 INFO  time: compiled bestgame in 0.35s
2024.04.12 20:48:19 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:48:19 INFO  compiling bestgame (1 scala source)
2024.04.12 20:48:19 INFO  time: compiled bestgame in 0.26s
2024.04.12 20:48:20 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:48:20 INFO  compiling bestgame (1 scala source)
2024.04.12 20:48:20 INFO  time: compiled bestgame in 0.19s
2024.04.12 20:49:24 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:49:24 INFO  compiling bestgame (1 scala source)
2024.04.12 20:49:24 INFO  time: compiled bestgame in 0.23s
2024.04.12 20:49:33 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:50:44 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:50:44 INFO  compiling bestgame (1 scala source)
2024.04.12 20:50:44 INFO  time: compiled bestgame in 0.84s
2024.04.12 20:50:46 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:50:46 INFO  compiling bestgame (1 scala source)
2024.04.12 20:50:46 INFO  time: compiled bestgame in 0.72s
2024.04.12 20:50:56 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:50:56 INFO  compiling bestgame (1 scala source)
2024.04.12 20:50:56 INFO  time: compiled bestgame in 0.16s
Π°ΠΏΡ€. 12, 2024 8:52:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12458
Π°ΠΏΡ€. 12, 2024 8:53:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12548
2024.04.12 20:53:09 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:53:09 INFO  compiling bestgame (1 scala source)
2024.04.12 20:53:11 INFO  time: compiled bestgame in 1.95s
2024.04.12 20:53:38 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:53:38 INFO  compiling bestgame (1 scala source)
2024.04.12 20:53:38 INFO  time: compiled bestgame in 0.73s
2024.04.12 20:53:40 WARN  Using indexes to guess the definition of PathCodec
2024.04.12 20:53:41 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:53:41 INFO  compiling bestgame (1 scala source)
2024.04.12 20:53:41 INFO  time: compiled bestgame in 0.62s
2024.04.12 20:53:48 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:53:48 INFO  compiling bestgame (1 scala source)
2024.04.12 20:53:48 INFO  time: compiled bestgame in 0.82s
2024.04.12 20:55:17 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:55:17 INFO  compiling bestgame (1 scala source)
2024.04.12 20:55:17 INFO  time: compiled bestgame in 0.4s
2024.04.12 20:55:22 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:55:22 INFO  compiling bestgame (1 scala source)
2024.04.12 20:55:22 INFO  time: compiled bestgame in 0.32s
2024.04.12 20:55:48 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:55:48 INFO  compiling bestgame (1 scala source)
2024.04.12 20:55:48 INFO  time: compiled bestgame in 0.34s
2024.04.12 20:56:00 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:56:00 INFO  compiling bestgame (1 scala source)
2024.04.12 20:56:00 INFO  time: compiled bestgame in 0.29s
Π°ΠΏΡ€. 12, 2024 8:57:25 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-12\r_compiler-error_(bestgame)_20-57-25-821.md
2024.04.12 20:57:31 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:57:31 INFO  compiling bestgame (1 scala source)
2024.04.12 20:57:31 INFO  time: compiled bestgame in 0.13s
2024.04.12 20:57:38 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:57:38 INFO  compiling bestgame (1 scala source)
2024.04.12 20:57:38 INFO  time: compiled bestgame in 0.49s
2024.04.12 20:57:59 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:57:59 INFO  compiling bestgame (1 scala source)
2024.04.12 20:57:59 INFO  time: compiled bestgame in 0.1s
2024.04.12 20:58:10 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:58:10 INFO  compiling bestgame (1 scala source)
2024.04.12 20:58:10 INFO  time: compiled bestgame in 88ms
2024.04.12 20:58:19 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:58:19 INFO  compiling bestgame (1 scala source)
2024.04.12 20:58:19 INFO  time: compiled bestgame in 0.12s
Π°ΠΏΡ€. 12, 2024 8:58:21 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-12\r_compiler-error_(bestgame)_20-58-21-776.md
2024.04.12 20:58:22 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 20:58:22 INFO  compiling bestgame (1 scala source)
2024.04.12 20:58:22 INFO  time: compiled bestgame in 98ms
Π°ΠΏΡ€. 12, 2024 8:58:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13246
2024.04.12 21:00:42 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 21:00:42 INFO  compiling bestgame (1 scala source)
2024.04.12 21:00:42 INFO  time: compiled bestgame in 0.44s
Π°ΠΏΡ€. 12, 2024 9:00:53 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-12\r_compiler-error_(bestgame)_21-00-53-005.md
Π°ΠΏΡ€. 12, 2024 9:00:54 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-12\r_compiler-error_(bestgame)_21-00-54-096.md
Π°ΠΏΡ€. 12, 2024 9:00:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13425
2024.04.12 21:01:03 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 21:01:03 INFO  compiling bestgame (1 scala source)
2024.04.12 21:01:03 INFO  time: compiled bestgame in 0.12s
2024.04.12 21:01:17 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 21:01:17 INFO  compiling bestgame (1 scala source)
2024.04.12 21:01:17 INFO  time: compiled bestgame in 0.11s
2024.04.12 21:01:29 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 21:01:29 INFO  compiling bestgame (1 scala source)
2024.04.12 21:01:29 INFO  time: compiled bestgame in 0.11s
2024.04.12 21:01:36 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 21:01:36 INFO  compiling bestgame (1 scala source)
2024.04.12 21:01:36 INFO  time: compiled bestgame in 0.13s
2024.04.12 21:01:37 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 21:01:37 INFO  compiling bestgame (1 scala source)
2024.04.12 21:01:37 INFO  time: compiled bestgame in 0.12s
Π°ΠΏΡ€. 12, 2024 9:01:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13621
2024.04.12 21:01:44 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 21:01:44 INFO  compiling bestgame (1 scala source)
2024.04.12 21:01:44 INFO  time: compiled bestgame in 0.11s
2024.04.12 21:01:46 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 21:01:46 INFO  compiling bestgame (1 scala source)
2024.04.12 21:01:46 INFO  time: compiled bestgame in 0.31s
2024.04.12 21:01:51 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 21:01:51 INFO  compiling bestgame (1 scala source)
2024.04.12 21:01:51 INFO  time: compiled bestgame in 0.28s
2024.04.12 21:01:53 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\main.scala
scala.meta.tokenizers.TokenizeException: <input>:22: error: unclosed string interpolation
          Console.printLine(s"Channel discon #$")
                              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.12 21:01:54 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\main.scala
scala.meta.tokenizers.TokenizeException: <input>:22: error: unclosed string interpolation
          Console.printLine(s"Channel discon $")
                              ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:357)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.12 21:01:55 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 21:01:55 INFO  compiling bestgame (1 scala source)
2024.04.12 21:01:55 INFO  time: compiled bestgame in 0.37s
2024.04.12 21:02:48 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 21:02:48 INFO  compiling bestgame (1 scala source)
2024.04.12 21:02:48 INFO  time: compiled bestgame in 0.86s
2024.04.12 21:02:50 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.12 21:02:50 INFO  compiling bestgame (1 scala source)
2024.04.12 21:02:50 INFO  time: compiled bestgame in 0.56s
2024.04.12 21:03:44 INFO  Shutting down server
2024.04.12 21:03:44 INFO  shutting down Metals
2024.04.12 21:03:44 INFO  Shut down connection with build server.
2024.04.12 21:03:44 INFO  Shut down connection with build server.
Π°ΠΏΡ€. 12, 2024 9:03:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint notify
INFO: Failed to send notification message.
org.eclipse.lsp4j.jsonrpc.JsonRpcException: java.nio.channels.ClosedChannelException
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:72)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.notify(RemoteEndpoint.java:126)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.sendCancelNotification(RemoteEndpoint.java:180)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint$1.cancel(RemoteEndpoint.java:150)
	at scala.meta.internal.metals.utils.FutureWithTimeout$$anon$1.$anonfun$cancel$1(FutureWithTimeout.scala:37)
	at scala.runtime.java8.JFunction0$mcZ$sp.apply(JFunction0$mcZ$sp.scala:17)
	at scala.util.Try$.apply(Try.scala:210)
	at scala.meta.internal.metals.utils.FutureWithTimeout$$anon$1.cancel(FutureWithTimeout.scala:37)
	at scala.meta.internal.metals.Cancelable$.$anonfun$cancelAll$1(Cancelable.scala:29)
	at scala.collection.immutable.List.foreach(List.scala:333)
	at scala.meta.internal.metals.Cancelable$.cancelAll(Cancelable.scala:28)
	at scala.meta.internal.metals.MutableCancelable.cancel(MutableCancelable.scala:25)
	at scala.meta.internal.metals.utils.RequestRegistry.cancel(RequestRegistry.scala:94)
	at scala.meta.internal.metals.BuildServerConnection.cancel(BuildServerConnection.scala:396)
	at scala.meta.internal.bsp.BspSession.$anonfun$cancel$1(BspSession.scala:34)
	at scala.meta.internal.bsp.BspSession.$anonfun$cancel$1$adapted(BspSession.scala:34)
	at scala.collection.immutable.List.foreach(List.scala:333)
	at scala.meta.internal.bsp.BspSession.cancel(BspSession.scala:34)
	at scala.meta.internal.metals.Cancelable$.$anonfun$cancelAll$1(Cancelable.scala:29)
	at scala.collection.immutable.List.foreach(List.scala:333)
	at scala.meta.internal.metals.Cancelable$.cancelAll(Cancelable.scala:28)
	at scala.meta.internal.metals.MutableCancelable.cancel(MutableCancelable.scala:25)
	at scala.meta.internal.metals.MetalsLspService.cancel(MetalsLspService.scala:162)
	at scala.meta.internal.metals.MetalsLspService.onShutdown(MetalsLspService.scala:947)
	at scala.meta.internal.metals.WorkspaceLspService.$anonfun$shutdown$2(WorkspaceLspService.scala:1199)
	at scala.meta.internal.metals.WorkspaceLspService.$anonfun$shutdown$2$adapted(WorkspaceLspService.scala:1199)
	at scala.collection.immutable.List.foreach(List.scala:333)
	at scala.meta.internal.metals.WorkspaceLspService.shutdown(WorkspaceLspService.scala:1199)
	at scala.meta.metals.MetalsLanguageServer.shutdown(MetalsLanguageServer.scala:260)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.nio.channels.ClosedChannelException
	at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:224)
	at java.base/sun.nio.ch.SocketChannelImpl.implWrite(SocketChannelImpl.java:560)
	at java.base/sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:618)
	at java.base/sun.nio.ch.SinkChannelImpl.write(SinkChannelImpl.java:124)
	at java.base/sun.nio.ch.ChannelOutputStream.writeFully(ChannelOutputStream.java:68)
	at java.base/sun.nio.ch.ChannelOutputStream.write(ChannelOutputStream.java:102)
	at java.base/java.io.OutputStream.write(OutputStream.java:124)
	at java.base/sun.nio.ch.ChannelOutputStream.write(ChannelOutputStream.java:79)
	at scala.meta.internal.metals.ClosableOutputStream.write(ClosableOutputStream.scala:26)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:139)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:110)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:67)
	... 43 more

Π°ΠΏΡ€. 12, 2024 9:03:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint notify
INFO: Failed to send notification message.
org.eclipse.lsp4j.jsonrpc.JsonRpcException: java.nio.channels.ClosedChannelException
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:72)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.notify(RemoteEndpoint.java:126)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.sendCancelNotification(RemoteEndpoint.java:180)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint$1.cancel(RemoteEndpoint.java:150)
	at scala.meta.internal.metals.utils.RequestRegistry.$anonfun$register$5(RequestRegistry.scala:78)
	at scala.runtime.java8.JFunction0$mcZ$sp.apply(JFunction0$mcZ$sp.scala:17)
	at scala.util.Try$.apply(Try.scala:210)
	at scala.meta.internal.metals.utils.RequestRegistry.$anonfun$register$4(RequestRegistry.scala:78)
	at scala.meta.internal.metals.Cancelable$$anon$1.cancel(Cancelable.scala:18)
	at scala.meta.internal.metals.Cancelable$.$anonfun$cancelAll$1(Cancelable.scala:29)
	at scala.collection.immutable.List.foreach(List.scala:333)
	at scala.meta.internal.metals.Cancelable$.cancelAll(Cancelable.scala:28)
	at scala.meta.internal.metals.MutableCancelable.cancel(MutableCancelable.scala:25)
	at scala.meta.internal.metals.utils.RequestRegistry.cancel(RequestRegistry.scala:94)
	at scala.meta.internal.metals.BuildServerConnection.cancel(BuildServerConnection.scala:396)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$shutdown$1(BuildServerConnection.scala:171)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$shutdown$1$adapted(BuildServerConnection.scala:163)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.nio.channels.ClosedChannelException
	at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:224)
	at java.base/sun.nio.ch.SocketChannelImpl.implWrite(SocketChannelImpl.java:560)
	at java.base/sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:618)
	at java.base/sun.nio.ch.SinkChannelImpl.write(SinkChannelImpl.java:124)
	at java.base/sun.nio.ch.ChannelOutputStream.writeFully(ChannelOutputStream.java:68)
	at java.base/sun.nio.ch.ChannelOutputStream.write(ChannelOutputStream.java:102)
	at java.base/java.io.OutputStream.write(OutputStream.java:124)
	at java.base/sun.nio.ch.ChannelOutputStream.write(ChannelOutputStream.java:79)
	at scala.meta.internal.metals.ClosableOutputStream.write(ClosableOutputStream.scala:26)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:139)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:110)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:67)
	... 20 more

2024.04.12 21:03:44 INFO  Failed to run request with params WorkspaceBuildTargetsResult
2024.04.12 21:03:44 INFO  Cancelling compilation on Bloop server
2024.04.12 21:03:44 INFO  Exiting server
2024.04.15 22:56:43 INFO  Started: Metals version 1.2.2 in folders 'D:\bestgame' for client Visual Studio Code 1.88.1.
22:56:45.827 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
22:56:45.829 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
22:56:45.829 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
22:56:45.830 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
22:56:45.830 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@33909752 ...
22:56:45.830 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
22:56:45.830 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
22:56:45.830 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@33909752 ...
22:56:45.831 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/C:/Users/yidtdr/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
22:56:45.832 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
22:56:45.832 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
22:56:45.832 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
22:56:45.832 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
22:56:45.832 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
22:56:45.832 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
22:56:45.834 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
22:56:45.834 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
22:56:45.835 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
22:56:45.835 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
22:56:45.835 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
22:56:45.912 [pool-1-thread-1] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:D:\bestgame\.metals\metals (H2 2.2)
22:56:45.912 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
22:56:45.912 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
22:56:45.912 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
22:56:45.913 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
22:56:45.915 [pool-1-thread-1] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
22:56:45.915 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
22:56:45.916 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
22:56:45.921 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
22:56:45.923 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
22:56:45.927 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
22:56:45.928 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
22:56:45.928 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
22:56:45.928 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
22:56:45.928 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
22:56:45.928 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
22:56:45.928 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
22:56:45.928 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
22:56:45.928 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
22:56:45.928 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
22:56:45.939 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.017s)
22:56:45.941 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
22:56:45.944 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
22:56:45.948 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
22:56:45.952 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 35 of 100M
2024.04.15 22:56:46 INFO  Attempting to connect to the build server...
2024.04.15 22:56:46 INFO  skipping build import with status 'Started'
2024.04.15 22:56:46 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.15 22:56:50 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.15 22:56:50 INFO  Attempting to connect to the build server...
2024.04.15 22:56:50 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.15 22:56:50 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.15 22:56:50 INFO  time: Connected to build server in 4.06s
2024.04.15 22:56:50 INFO  Connected to Build server: Bloop v1.5.15
2024.04.15 22:56:51 INFO  time: Imported build in 0.18s
2024.04.15 22:56:52 INFO  no build target found for D:\bestgame\src\main\scala\main.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.15 22:56:55 INFO  time: indexed workspace in 2.6s
2024.04.15 22:56:55 INFO  no build target found for D:\bestgame\src\main\scala\main.scala. Using presentation compiler with project's scala-library version: 3.3.1
2024.04.15 22:56:55 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 22:56:55 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 22:58:11 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 22:58:11 INFO  compiling bestgame (1 scala source)
2024.04.15 22:58:14 INFO  time: compiled bestgame in 3.44s
2024.04.15 22:58:31 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 22:58:31 INFO  compiling bestgame (1 scala source)
2024.04.15 22:58:31 INFO  time: compiled bestgame in 0.48s
2024.04.15 23:00:20 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:00:20 INFO  compiling bestgame (1 scala source)
2024.04.15 23:00:20 INFO  time: compiled bestgame in 0.26s
2024.04.15 23:00:35 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:00:35 INFO  compiling bestgame (1 scala source)
2024.04.15 23:00:35 INFO  time: compiled bestgame in 0.23s
2024.04.15 23:00:35 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:00:45 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:00:45 INFO  compiling bestgame (1 scala source)
2024.04.15 23:00:45 INFO  time: compiled bestgame in 0.14s
2024.04.15 23:00:45 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:00:45 INFO  compiling bestgame (1 scala source)
2024.04.15 23:00:45 INFO  time: compiled bestgame in 0.12s
Π°ΠΏΡ€. 15, 2024 11:01:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 243
2024.04.15 23:01:26 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:01:29 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:01:29 INFO  compiling bestgame (1 scala source)
2024.04.15 23:01:29 INFO  time: compiled bestgame in 0.3s
Π°ΠΏΡ€. 15, 2024 11:01:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 282
2024.04.15 23:17:15 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:17:15 INFO  compiling bestgame (1 scala source)
2024.04.15 23:17:15 INFO  time: compiled bestgame in 0.18s
2024.04.15 23:20:50 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:20:50 INFO  compiling bestgame (1 scala source)
2024.04.15 23:20:50 INFO  time: compiled bestgame in 40ms
2024.04.15 23:23:08 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:23:08 INFO  compiling bestgame (1 scala source)
2024.04.15 23:23:08 INFO  time: compiled bestgame in 0.2s
Π°ΠΏΡ€. 15, 2024 11:23:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 449
2024.04.15 23:23:50 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:23:50 INFO  compiling bestgame (1 scala source)
2024.04.15 23:23:50 INFO  time: compiled bestgame in 70ms
2024.04.15 23:23:57 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:23:57 INFO  compiling bestgame (1 scala source)
2024.04.15 23:23:57 INFO  time: compiled bestgame in 0.62s
2024.04.15 23:24:15 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:24:15 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:24:15 INFO  time: compiled bestgame in 0.34s
2024.04.15 23:24:19 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:24:19 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:24:19 INFO  time: compiled bestgame in 0.28s
2024.04.15 23:24:23 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:24:23 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:24:23 INFO  time: compiled bestgame in 0.22s
2024.04.15 23:24:31 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:24:31 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:24:31 INFO  time: compiled bestgame in 0.19s
2024.04.15 23:24:54 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:24:54 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:24:54 INFO  time: compiled bestgame in 0.18s
Π°ΠΏΡ€. 15, 2024 11:26:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 772
2024.04.15 23:26:05 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:26:05 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:26:05 INFO  time: compiled bestgame in 0.2s
2024.04.15 23:28:12 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:28:12 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:28:12 INFO  time: compiled bestgame in 0.19s
2024.04.15 23:28:26 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:28:26 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:28:26 INFO  time: compiled bestgame in 0.11s
2024.04.15 23:28:58 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:28:58 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:28:58 INFO  time: compiled bestgame in 87ms
2024.04.15 23:29:15 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:29:15 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:29:15 INFO  time: compiled bestgame in 65ms
Π°ΠΏΡ€. 15, 2024 11:29:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1184
2024.04.15 23:29:18 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:29:18 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:29:18 INFO  time: compiled bestgame in 0.11s
2024.04.15 23:29:27 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:29:27 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:29:27 INFO  time: compiled bestgame in 60ms
2024.04.15 23:29:30 WARN  Using indexes to guess the definition of price
2024.04.15 23:29:32 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:29:32 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:29:32 INFO  time: compiled bestgame in 70ms
2024.04.15 23:29:37 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:29:37 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:29:37 INFO  time: compiled bestgame in 63ms
Π°ΠΏΡ€. 15, 2024 11:33:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1330
2024.04.15 23:33:41 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:33:41 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:33:41 INFO  time: compiled bestgame in 81ms
2024.04.15 23:33:43 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:33:43 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:33:43 INFO  time: compiled bestgame in 64ms
2024.04.15 23:33:50 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:33:50 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:33:50 INFO  time: compiled bestgame in 65ms
2024.04.15 23:33:54 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:33:54 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:33:54 INFO  time: compiled bestgame in 80ms
2024.04.15 23:33:56 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:33:56 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:33:56 INFO  time: compiled bestgame in 72ms
2024.04.15 23:34:08 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:34:08 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:34:08 INFO  time: compiled bestgame in 0.22s
2024.04.15 23:34:31 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:34:31 INFO  compiling bestgame (1 scala source)
2024.04.15 23:34:31 INFO  time: compiled bestgame in 0.32s
2024.04.15 23:34:31 INFO  compiling bestgame (3 scala sources)
2024.04.15 23:34:32 INFO  time: compiled bestgame in 1.06s
2024.04.15 23:34:40 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:34:40 INFO  compiling bestgame (1 scala source)
2024.04.15 23:34:40 INFO  time: compiled bestgame in 0.26s
2024.04.15 23:35:34 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.15 23:35:34 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:35:34 INFO  compiling bestgame (1 scala source)
2024.04.15 23:35:34 INFO  time: compiled bestgame in 0.21s
2024.04.15 23:35:34 INFO  compiling bestgame (1 scala source)
2024.04.15 23:35:34 INFO  time: compiled bestgame in 0.23s
Π°ΠΏΡ€. 15, 2024 11:35:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1780
2024.04.15 23:36:29 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:36:29 INFO  compiling bestgame (1 scala source)
2024.04.15 23:36:29 INFO  time: compiled bestgame in 0.12s
2024.04.15 23:36:38 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:36:38 INFO  compiling bestgame (1 scala source)
2024.04.15 23:36:38 INFO  time: compiled bestgame in 0.21s
2024.04.15 23:36:38 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:36:38 INFO  compiling bestgame (1 scala source)
2024.04.15 23:36:39 INFO  time: compiled bestgame in 0.24s
2024.04.15 23:36:48 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\SocketEvents.scala
scala.meta.tokenizers.TokenizeException: <input>:13: error: unclosed string interpolation
    case (s"buy/${name}/$") => Buy(null)
                       ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:249)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.15 23:36:49 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\SocketEvents.scala
scala.meta.tokenizers.TokenizeException: <input>:13: error: unclosed string interpolation
    case (s"buy/${name}/$") => Buy(null)
                       ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:249)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.15 23:36:57 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:36:57 INFO  compiling bestgame (1 scala source)
2024.04.15 23:36:57 INFO  time: compiled bestgame in 0.23s
2024.04.15 23:37:02 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:37:02 INFO  compiling bestgame (1 scala source)
2024.04.15 23:37:02 INFO  time: compiled bestgame in 0.22s
2024.04.15 23:37:30 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:37:30 INFO  compiling bestgame (1 scala source)
2024.04.15 23:37:30 INFO  time: compiled bestgame in 0.21s
2024.04.15 23:37:31 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.15 23:37:34 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.15 23:37:36 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.15 23:37:36 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.15 23:37:37 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.15 23:37:38 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:37:38 INFO  compiling bestgame (1 scala source)
2024.04.15 23:37:37 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.15 23:37:38 INFO  time: compiled bestgame in 81ms
2024.04.15 23:37:38 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.15 23:37:39 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:37:39 INFO  compiling bestgame (1 scala source)
2024.04.15 23:37:39 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.15 23:37:39 INFO  time: compiled bestgame in 80ms
2024.04.15 23:37:39 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.15 23:37:43 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:37:43 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\SocketEvents.scala
2024.04.15 23:37:43 INFO  compiling bestgame (1 scala source)
2024.04.15 23:37:43 INFO  time: compiled bestgame in 0.28s
Π°ΠΏΡ€. 15, 2024 11:37:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2359
2024.04.15 23:37:55 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:37:55 INFO  compiling bestgame (1 scala source)
2024.04.15 23:37:55 INFO  time: compiled bestgame in 0.23s
2024.04.15 23:38:00 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:38:00 INFO  compiling bestgame (1 scala source)
2024.04.15 23:38:00 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:38:00 INFO  time: compiled bestgame in 0.16s
2024.04.15 23:38:15 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:38:15 INFO  compiling bestgame (1 scala source)
2024.04.15 23:38:15 INFO  time: compiled bestgame in 0.17s
2024.04.15 23:38:44 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:38:44 INFO  compiling bestgame (1 scala source)
2024.04.15 23:38:44 INFO  time: compiled bestgame in 0.97s
2024.04.15 23:38:46 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:38:50 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:38:51 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
Π°ΠΏΡ€. 15, 2024 11:38:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2561
2024.04.15 23:38:53 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:38:55 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:38:56 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:38:56 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:39:01 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:39:01 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:39:01 INFO  compiling bestgame (1 scala source)
2024.04.15 23:39:01 INFO  time: compiled bestgame in 0.75s
2024.04.15 23:39:02 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:39:54 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:39:54 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:39:54 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:39:54 INFO  time: compiled bestgame in 0.72s
2024.04.15 23:39:55 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:39:56 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:39:56 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:39:57 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:39:57 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:39:57 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:39:57 INFO  time: compiled bestgame in 0.57s
2024.04.15 23:39:58 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:40:02 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:40:03 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:40:03 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:40:03 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:40:03 INFO  time: compiled bestgame in 0.61s
2024.04.15 23:40:04 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:40:11 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:40:11 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:40:11 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:40:11 INFO  time: compiled bestgame in 0.65s
2024.04.15 23:40:12 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:40:18 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:40:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:40:18 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:40:18 INFO  time: compiled bestgame in 0.48s
2024.04.15 23:40:19 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:40:27 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:40:33 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Items.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed string literal
    case (") => Connect(text)
          ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:553)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:372)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:376)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.15 23:40:33 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:40:34 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:40:35 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:40:38 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:40:39 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:40:39 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:40:39 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:40:39 INFO  time: compiled bestgame in 0.46s
2024.04.15 23:40:40 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:40:43 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:40:44 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:40:44 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:40:44 INFO  time: compiled bestgame in 0.46s
2024.04.15 23:40:45 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:40:57 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:40:59 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:40:59 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:40:59 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:40:59 INFO  time: compiled bestgame in 0.1s
2024.04.15 23:41:00 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:41:17 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:41:21 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:41:22 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:41:24 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:41:24 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:41:25 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:41:25 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:41:32 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:41:34 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:41:34 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:41:34 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:41:34 INFO  time: compiled bestgame in 73ms
2024.04.15 23:41:34 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:41:41 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:41:45 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:41:51 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:41:52 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:41:52 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:41:52 INFO  time: compiled bestgame in 69ms
2024.04.15 23:41:52 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:41:53 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:41:53 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:41:54 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:41:55 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:41:57 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:41:57 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:41:57 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:41:57 INFO  time: compiled bestgame in 86ms
2024.04.15 23:41:58 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
Π°ΠΏΡ€. 15, 2024 11:42:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3160
2024.04.15 23:42:07 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:42:10 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:42:10 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:42:10 INFO  time: compiled bestgame in 75ms
2024.04.15 23:42:11 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:42:14 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:42:15 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:42:15 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:42:15 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:42:15 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:42:15 INFO  time: compiled bestgame in 96ms
2024.04.15 23:42:15 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
Π°ΠΏΡ€. 15, 2024 11:42:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3183
2024.04.15 23:42:28 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:42:32 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:42:32 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:42:32 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:42:32 INFO  time: compiled bestgame in 66ms
2024.04.15 23:42:33 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
Π°ΠΏΡ€. 15, 2024 11:42:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3228
2024.04.15 23:42:40 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Items.scala
2024.04.15 23:42:46 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:42:49 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:42:52 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:42:52 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:42:52 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:42:52 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:42:52 INFO  time: compiled bestgame in 0.48s
2024.04.15 23:42:53 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:43:07 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:43:08 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:43:09 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:43:10 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\App.scala
2024.04.15 23:43:10 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:43:10 INFO  compiling bestgame (2 scala sources)
2024.04.15 23:43:10 INFO  time: compiled bestgame in 0.19s
2024.04.15 23:43:19 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:43:19 INFO  compiling bestgame (1 scala source)
2024.04.15 23:43:19 INFO  time: compiled bestgame in 0.18s
2024.04.15 23:43:57 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:43:57 INFO  compiling bestgame (1 scala source)
2024.04.15 23:43:57 INFO  time: compiled bestgame in 0.18s
2024.04.15 23:44:01 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:44:01 INFO  compiling bestgame (1 scala source)
2024.04.15 23:44:01 INFO  time: compiled bestgame in 0.18s
2024.04.15 23:44:26 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:44:26 INFO  compiling bestgame (1 scala source)
2024.04.15 23:44:26 INFO  time: compiled bestgame in 44ms
2024.04.15 23:44:45 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:44:45 INFO  compiling bestgame (1 scala source)
2024.04.15 23:44:45 INFO  time: compiled bestgame in 73ms
2024.04.15 23:45:05 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:45:05 INFO  compiling bestgame (1 scala source)
2024.04.15 23:45:05 INFO  time: compiled bestgame in 67ms
2024.04.15 23:45:17 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:45:17 INFO  compiling bestgame (1 scala source)
2024.04.15 23:45:17 INFO  time: compiled bestgame in 75ms
2024.04.15 23:45:36 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:45:36 INFO  compiling bestgame (1 scala source)
2024.04.15 23:45:36 INFO  time: compiled bestgame in 0.11s
2024.04.15 23:46:07 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:46:07 INFO  compiling bestgame (1 scala source)
2024.04.15 23:46:07 INFO  time: compiled bestgame in 80ms
2024.04.15 23:46:24 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:46:24 INFO  compiling bestgame (1 scala source)
2024.04.15 23:46:24 INFO  time: compiled bestgame in 0.1s
2024.04.15 23:46:35 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:46:35 INFO  compiling bestgame (1 scala source)
2024.04.15 23:46:35 INFO  time: compiled bestgame in 89ms
2024.04.15 23:46:45 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.15 23:46:45 INFO  compiling bestgame (1 scala source)
2024.04.15 23:46:45 INFO  time: compiled bestgame in 0.14s
2024.04.16 00:12:36 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:12:36 INFO  compiling bestgame (1 scala source)
2024.04.16 00:12:36 INFO  time: compiled bestgame in 0.23s
2024.04.16 00:12:36 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:12:42 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:12:42 INFO  compiling bestgame (1 scala source)
2024.04.16 00:12:42 INFO  time: compiled bestgame in 63ms
Π°ΠΏΡ€. 16, 2024 12:12:58 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4362
2024.04.16 00:14:45 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:14:45 INFO  compiling bestgame (1 scala source)
2024.04.16 00:14:45 INFO  time: compiled bestgame in 0.26s
2024.04.16 00:14:50 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:15:01 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:15:01 INFO  compiling bestgame (1 scala source)
2024.04.16 00:15:01 INFO  time: compiled bestgame in 0.21s
Π°ΠΏΡ€. 16, 2024 12:15:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4487
2024.04.16 00:15:23 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\Game.scala
scala.meta.tokenizers.TokenizeException: <input>:8: error: unclosed string interpolation
    s"${player.money} ${player.planted} $"
                                       ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringPart(LegacyScanner.scala:659)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:249)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:211)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1011)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:962)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:332)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:541)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

Π°ΠΏΡ€. 16, 2024 12:15:38 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4598
2024.04.16 00:15:51 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:15:51 INFO  compiling bestgame (1 scala source)
2024.04.16 00:15:51 INFO  time: compiled bestgame in 0.11s
Π°ΠΏΡ€. 16, 2024 12:16:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4710
2024.04.16 00:16:20 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:16:20 INFO  compiling bestgame (1 scala source)
2024.04.16 00:16:20 INFO  time: compiled bestgame in 0.2s
2024.04.16 00:16:22 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:16:22 INFO  compiling bestgame (1 scala source)
2024.04.16 00:16:22 INFO  time: compiled bestgame in 0.2s
2024.04.16 00:16:26 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:16:26 INFO  compiling bestgame (1 scala source)
2024.04.16 00:16:26 INFO  time: compiled bestgame in 96ms
2024.04.16 00:19:36 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:19:36 INFO  compiling bestgame (1 scala source)
2024.04.16 00:19:36 INFO  time: compiled bestgame in 0.35s
2024.04.16 00:21:17 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:21:17 INFO  compiling bestgame (1 scala source)
2024.04.16 00:21:17 INFO  time: compiled bestgame in 0.2s
2024.04.16 00:21:32 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:21:32 INFO  compiling bestgame (1 scala source)
2024.04.16 00:21:32 INFO  time: compiled bestgame in 0.13s
2024.04.16 00:21:37 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:21:37 INFO  compiling bestgame (1 scala source)
2024.04.16 00:21:37 INFO  time: compiled bestgame in 0.3s
2024.04.16 00:23:31 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
Π°ΠΏΡ€. 16, 2024 12:29:43 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5303
Π°ΠΏΡ€. 16, 2024 12:29:50 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5317
2024.04.16 00:30:36 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:30:36 INFO  compiling bestgame (1 scala source)
2024.04.16 00:30:36 INFO  time: compiled bestgame in 0.49s
2024.04.16 00:30:52 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:30:52 INFO  compiling bestgame (1 scala source)
2024.04.16 00:30:52 INFO  time: compiled bestgame in 0.73s
2024.04.16 00:30:53 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:31:02 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
Π°ΠΏΡ€. 16, 2024 12:32:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5855
2024.04.16 00:32:55 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:32:56 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:32:58 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:33:04 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:33:05 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:33:06 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:33:08 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:33:09 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:33:15 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:33:16 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:33:16 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:33:17 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:33:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:33:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:33:19 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:33:19 INFO  compiling bestgame (1 scala source)
2024.04.16 00:33:19 INFO  time: compiled bestgame in 0.24s
2024.04.16 00:33:19 INFO  compiling bestgame (2 scala sources)
2024.04.16 00:33:19 INFO  time: compiled bestgame in 0.28s
2024.04.16 00:33:23 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:33:23 INFO  compiling bestgame (1 scala source)
2024.04.16 00:33:23 INFO  time: compiled bestgame in 0.21s
2024.04.16 00:36:10 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:36:10 INFO  compiling bestgame (1 scala source)
2024.04.16 00:36:10 INFO  time: compiled bestgame in 0.14s
2024.04.16 00:36:11 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:12 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:13 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:14 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:14 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:15 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:16 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:20 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:20 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:22 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:28 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:29 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:29 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:36:29 INFO  compiling bestgame (1 scala source)
2024.04.16 00:36:29 INFO  time: compiled bestgame in 0.14s
2024.04.16 00:36:29 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:30 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:36:30 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:30 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:30 INFO  compiling bestgame (1 scala source)
2024.04.16 00:36:30 INFO  time: compiled bestgame in 0.16s
2024.04.16 00:36:30 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:33 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:33 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:36:33 INFO  compiling bestgame (1 scala source)
2024.04.16 00:36:33 INFO  time: compiled bestgame in 90ms
2024.04.16 00:36:33 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:34 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:34 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:35 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:36:35 INFO  compiling bestgame (1 scala source)
2024.04.16 00:36:35 INFO  time: compiled bestgame in 0.35s
2024.04.16 00:36:35 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:46 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:47 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:48 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:49 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:50 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:53 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:55 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:36:56 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:08 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:09 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:09 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:11 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:11 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:12 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:13 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:14 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:15 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:16 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:20 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:21 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:22 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:24 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:26 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:27 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:37:27 INFO  compiling bestgame (1 scala source)
2024.04.16 00:37:27 INFO  time: compiled bestgame in 0.17s
2024.04.16 00:37:28 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:30 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:37:30 INFO  compiling bestgame (1 scala source)
2024.04.16 00:37:30 INFO  time: compiled bestgame in 0.19s
2024.04.16 00:37:30 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:43 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
Π°ΠΏΡ€. 16, 2024 12:37:43 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6806
2024.04.16 00:37:43 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:43 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\ItemContainer.scala
2024.04.16 00:37:44 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:37:44 INFO  compiling bestgame (1 scala source)
2024.04.16 00:37:44 INFO  time: compiled bestgame in 0.15s
2024.04.16 00:39:31 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 00:39:31 INFO  compiling bestgame (1 scala source)
2024.04.16 00:39:31 INFO  time: compiled bestgame in 0.16s
2024.04.16 00:48:51 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.16 00:48:51 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.16 00:48:52 INFO  Connected to Build server: Bloop v1.5.15
2024.04.16 00:48:52 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.16 00:48:52 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
Π°ΠΏΡ€. 16, 2024 1:18:47 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6892
2024.04.16 01:32:34 INFO  Shutting down server
2024.04.16 01:32:34 INFO  shutting down Metals
2024.04.16 01:32:34 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.16 01:32:35 INFO  Shut down connection with build server.
2024.04.16 01:32:35 INFO  Shut down connection with build server.
Π°ΠΏΡ€. 16, 2024 1:32:35 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint notify
INFO: Failed to send notification message.
org.eclipse.lsp4j.jsonrpc.JsonRpcException: java.nio.channels.ClosedChannelException
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:72)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.notify(RemoteEndpoint.java:126)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.sendCancelNotification(RemoteEndpoint.java:180)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint$1.cancel(RemoteEndpoint.java:150)
	at scala.meta.internal.metals.utils.RequestRegistry.$anonfun$register$5(RequestRegistry.scala:78)
	at scala.runtime.java8.JFunction0$mcZ$sp.apply(JFunction0$mcZ$sp.scala:17)
	at scala.util.Try$.apply(Try.scala:210)
	at scala.meta.internal.metals.utils.RequestRegistry.$anonfun$register$4(RequestRegistry.scala:78)
	at scala.meta.internal.metals.Cancelable$$anon$1.cancel(Cancelable.scala:18)
	at scala.meta.internal.metals.Cancelable$.$anonfun$cancelAll$1(Cancelable.scala:29)
	at scala.collection.immutable.List.foreach(List.scala:333)
	at scala.meta.internal.metals.Cancelable$.cancelAll(Cancelable.scala:28)
	at scala.meta.internal.metals.MutableCancelable.cancel(MutableCancelable.scala:25)
	at scala.meta.internal.metals.utils.RequestRegistry.cancel(RequestRegistry.scala:94)
	at scala.meta.internal.metals.BuildServerConnection.cancel(BuildServerConnection.scala:396)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$shutdown$1(BuildServerConnection.scala:171)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$shutdown$1$adapted(BuildServerConnection.scala:163)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.nio.channels.ClosedChannelException
	at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:224)
	at java.base/sun.nio.ch.SocketChannelImpl.implWrite(SocketChannelImpl.java:560)
	at java.base/sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:618)
	at java.base/sun.nio.ch.SinkChannelImpl.write(SinkChannelImpl.java:124)
	at java.base/sun.nio.ch.ChannelOutputStream.writeFully(ChannelOutputStream.java:68)
	at java.base/sun.nio.ch.ChannelOutputStream.write(ChannelOutputStream.java:102)
	at java.base/java.io.OutputStream.write(OutputStream.java:124)
	at java.base/sun.nio.ch.ChannelOutputStream.write(ChannelOutputStream.java:79)
	at scala.meta.internal.metals.ClosableOutputStream.write(ClosableOutputStream.scala:26)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:139)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:110)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:67)
	... 20 more

2024.04.16 01:32:35 INFO  Failed to run request with params WorkspaceBuildTargetsResult
2024.04.16 01:32:34 INFO  Exiting server
2024.04.17 11:07:28 INFO  Started: Metals version 1.2.2 in folders 'D:\bestgame' for client Visual Studio Code 1.88.1.
11:07:28.865 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- Flyway Community Edition 9.22.3 by Redgate
11:07:28.869 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- See release notes here: https://rd.gt/416ObMi
11:07:28.869 [pool-1-thread-1] INFO org.flywaydb.core.internal.license.VersionPrinter -- 
11:07:28.873 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/callback' ...
11:07:28.873 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/callback using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@33909752 ...
11:07:28.873 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Unable to resolve location classpath:db/callback.
11:07:28.873 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classpath resources at 'classpath:db/migration' ...
11:07:28.873 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Determining location urls for classpath:db/migration using ClassLoader jdk.internal.loader.ClassLoaders$AppClassLoader@33909752 ...
11:07:28.873 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning URL: jar:file:/C:/Users/yidtdr/AppData/Local/Coursier/cache/v1/https/repo1.maven.org/maven2/org/scalameta/metals_2.13/1.2.2/metals_2.13-1.2.2.jar!/db/migration
11:07:28.877 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/
11:07:28.877 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V1__Create_tables.sql
11:07:28.877 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V2__Server_discovery.sql
11:07:28.877 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V3__Jar_symbols.sql
11:07:28.877 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Found resource: db/migration/V4__Fingerprints.sql
11:07:28.877 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.classpath.ClassPathScanner -- Scanning for classes at classpath:db/migration
11:07:28.889 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
11:07:28.889 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V4__Fingerprints.sql
11:07:28.889 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V1__Create_tables.sql
11:07:28.889 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V3__Jar_symbols.sql
11:07:28.889 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.resource.ResourceNameValidator -- Validating V2__Server_discovery.sql
11:07:29.008 [pool-1-thread-1] INFO org.flywaydb.core.FlywayExecutor -- Database: jdbc:h2:file:D:\bestgame\.metals\metals (H2 2.2)
11:07:29.008 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Driver: H2 JDBC Driver 2.2.224 (2023-09-17)
11:07:29.008 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- DDL Transactions Supported: false
11:07:29.012 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Schemas: 
11:07:29.012 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.schemahistory.SchemaHistoryFactory -- Default schema: null
11:07:29.016 [pool-1-thread-1] WARN org.flywaydb.core.internal.database.base.Database -- Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
11:07:29.020 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.callback.SqlScriptCallbackFactory -- Scanning for SQL callbacks ...
11:07:29.020 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
11:07:29.028 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbValidate -- Validating migrations ...
11:07:29.032 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
11:07:29.040 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
11:07:29.040 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
11:07:29.040 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
11:07:29.040 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
11:07:29.040 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
11:07:29.044 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V4__Fingerprints.sql (filename: V4__Fingerprints.sql)
11:07:29.044 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V1__Create_tables.sql (filename: V1__Create_tables.sql)
11:07:29.044 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V3__Jar_symbols.sql (filename: V3__Jar_symbols.sql)
11:07:29.044 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/V2__Server_discovery.sql (filename: V2__Server_discovery.sql)
11:07:29.044 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.scanner.Scanner -- Filtering out resource: db/migration/ (filename: )
11:07:29.056 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbValidate -- Successfully validated 4 migrations (execution time 00:00.025s)
11:07:29.056 [pool-1-thread-1] DEBUG org.flywaydb.core.internal.command.DbSchemas -- Skipping creation of existing schema: "PUBLIC"
11:07:29.064 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Current version of schema "PUBLIC": 4
11:07:29.068 [pool-1-thread-1] INFO org.flywaydb.core.internal.command.DbMigrate -- Schema "PUBLIC" is up to date. No migration necessary.
11:07:29.076 [pool-1-thread-1] DEBUG org.flywaydb.core.FlywayExecutor -- Memory usage: 34 of 100M
2024.04.17 11:07:29 INFO  Attempting to connect to the build server...
2024.04.17 11:07:29 INFO  skipping build import with status 'Started'
2024.04.17 11:07:29 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.17 11:07:35 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.17 11:07:35 INFO  Attempting to connect to the build server...
2024.04.17 11:07:35 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.17 11:07:35 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.17 11:07:35 INFO  time: Connected to build server in 6.32s
2024.04.17 11:07:35 INFO  Connected to Build server: Bloop v1.5.15
2024.04.17 11:07:36 INFO  time: Imported build in 0.3s
2024.04.17 11:07:39 INFO  no build target found for D:\bestgame\src\main\scala\gameClasses\World.scala. Using presentation compiler with project's scala-library version: 3.3.1
Π°ΠΏΡ€. 17, 2024 11:07:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7
Π°ΠΏΡ€. 17, 2024 11:07:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12
Π°ΠΏΡ€. 17, 2024 11:07:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14
Π°ΠΏΡ€. 17, 2024 11:07:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17
Π°ΠΏΡ€. 17, 2024 11:07:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 21
Π°ΠΏΡ€. 17, 2024 11:07:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 22
Π°ΠΏΡ€. 17, 2024 11:07:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 24
Π°ΠΏΡ€. 17, 2024 11:07:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 27
Π°ΠΏΡ€. 17, 2024 11:07:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 26
Π°ΠΏΡ€. 17, 2024 11:07:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 31
2024.04.17 11:07:44 INFO  time: indexed workspace in 5s
2024.04.17 11:07:45 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
Π°ΠΏΡ€. 17, 2024 11:07:48 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 54
Π°ΠΏΡ€. 17, 2024 11:07:48 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 56
2024.04.17 11:07:48 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
Π°ΠΏΡ€. 17, 2024 11:08:04 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-17\r_compiler-error_(bestgame)_11-08-04-902.md
Π°ΠΏΡ€. 17, 2024 11:08:10 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-17\r_compiler-error_(bestgame)_11-08-10-933.md
Π°ΠΏΡ€. 17, 2024 11:08:11 AM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-17\r_compiler-error_(bestgame)_11-08-11-384.md
2024.04.17 11:08:28 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.17 11:08:28 INFO  compiling bestgame (1 scala source)
2024.04.17 11:08:31 INFO  time: compiled bestgame in 2.93s
2024.04.17 11:08:31 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.17 13:39:35 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.17 13:39:35 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.17 13:39:35 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.17 13:39:35 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.17 13:39:35 INFO  Connected to Build server: Bloop v1.5.15
2024.04.17 13:39:35 INFO  Connected to Build server: Bloop v1.5.15
2024.04.17 13:39:35 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.17 13:39:35 INFO  Bloop uses C:\Program Files\Java\jdk-17 defined at C:\Users\yidtdr\.bloop\bloop.json
2024.04.17 13:39:35 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.17 13:39:35 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.17 13:39:35 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.17 13:39:35 INFO  compiling bestgame (1 scala source)
2024.04.17 13:39:36 INFO  time: compiled bestgame in 1.01s
2024.04.17 13:39:37 INFO  time: Imported build in 1.31s
2024.04.17 13:39:37 INFO  time: Imported build in 1.32s
2024.04.17 13:39:38 INFO  time: indexed workspace in 1.33s
2024.04.17 13:39:38 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.17 13:39:38 INFO  compiling bestgame (1 scala source)
2024.04.17 13:39:39 INFO  time: indexed workspace in 2.36s
2024.04.17 13:39:41 INFO  time: compiled bestgame in 3.06s
Π°ΠΏΡ€. 17, 2024 1:39:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 343
2024.04.17 13:39:41 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.17 13:39:41 INFO  compiling bestgame (1 scala source)
error: D:\bestgame\.metals\.tmp\.metals\.tmp\Main-1542075677857599957.scala is not a file
2024.04.17 13:39:41 INFO  time: compiled bestgame in 0.37s
2024.04.17 13:40:04 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.17 13:40:04 INFO  compiling bestgame (1 scala source)
2024.04.17 13:40:04 INFO  time: compiled bestgame in 0.81s
2024.04.17 13:40:11 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.17 13:40:11 INFO  compiling bestgame (1 scala source)
2024.04.17 13:40:11 INFO  time: compiled bestgame in 0.2s
Π°ΠΏΡ€. 17, 2024 1:45:52 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-17\r_compiler-error_(bestgame)_13-45-52-254.md
2024.04.17 13:46:00 WARN  Bloop is running with 17.0.8 but your code requires 22 to compile, this might cause some compilation issues when using JDK API unsupported by the Bloop's current JVM version
2024.04.17 13:46:00 INFO  compiling bestgame (1 scala source)
2024.04.17 13:46:00 INFO  time: compiled bestgame in 0.42s
Π°ΠΏΡ€. 17, 2024 1:46:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 616
2024.04.20 20:41:56 INFO  Started: Metals version 1.3.0 in folders 'D:\bestgame' for client Visual Studio Code 1.88.1.
SLF4J: Class path contains multiple SLF4J providers.
SLF4J: Found provider [scribe.slf4j.ScribeServiceProvider@6b2a9b0b]
SLF4J: Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@39b6efc0]
SLF4J: See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J: Actual provider is of type [scribe.slf4j.ScribeServiceProvider@6b2a9b0b]
2024.04.20 20:42:00 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
Π°ΠΏΡ€. 20, 2024 8:42:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2
Π°ΠΏΡ€. 20, 2024 8:42:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1
2024.04.20 20:42:03 INFO  Attempting to connect to the build server...
2024.04.20 20:42:03 INFO  Replacing bloop java home C:\Program Files\Java\jdk-17 with java home at C:\Program Files\Java\jdk-22.
2024.04.20 20:42:22 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.20 20:42:22 INFO  Attempting to connect to the build server...
2024.04.20 20:42:22 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.20 20:42:32 INFO  time: Connected to build server in 28s
2024.04.20 20:42:32 INFO  Connected to Build server: Bloop v1.5.17
2024.04.20 20:42:32 INFO  time: Imported build in 0.16s
2024.04.20 20:42:36 INFO  no build target found for D:\bestgame\src\main\scala\gameClasses\Tile.scala. Using presentation compiler with project's scala-library version: 3.3.3
Π°ΠΏΡ€. 20, 2024 8:42:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 20
Π°ΠΏΡ€. 20, 2024 8:42:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 21
2024.04.20 20:42:44 INFO  no build target found for D:\bestgame\src\main\scala\gameClasses\Tile.scala. Using presentation compiler with project's scala-library version: 3.3.1
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 23
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 29
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 27
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 33
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 38
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 35
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 37
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 41
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 46
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 43
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 45
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 53
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 55
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 57
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 59
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 61
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 63
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 67
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 72
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 69
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 71
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 75
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 77
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 81
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 83
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 79
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 85
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 87
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 90
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 92
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 89
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 94
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 99
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 96
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 98
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 102
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 103
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 108
Π°ΠΏΡ€. 20, 2024 8:42:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 105
Π°ΠΏΡ€. 20, 2024 8:42:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 119
2024.04.20 20:42:46 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:42:46 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:42:47 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:42:48 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:42:49 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:42:49 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:42:50 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:42:50 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:42:50 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:42:52 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:42:52 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:42:53 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:42:53 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:42:55 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:42:55 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:42:55 INFO  time: indexed workspace in 18s
2024.04.20 20:42:56 INFO  compiling bestgame (1 scala source)
2024.04.20 20:42:56 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:42:59 INFO  time: compiled bestgame in 2.77s
2024.04.20 20:42:59 INFO  compiling bestgame (1 scala source)
2024.04.20 20:42:59 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:43:00 INFO  time: compiled bestgame in 0.96s
2024.04.20 20:43:01 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:43:15 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:43:23 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:43:24 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:43:25 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:43:25 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:43:26 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:43:27 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:43:28 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:43:35 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:44:24 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:44:25 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:44:43 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:44:43 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
    const tableBody = document.getElementById('tableBody');
                                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:54:59 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:55:11 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:55:13 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:55:19 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:55:22 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:55:23 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:55:23 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:55:26 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:55:29 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:55:42 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:55:45 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:55:48 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:55:49 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:55:52 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:55:53 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:55:54 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

Π°ΠΏΡ€. 20, 2024 8:55:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 594
2024.04.20 20:55:56 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:55:59 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:56:00 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:56:21 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:56:22 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:56:23 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:56:25 INFO  compiling bestgame (1 scala source)
2024.04.20 20:56:25 INFO  time: compiled bestgame in 0.16s
2024.04.20 20:56:26 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:56:42 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:56:44 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:56:45 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:57:48 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:57:49 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:57:50 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:57:56 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:57:58 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

Π°ΠΏΡ€. 20, 2024 8:57:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 732
2024.04.20 20:57:58 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:57:58 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:00 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:00 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:01 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:01 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:02 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:03 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:04 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:05 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:07 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:10 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:10 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:10 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:11 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:12 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:13 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:14 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:14 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:15 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:15 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:20 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:21 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:21 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:24 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:24 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:25 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:26 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:26 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:27 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:27 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:28 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:30 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.20 20:58:31 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Tile.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed character literal
  const tableBody = document.getElementById('tableBody');
                                                      ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.21 00:38:53 INFO  Shutting down server
2024.04.21 00:38:53 INFO  shutting down Metals
2024.04.21 00:38:53 INFO  Shut down connection with build server.
2024.04.21 00:38:53 INFO  Shut down connection with build server.
2024.04.21 00:38:53 INFO  Exiting server
2024.04.24 20:15:14 INFO  Started: Metals version 1.3.0 in folders 'D:\bestgame' for client Visual Studio Code 1.88.1.
SLF4J: Class path contains multiple SLF4J providers.
SLF4J: Found provider [scribe.slf4j.ScribeServiceProvider@4cc2b682]
SLF4J: Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@7db17cd2]
SLF4J: See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J: Actual provider is of type [scribe.slf4j.ScribeServiceProvider@4cc2b682]
2024.04.24 20:15:14 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.04.24 20:15:15 INFO  Attempting to connect to the build server...
2024.04.24 20:15:18 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.24 20:15:18 INFO  Attempting to connect to the build server...
2024.04.24 20:15:18 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.24 20:15:18 INFO  time: Connected to build server in 3.92s
2024.04.24 20:15:18 INFO  Connected to Build server: Bloop v1.5.17
2024.04.24 20:15:19 INFO  time: Imported build in 0.44s
2024.04.24 20:15:26 INFO  no build target found for D:\bestgame\src\main\scala\gameClasses\Tile.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.04.24 20:15:41 INFO  time: indexed workspace in 14s
2024.04.24 20:15:45 INFO  compiling bestgame (1 scala source)
2024.04.24 20:15:47 INFO  time: compiled bestgame in 1.53s
2024.04.24 20:17:51 INFO  compiling bestgame (1 scala source)
2024.04.24 20:17:51 INFO  time: compiled bestgame in 0.12s
Π°ΠΏΡ€. 24, 2024 8:20:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 138
Π°ΠΏΡ€. 24, 2024 8:20:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 166
2024.04.24 20:20:34 INFO  compiling bestgame (2 scala sources)
2024.04.24 20:20:34 INFO  time: compiled bestgame in 0.56s
Π°ΠΏΡ€. 24, 2024 8:22:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 367
2024.04.24 20:22:45 INFO  compiling bestgame (2 scala sources)
2024.04.24 20:22:45 INFO  time: compiled bestgame in 0.3s
Π°ΠΏΡ€. 24, 2024 8:22:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 452
2024.04.24 20:22:54 INFO  compiling bestgame (2 scala sources)
2024.04.24 20:22:54 INFO  time: compiled bestgame in 0.43s
2024.04.24 20:22:59 INFO  compiling bestgame (2 scala sources)
2024.04.24 20:22:59 INFO  time: compiled bestgame in 0.12s
2024.04.24 20:23:00 INFO  compiling bestgame (2 scala sources)
2024.04.24 20:23:00 INFO  time: compiled bestgame in 0.21s
Π°ΠΏΡ€. 24, 2024 8:23:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 505
2024.04.24 20:23:15 INFO  compiling bestgame (2 scala sources)
2024.04.24 20:23:15 INFO  time: compiled bestgame in 0.12s
2024.04.24 20:23:19 INFO  compiling bestgame (2 scala sources)
2024.04.24 20:23:19 INFO  time: compiled bestgame in 0.11s
2024.04.24 20:24:11 INFO  compiling bestgame (2 scala sources)
2024.04.24 20:24:11 INFO  time: compiled bestgame in 0.12s
2024.04.24 20:24:12 INFO  compiling bestgame (2 scala sources)
2024.04.24 20:24:12 INFO  time: compiled bestgame in 0.16s
2024.04.24 20:24:12 INFO  compiling bestgame (2 scala sources)
2024.04.24 20:24:12 INFO  time: compiled bestgame in 0.12s
2024.04.24 20:24:14 INFO  compiling bestgame (2 scala sources)
2024.04.24 20:24:14 INFO  time: compiled bestgame in 85ms
2024.04.24 20:24:18 INFO  compiling bestgame (1 scala source)
2024.04.24 20:24:18 INFO  time: compiled bestgame in 0.52s
2024.04.24 20:24:19 INFO  compiling bestgame (1 scala source)
2024.04.24 20:24:19 INFO  time: compiled bestgame in 0.34s
2024.04.24 20:24:22 INFO  compiling bestgame (1 scala source)
2024.04.24 20:24:22 INFO  time: compiled bestgame in 0.14s
Π°ΠΏΡ€. 24, 2024 8:25:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 719
2024.04.24 20:25:05 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Tile.scala
2024.04.24 20:25:05 INFO  compiling bestgame (1 scala source)
2024.04.24 20:25:05 INFO  time: compiled bestgame in 94ms
Π°ΠΏΡ€. 24, 2024 8:56:30 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: A severe compiler error occurred, full details of the error can be found in the error report D:\bestgame\.metals\.reports\metals-full\2024-04-24\r_compiler-error_(bestgame)_20-56-30-343.md
Π°ΠΏΡ€. 24, 2024 8:57:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1183
2024.04.24 20:57:14 INFO  compiling bestgame (1 scala source)
2024.04.24 20:57:14 INFO  time: compiled bestgame in 0.15s
2024.04.24 20:57:23 INFO  compiling bestgame (1 scala source)
2024.04.24 20:57:23 INFO  time: compiled bestgame in 81ms
2024.04.24 20:57:26 INFO  compiling bestgame (1 scala source)
2024.04.24 20:57:26 INFO  time: compiled bestgame in 74ms
2024.04.24 20:57:33 INFO  compiling bestgame (1 scala source)
2024.04.24 20:57:33 INFO  time: compiled bestgame in 68ms
2024.04.24 20:57:43 INFO  compiling bestgame (1 scala source)
2024.04.24 20:57:43 INFO  time: compiled bestgame in 76ms
2024.04.24 20:57:47 INFO  compiling bestgame (1 scala source)
2024.04.24 20:57:47 INFO  time: compiled bestgame in 0.27s
2024.04.24 20:58:51 INFO  compiling bestgame (1 scala source)
2024.04.24 20:58:51 INFO  time: compiled bestgame in 0.56s
2024.04.24 20:59:14 INFO  compiling bestgame (2 scala sources)
2024.04.24 20:59:14 INFO  time: compiled bestgame in 0.37s
2024.04.24 21:00:11 INFO  compiling bestgame (1 scala source)
2024.04.24 21:00:11 INFO  time: compiled bestgame in 0.25s
Π°ΠΏΡ€. 24, 2024 9:00:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1767
2024.04.24 21:00:22 INFO  compiling bestgame (1 scala source)
2024.04.24 21:00:22 INFO  time: compiled bestgame in 0.18s
2024.04.24 21:00:57 INFO  compiling bestgame (1 scala source)
2024.04.24 21:00:57 INFO  time: compiled bestgame in 98ms
2024.04.24 21:00:57 INFO  compiling bestgame (1 scala source)
2024.04.24 21:00:57 INFO  time: compiled bestgame in 0.12s
2024.04.24 21:03:25 INFO  compiling bestgame (1 scala source)
2024.04.24 21:03:25 INFO  time: compiled bestgame in 0.26s
2024.04.24 21:03:43 INFO  compiling bestgame (1 scala source)
2024.04.24 21:03:43 INFO  time: compiled bestgame in 0.17s
2024.04.24 21:05:16 INFO  compiling bestgame (1 scala source)
2024.04.24 21:05:16 INFO  time: compiled bestgame in 0.31s
2024.04.24 21:05:17 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\World.scala
2024.04.24 21:05:25 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\World.scala
2024.04.24 21:05:26 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\World.scala
2024.04.24 21:05:26 INFO  compiling bestgame (1 scala source)
2024.04.24 21:05:26 INFO  time: compiled bestgame in 0.2s
Π°ΠΏΡ€. 24, 2024 9:06:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2465
2024.04.24 21:06:24 INFO  compiling bestgame (1 scala source)
2024.04.24 21:06:24 INFO  time: compiled bestgame in 0.23s
2024.04.24 21:06:44 INFO  compiling bestgame (1 scala source)
2024.04.24 21:06:44 INFO  time: compiled bestgame in 0.15s
2024.04.24 21:06:52 INFO  compiling bestgame (1 scala source)
2024.04.24 21:06:52 INFO  time: compiled bestgame in 0.17s
Π°ΠΏΡ€. 24, 2024 9:07:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2614
2024.04.24 21:07:35 INFO  compiling bestgame (1 scala source)
2024.04.24 21:07:35 WARN  Using indexes to guess the definition of collect
2024.04.24 21:07:35 INFO  time: compiled bestgame in 0.39s
Π°ΠΏΡ€. 24, 2024 9:07:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2665
2024.04.24 21:07:51 INFO  compiling bestgame (2 scala sources)
2024.04.24 21:07:51 INFO  time: compiled bestgame in 0.22s
Π°ΠΏΡ€. 24, 2024 9:07:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2727
Π°ΠΏΡ€. 24, 2024 9:07:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2736
2024.04.24 21:08:14 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\Game.scala
2024.04.24 21:08:14 INFO  compiling bestgame (1 scala source)
2024.04.24 21:08:14 INFO  time: compiled bestgame in 0.15s
2024.04.24 21:09:02 INFO  compiling bestgame (1 scala source)
2024.04.24 21:09:02 INFO  time: compiled bestgame in 0.17s
2024.04.24 21:10:48 INFO  compiling bestgame (1 scala source)
2024.04.24 21:10:49 INFO  time: compiled bestgame in 1.15s
Π°ΠΏΡ€. 24, 2024 9:11:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3168
2024.04.24 21:14:38 INFO  compiling bestgame (1 scala source)
2024.04.24 21:14:39 INFO  time: compiled bestgame in 1.07s
Π°ΠΏΡ€. 24, 2024 9:15:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3326
2024.04.24 21:17:05 INFO  compiling bestgame (1 scala source)
2024.04.24 21:17:05 INFO  time: compiled bestgame in 0.67s
Π°ΠΏΡ€. 24, 2024 9:18:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3482
2024.04.24 21:18:38 INFO  compiling bestgame (1 scala source)
2024.04.24 21:18:38 INFO  time: compiled bestgame in 0.94s
Π°ΠΏΡ€. 24, 2024 9:18:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3537
2024.04.24 21:19:04 INFO  compiling bestgame (1 scala source)
2024.04.24 21:19:04 INFO  time: compiled bestgame in 0.19s
2024.04.24 21:19:46 INFO  compiling bestgame (1 scala source)
2024.04.24 21:19:46 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\Game.scala
2024.04.24 21:19:46 INFO  time: compiled bestgame in 0.27s
2024.04.24 21:20:00 INFO  compiling bestgame (1 scala source)
2024.04.24 21:20:00 INFO  time: compiled bestgame in 0.21s
2024.04.24 21:20:45 INFO  compiling bestgame (1 scala source)
2024.04.24 21:20:45 INFO  time: compiled bestgame in 0.56s
Π°ΠΏΡ€. 24, 2024 9:20:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3730
Π°ΠΏΡ€. 24, 2024 9:20:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3739
Π°ΠΏΡ€. 24, 2024 9:20:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3748
2024.04.24 21:20:55 INFO  compiling bestgame (2 scala sources)
2024.04.24 21:20:55 INFO  time: compiled bestgame in 0.17s
2024.04.24 21:20:55 INFO  compiling bestgame (1 scala source)
2024.04.24 21:20:55 INFO  time: compiled bestgame in 0.15s
Π°ΠΏΡ€. 24, 2024 9:20:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3795
Π°ΠΏΡ€. 24, 2024 9:20:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3804
Π°ΠΏΡ€. 24, 2024 9:20:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3813
2024.04.24 21:21:12 INFO  compiling bestgame (1 scala source)
2024.04.24 21:21:12 INFO  time: compiled bestgame in 0.14s
Π°ΠΏΡ€. 24, 2024 9:21:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3854
Π°ΠΏΡ€. 24, 2024 9:21:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3869
Π°ΠΏΡ€. 24, 2024 9:21:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3878
Π°ΠΏΡ€. 24, 2024 9:22:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3901
Π°ΠΏΡ€. 24, 2024 9:22:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3920
2024.04.24 21:23:03 INFO  compiling bestgame (1 scala source)
2024.04.24 21:23:03 INFO  time: compiled bestgame in 0.12s
2024.04.24 21:23:08 INFO  compiling bestgame (1 scala source)
2024.04.24 21:23:08 INFO  time: compiled bestgame in 85ms
Π°ΠΏΡ€. 24, 2024 9:23:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3965
Π°ΠΏΡ€. 24, 2024 9:23:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3975
2024.04.24 21:24:00 INFO  compiling bestgame (1 scala source)
2024.04.24 21:24:00 INFO  time: compiled bestgame in 0.12s
Π°ΠΏΡ€. 24, 2024 9:24:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4122
Π°ΠΏΡ€. 24, 2024 9:24:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4125
2024.04.24 21:24:53 INFO  compiling bestgame (1 scala source)
2024.04.24 21:24:53 INFO  time: compiled bestgame in 0.13s
Π°ΠΏΡ€. 24, 2024 9:25:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4205
2024.04.24 21:25:56 INFO  compiling bestgame (1 scala source)
2024.04.24 21:25:56 INFO  time: compiled bestgame in 83ms
2024.04.24 21:26:02 INFO  compiling bestgame (1 scala source)
2024.04.24 21:26:02 INFO  time: compiled bestgame in 0.12s
Π°ΠΏΡ€. 24, 2024 9:26:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4298
2024.04.24 21:26:37 INFO  compiling bestgame (1 scala source)
2024.04.24 21:26:37 INFO  time: compiled bestgame in 0.2s
Π°ΠΏΡ€. 24, 2024 9:26:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4394
2024.04.24 21:32:48 INFO  compiling bestgame (1 scala source)
2024.04.24 21:32:48 INFO  time: compiled bestgame in 0.24s
Π°ΠΏΡ€. 24, 2024 9:34:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4592
2024.04.24 21:34:38 INFO  compiling bestgame (1 scala source)
2024.04.24 21:34:38 INFO  time: compiled bestgame in 0.24s
2024.04.24 21:34:41 INFO  compiling bestgame (1 scala source)
2024.04.24 21:34:41 INFO  time: compiled bestgame in 0.18s
2024.04.24 21:34:48 INFO  compiling bestgame (1 scala source)
2024.04.24 21:34:48 INFO  time: compiled bestgame in 0.1s
Π°ΠΏΡ€. 24, 2024 9:34:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4690
2024.04.24 21:34:59 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\World.scala
scala.meta.tokenizers.TokenizeException: <input>:28: error: unclosed character literal
      output += ''
                ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.24 21:35:01 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\World.scala
scala.meta.tokenizers.TokenizeException: <input>:28: error: unclosed character literal
      output += ''
                ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.24 21:35:03 INFO  compiling bestgame (1 scala source)
2024.04.24 21:35:03 INFO  time: compiled bestgame in 0.14s
2024.04.24 21:36:15 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\World.scala
scala.meta.tokenizers.TokenizeException: <input>:28: error: unclosed character literal
      output += '\';
                ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.24 21:36:15 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\World.scala
scala.meta.tokenizers.TokenizeException: <input>:28: error: unclosed character literal
      output += '\';
                ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.24 21:36:16 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\World.scala
scala.meta.tokenizers.TokenizeException: <input>:28: error: unclosed character literal
      output += '';
                ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.24 21:36:17 INFO  compiling bestgame (1 scala source)
2024.04.24 21:36:17 INFO  time: compiled bestgame in 0.24s
2024.04.24 21:38:07 INFO  compiling bestgame (1 scala source)
2024.04.24 21:38:07 INFO  time: compiled bestgame in 0.16s
Π°ΠΏΡ€. 24, 2024 9:41:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4858
2024.04.24 21:41:24 INFO  compiling bestgame (1 scala source)
2024.04.24 21:41:24 INFO  time: compiled bestgame in 86ms
2024.04.24 21:41:24 INFO  compiling bestgame (1 scala source)
2024.04.24 21:41:24 INFO  time: compiled bestgame in 0.12s
Π°ΠΏΡ€. 24, 2024 9:47:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4895
2024.04.24 21:47:19 INFO  compiling bestgame (1 scala source)
2024.04.24 21:47:19 INFO  time: compiled bestgame in 0.1s
2024.04.24 21:47:19 INFO  compiling bestgame (1 scala source)
2024.04.24 21:47:19 INFO  time: compiled bestgame in 0.12s
Π°ΠΏΡ€. 24, 2024 10:00:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4957
2024.04.24 22:54:53 WARN  Using indexes to guess the definition of planted
2024.04.24 22:54:53 WARN  Using indexes to guess the definition of planted
2024.04.24 22:54:54 INFO  compiling bestgame (1 scala source)
2024.04.24 22:54:56 INFO  time: compiled bestgame in 1.82s
2024.04.24 22:55:17 INFO  compiling bestgame (1 scala source)
2024.04.24 22:55:17 INFO  time: compiled bestgame in 0.31s
Π°ΠΏΡ€. 24, 2024 10:55:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5075
2024.04.24 23:03:51 INFO  compiling bestgame (1 scala source)
2024.04.24 23:03:51 INFO  time: compiled bestgame in 0.1s
2024.04.24 23:04:30 INFO  compiling bestgame (1 scala source)
2024.04.24 23:04:31 INFO  time: compiled bestgame in 1.13s
Π°ΠΏΡ€. 24, 2024 11:06:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5397
2024.04.24 23:06:18 INFO  compiling bestgame (1 scala source)
2024.04.24 23:06:18 INFO  time: compiled bestgame in 0.28s
2024.04.24 23:06:34 INFO  compiling bestgame (1 scala source)
2024.04.24 23:06:34 INFO  time: compiled bestgame in 0.21s
2024.04.24 23:06:57 INFO  compiling bestgame (1 scala source)
2024.04.24 23:06:57 INFO  time: compiled bestgame in 67ms
2024.04.24 23:07:00 INFO  compiling bestgame (1 scala source)
2024.04.24 23:07:00 INFO  time: compiled bestgame in 0.13s
2024.04.24 23:07:22 INFO  compiling bestgame (1 scala source)
2024.04.24 23:07:22 INFO  time: compiled bestgame in 0.17s
2024.04.24 23:09:09 INFO  compiling bestgame (5 scala sources)
2024.04.24 23:09:09 INFO  time: compiled bestgame in 0.52s
2024.04.24 23:09:17 INFO  compiling bestgame (1 scala source)
2024.04.24 23:09:17 INFO  time: compiled bestgame in 51ms
2024.04.24 23:09:24 INFO  compiling bestgame (1 scala source)
2024.04.24 23:09:24 INFO  time: compiled bestgame in 45ms
2024.04.24 23:09:27 INFO  compiling bestgame (1 scala source)
2024.04.24 23:09:27 INFO  time: compiled bestgame in 0.12s
2024.04.24 23:09:27 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:09:27 INFO  time: compiled bestgame in 0.21s
2024.04.24 23:10:47 INFO  compiling bestgame (2 scala sources)
2024.04.24 23:10:47 INFO  time: compiled bestgame in 0.27s
2024.04.24 23:10:47 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:10:47 INFO  time: compiled bestgame in 0.13s
2024.04.24 23:10:47 INFO  compiling bestgame (2 scala sources)
2024.04.24 23:10:47 INFO  time: compiled bestgame in 0.19s
2024.04.24 23:10:47 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:10:47 INFO  time: compiled bestgame in 0.25s
2024.04.24 23:11:08 INFO  compiling bestgame (3 scala sources)
2024.04.24 23:11:08 INFO  time: compiled bestgame in 0.31s
Π°ΠΏΡ€. 24, 2024 11:11:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5785
2024.04.24 23:11:32 INFO  compiling bestgame (3 scala sources)
2024.04.24 23:11:32 INFO  time: compiled bestgame in 0.95s
Π°ΠΏΡ€. 24, 2024 11:11:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5940
2024.04.24 23:11:41 INFO  compiling bestgame (3 scala sources)
2024.04.24 23:11:41 INFO  time: compiled bestgame in 0.35s
2024.04.24 23:11:44 INFO  compiling bestgame (3 scala sources)
2024.04.24 23:11:44 INFO  time: compiled bestgame in 0.45s
Π°ΠΏΡ€. 24, 2024 11:12:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6011
Π°ΠΏΡ€. 24, 2024 11:12:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6020
Π°ΠΏΡ€. 24, 2024 11:12:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6036
2024.04.24 23:12:12 INFO  compiling bestgame (3 scala sources)
2024.04.24 23:12:12 INFO  time: compiled bestgame in 0.16s
2024.04.24 23:13:01 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:13:01 INFO  time: compiled bestgame in 0.18s
2024.04.24 23:13:01 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:13:01 INFO  time: compiled bestgame in 0.53s
Π°ΠΏΡ€. 24, 2024 11:13:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6124
Π°ΠΏΡ€. 24, 2024 11:13:12 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\bestgame\src\main\scala\gameClasses\Items.scala
java.nio.file.NoSuchFileException: D:\bestgame\src\main\scala\gameClasses\Items.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3273)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:410)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:279)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:290)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$7(SymbolIndexBucket.scala:221)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$7$adapted(SymbolIndexBucket.scala:216)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:619)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:617)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:935)
	at scala.collection.IterableOps$WithFilter.foreach(Iterable.scala:905)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:216)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:178)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:159)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:159)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.mtags.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:255)
	at scala.meta.internal.pc.HoverProvider$.$anonfun$7(HoverProvider.scala:135)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.pc.HoverProvider$.hover(HoverProvider.scala:135)
	at scala.meta.internal.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:368)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:156)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:142)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:245)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)

Π°ΠΏΡ€. 24, 2024 11:13:12 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\bestgame\src\main\scala\gameClasses\Items.scala
java.nio.file.NoSuchFileException: D:\bestgame\src\main\scala\gameClasses\Items.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3273)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:410)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:279)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:290)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:301)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$7(SymbolIndexBucket.scala:221)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$7$adapted(SymbolIndexBucket.scala:216)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:619)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:617)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:935)
	at scala.collection.IterableOps$WithFilter.foreach(Iterable.scala:905)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:216)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:178)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:159)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:159)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.mtags.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:255)
	at scala.meta.internal.pc.HoverProvider$.$anonfun$7(HoverProvider.scala:135)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.pc.HoverProvider$.hover(HoverProvider.scala:135)
	at scala.meta.internal.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:368)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:156)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:142)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:245)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)

Π°ΠΏΡ€. 24, 2024 11:13:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6142
Π°ΠΏΡ€. 24, 2024 11:13:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6163
Π°ΠΏΡ€. 24, 2024 11:13:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6194
2024.04.24 23:13:36 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:13:36 INFO  time: compiled bestgame in 0.11s
2024.04.24 23:13:46 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:13:46 INFO  time: compiled bestgame in 94ms
2024.04.24 23:13:53 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:13:53 INFO  time: compiled bestgame in 74ms
Π°ΠΏΡ€. 24, 2024 11:14:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6297
2024.04.24 23:14:25 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.3.0' (since 2h 59m 6.333s)
2024.04.24 23:14:25 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:14:25 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:14:25 INFO  time: compiled bestgame in 0.14s
Π°ΠΏΡ€. 24, 2024 11:14:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6339
2024.04.24 23:14:30 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:14:30 INFO  time: compiled bestgame in 88ms
2024.04.24 23:14:41 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:14:41 INFO  time: compiled bestgame in 0.11s
Π°ΠΏΡ€. 24, 2024 11:14:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6420
2024.04.24 23:14:49 WARN  Using indexes to guess the definition of Item
2024.04.24 23:14:55 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:14:55 INFO  time: compiled bestgame in 84ms
2024.04.24 23:25:03 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:25:03 INFO  time: compiled bestgame in 0.83s
2024.04.24 23:25:20 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:25:20 INFO  time: compiled bestgame in 0.11s
2024.04.24 23:25:25 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:25:25 INFO  time: compiled bestgame in 0.13s
2024.04.24 23:25:27 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:25:27 INFO  time: compiled bestgame in 0.16s
2024.04.24 23:25:29 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:25:29 INFO  time: compiled bestgame in 82ms
2024.04.24 23:25:35 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:25:35 INFO  time: compiled bestgame in 5ms
2024.04.24 23:25:39 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:25:39 INFO  time: compiled bestgame in 82ms
2024.04.24 23:25:40 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:25:40 INFO  time: compiled bestgame in 91ms
2024.04.24 23:25:54 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:25:54 INFO  time: compiled bestgame in 94ms
2024.04.24 23:25:56 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:25:56 INFO  time: compiled bestgame in 81ms
2024.04.24 23:32:15 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:32:15 INFO  time: compiled bestgame in 98ms
2024.04.24 23:32:23 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:32:23 INFO  time: compiled bestgame in 0.12s
2024.04.24 23:32:24 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:32:24 INFO  time: compiled bestgame in 97ms
2024.04.24 23:33:59 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:33:59 INFO  time: compiled bestgame in 0.14s
2024.04.24 23:34:02 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:34:02 INFO  time: compiled bestgame in 0.14s
2024.04.24 23:34:08 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:34:08 INFO  time: compiled bestgame in 84ms
2024.04.24 23:34:14 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:34:14 INFO  time: compiled bestgame in 79ms
2024.04.24 23:34:19 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:34:19 INFO  time: compiled bestgame in 80ms
2024.04.24 23:34:19 INFO  compiling bestgame (4 scala sources)
2024.04.24 23:34:19 INFO  time: compiled bestgame in 0.1s
2024.04.24 23:40:12 INFO  Shutting down server
2024.04.24 23:40:12 INFO  shutting down Metals
2024.04.24 23:40:12 INFO  Shut down connection with build server.
2024.04.24 23:40:12 INFO  Shut down connection with build server.
2024.04.24 23:40:12 INFO  Exiting server
2024.04.25 12:16:26 INFO  Started: Metals version 1.3.0 in folders 'D:\bestgame' for client Visual Studio Code 1.88.1.
SLF4J: Class path contains multiple SLF4J providers.
SLF4J: Found provider [scribe.slf4j.ScribeServiceProvider@4566386]
SLF4J: Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@6b2a9b0b]
SLF4J: See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.
SLF4J: Actual provider is of type [scribe.slf4j.ScribeServiceProvider@4566386]
2024.04.25 12:16:27 WARN  Flyway upgrade recommended: H2 2.2.224 is newer than this version of Flyway and support has not been tested. The latest supported version of H2 is 2.2.220.
2024.04.25 12:16:27 INFO  Attempting to connect to the build server...
2024.04.25 12:16:32 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.25 12:16:32 INFO  Attempting to connect to the build server...
2024.04.25 12:16:32 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.25 12:16:32 INFO  time: Connected to build server in 4.68s
2024.04.25 12:16:32 INFO  Connected to Build server: Bloop v1.5.17
2024.04.25 12:16:32 INFO  time: Imported build in 0.33s
2024.04.25 12:16:43 INFO  no build target found for D:\bestgame\src\main\scala\gameClasses\Seeds.scala. Using presentation compiler with project's scala-library version: 3.3.3
2024.04.25 12:17:12 INFO  time: indexed workspace in 28s
2024.04.25 12:17:13 INFO  compiling bestgame (4 scala sources)
2024.04.25 12:17:22 INFO  time: compiled bestgame in 9.85s
2024.04.25 12:17:22 INFO  compiling bestgame (4 scala sources)
2024.04.25 12:17:24 INFO  time: compiled bestgame in 1.44s
2024.04.25 12:17:24 INFO  compiling bestgame (4 scala sources)
2024.04.25 12:17:25 INFO  time: compiled bestgame in 0.89s
2024.04.25 12:34:48 INFO  time: code lens generation in 2.33s
2024.04.25 12:34:51 INFO  running 'C:\Program Files\Java\jdk-22\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals10315941037528618365\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.25 12:34:53 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 22)
2024.04.25 12:34:56 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.25 12:34:56 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.25 12:34:59 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.25 12:34:59 INFO  [info] loading project definition from D:\bestgame\project
2024.04.25 12:35:02 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.25 12:35:02 INFO  [success] Total time: 2 s, completed 25 Π°ΠΏΡ€. 2024β€―Π³., 12:35:02
2024.04.25 12:35:04 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.25 12:35:04 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.25 12:35:05 INFO  [success] Generated .bloop\bestgame-test.json
2024.04.25 12:35:05 INFO  [success] Generated .bloop\bestgame.json
2024.04.25 12:35:05 INFO  [success] Total time: 1 s, completed 25 Π°ΠΏΡ€. 2024β€―Π³., 12:35:05
2024.04.25 12:35:05 INFO  time: ran 'sbt bloopInstall' in 13s
2024.04.25 12:35:05 INFO  Disconnecting from Bloop session...
2024.04.25 12:35:05 INFO  Shut down connection with build server.
2024.04.25 12:35:05 INFO  Shut down connection with build server.
2024.04.25 12:35:05 INFO  Attempting to connect to the build server...
2024.04.25 12:35:05 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.25 12:35:05 INFO  Attempting to connect to the build server...
2024.04.25 12:35:05 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.25 12:35:05 INFO  time: Connected to build server in 0.16s
2024.04.25 12:35:05 INFO  Connected to Build server: Bloop v1.5.17
2024.04.25 12:35:13 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:35:14 INFO  time: compiled bestgame in 1.29s
2024.04.25 12:35:19 INFO  time: indexed workspace in 13s
2024.04.25 12:35:19 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:35:24 INFO  time: compiled bestgame in 4.87s
Π°ΠΏΡ€. 25, 2024 12:35:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 101
2024.04.25 12:35:24 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:35:24 INFO  time: compiled bestgame in 0.64s
2024.04.25 12:35:25 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:35:25 INFO  time: compiled bestgame in 0.5s
Π°ΠΏΡ€. 25, 2024 12:36:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 138
2024.04.25 12:36:43 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:36:43 INFO  time: compiled bestgame in 0.38s
Π°ΠΏΡ€. 25, 2024 12:36:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 178
Π°ΠΏΡ€. 25, 2024 12:36:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 195
Π°ΠΏΡ€. 25, 2024 12:37:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 223
Π°ΠΏΡ€. 25, 2024 12:37:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 285
2024.04.25 12:37:39 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:37:39 INFO  time: compiled bestgame in 0.36s
2024.04.25 12:37:54 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:37:54 INFO  time: compiled bestgame in 0.34s
2024.04.25 12:38:14 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:38:14 INFO  time: compiled bestgame in 0.35s
2024.04.25 12:38:18 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:38:18 INFO  time: compiled bestgame in 0.35s
2024.04.25 12:38:22 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:38:22 INFO  time: compiled bestgame in 0.43s
2024.04.25 12:38:24 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:38:24 INFO  time: compiled bestgame in 0.3s
2024.04.25 12:38:26 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:38:26 INFO  time: compiled bestgame in 0.49s
2024.04.25 12:38:33 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:38:33 INFO  time: compiled bestgame in 0.29s
2024.04.25 12:38:34 WARN  Using indexes to guess the definition of price
2024.04.25 12:38:36 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.3.0' (since 3m 30.553s)
2024.04.25 12:38:36 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:38:36 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:38:36 INFO  time: compiled bestgame in 0.38s
2024.04.25 12:38:51 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:38:51 INFO  time: compiled bestgame in 0.3s
2024.04.25 12:38:52 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:38:52 INFO  time: compiled bestgame in 0.45s
2024.04.25 12:38:54 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:38:54 INFO  time: compiled bestgame in 0.42s
2024.04.25 12:38:56 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:38:56 INFO  time: compiled bestgame in 0.31s
2024.04.25 12:38:58 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:38:58 INFO  time: compiled bestgame in 0.27s
2024.04.25 12:40:03 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:40:03 INFO  time: compiled bestgame in 0.31s
2024.04.25 12:40:43 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:40:43 INFO  time: compiled bestgame in 0.24s
2024.04.25 12:40:45 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:40:45 INFO  time: compiled bestgame in 0.26s
2024.04.25 12:40:47 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:40:47 INFO  time: compiled bestgame in 0.22s
2024.04.25 12:40:57 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:40:57 INFO  time: compiled bestgame in 0.25s
2024.04.25 12:41:00 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:41:00 INFO  time: compiled bestgame in 0.25s
2024.04.25 12:41:27 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:41:27 INFO  time: compiled bestgame in 0.35s
2024.04.25 12:41:33 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:41:33 INFO  time: compiled bestgame in 0.25s
2024.04.25 12:41:36 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:41:36 INFO  time: compiled bestgame in 0.23s
2024.04.25 12:41:43 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:41:46 INFO  time: compiled bestgame in 2.94s
Π°ΠΏΡ€. 25, 2024 12:41:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 981
2024.04.25 12:42:10 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:42:10 INFO  time: compiled bestgame in 0.89s
Π°ΠΏΡ€. 25, 2024 12:42:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1116
2024.04.25 12:42:30 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:42:30 INFO  time: compiled bestgame in 0.71s
2024.04.25 12:42:34 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:42:35 INFO  time: compiled bestgame in 1.06s
Π°ΠΏΡ€. 25, 2024 12:42:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1173
Π°ΠΏΡ€. 25, 2024 12:42:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1182
Π°ΠΏΡ€. 25, 2024 12:42:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1195
2024.04.25 12:42:43 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:42:43 INFO  time: compiled bestgame in 0.59s
Π°ΠΏΡ€. 25, 2024 12:43:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1239
2024.04.25 12:43:25 WARN  Using indexes to guess the definition of Seeds
Π°ΠΏΡ€. 25, 2024 12:43:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1259
2024.04.25 12:43:26 WARN  Using indexes to guess the definition of Seeds
Π°ΠΏΡ€. 25, 2024 12:43:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1262
2024.04.25 12:43:32 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:43:32 INFO  time: compiled bestgame in 0.77s
2024.04.25 12:43:39 INFO  compiling bestgame (14 scala sources)
2024.04.25 12:43:41 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 12:43:41 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 12:43:41 INFO  time: compiled bestgame in 2.3s
2024.04.25 12:43:41 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 12:44:16 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 12:44:20 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 12:44:45 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 12:46:36 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 12:52:09 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 12:52:42 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 12:53:17 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 12:53:17 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 12:53:17 INFO  compiling bestgame (1 scala source)
2024.04.25 12:53:17 INFO  time: compiled bestgame in 0.32s
Π°ΠΏΡ€. 25, 2024 12:54:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1407
2024.04.25 12:54:16 INFO  compiling bestgame (1 scala source)
2024.04.25 12:54:16 INFO  time: compiled bestgame in 0.2s
2024.04.25 12:54:53 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
scala.meta.tokenizers.TokenizeException: <input>:3: error: unclosed quoted identifier
sealed trait Seed extends Itemx`
                               ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getBackquotedIdent(LegacyScanner.scala:496)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:344)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 12:55:58 INFO  compiling bestgame (1 scala source)
2024.04.25 12:55:58 INFO  time: compiled bestgame in 0.21s
2024.04.25 12:56:19 INFO  compiling bestgame (1 scala source)
2024.04.25 12:56:19 INFO  time: compiled bestgame in 0.15s
2024.04.25 12:56:41 INFO  compiling bestgame (1 scala source)
2024.04.25 12:56:41 INFO  time: compiled bestgame in 0.11s
2024.04.25 12:56:47 INFO  compiling bestgame (1 scala source)
2024.04.25 12:56:47 INFO  time: compiled bestgame in 77ms
2024.04.25 12:56:52 WARN  Could not find semantic tokens for: file:///D:/bestgame/src/main/scala/Assets.scala
2024.04.25 12:56:53 WARN  Could not find semantic tokens for: file:///D:/bestgame/src/main/scala/Assets.scala
2024.04.25 12:57:00 INFO  compiling bestgame (1 scala source)
2024.04.25 12:57:00 INFO  time: compiled bestgame in 0.11s
2024.04.25 12:57:06 INFO  compiling bestgame (1 scala source)
2024.04.25 12:57:06 INFO  time: compiled bestgame in 94ms
2024.04.25 12:57:17 INFO  compiling bestgame (1 scala source)
2024.04.25 12:57:17 INFO  time: compiled bestgame in 0.12s
2024.04.25 12:57:27 INFO  compiling bestgame (1 scala source)
2024.04.25 12:57:27 INFO  time: compiled bestgame in 81ms
Π°ΠΏΡ€. 25, 2024 12:57:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1773
Π°ΠΏΡ€. 25, 2024 12:57:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1786
2024.04.25 12:57:45 INFO  compiling bestgame (1 scala source)
2024.04.25 12:57:45 INFO  time: compiled bestgame in 0.31s
2024.04.25 12:58:38 INFO  compiling bestgame (1 scala source)
2024.04.25 12:58:38 INFO  time: compiled bestgame in 0.11s
2024.04.25 12:58:41 INFO  compiling bestgame (1 scala source)
2024.04.25 12:58:41 INFO  time: compiled bestgame in 0.25s
2024.04.25 12:58:46 INFO  compiling bestgame (1 scala source)
2024.04.25 12:58:46 INFO  time: compiled bestgame in 91ms
2024.04.25 12:59:00 INFO  compiling bestgame (1 scala source)
2024.04.25 12:59:00 INFO  time: compiled bestgame in 0.38s
2024.04.25 12:59:01 INFO  compiling bestgame (1 scala source)
2024.04.25 12:59:01 INFO  time: compiled bestgame in 0.48s
Π°ΠΏΡ€. 25, 2024 12:59:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1955
Π°ΠΏΡ€. 25, 2024 12:59:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2005
Π°ΠΏΡ€. 25, 2024 12:59:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2032
2024.04.25 12:59:32 INFO  compiling bestgame (1 scala source)
2024.04.25 12:59:32 INFO  time: compiled bestgame in 78ms
Π°ΠΏΡ€. 25, 2024 1:00:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2131
2024.04.25 13:01:49 INFO  compiling bestgame (1 scala source)
2024.04.25 13:01:49 INFO  time: compiled bestgame in 90ms
2024.04.25 13:01:59 INFO  compiling bestgame (1 scala source)
2024.04.25 13:01:59 INFO  time: compiled bestgame in 84ms
Π°ΠΏΡ€. 25, 2024 1:02:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2277
2024.04.25 13:02:22 INFO  compiling bestgame (1 scala source)
2024.04.25 13:02:22 INFO  time: compiled bestgame in 0.16s
2024.04.25 13:06:06 INFO  compiling bestgame (1 scala source)
2024.04.25 13:06:06 INFO  time: compiled bestgame in 0.21s
2024.04.25 13:06:07 INFO  compiling bestgame (1 scala source)
2024.04.25 13:06:07 INFO  time: compiled bestgame in 0.19s
Π°ΠΏΡ€. 25, 2024 1:07:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2497
2024.04.25 13:07:12 INFO  compiling bestgame (1 scala source)
2024.04.25 13:07:12 INFO  time: compiled bestgame in 0.25s
2024.04.25 13:07:31 INFO  compiling bestgame (1 scala source)
2024.04.25 13:07:31 INFO  time: compiled bestgame in 66ms
2024.04.25 13:24:34 INFO  compiling bestgame (1 scala source)
2024.04.25 13:24:34 INFO  time: compiled bestgame in 0.26s
2024.04.25 13:24:36 INFO  compiling bestgame (1 scala source)
2024.04.25 13:24:36 INFO  time: compiled bestgame in 0.34s
2024.04.25 13:24:52 INFO  compiling bestgame (1 scala source)
2024.04.25 13:24:52 INFO  time: compiled bestgame in 0.18s
2024.04.25 13:25:29 INFO  compiling bestgame (1 scala source)
2024.04.25 13:25:29 INFO  time: compiled bestgame in 0.34s
2024.04.25 13:25:42 INFO  compiling bestgame (1 scala source)
2024.04.25 13:25:42 INFO  time: compiled bestgame in 0.15s
2024.04.25 13:25:46 INFO  compiling bestgame (1 scala source)
2024.04.25 13:25:46 INFO  time: compiled bestgame in 0.15s
Π°ΠΏΡ€. 25, 2024 1:30:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2786
2024.04.25 13:30:51 INFO  compiling bestgame (1 scala source)
2024.04.25 13:30:51 INFO  time: compiled bestgame in 0.11s
2024.04.25 13:31:01 INFO  compiling bestgame (1 scala source)
2024.04.25 13:31:01 INFO  time: compiled bestgame in 67ms
2024.04.25 13:31:11 INFO  compiling bestgame (1 scala source)
2024.04.25 13:31:11 INFO  time: compiled bestgame in 74ms
2024.04.25 13:31:21 INFO  compiling bestgame (1 scala source)
2024.04.25 13:31:21 INFO  time: compiled bestgame in 89ms
Π°ΠΏΡ€. 25, 2024 1:31:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2942
Π°ΠΏΡ€. 25, 2024 1:31:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2950
Π°ΠΏΡ€. 25, 2024 1:31:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2960
Π°ΠΏΡ€. 25, 2024 1:32:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2990
Π°ΠΏΡ€. 25, 2024 1:32:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2994
2024.04.25 13:32:07 INFO  compiling bestgame (1 scala source)
2024.04.25 13:32:07 INFO  time: compiled bestgame in 94ms
2024.04.25 13:32:13 INFO  compiling bestgame (1 scala source)
2024.04.25 13:32:13 INFO  time: compiled bestgame in 96ms
2024.04.25 13:32:17 WARN  Using indexes to guess the definition of Wheat
2024.04.25 13:32:20 INFO  compiling bestgame (1 scala source)
2024.04.25 13:32:20 INFO  time: compiled bestgame in 0.25s
2024.04.25 13:32:20 INFO  compiling bestgame (2 scala sources)
2024.04.25 13:32:20 INFO  time: compiled bestgame in 0.36s
Π°ΠΏΡ€. 25, 2024 1:32:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3098
2024.04.25 13:32:47 INFO  compiling bestgame (1 scala source)
2024.04.25 13:32:47 INFO  time: compiled bestgame in 0.18s
2024.04.25 13:32:51 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
scala.meta.tokenizers.TokenizeException: <input>:17: error: unclosed quoted identifier
    `
    ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getBackquotedIdent(LegacyScanner.scala:496)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:344)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 13:32:52 INFO  compiling bestgame (1 scala source)
2024.04.25 13:32:52 INFO  time: compiled bestgame in 0.13s
2024.04.25 13:32:52 INFO  compiling bestgame (2 scala sources)
2024.04.25 13:32:52 INFO  time: compiled bestgame in 0.26s
2024.04.25 13:32:55 INFO  compiling bestgame (1 scala source)
2024.04.25 13:32:55 INFO  time: compiled bestgame in 0.17s
2024.04.25 13:32:55 INFO  compiling bestgame (2 scala sources)
2024.04.25 13:32:55 INFO  time: compiled bestgame in 0.25s
2024.04.25 13:33:06 INFO  compiling bestgame (1 scala source)
2024.04.25 13:33:06 INFO  time: compiled bestgame in 0.2s
2024.04.25 13:33:06 INFO  compiling bestgame (1 scala source)
2024.04.25 13:33:06 INFO  time: compiled bestgame in 0.23s
2024.04.25 13:33:17 INFO  compiling bestgame (2 scala sources)
2024.04.25 13:33:17 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\Game.scala
2024.04.25 13:33:17 INFO  time: compiled bestgame in 0.16s
Π°ΠΏΡ€. 25, 2024 1:33:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3353
2024.04.25 13:40:10 INFO  running 'C:\Program Files\Java\jdk-22\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals16051989024523781002\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.25 13:40:11 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 22)
2024.04.25 13:40:11 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.25 13:40:12 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.25 13:40:12 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.25 13:40:13 INFO  [info] loading project definition from D:\bestgame\project
2024.04.25 13:40:15 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.25 13:40:15 INFO  [success] Total time: 2 s, completed 25 Π°ΠΏΡ€. 2024β€―Π³., 13:40:16
2024.04.25 13:40:19 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.25 13:40:19 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.25 13:40:23 INFO  [success] Generated .bloop\bestgame.json
2024.04.25 13:40:23 INFO  [success] Generated .bloop\bestgame-test.json
2024.04.25 13:40:23 INFO  [success] Total time: 4 s, completed 25 Π°ΠΏΡ€. 2024β€―Π³., 13:40:23
2024.04.25 13:40:23 INFO  time: ran 'sbt bloopInstall' in 13s
2024.04.25 13:40:23 INFO  Disconnecting from Bloop session...
2024.04.25 13:40:23 INFO  Shut down connection with build server.
2024.04.25 13:40:23 INFO  Shut down connection with build server.
2024.04.25 13:40:23 INFO  Attempting to connect to the build server...
2024.04.25 13:40:23 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.25 13:40:23 INFO  Attempting to connect to the build server...
2024.04.25 13:40:23 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.25 13:40:23 INFO  time: Connected to build server in 0.19s
2024.04.25 13:40:23 INFO  Connected to Build server: Bloop v1.5.17
2024.04.25 13:40:44 INFO  time: indexed workspace in 20s
2024.04.25 13:40:55 INFO  time: code lens generation in 10s
2024.04.25 13:41:56 INFO  compiling bestgame (15 scala sources)
2024.04.25 13:41:58 INFO  time: compiled bestgame in 1.87s
Π°ΠΏΡ€. 25, 2024 1:41:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3460
2024.04.25 13:44:45 INFO  compiling bestgame (1 scala source)
2024.04.25 13:44:45 INFO  time: compiled bestgame in 0.21s
Π°ΠΏΡ€. 25, 2024 1:44:50 PM scala.meta.internal.pc.CompilerSearchVisitor visitClassfile
WARNING: cannot resolve reference to type cse.type.Result
the classfile defining the type might be missing from the classpath
dotty.tools.dotc.core.MissingType: cannot resolve reference to type cse.type.Result
the classfile defining the type might be missing from the classpath

Π°ΠΏΡ€. 25, 2024 1:44:50 PM scala.meta.internal.pc.CompilerSearchVisitor visitClassfile
WARNING: cannot resolve reference to type cse.type.Result
the classfile defining the type might be missing from the classpath
dotty.tools.dotc.core.MissingType: cannot resolve reference to type cse.type.Result
the classfile defining the type might be missing from the classpath

2024.04.25 13:44:55 INFO  compiling bestgame (1 scala source)
2024.04.25 13:44:55 INFO  time: compiled bestgame in 0.22s
Π°ΠΏΡ€. 25, 2024 1:46:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3560
2024.04.25 13:46:15 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.3.0' (since 5m 52.031s)
2024.04.25 13:51:26 INFO  compiling bestgame (1 scala source)
2024.04.25 13:51:28 INFO  time: compiled bestgame in 1.52s
2024.04.25 14:01:28 INFO  compiling bestgame (1 scala source)
2024.04.25 14:01:28 INFO  time: compiled bestgame in 0.27s
2024.04.25 14:01:59 INFO  compiling bestgame (1 scala source)
2024.04.25 14:01:59 INFO  time: compiled bestgame in 0.3s
Π°ΠΏΡ€. 25, 2024 2:22:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4421
2024.04.25 14:22:34 INFO  compiling bestgame (1 scala source)
2024.04.25 14:22:34 INFO  time: compiled bestgame in 0.94s
Π°ΠΏΡ€. 25, 2024 2:23:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4507
Π°ΠΏΡ€. 25, 2024 2:23:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4535
2024.04.25 14:23:15 INFO  compiling bestgame (1 scala source)
2024.04.25 14:23:15 INFO  time: compiled bestgame in 0.21s
2024.04.25 14:23:32 INFO  compiling bestgame (1 scala source)
2024.04.25 14:23:32 INFO  time: compiled bestgame in 0.46s
2024.04.25 14:23:34 INFO  compiling bestgame (1 scala source)
2024.04.25 14:23:34 INFO  time: compiled bestgame in 0.93s
2024.04.25 14:24:21 INFO  compiling bestgame (1 scala source)
2024.04.25 14:24:21 INFO  time: compiled bestgame in 0.49s
2024.04.25 14:24:41 INFO  compiling bestgame (1 scala source)
2024.04.25 14:24:41 INFO  time: compiled bestgame in 0.12s
Π°ΠΏΡ€. 25, 2024 2:24:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4832
2024.04.25 14:24:47 INFO  compiling bestgame (1 scala source)
2024.04.25 14:24:47 INFO  time: compiled bestgame in 59ms
Π°ΠΏΡ€. 25, 2024 2:25:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4865
2024.04.25 14:26:13 INFO  compiling bestgame (1 scala source)
2024.04.25 14:26:13 INFO  time: compiled bestgame in 97ms
Π°ΠΏΡ€. 25, 2024 2:26:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4949
2024.04.25 14:26:29 INFO  compiling bestgame (1 scala source)
2024.04.25 14:26:29 INFO  time: compiled bestgame in 97ms
Π°ΠΏΡ€. 25, 2024 2:28:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5023
2024.04.25 14:29:34 INFO  compiling bestgame (1 scala source)
2024.04.25 14:29:34 INFO  time: compiled bestgame in 0.14s
2024.04.25 14:29:39 INFO  compiling bestgame (1 scala source)
2024.04.25 14:29:39 INFO  time: compiled bestgame in 0.41s
2024.04.25 14:29:50 WARN  Using indexes to guess the definition of DBVars
2024.04.25 14:30:58 INFO  compiling bestgame (1 scala source)
2024.04.25 14:30:58 INFO  Deduplicating compilation of bestgame from bsp client 'Metals 1.3.0' (since 50m 35.336s)
2024.04.25 14:30:58 INFO  compiling bestgame (1 scala source)
2024.04.25 14:30:58 INFO  time: compiled bestgame in 0.24s
2024.04.25 14:39:03 INFO  compiling bestgame (1 scala source)
2024.04.25 14:39:03 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 14:39:03 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 14:39:03 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 14:39:03 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 14:39:03 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 14:39:03 INFO  time: compiled bestgame in 0.41s
2024.04.25 14:39:10 INFO  running 'C:\Program Files\Java\jdk-22\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals4854703719057972214\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.25 14:39:13 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 22)
2024.04.25 14:39:13 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.25 14:39:14 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.25 14:39:15 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.25 14:39:15 INFO  [info] loading project definition from D:\bestgame\project
2024.04.25 14:39:18 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.25 14:39:18 INFO  [success] Total time: 3 s, completed 25 Π°ΠΏΡ€. 2024β€―Π³., 14:39:18
2024.04.25 14:39:18 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.25 14:39:18 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.25 14:39:21 INFO  [success] Generated .bloop\bestgame.json
2024.04.25 14:39:21 INFO  [success] Generated .bloop\bestgame-test.json
2024.04.25 14:39:21 INFO  [success] Total time: 2 s, completed 25 Π°ΠΏΡ€. 2024β€―Π³., 14:39:21
2024.04.25 14:39:21 INFO  time: ran 'sbt bloopInstall' in 10s
2024.04.25 14:39:21 INFO  Disconnecting from Bloop session...
2024.04.25 14:39:21 INFO  Shut down connection with build server.
2024.04.25 14:39:21 INFO  Shut down connection with build server.
2024.04.25 14:39:21 INFO  Attempting to connect to the build server...
2024.04.25 14:39:21 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.25 14:39:21 INFO  Attempting to connect to the build server...
2024.04.25 14:39:21 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.25 14:39:21 INFO  time: Connected to build server in 0.32s
2024.04.25 14:39:21 INFO  Connected to Build server: Bloop v1.5.17
2024.04.25 14:39:34 INFO  time: indexed workspace in 12s
2024.04.25 14:39:35 INFO  compiling bestgame (15 scala sources)
2024.04.25 14:39:41 INFO  time: compiled bestgame in 6.47s
Π°ΠΏΡ€. 25, 2024 2:40:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5318
2024.04.25 14:40:20 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\ENVars.scala
scala.meta.tokenizers.TokenizeException: <input>:6: error: unclosed character literal
	readResult.load(new FileInputStream(''))
                                     ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 14:40:21 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\ENVars.scala
scala.meta.tokenizers.TokenizeException: <input>:6: error: unclosed character literal
	readResult.load(new FileInputStream(''))
                                     ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 14:40:24 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\ENVars.scala
scala.meta.tokenizers.TokenizeException: <input>:6: error: unclosed character literal
	readResult.load(new FileInputStream('.com'))
                                     ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 14:40:25 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\ENVars.scala
scala.meta.tokenizers.TokenizeException: <input>:6: error: unclosed character literal
	readResult.load(new FileInputStream(''))
                                     ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 14:40:35 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\ENVars.scala
scala.meta.tokenizers.TokenizeException: <input>:6: error: unclosed character literal
	readResult.load(new FileInputStream('en'))
                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 14:40:35 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\ENVars.scala
scala.meta.tokenizers.TokenizeException: <input>:6: error: unclosed character literal
	readResult.load(new FileInputStream('envi'))
                                          ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 14:40:36 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\ENVars.scala
scala.meta.tokenizers.TokenizeException: <input>:6: error: unclosed character literal
	readResult.load(new FileInputStream('en'))
                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 14:40:37 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\ENVars.scala
scala.meta.tokenizers.TokenizeException: <input>:6: error: unclosed character literal
	readResult.load(new FileInputStream(''))
                                     ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchSingleQuote$1(LegacyScanner.scala:414)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:419)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 14:40:47 INFO  compiling bestgame (1 scala source)
2024.04.25 14:40:47 INFO  time: compiled bestgame in 0.13s
2024.04.25 14:41:34 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\ENVars.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed string literal
			val dbHost = readResult..getProperty("DBVars.dbHost;
                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:560)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:379)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 14:41:34 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\ENVars.scala
scala.meta.tokenizers.TokenizeException: <input>:9: error: unclosed string literal
			val dbHost = readResult..getProperty(";
                                        ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:560)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:379)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 14:41:43 INFO  compiling bestgame (1 scala source)
2024.04.25 14:41:43 INFO  time: compiled bestgame in 0.16s
2024.04.25 14:42:00 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java

Uri: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1570)
```

Π°ΠΏΡ€. 25, 2024 2:42:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/util/Properties.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1995, 2021, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.util;\n\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.StreamCorruptedException;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\nimport jdk.internal.util.StaticProperty;\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.UTF_8;\n\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.ArraysSupport;\nimport jdk.internal.util.xml.PropertiesDefaultHandler;\n\n/**\n * The {@code Properties} class represents a persistent set of\n * properties. The {@code Properties} can be saved to a stream\n * or loaded from a stream. Each key and its corresponding value in\n * the property list is a string.\n * \u003cp\u003e\n * A property list can contain another property list as its\n * \"defaults\"; this second property list is searched if\n * the property key is not found in the original property list.\n * \u003cp\u003e\n * Because {@code Properties} inherits from {@code Hashtable}, the\n * {@code put} and {@code putAll} methods can be applied to a\n * {@code Properties} object.  Their use is strongly discouraged as they\n * allow the caller to insert entries whose keys or values are not\n * {@code Strings}.  The {@code setProperty} method should be used\n * instead.  If the {@code store} or {@code save} method is called\n * on a \"compromised\" {@code Properties} object that contains a\n * non-{@code String} key or value, the call will fail. Similarly,\n * the call to the {@code propertyNames} or {@code list} method\n * will fail if it is called on a \"compromised\" {@code Properties}\n * object that contains a non-{@code String} key.\n *\n * \u003cp\u003e\n * The iterators returned by the {@code iterator} method of this class\u0027s\n * \"collection views\" (that is, {@code entrySet()}, {@code keySet()}, and\n * {@code values()}) may not fail-fast (unlike the Hashtable implementation).\n * These iterators are guaranteed to traverse elements as they existed upon\n * construction exactly once, and may (but are not guaranteed to) reflect any\n * modifications subsequent to construction.\n * \u003cp\u003e\n * The {@link #load(java.io.Reader) load(Reader)} {@code /}\n * {@link #store(java.io.Writer, java.lang.String) store(Writer, String)}\n * methods load and store properties from and to a character based stream\n * in a simple line-oriented format specified below.\n *\n * The {@link #load(java.io.InputStream) load(InputStream)} {@code /}\n * {@link #store(java.io.OutputStream, java.lang.String) store(OutputStream, String)}\n * methods work the same way as the load(Reader)/store(Writer, String) pair, except\n * the input/output stream is encoded in ISO 8859-1 character encoding.\n * Characters that cannot be directly represented in this encoding can be written using\n * Unicode escapes as defined in section {@jls 3.3} of\n * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e;\n * only a single \u0027u\u0027 character is allowed in an escape\n * sequence.\n *\n * \u003cp\u003e The {@link #loadFromXML(InputStream)} and {@link\n * #storeToXML(OutputStream, String, String)} methods load and store properties\n * in a simple XML format.  By default the UTF-8 character encoding is used,\n * however a specific encoding may be specified if required. Implementations\n * are required to support UTF-8 and UTF-16 and may support other encodings.\n * An XML properties document has the following DOCTYPE declaration:\n *\n * \u003cpre\u003e\n * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n * \u003c/pre\u003e\n * Note that the system URI (http://java.sun.com/dtd/properties.dtd) is\n * \u003ci\u003enot\u003c/i\u003e accessed when exporting or importing properties; it merely\n * serves as a string to uniquely identify the DTD, which is:\n * \u003cpre\u003e\n *    \u0026lt;?xml version\u003d\"1.0\" encoding\u003d\"UTF-8\"?\u0026gt;\n *\n *    \u0026lt;!-- DTD for properties --\u0026gt;\n *\n *    \u0026lt;!ELEMENT properties ( comment?, entry* ) \u0026gt;\n *\n *    \u0026lt;!ATTLIST properties version CDATA #FIXED \"1.0\"\u0026gt;\n *\n *    \u0026lt;!ELEMENT comment (#PCDATA) \u0026gt;\n *\n *    \u0026lt;!ELEMENT entry (#PCDATA) \u0026gt;\n *\n *    \u0026lt;!ATTLIST entry key CDATA #REQUIRED\u0026gt;\n * \u003c/pre\u003e\n *\n * \u003cp\u003eThis class is thread-safe: multiple threads can share a single\n * {@code Properties} object without the need for external synchronization.\n *\n * @apiNote\n * The {@code Properties} class does not inherit the concept of a load factor\n * from its superclass, {@code Hashtable}.\n *\n * @author  Arthur van Hoff\n * @author  Michael McCloskey\n * @author  Xueming Shen\n * @since   1.0\n */\npublic class Properties extends Hashtable\u003cObject,Object\u003e {\n    /**\n     * use serialVersionUID from JDK 1.1.X for interoperability\n     */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d 4112578634029874840L;\n\n    private static final Unsafe UNSAFE \u003d Unsafe.getUnsafe();\n\n    /**\n     * A property list that contains default values for any keys not\n     * found in this property list.\n     *\n     * @serial\n     */\n    protected volatile Properties defaults;\n\n    /**\n     * Properties does not store values in its inherited Hashtable, but instead\n     * in an internal ConcurrentHashMap.  Synchronization is omitted from\n     * simple read operations.  Writes and bulk operations remain synchronized,\n     * as in Hashtable.\n     */\n    private transient volatile ConcurrentHashMap\u003cObject, Object\u003e map;\n\n    /**\n     * Creates an empty property list with no default values.\n     *\n     * @implNote The initial capacity of a {@code Properties} object created\n     * with this constructor is unspecified.\n     */\n    public Properties() {\n        this(null, 8);\n    }\n\n    /**\n     * Creates an empty property list with no default values, and with an\n     * initial size accommodating the specified number of elements without the\n     * need to dynamically resize.\n     *\n     * @param  initialCapacity the {@code Properties} will be sized to\n     *         accommodate this many elements\n     * @throws IllegalArgumentException if the initial capacity is less than\n     *         zero.\n     */\n    public Properties(int initialCapacity) {\n        this(null, initialCapacity);\n    }\n\n    /**\n     * Creates an empty property list with the specified defaults.\n     *\n     * @implNote The initial capacity of a {@code Properties} object created\n     * with this constructor is unspecified.\n     *\n     * @param   defaults   the defaults.\n     */\n    public Properties(Properties defaults) {\n        this(defaults, 8);\n    }\n\n    private Properties(Properties defaults, int initialCapacity) {\n        // use package-private constructor to\n        // initialize unused fields with dummy values\n        super((Void) null);\n        map \u003d new ConcurrentHashMap\u003c\u003e(initialCapacity);\n        this.defaults \u003d defaults;\n\n        // Ensure writes can\u0027t be reordered\n        UNSAFE.storeFence();\n    }\n\n    /**\n     * Calls the {@code Hashtable} method {@code put}. Provided for\n     * parallelism with the {@code getProperty} method. Enforces use of\n     * strings for property keys and values. The value returned is the\n     * result of the {@code Hashtable} call to {@code put}.\n     *\n     * @param key the key to be placed into this property list.\n     * @param value the value corresponding to {@code key}.\n     * @return     the previous value of the specified key in this property\n     *             list, or {@code null} if it did not have one.\n     * @see #getProperty\n     * @since    1.2\n     */\n    public synchronized Object setProperty(String key, String value) {\n        return put(key, value);\n    }\n\n\n    /**\n     * Reads a property list (key and element pairs) from the input\n     * character stream in a simple line-oriented format.\n     * \u003cp\u003e\n     * Properties are processed in terms of lines. There are two\n     * kinds of lines, \u003ci\u003enatural lines\u003c/i\u003e and \u003ci\u003elogical lines\u003c/i\u003e.\n     * A natural line is defined as a line of\n     * characters that is terminated either by a set of line terminator\n     * characters ({@code \\n} or {@code \\r} or {@code \\r\\n})\n     * or by the end of the stream. A natural line may be either a blank line,\n     * a comment line, or hold all or some of a key-element pair. A logical\n     * line holds all the data of a key-element pair, which may be spread\n     * out across several adjacent natural lines by escaping\n     * the line terminator sequence with a backslash character\n     * {@code \\}.  Note that a comment line cannot be extended\n     * in this manner; every natural line that is a comment must have\n     * its own comment indicator, as described below. Lines are read from\n     * input until the end of the stream is reached.\n     *\n     * \u003cp\u003e\n     * A natural line that contains only white space characters is\n     * considered blank and is ignored.  A comment line has an ASCII\n     * {@code \u0027#\u0027} or {@code \u0027!\u0027} as its first non-whitespace\n     * character; comment lines are also ignored and do not\n     * encode key-element information.  In addition to line\n     * terminators, this format considers the characters space\n     * ({@code \u0027 \u0027}, {@code \u0027\\u005Cu0020\u0027}), tab\n     * ({@code \u0027\\t\u0027}, {@code \u0027\\u005Cu0009\u0027}), and form feed\n     * ({@code \u0027\\f\u0027}, {@code \u0027\\u005Cu000C\u0027}) to be white\n     * space.\n     *\n     * \u003cp\u003e\n     * If a logical line is spread across several natural lines, the\n     * backslash escaping the line terminator sequence, the line\n     * terminator sequence, and any white space at the start of the\n     * following line have no effect on the key or element values.\n     * The remainder of the discussion of key and element parsing\n     * (when loading) will assume all the characters constituting\n     * the key and element appear on a single natural line after\n     * line continuation characters have been removed.  Note that\n     * it is \u003ci\u003enot\u003c/i\u003e sufficient to only examine the character\n     * preceding a line terminator sequence to decide if the line\n     * terminator is escaped; there must be an odd number of\n     * contiguous backslashes for the line terminator to be escaped.\n     * Since the input is processed from left to right, a\n     * non-zero even number of 2\u003ci\u003en\u003c/i\u003e contiguous backslashes\n     * before a line terminator (or elsewhere) encodes \u003ci\u003en\u003c/i\u003e\n     * backslashes after escape processing.\n     *\n     * \u003cp\u003e\n     * The key contains all of the characters in the line starting\n     * with the first non-whitespace character and up to, but not\n     * including, the first unescaped {@code \u0027\u003d\u0027},\n     * {@code \u0027:\u0027}, or white space character other than a line\n     * terminator. All of these key termination characters may be\n     * included in the key by escaping them with a preceding backslash\n     * character; for example,\u003cp\u003e\n     *\n     * {@code \\:\\\u003d}\u003cp\u003e\n     *\n     * would be the two-character key {@code \":\u003d\"}.  Line\n     * terminator characters can be included using {@code \\r} and\n     * {@code \\n} escape sequences.  Any white space after the\n     * key is skipped; if the first non-whitespace character after\n     * the key is {@code \u0027\u003d\u0027} or {@code \u0027:\u0027}, then it is\n     * ignored and any white space characters after it are also\n     * skipped.  All remaining characters on the line become part of\n     * the associated element string; if there are no remaining\n     * characters, the element is the empty string\n     * {@code \"\"}.  Once the raw character sequences\n     * constituting the key and element are identified, escape\n     * processing is performed as described above.\n     *\n     * \u003cp\u003e\n     * As an example, each of the following three lines specifies the key\n     * {@code \"Truth\"} and the associated element value\n     * {@code \"Beauty\"}:\n     * \u003cpre\u003e\n     * Truth \u003d Beauty\n     *  Truth:Beauty\n     * Truth                    :Beauty\n     * \u003c/pre\u003e\n     * As another example, the following three lines specify a single\n     * property:\n     * \u003cpre\u003e\n     * fruits                           apple, banana, pear, \\\n     *                                  cantaloupe, watermelon, \\\n     *                                  kiwi, mango\n     * \u003c/pre\u003e\n     * The key is {@code \"fruits\"} and the associated element is:\n     * \u003cpre\u003e\"apple, banana, pear, cantaloupe, watermelon, kiwi, mango\"\u003c/pre\u003e\n     * Note that a space appears before each {@code \\} so that a space\n     * will appear after each comma in the final result; the {@code \\},\n     * line terminator, and leading white space on the continuation line are\n     * merely discarded and are \u003ci\u003enot\u003c/i\u003e replaced by one or more other\n     * characters.\n     * \u003cp\u003e\n     * As a third example, the line:\n     * \u003cpre\u003echeeses\n     * \u003c/pre\u003e\n     * specifies that the key is {@code \"cheeses\"} and the associated\n     * element is the empty string {@code \"\"}.\n     * \u003cp\u003e\n     * \u003ca id\u003d\"unicodeescapes\"\u003e\u003c/a\u003e\n     * Characters in keys and elements can be represented in escape\n     * sequences similar to those used for character and string literals\n     * (see sections {@jls 3.3} and {@jls 3.10.6} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e).\n     *\n     * The differences from the character escape sequences and Unicode\n     * escapes used for characters and strings are:\n     *\n     * \u003cul\u003e\n     * \u003cli\u003e Octal escapes are not recognized.\n     *\n     * \u003cli\u003e The character sequence {@code \\b} does \u003ci\u003enot\u003c/i\u003e\n     * represent a backspace character.\n     *\n     * \u003cli\u003e The method does not treat a backslash character,\n     * {@code \\}, before a non-valid escape character as an\n     * error; the backslash is silently dropped.  For example, in a\n     * Java string the sequence {@code \"\\z\"} would cause a\n     * compile time error.  In contrast, this method silently drops\n     * the backslash.  Therefore, this method treats the two character\n     * sequence {@code \"\\b\"} as equivalent to the single\n     * character {@code \u0027b\u0027}.\n     *\n     * \u003cli\u003e Escapes are not necessary for single and double quotes;\n     * however, by the rule above, single and double quote characters\n     * preceded by a backslash still yield single and double quote\n     * characters, respectively.\n     *\n     * \u003cli\u003e Only a single \u0027u\u0027 character is allowed in a Unicode escape\n     * sequence.\n     *\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The specified stream remains open after this method returns.\n     *\n     * @param   reader   the input character stream.\n     * @throws  IOException  if an error occurred when reading from the\n     *          input stream.\n     * @throws  IllegalArgumentException if a malformed Unicode escape\n     *          appears in the input.\n     * @throws  NullPointerException if {@code reader} is null.\n     * @since   1.6\n     */\n    public synchronized void load(Reader reader) throws IOException {\n        Objects.requireNonNull(reader, \"reader parameter is null\");\n        load0(new LineReader(reader));\n    }\n\n    /**\n     * Reads a property list (key and element pairs) from the input\n     * byte stream. The input stream is in a simple line-oriented\n     * format as specified in\n     * {@link #load(java.io.Reader) load(Reader)} and is assumed to use\n     * the ISO 8859-1 character encoding; that is each byte is one Latin1\n     * character. Characters not in Latin1, and certain special characters,\n     * are represented in keys and elements using Unicode escapes as defined in\n     * section {@jls 3.3} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     * \u003cp\u003e\n     * The specified stream remains open after this method returns.\n     *\n     * @param      inStream   the input stream.\n     * @throws     IOException  if an error occurred when reading from the\n     *             input stream.\n     * @throws     IllegalArgumentException if the input stream contains a\n     *             malformed Unicode escape sequence.\n     * @throws     NullPointerException if {@code inStream} is null.\n     * @since 1.2\n     */\n    public synchronized void load(InputStream inStream) throws IOException {\n        Objects.requireNonNull(inStream, \"inStream parameter is null\");\n        load0(new LineReader(inStream));\n    }\n\n    private void load0(LineReader lr) throws IOException {\n        StringBuilder outBuffer \u003d new StringBuilder();\n        int limit;\n        int keyLen;\n        int valueStart;\n        boolean hasSep;\n        boolean precedingBackslash;\n\n        while ((limit \u003d lr.readLine()) \u003e\u003d 0) {\n            keyLen \u003d 0;\n            valueStart \u003d limit;\n            hasSep \u003d false;\n\n            //System.out.println(\"line\u003d\u003c\" + new String(lineBuf, 0, limit) + \"\u003e\");\n            precedingBackslash \u003d false;\n            while (keyLen \u003c limit) {\n                char c \u003d lr.lineBuf[keyLen];\n                //need check if escaped.\n                if ((c \u003d\u003d \u0027\u003d\u0027 ||  c \u003d\u003d \u0027:\u0027) \u0026\u0026 !precedingBackslash) {\n                    valueStart \u003d keyLen + 1;\n                    hasSep \u003d true;\n                    break;\n                } else if ((c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\t\u0027 ||  c \u003d\u003d \u0027\\f\u0027) \u0026\u0026 !precedingBackslash) {\n                    valueStart \u003d keyLen + 1;\n                    break;\n                }\n                if (c \u003d\u003d \u0027\\\\\u0027) {\n                    precedingBackslash \u003d !precedingBackslash;\n                } else {\n                    precedingBackslash \u003d false;\n                }\n                keyLen++;\n            }\n            while (valueStart \u003c limit) {\n                char c \u003d lr.lineBuf[valueStart];\n                if (c !\u003d \u0027 \u0027 \u0026\u0026 c !\u003d \u0027\\t\u0027 \u0026\u0026  c !\u003d \u0027\\f\u0027) {\n                    if (!hasSep \u0026\u0026 (c \u003d\u003d \u0027\u003d\u0027 ||  c \u003d\u003d \u0027:\u0027)) {\n                        hasSep \u003d true;\n                    } else {\n                        break;\n                    }\n                }\n                valueStart++;\n            }\n            String key \u003d loadConvert(lr.lineBuf, 0, keyLen, outBuffer);\n            String value \u003d loadConvert(lr.lineBuf, valueStart, limit - valueStart, outBuffer);\n            put(key, value);\n        }\n    }\n\n    /* Read in a \"logical line\" from an InputStream/Reader, skip all comment\n     * and blank lines and filter out those leading whitespace characters\n     * (\\u0020, \\u0009 and \\u000c) from the beginning of a \"natural line\".\n     * Method returns the char length of the \"logical line\" and stores\n     * the line in \"lineBuf\".\n     */\n    private static class LineReader {\n        LineReader(InputStream inStream) {\n            this.inStream \u003d inStream;\n            inByteBuf \u003d new byte[8192];\n        }\n\n        LineReader(Reader reader) {\n            this.reader \u003d reader;\n            inCharBuf \u003d new char[8192];\n        }\n\n        char[] lineBuf \u003d new char[1024];\n        private byte[] inByteBuf;\n        private char[] inCharBuf;\n        private int inLimit \u003d 0;\n        private int inOff \u003d 0;\n        private InputStream inStream;\n        private Reader reader;\n\n        int readLine() throws IOException {\n            // use locals to optimize for interpreted performance\n            int len \u003d 0;\n            int off \u003d inOff;\n            int limit \u003d inLimit;\n\n            boolean skipWhiteSpace \u003d true;\n            boolean appendedLineBegin \u003d false;\n            boolean precedingBackslash \u003d false;\n            boolean fromStream \u003d inStream !\u003d null;\n            byte[] byteBuf \u003d inByteBuf;\n            char[] charBuf \u003d inCharBuf;\n            char[] lineBuf \u003d this.lineBuf;\n            char c;\n\n            while (true) {\n                if (off \u003e\u003d limit) {\n                    inLimit \u003d limit \u003d fromStream ? inStream.read(byteBuf)\n                                                 : reader.read(charBuf);\n                    if (limit \u003c\u003d 0) {\n                        if (len \u003d\u003d 0) {\n                            return -1;\n                        }\n                        return precedingBackslash ? len - 1 : len;\n                    }\n                    off \u003d 0;\n                }\n\n                // (char)(byte \u0026 0xFF) is equivalent to calling a ISO8859-1 decoder.\n                c \u003d (fromStream) ? (char)(byteBuf[off++] \u0026 0xFF) : charBuf[off++];\n\n                if (skipWhiteSpace) {\n                    if (c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\t\u0027 || c \u003d\u003d \u0027\\f\u0027) {\n                        continue;\n                    }\n                    if (!appendedLineBegin \u0026\u0026 (c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\n\u0027)) {\n                        continue;\n                    }\n                    skipWhiteSpace \u003d false;\n                    appendedLineBegin \u003d false;\n\n                }\n                if (len \u003d\u003d 0) { // Still on a new logical line\n                    if (c \u003d\u003d \u0027#\u0027 || c \u003d\u003d \u0027!\u0027) {\n                        // Comment, quickly consume the rest of the line\n\n                        // When checking for new line characters a range check,\n                        // starting with the higher bound (\u0027\\r\u0027) means one less\n                        // branch in the common case.\n                        commentLoop: while (true) {\n                            if (fromStream) {\n                                byte b;\n                                while (off \u003c limit) {\n                                    b \u003d byteBuf[off++];\n                                    if (b \u003c\u003d \u0027\\r\u0027 \u0026\u0026 (b \u003d\u003d \u0027\\r\u0027 || b \u003d\u003d \u0027\\n\u0027))\n                                        break commentLoop;\n                                }\n                                if (off \u003d\u003d limit) {\n                                    inLimit \u003d limit \u003d inStream.read(byteBuf);\n                                    if (limit \u003c\u003d 0) { // EOF\n                                        return -1;\n                                    }\n                                    off \u003d 0;\n                                }\n                            } else {\n                                while (off \u003c limit) {\n                                    c \u003d charBuf[off++];\n                                    if (c \u003c\u003d \u0027\\r\u0027 \u0026\u0026 (c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\n\u0027))\n                                        break commentLoop;\n                                }\n                                if (off \u003d\u003d limit) {\n                                    inLimit \u003d limit \u003d reader.read(charBuf);\n                                    if (limit \u003c\u003d 0) { // EOF\n                                        return -1;\n                                    }\n                                    off \u003d 0;\n                                }\n                            }\n                        }\n                        skipWhiteSpace \u003d true;\n                        continue;\n                    }\n                }\n\n                if (c !\u003d \u0027\\n\u0027 \u0026\u0026 c !\u003d \u0027\\r\u0027) {\n                    lineBuf[len++] \u003d c;\n                    if (len \u003d\u003d lineBuf.length) {\n                        lineBuf \u003d new char[ArraysSupport.newLength(len, 1, len)];\n                        System.arraycopy(this.lineBuf, 0, lineBuf, 0, len);\n                        this.lineBuf \u003d lineBuf;\n                    }\n                    // flip the preceding backslash flag\n                    precedingBackslash \u003d (c \u003d\u003d \u0027\\\\\u0027) ? !precedingBackslash : false;\n                } else {\n                    // reached EOL\n                    if (len \u003d\u003d 0) {\n                        skipWhiteSpace \u003d true;\n                        continue;\n                    }\n                    if (off \u003e\u003d limit) {\n                        inLimit \u003d limit \u003d fromStream ? inStream.read(byteBuf)\n                                                     : reader.read(charBuf);\n                        off \u003d 0;\n                        if (limit \u003c\u003d 0) { // EOF\n                            return precedingBackslash ? len - 1 : len;\n                        }\n                    }\n                    if (precedingBackslash) {\n                        // backslash at EOL is not part of the line\n                        len -\u003d 1;\n                        // skip leading whitespace characters in the following line\n                        skipWhiteSpace \u003d true;\n                        appendedLineBegin \u003d true;\n                        precedingBackslash \u003d false;\n                        // take care not to include any subsequent \\n\n                        if (c \u003d\u003d \u0027\\r\u0027) {\n                            if (fromStream) {\n                                if (byteBuf[off] \u003d\u003d \u0027\\n\u0027) {\n                                    off++;\n                                }\n                            } else {\n                                if (charBuf[off] \u003d\u003d \u0027\\n\u0027) {\n                                    off++;\n                                }\n                            }\n                        }\n                    } else {\n                        inOff \u003d off;\n                        return len;\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n     * Converts encoded \u0026#92;uxxxx to unicode chars\n     * and changes special saved chars to their original forms\n     */\n    private String loadConvert(char[] in, int off, int len, StringBuilder out) {\n        char aChar;\n        int end \u003d off + len;\n        int start \u003d off;\n        while (off \u003c end) {\n            aChar \u003d in[off++];\n            if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                break;\n            }\n        }\n        if (off \u003d\u003d end) { // No backslash\n            return new String(in, start, len);\n        }\n\n        // backslash found at off - 1, reset the shared buffer, rewind offset\n        out.setLength(0);\n        off--;\n        out.append(in, start, off - start);\n\n        while (off \u003c end) {\n            aChar \u003d in[off++];\n            if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                // No need to bounds check since LineReader::readLine excludes\n                // unescaped \\s at the end of the line\n                aChar \u003d in[off++];\n                if(aChar \u003d\u003d \u0027u\u0027) {\n                    // Read the xxxx\n                    if (off \u003e end - 4)\n                        throw new IllegalArgumentException(\n                                     \"Malformed \\\\uxxxx encoding.\");\n                    int value \u003d 0;\n                    for (int i \u003d 0; i \u003c 4; i++) {\n                        aChar \u003d in[off++];\n                        value \u003d switch (aChar) {\n                            case \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027 -\u003e (value \u003c\u003c 4) + aChar - \u00270\u0027;\n                            case \u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027, \u0027f\u0027                     -\u003e (value \u003c\u003c 4) + 10 + aChar - \u0027a\u0027;\n                            case \u0027A\u0027, \u0027B\u0027, \u0027C\u0027, \u0027D\u0027, \u0027E\u0027, \u0027F\u0027                     -\u003e (value \u003c\u003c 4) + 10 + aChar - \u0027A\u0027;\n                            default -\u003e throw new IllegalArgumentException(\"Malformed \\\\uxxxx encoding.\");\n                        };\n                    }\n                    out.append((char)value);\n                } else {\n                    if (aChar \u003d\u003d \u0027t\u0027) aChar \u003d \u0027\\t\u0027;\n                    else if (aChar \u003d\u003d \u0027r\u0027) aChar \u003d \u0027\\r\u0027;\n                    else if (aChar \u003d\u003d \u0027n\u0027) aChar \u003d \u0027\\n\u0027;\n                    else if (aChar \u003d\u003d \u0027f\u0027) aChar \u003d \u0027\\f\u0027;\n                    out.append(aChar);\n                }\n            } else {\n                out.append(aChar);\n            }\n        }\n        return out.toString();\n    }\n\n    /*\n     * Converts unicodes to encoded \u0026#92;uxxxx and escapes\n     * special characters with a preceding slash\n     */\n    private String saveConvert(String theString,\n                               boolean escapeSpace,\n                               boolean escapeUnicode) {\n        int len \u003d theString.length();\n        int bufLen \u003d len * 2;\n        if (bufLen \u003c 0) {\n            bufLen \u003d Integer.MAX_VALUE;\n        }\n        StringBuilder outBuffer \u003d new StringBuilder(bufLen);\n        HexFormat hex \u003d HexFormat.of().withUpperCase();\n        for(int x\u003d0; x\u003clen; x++) {\n            char aChar \u003d theString.charAt(x);\n            // Handle common case first, selecting largest block that\n            // avoids the specials below\n            if ((aChar \u003e 61) \u0026\u0026 (aChar \u003c 127)) {\n                if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                    outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027\\\\\u0027);\n                    continue;\n                }\n                outBuffer.append(aChar);\n                continue;\n            }\n            switch(aChar) {\n                case \u0027 \u0027:\n                    if (x \u003d\u003d 0 || escapeSpace)\n                        outBuffer.append(\u0027\\\\\u0027);\n                    outBuffer.append(\u0027 \u0027);\n                    break;\n                case \u0027\\t\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027t\u0027);\n                          break;\n                case \u0027\\n\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027n\u0027);\n                          break;\n                case \u0027\\r\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027r\u0027);\n                          break;\n                case \u0027\\f\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027f\u0027);\n                          break;\n                case \u0027\u003d\u0027: // Fall through\n                case \u0027:\u0027: // Fall through\n                case \u0027#\u0027: // Fall through\n                case \u0027!\u0027:\n                    outBuffer.append(\u0027\\\\\u0027); outBuffer.append(aChar);\n                    break;\n                default:\n                    if (((aChar \u003c 0x0020) || (aChar \u003e 0x007e)) \u0026 escapeUnicode ) {\n                        outBuffer.append(\"\\\\u\");\n                        outBuffer.append(hex.toHexDigits(aChar));\n                    } else {\n                        outBuffer.append(aChar);\n                    }\n            }\n        }\n        return outBuffer.toString();\n    }\n\n    private static void writeComments(BufferedWriter bw, String comments)\n        throws IOException {\n        HexFormat hex \u003d HexFormat.of().withUpperCase();\n        bw.write(\"#\");\n        int len \u003d comments.length();\n        int current \u003d 0;\n        int last \u003d 0;\n        while (current \u003c len) {\n            char c \u003d comments.charAt(current);\n            if (c \u003e \u0027\\u00ff\u0027 || c \u003d\u003d \u0027\\n\u0027 || c \u003d\u003d \u0027\\r\u0027) {\n                if (last !\u003d current)\n                    bw.write(comments.substring(last, current));\n                if (c \u003e \u0027\\u00ff\u0027) {\n                    bw.write(\"\\\\u\");\n                    bw.write(hex.toHexDigits(c));\n                } else {\n                    bw.newLine();\n                    if (c \u003d\u003d \u0027\\r\u0027 \u0026\u0026\n                        current !\u003d len - 1 \u0026\u0026\n                        comments.charAt(current + 1) \u003d\u003d \u0027\\n\u0027) {\n                        current++;\n                    }\n                    if (current \u003d\u003d len - 1 ||\n                        (comments.charAt(current + 1) !\u003d \u0027#\u0027 \u0026\u0026\n                        comments.charAt(current + 1) !\u003d \u0027!\u0027))\n                        bw.write(\"#\");\n                }\n                last \u003d current + 1;\n            }\n            current++;\n        }\n        if (last !\u003d current)\n            bw.write(comments.substring(last, current));\n        bw.newLine();\n    }\n\n    /**\n     * Calls the {@code store(OutputStream out, String comments)} method\n     * and suppresses IOExceptions that were thrown.\n     *\n     * @deprecated This method does not throw an IOException if an I/O error\n     * occurs while saving the property list.  The preferred way to save a\n     * properties list is via the {@code store(OutputStream out,\n     * String comments)} method or the\n     * {@code storeToXML(OutputStream os, String comment)} method.\n     *\n     * @param   out      an output stream.\n     * @param   comments   a description of the property list.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not\n     *             {@code Strings}.\n     */\n    @Deprecated\n    public void save(OutputStream out, String comments)  {\n        try {\n            store(out, comments);\n        } catch (IOException e) {\n        }\n    }\n\n    /**\n     * Writes this property list (key and element pairs) in this\n     * {@code Properties} table to the output character stream in a\n     * format suitable for using the {@link #load(java.io.Reader) load(Reader)}\n     * method.\n     * \u003cp\u003e\n     * Properties from the defaults table of this {@code Properties}\n     * table (if any) are \u003ci\u003enot\u003c/i\u003e written out by this method.\n     * \u003cp\u003e\n     * If the comments argument is not null, then an ASCII {@code #}\n     * character, the comments string, and a line separator are first written\n     * to the output stream. Thus, the {@code comments} can serve as an\n     * identifying comment. Any one of a line feed ({@code \\n}), a carriage\n     * return ({@code \\r}), or a carriage return followed immediately by a line feed\n     * ({@code \\r\\n}) in comments is replaced by a\n     * {@link System#lineSeparator() line separator} and if the next\n     * character in comments is not character {@code #} or character {@code !} then\n     * an ASCII {@code #} is written out after that line separator.\n     * \u003cp\u003e\n     * If the {@systemProperty java.properties.date} is set on the command line\n     * and is non-empty (as determined by {@link String#isEmpty()  String.isEmpty}),\n     * a comment line is written as follows.\n     * First, a {@code #} character is written, followed by the contents\n     * of the property, followed by a line separator. Any line terminator characters\n     * in the value of the system property are treated the same way as noted above\n     * for the comments argument.\n     * If the system property is not set or is empty, a comment line is written\n     * as follows.\n     * First, a {@code #} character is written, followed by the current date and time\n     * formatted as if by the {@link Date#toString() Date.toString} method,\n     * followed by a line separator.\n     * \u003cp\u003e\n     * Then every entry in this {@code Properties} table is\n     * written out, one per line. For each entry the key string is\n     * written, then an ASCII {@code \u003d}, then the associated\n     * element string. For the key, all space characters are\n     * written with a preceding {@code \\} character.  For the\n     * element, leading space characters, but not embedded or trailing\n     * space characters, are written with a preceding {@code \\}\n     * character. The key and element characters {@code #},\n     * {@code !}, {@code \u003d}, and {@code :} are written\n     * with a preceding backslash to ensure that they are properly loaded.\n     * \u003cp\u003e\n     * After the entries have been written, the output stream is flushed.\n     * The output stream remains open after this method returns.\n     *\n     * @implSpec The keys and elements are written in the natural sort order\n     * of the keys in the {@code entrySet()} unless {@code entrySet()} is\n     * overridden by a subclass to return a different value than {@code super.entrySet()}.\n     *\n     * @param   writer      an output character stream writer.\n     * @param   comments   a description of the property list.\n     * @throws     IOException if writing this property list to the specified\n     *             output stream throws an {@code IOException}.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not {@code Strings}.\n     * @throws     NullPointerException  if {@code writer} is null.\n     * @since 1.6\n     */\n    public void store(Writer writer, String comments)\n        throws IOException\n    {\n        store0((writer instanceof BufferedWriter)?(BufferedWriter)writer\n                                                 : new BufferedWriter(writer),\n               comments,\n               false);\n    }\n\n    /**\n     * Writes this property list (key and element pairs) in this\n     * {@code Properties} table to the output stream in a format suitable\n     * for loading into a {@code Properties} table using the\n     * {@link #load(InputStream) load(InputStream)} method.\n     * \u003cp\u003e\n     * Properties from the defaults table of this {@code Properties}\n     * table (if any) are \u003ci\u003enot\u003c/i\u003e written out by this method.\n     * \u003cp\u003e\n     * This method outputs the comments, properties keys and values in\n     * the same format as specified in\n     * {@link #store(java.io.Writer, java.lang.String) store(Writer)},\n     * with the following differences:\n     * \u003cul\u003e\n     * \u003cli\u003eThe stream is written using the ISO 8859-1 character encoding.\n     *\n     * \u003cli\u003eCharacters not in Latin-1 in the comments are written as\n     * {@code \\u005Cu}\u003ci\u003exxxx\u003c/i\u003e for their appropriate unicode\n     * hexadecimal value \u003ci\u003exxxx\u003c/i\u003e.\n     *\n     * \u003cli\u003eCharacters less than {@code \\u005Cu0020} and characters greater\n     * than {@code \\u005Cu007E} in property keys or values are written\n     * as {@code \\u005Cu}\u003ci\u003exxxx\u003c/i\u003e for the appropriate hexadecimal\n     * value \u003ci\u003exxxx\u003c/i\u003e.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * After the entries have been written, the output stream is flushed.\n     * The output stream remains open after this method returns.\n     *\n     * @param   out      an output stream.\n     * @param   comments   a description of the property list.\n     * @throws     IOException if writing this property list to the specified\n     *             output stream throws an {@code IOException}.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not {@code Strings}.\n     * @throws     NullPointerException  if {@code out} is null.\n     * @since 1.2\n     */\n    public void store(OutputStream out, String comments)\n        throws IOException\n    {\n        store0(new BufferedWriter(new OutputStreamWriter(out, ISO_8859_1.INSTANCE)),\n               comments,\n               true);\n    }\n\n    private void store0(BufferedWriter bw, String comments, boolean escUnicode)\n        throws IOException\n    {\n        if (comments !\u003d null) {\n            writeComments(bw, comments);\n        }\n        writeDateComment(bw);\n\n        synchronized (this) {\n            @SuppressWarnings(\"unchecked\")\n            Collection\u003cMap.Entry\u003cString, String\u003e\u003e entries \u003d (Set\u003cMap.Entry\u003cString, String\u003e\u003e) (Set) entrySet();\n            // entrySet() can be overridden by subclasses. Here we check to see if\n            // the returned instance type is the one returned by the Properties.entrySet()\n            // implementation. If yes, then we sort those entries in the natural order\n            // of their key. Else, we consider that the subclassed implementation may\n            // potentially have returned a differently ordered entries and so we just\n            // use the iteration order of the returned instance.\n            if (entries instanceof Collections.SynchronizedSet\u003c?\u003e ss\n                    \u0026\u0026 ss.c instanceof EntrySet) {\n                entries \u003d new ArrayList\u003c\u003e(entries);\n                ((List\u003cMap.Entry\u003cString, String\u003e\u003e) entries).sort(Map.Entry.comparingByKey());\n            }\n            for (Map.Entry\u003cString, String\u003e e : entries) {\n                String key \u003d e.getKey();\n                String val \u003d e.getValue();\n                key \u003d saveConvert(key, true, escUnicode);\n                /* No need to escape embedded and trailing spaces for value, hence\n                 * pass false to flag.\n                 */\n                val \u003d saveConvert(val, false, escUnicode);\n                bw.write(key + \"\u003d\" + val);\n                bw.newLine();\n            }\n        }\n        bw.flush();\n    }\n\n    private static void writeDateComment(BufferedWriter bw) throws IOException {\n        // value of java.properties.date system property isn\u0027t sensitive\n        // and so doesn\u0027t need any security manager checks to make the value accessible\n        // to the callers\n        String sysPropVal \u003d StaticProperty.javaPropertiesDate();\n        if (sysPropVal !\u003d null \u0026\u0026 !sysPropVal.isEmpty()) {\n            writeComments(bw, sysPropVal);\n        } else {\n            bw.write(\"#\" + new Date());\n            bw.newLine();\n        }\n    }\n\n    /**\n     * Loads all of the properties represented by the XML document on the\n     * specified input stream into this properties table.\n     *\n     * \u003cp\u003eThe XML document must have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     * Furthermore, the document must satisfy the properties DTD described\n     * above.\n     *\n     * \u003cp\u003e An implementation is required to read XML documents that use the\n     * \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An implementation may\n     * support additional encodings.\n     *\n     * \u003cp\u003eThe specified stream is closed after this method returns.\n     *\n     * @param in the input stream from which to read the XML document.\n     * @throws IOException if reading from the specified input stream\n     *         results in an {@code IOException}.\n     * @throws java.io.UnsupportedEncodingException if the document\u0027s encoding\n     *         declaration can be read and it specifies an encoding that is not\n     *         supported\n     * @throws InvalidPropertiesFormatException Data on input stream does not\n     *         constitute a valid XML document with the mandated document type.\n     * @throws NullPointerException if {@code in} is null.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #storeToXML(OutputStream, String, String)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 1.5\n     */\n    public synchronized void loadFromXML(InputStream in)\n        throws IOException, InvalidPropertiesFormatException\n    {\n        Objects.requireNonNull(in);\n        PropertiesDefaultHandler handler \u003d new PropertiesDefaultHandler();\n        handler.load(this, in);\n        in.close();\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table.\n     *\n     * \u003cp\u003e An invocation of this method of the form {@code props.storeToXML(os,\n     * comment)} behaves in exactly the same way as the invocation\n     * {@code props.storeToXML(os, comment, \"UTF-8\");}.\n     *\n     * @param os the output stream on which to emit the XML document.\n     * @param comment a description of the property list, or {@code null}\n     *        if no comment is desired.\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws NullPointerException if {@code os} is null.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not\n     *         {@code Strings}.\n     * @see    #loadFromXML(InputStream)\n     * @since 1.5\n     */\n    public void storeToXML(OutputStream os, String comment)\n        throws IOException\n    {\n        storeToXML(os, comment, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table, using the specified encoding.\n     *\n     * \u003cp\u003eThe XML document will have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003eIf the specified comment is {@code null} then no comment\n     * will be stored in the document.\n     *\n     * \u003cp\u003e An implementation is required to support writing of XML documents\n     * that use the \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An\n     * implementation may support additional encodings.\n     *\n     * \u003cp\u003eThe specified stream remains open after this method returns.\n     *\n     * \u003cp\u003eThis method behaves the same as\n     * {@linkplain #storeToXML(OutputStream os, String comment, Charset charset)}\n     * except that it will {@linkplain java.nio.charset.Charset#forName look up the charset}\n     * using the given encoding name.\n     *\n     * @param os        the output stream on which to emit the XML document.\n     * @param comment   a description of the property list, or {@code null}\n     *                  if no comment is desired.\n     * @param  encoding the name of a supported\n     *                  \u003ca href\u003d\"../lang/package-summary.html#charenc\"\u003e\n     *                  character encoding\u003c/a\u003e\n     *\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws java.io.UnsupportedEncodingException if the encoding is not\n     *         supported by the implementation.\n     * @throws NullPointerException if {@code os} is {@code null},\n     *         or if {@code encoding} is {@code null}.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not {@code Strings}.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #loadFromXML(InputStream)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 1.5\n     */\n    public void storeToXML(OutputStream os, String comment, String encoding)\n        throws IOException {\n        Objects.requireNonNull(os);\n        Objects.requireNonNull(encoding);\n\n        try {\n            Charset charset \u003d Charset.forName(encoding);\n            storeToXML(os, comment, charset);\n        } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {\n            throw new UnsupportedEncodingException(encoding);\n        }\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table, using the specified encoding.\n     *\n     * \u003cp\u003eThe XML document will have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003eIf the specified comment is {@code null} then no comment\n     * will be stored in the document.\n     *\n     * \u003cp\u003e An implementation is required to support writing of XML documents\n     * that use the \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An\n     * implementation may support additional encodings.\n     *\n     * \u003cp\u003e Unmappable characters for the specified charset will be encoded as\n     * numeric character references.\n     *\n     * \u003cp\u003eThe specified stream remains open after this method returns.\n     *\n     * @param os        the output stream on which to emit the XML document.\n     * @param comment   a description of the property list, or {@code null}\n     *                  if no comment is desired.\n     * @param charset   the charset\n     *\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws NullPointerException if {@code os} or {@code charset} is {@code null}.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not {@code Strings}.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #loadFromXML(InputStream)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 10\n     */\n    public void storeToXML(OutputStream os, String comment, Charset charset)\n        throws IOException {\n        Objects.requireNonNull(os, \"OutputStream\");\n        Objects.requireNonNull(charset, \"Charset\");\n        PropertiesDefaultHandler handler \u003d new PropertiesDefaultHandler();\n        handler.store(this, os, comment, charset);\n    }\n\n    /**\n     * Searches for the property with the specified key in this property list.\n     * If the key is not found in this property list, the default property list,\n     * and its defaults, recursively, are then checked. The method returns\n     * {@code null} if the property is not found.\n     *\n     * @param   key   the property key.\n     * @return  the value in this property list with the specified key value.\n     * @see     #setProperty\n     * @see     #defaults\n     */\n    public String getProperty(String key) {\n        Object oval \u003d map.get(key);\n        String sval \u003d (oval instanceof String) ? (String)oval : null;\n        Properties defaults;\n        return ((sval \u003d\u003d null) \u0026\u0026 ((defaults \u003d this.defaults) !\u003d null)) ? defaults.getProperty(key) : sval;\n    }\n\n    /**\n     * Searches for the property with the specified key in this property list.\n     * If the key is not found in this property list, the default property list,\n     * and its defaults, recursively, are then checked. The method returns the\n     * default value argument if the property is not found.\n     *\n     * @param   key            the hashtable key.\n     * @param   defaultValue   a default value.\n     *\n     * @return  the value in this property list with the specified key value.\n     * @see     #setProperty\n     * @see     #defaults\n     */\n    public String getProperty(String key, String defaultValue) {\n        String val \u003d getProperty(key);\n        return (val \u003d\u003d null) ? defaultValue : val;\n    }\n\n    /**\n     * Returns an enumeration of all the keys in this property list,\n     * including distinct keys in the default property list if a key\n     * of the same name has not already been found from the main\n     * properties list.\n     *\n     * @return  an enumeration of all the keys in this property list, including\n     *          the keys in the default property list.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     * @see     java.util.Enumeration\n     * @see     java.util.Properties#defaults\n     * @see     #stringPropertyNames\n     */\n    public Enumeration\u003c?\u003e propertyNames() {\n        Hashtable\u003cString,Object\u003e h \u003d new Hashtable\u003c\u003e();\n        enumerate(h);\n        return h.keys();\n    }\n\n    /**\n     * Returns an unmodifiable set of keys from this property list\n     * where the key and its corresponding value are strings,\n     * including distinct keys in the default property list if a key\n     * of the same name has not already been found from the main\n     * properties list.  Properties whose key or value is not\n     * of type {@code String} are omitted.\n     * \u003cp\u003e\n     * The returned set is not backed by this {@code Properties} object.\n     * Changes to this {@code Properties} object are not reflected in the\n     * returned set.\n     *\n     * @return  an unmodifiable set of keys in this property list where\n     *          the key and its corresponding value are strings,\n     *          including the keys in the default property list.\n     * @see     java.util.Properties#defaults\n     * @since   1.6\n     */\n    public Set\u003cString\u003e stringPropertyNames() {\n        Map\u003cString, String\u003e h \u003d new HashMap\u003c\u003e();\n        enumerateStringProperties(h);\n        return Collections.unmodifiableSet(h.keySet());\n    }\n\n    /**\n     * Prints this property list out to the specified output stream.\n     * This method is useful for debugging.\n     *\n     * @param   out   an output stream.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     */\n    public void list(PrintStream out) {\n        out.println(\"-- listing properties --\");\n        Map\u003cString, Object\u003e h \u003d new HashMap\u003c\u003e();\n        enumerate(h);\n        for (Map.Entry\u003cString, Object\u003e e : h.entrySet()) {\n            String key \u003d e.getKey();\n            String val \u003d (String)e.getValue();\n            if (val.length() \u003e 40) {\n                val \u003d val.substring(0, 37) + \"...\";\n            }\n            out.println(key + \"\u003d\" + val);\n        }\n    }\n\n    /**\n     * Prints this property list out to the specified output stream.\n     * This method is useful for debugging.\n     *\n     * @param   out   an output stream.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     * @since   1.1\n     */\n    /*\n     * Rather than use an anonymous inner class to share common code, this\n     * method is duplicated in order to ensure that a non-1.1 compiler can\n     * compile this file.\n     */\n    public void list(PrintWriter out) {\n        out.println(\"-- listing properties --\");\n        Map\u003cString, Object\u003e h \u003d new HashMap\u003c\u003e();\n        enumerate(h);\n        for (Map.Entry\u003cString, Object\u003e e : h.entrySet()) {\n            String key \u003d e.getKey();\n            String val \u003d (String)e.getValue();\n            if (val.length() \u003e 40) {\n                val \u003d val.substring(0, 37) + \"...\";\n            }\n            out.println(key + \"\u003d\" + val);\n        }\n    }\n\n    /**\n     * Enumerates all key/value pairs into the specified Map.\n     * @param h the Map\n     * @throws ClassCastException if any of the property keys\n     *         is not of String type.\n     */\n    private void enumerate(Map\u003cString, Object\u003e h) {\n        if (defaults !\u003d null) {\n            defaults.enumerate(h);\n        }\n        for (Map.Entry\u003cObject, Object\u003e e : entrySet()) {\n            String key \u003d (String)e.getKey();\n            h.put(key, e.getValue());\n        }\n    }\n\n    /**\n     * Enumerates all key/value pairs into the specified Map\n     * and omits the property if the key or value is not a string.\n     * @param h the Map\n     */\n    private void enumerateStringProperties(Map\u003cString, String\u003e h) {\n        if (defaults !\u003d null) {\n            defaults.enumerateStringProperties(h);\n        }\n        for (Map.Entry\u003cObject, Object\u003e e : entrySet()) {\n            Object k \u003d e.getKey();\n            Object v \u003d e.getValue();\n            if (k instanceof String \u0026\u0026 v instanceof String) {\n                h.put((String) k, (String) v);\n            }\n        }\n    }\n\n    //\n    // Hashtable methods overridden and delegated to a ConcurrentHashMap instance\n\n    @Override\n    public int size() {\n        return map.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    @Override\n    public Enumeration\u003cObject\u003e keys() {\n        // CHM.keys() returns Iterator w/ remove() - instead wrap keySet()\n        return Collections.enumeration(map.keySet());\n    }\n\n    @Override\n    public Enumeration\u003cObject\u003e elements() {\n        // CHM.elements() returns Iterator w/ remove() - instead wrap values()\n        return Collections.enumeration(map.values());\n    }\n\n    @Override\n    public boolean contains(Object value) {\n        return map.contains(value);\n    }\n\n    @Override\n    public boolean containsValue(Object value) {\n        return map.containsValue(value);\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return map.containsKey(key);\n    }\n\n    @Override\n    public Object get(Object key) {\n        return map.get(key);\n    }\n\n    @Override\n    public synchronized Object put(Object key, Object value) {\n        return map.put(key, value);\n    }\n\n    @Override\n    public synchronized Object remove(Object key) {\n        return map.remove(key);\n    }\n\n    @Override\n    public synchronized void putAll(Map\u003c?, ?\u003e t) {\n        map.putAll(t);\n    }\n\n    @Override\n    public synchronized void clear() {\n        map.clear();\n    }\n\n    @Override\n    public synchronized String toString() {\n        return map.toString();\n    }\n\n    @Override\n    public Set\u003cObject\u003e keySet() {\n        return Collections.synchronizedSet(map.keySet(), this);\n    }\n\n    @Override\n    public Collection\u003cObject\u003e values() {\n        return Collections.synchronizedCollection(map.values(), this);\n    }\n\n    @Override\n    public Set\u003cMap.Entry\u003cObject, Object\u003e\u003e entrySet() {\n        return Collections.synchronizedSet(new EntrySet(map.entrySet()), this);\n    }\n\n    /*\n     * Properties.entrySet() should not support add/addAll, however\n     * ConcurrentHashMap.entrySet() provides add/addAll.  This class wraps the\n     * Set returned from CHM, changing add/addAll to throw UOE.\n     */\n    private static class EntrySet implements Set\u003cMap.Entry\u003cObject, Object\u003e\u003e {\n        private Set\u003cMap.Entry\u003cObject,Object\u003e\u003e entrySet;\n\n        private EntrySet(Set\u003cMap.Entry\u003cObject, Object\u003e\u003e entrySet) {\n            this.entrySet \u003d entrySet;\n        }\n\n        @Override public int size() { return entrySet.size(); }\n        @Override public boolean isEmpty() { return entrySet.isEmpty(); }\n        @Override public boolean contains(Object o) { return entrySet.contains(o); }\n        @Override public Object[] toArray() { return entrySet.toArray(); }\n        @Override public \u003cT\u003e T[] toArray(T[] a) { return entrySet.toArray(a); }\n        @Override public void clear() { entrySet.clear(); }\n        @Override public boolean remove(Object o) { return entrySet.remove(o); }\n\n        @Override\n        public boolean add(Map.Entry\u003cObject, Object\u003e e) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean addAll(Collection\u003c? extends Map.Entry\u003cObject, Object\u003e\u003e c) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean containsAll(Collection\u003c?\u003e c) {\n            return entrySet.containsAll(c);\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            return o \u003d\u003d this || entrySet.equals(o);\n        }\n\n        @Override\n        public int hashCode() {\n            return entrySet.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return entrySet.toString();\n        }\n\n        @Override\n        public boolean removeAll(Collection\u003c?\u003e c) {\n            return entrySet.removeAll(c);\n        }\n\n        @Override\n        public boolean retainAll(Collection\u003c?\u003e c) {\n            return entrySet.retainAll(c);\n        }\n\n        @Override\n        public Iterator\u003cMap.Entry\u003cObject, Object\u003e\u003e iterator() {\n            return entrySet.iterator();\n        }\n    }\n\n    @Override\n    public synchronized boolean equals(Object o) {\n        return map.equals(o);\n    }\n\n    @Override\n    public synchronized int hashCode() {\n        return map.hashCode();\n    }\n\n    @Override\n    public Object getOrDefault(Object key, Object defaultValue) {\n        return map.getOrDefault(key, defaultValue);\n    }\n\n    @Override\n    public synchronized void forEach(BiConsumer\u003c? super Object, ? super Object\u003e action) {\n        map.forEach(action);\n    }\n\n    @Override\n    public synchronized void replaceAll(BiFunction\u003c? super Object, ? super Object, ?\u003e function) {\n        map.replaceAll(function);\n    }\n\n    @Override\n    public synchronized Object putIfAbsent(Object key, Object value) {\n        return map.putIfAbsent(key, value);\n    }\n\n    @Override\n    public synchronized boolean remove(Object key, Object value) {\n        return map.remove(key, value);\n    }\n\n    @Override\n    public synchronized boolean replace(Object key, Object oldValue, Object newValue) {\n        return map.replace(key, oldValue, newValue);\n    }\n\n    @Override\n    public synchronized Object replace(Object key, Object value) {\n        return map.replace(key, value);\n    }\n\n    @Override\n    public synchronized Object computeIfAbsent(Object key,\n            Function\u003c? super Object, ?\u003e mappingFunction) {\n        return map.computeIfAbsent(key, mappingFunction);\n    }\n\n    @Override\n    public synchronized Object computeIfPresent(Object key,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.computeIfPresent(key, remappingFunction);\n    }\n\n    @Override\n    public synchronized Object compute(Object key,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.compute(key, remappingFunction);\n    }\n\n    @Override\n    public synchronized Object merge(Object key, Object value,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.merge(key, value, remappingFunction);\n    }\n\n    //\n    // Special Hashtable methods\n\n    @Override\n    protected void rehash() { /* no-op */ }\n\n    @Override\n    public synchronized Object clone() {\n        Properties clone \u003d (Properties) cloneHashtable();\n        clone.map \u003d new ConcurrentHashMap\u003c\u003e(map);\n        return clone;\n    }\n\n    //\n    // Hashtable serialization overrides\n    // (these should emit and consume Hashtable-compatible stream)\n\n    @Override\n    void writeHashtable(ObjectOutputStream s) throws IOException {\n        var map \u003d this.map;\n        List\u003cObject\u003e entryStack \u003d new ArrayList\u003c\u003e(map.size() * 2); // an estimate\n\n        for (Map.Entry\u003cObject, Object\u003e entry : map.entrySet()) {\n            entryStack.add(entry.getValue());\n            entryStack.add(entry.getKey());\n        }\n\n        // Write out the simulated threshold, loadfactor\n        float loadFactor \u003d 0.75f;\n        int count \u003d entryStack.size() / 2;\n        int length \u003d (int)(count / loadFactor) + (count / 20) + 3;\n        if (length \u003e count \u0026\u0026 (length \u0026 1) \u003d\u003d 0) {\n            length--;\n        }\n        synchronized (map) { // in case of multiple concurrent serializations\n            defaultWriteHashtable(s, length, loadFactor);\n        }\n\n        // Write out simulated length and real count of elements\n        s.writeInt(length);\n        s.writeInt(count);\n\n        // Write out the key/value objects from the stacked entries\n        for (int i \u003d entryStack.size() - 1; i \u003e\u003d 0; i--) {\n            s.writeObject(entryStack.get(i));\n        }\n    }\n\n    @Override\n    void readHashtable(ObjectInputStream s) throws IOException,\n            ClassNotFoundException {\n        // Read in the threshold and loadfactor\n        s.defaultReadObject();\n\n        // Read the original length of the array and number of elements\n        int origlength \u003d s.readInt();\n        int elements \u003d s.readInt();\n\n        // Validate # of elements\n        if (elements \u003c 0) {\n            throw new StreamCorruptedException(\"Illegal # of Elements: \" + elements);\n        }\n\n        // Constructing the backing map will lazily create an array when the first element is\n        // added, so check it before construction. Note that CHM\u0027s constructor takes a size\n        // that is the number of elements to be stored -- not the table size -- so it must be\n        // inflated by the default load factor of 0.75, then inflated to the next power of two.\n        // (CHM uses the same power-of-two computation as HashMap, and HashMap.tableSizeFor is\n        // accessible here.) Check Map.Entry[].class since it\u0027s the nearest public type to\n        // what is actually created.\n        SharedSecrets.getJavaObjectInputStreamAccess()\n                     .checkArray(s, Map.Entry[].class, HashMap.tableSizeFor((int)(elements / 0.75)));\n\n        // create CHM of appropriate capacity\n        var map \u003d new ConcurrentHashMap\u003c\u003e(elements);\n\n        // Read all the key/value objects\n        for (; elements \u003e 0; elements--) {\n            Object key \u003d s.readObject();\n            Object value \u003d s.readObject();\n            map.put(key, value);\n        }\n        this.map \u003d map;\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

Π°ΠΏΡ€. 25, 2024 2:42:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/util/Properties.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.04.25 14:42:00 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java

Uri: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1570)
```

Π°ΠΏΡ€. 25, 2024 2:42:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/util/Properties.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1995, 2021, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.util;\n\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.StreamCorruptedException;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\nimport jdk.internal.util.StaticProperty;\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.UTF_8;\n\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.ArraysSupport;\nimport jdk.internal.util.xml.PropertiesDefaultHandler;\n\n/**\n * The {@code Properties} class represents a persistent set of\n * properties. The {@code Properties} can be saved to a stream\n * or loaded from a stream. Each key and its corresponding value in\n * the property list is a string.\n * \u003cp\u003e\n * A property list can contain another property list as its\n * \"defaults\"; this second property list is searched if\n * the property key is not found in the original property list.\n * \u003cp\u003e\n * Because {@code Properties} inherits from {@code Hashtable}, the\n * {@code put} and {@code putAll} methods can be applied to a\n * {@code Properties} object.  Their use is strongly discouraged as they\n * allow the caller to insert entries whose keys or values are not\n * {@code Strings}.  The {@code setProperty} method should be used\n * instead.  If the {@code store} or {@code save} method is called\n * on a \"compromised\" {@code Properties} object that contains a\n * non-{@code String} key or value, the call will fail. Similarly,\n * the call to the {@code propertyNames} or {@code list} method\n * will fail if it is called on a \"compromised\" {@code Properties}\n * object that contains a non-{@code String} key.\n *\n * \u003cp\u003e\n * The iterators returned by the {@code iterator} method of this class\u0027s\n * \"collection views\" (that is, {@code entrySet()}, {@code keySet()}, and\n * {@code values()}) may not fail-fast (unlike the Hashtable implementation).\n * These iterators are guaranteed to traverse elements as they existed upon\n * construction exactly once, and may (but are not guaranteed to) reflect any\n * modifications subsequent to construction.\n * \u003cp\u003e\n * The {@link #load(java.io.Reader) load(Reader)} {@code /}\n * {@link #store(java.io.Writer, java.lang.String) store(Writer, String)}\n * methods load and store properties from and to a character based stream\n * in a simple line-oriented format specified below.\n *\n * The {@link #load(java.io.InputStream) load(InputStream)} {@code /}\n * {@link #store(java.io.OutputStream, java.lang.String) store(OutputStream, String)}\n * methods work the same way as the load(Reader)/store(Writer, String) pair, except\n * the input/output stream is encoded in ISO 8859-1 character encoding.\n * Characters that cannot be directly represented in this encoding can be written using\n * Unicode escapes as defined in section {@jls 3.3} of\n * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e;\n * only a single \u0027u\u0027 character is allowed in an escape\n * sequence.\n *\n * \u003cp\u003e The {@link #loadFromXML(InputStream)} and {@link\n * #storeToXML(OutputStream, String, String)} methods load and store properties\n * in a simple XML format.  By default the UTF-8 character encoding is used,\n * however a specific encoding may be specified if required. Implementations\n * are required to support UTF-8 and UTF-16 and may support other encodings.\n * An XML properties document has the following DOCTYPE declaration:\n *\n * \u003cpre\u003e\n * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n * \u003c/pre\u003e\n * Note that the system URI (http://java.sun.com/dtd/properties.dtd) is\n * \u003ci\u003enot\u003c/i\u003e accessed when exporting or importing properties; it merely\n * serves as a string to uniquely identify the DTD, which is:\n * \u003cpre\u003e\n *    \u0026lt;?xml version\u003d\"1.0\" encoding\u003d\"UTF-8\"?\u0026gt;\n *\n *    \u0026lt;!-- DTD for properties --\u0026gt;\n *\n *    \u0026lt;!ELEMENT properties ( comment?, entry* ) \u0026gt;\n *\n *    \u0026lt;!ATTLIST properties version CDATA #FIXED \"1.0\"\u0026gt;\n *\n *    \u0026lt;!ELEMENT comment (#PCDATA) \u0026gt;\n *\n *    \u0026lt;!ELEMENT entry (#PCDATA) \u0026gt;\n *\n *    \u0026lt;!ATTLIST entry key CDATA #REQUIRED\u0026gt;\n * \u003c/pre\u003e\n *\n * \u003cp\u003eThis class is thread-safe: multiple threads can share a single\n * {@code Properties} object without the need for external synchronization.\n *\n * @apiNote\n * The {@code Properties} class does not inherit the concept of a load factor\n * from its superclass, {@code Hashtable}.\n *\n * @author  Arthur van Hoff\n * @author  Michael McCloskey\n * @author  Xueming Shen\n * @since   1.0\n */\npublic class Properties extends Hashtable\u003cObject,Object\u003e {\n    /**\n     * use serialVersionUID from JDK 1.1.X for interoperability\n     */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d 4112578634029874840L;\n\n    private static final Unsafe UNSAFE \u003d Unsafe.getUnsafe();\n\n    /**\n     * A property list that contains default values for any keys not\n     * found in this property list.\n     *\n     * @serial\n     */\n    protected volatile Properties defaults;\n\n    /**\n     * Properties does not store values in its inherited Hashtable, but instead\n     * in an internal ConcurrentHashMap.  Synchronization is omitted from\n     * simple read operations.  Writes and bulk operations remain synchronized,\n     * as in Hashtable.\n     */\n    private transient volatile ConcurrentHashMap\u003cObject, Object\u003e map;\n\n    /**\n     * Creates an empty property list with no default values.\n     *\n     * @implNote The initial capacity of a {@code Properties} object created\n     * with this constructor is unspecified.\n     */\n    public Properties() {\n        this(null, 8);\n    }\n\n    /**\n     * Creates an empty property list with no default values, and with an\n     * initial size accommodating the specified number of elements without the\n     * need to dynamically resize.\n     *\n     * @param  initialCapacity the {@code Properties} will be sized to\n     *         accommodate this many elements\n     * @throws IllegalArgumentException if the initial capacity is less than\n     *         zero.\n     */\n    public Properties(int initialCapacity) {\n        this(null, initialCapacity);\n    }\n\n    /**\n     * Creates an empty property list with the specified defaults.\n     *\n     * @implNote The initial capacity of a {@code Properties} object created\n     * with this constructor is unspecified.\n     *\n     * @param   defaults   the defaults.\n     */\n    public Properties(Properties defaults) {\n        this(defaults, 8);\n    }\n\n    private Properties(Properties defaults, int initialCapacity) {\n        // use package-private constructor to\n        // initialize unused fields with dummy values\n        super((Void) null);\n        map \u003d new ConcurrentHashMap\u003c\u003e(initialCapacity);\n        this.defaults \u003d defaults;\n\n        // Ensure writes can\u0027t be reordered\n        UNSAFE.storeFence();\n    }\n\n    /**\n     * Calls the {@code Hashtable} method {@code put}. Provided for\n     * parallelism with the {@code getProperty} method. Enforces use of\n     * strings for property keys and values. The value returned is the\n     * result of the {@code Hashtable} call to {@code put}.\n     *\n     * @param key the key to be placed into this property list.\n     * @param value the value corresponding to {@code key}.\n     * @return     the previous value of the specified key in this property\n     *             list, or {@code null} if it did not have one.\n     * @see #getProperty\n     * @since    1.2\n     */\n    public synchronized Object setProperty(String key, String value) {\n        return put(key, value);\n    }\n\n\n    /**\n     * Reads a property list (key and element pairs) from the input\n     * character stream in a simple line-oriented format.\n     * \u003cp\u003e\n     * Properties are processed in terms of lines. There are two\n     * kinds of lines, \u003ci\u003enatural lines\u003c/i\u003e and \u003ci\u003elogical lines\u003c/i\u003e.\n     * A natural line is defined as a line of\n     * characters that is terminated either by a set of line terminator\n     * characters ({@code \\n} or {@code \\r} or {@code \\r\\n})\n     * or by the end of the stream. A natural line may be either a blank line,\n     * a comment line, or hold all or some of a key-element pair. A logical\n     * line holds all the data of a key-element pair, which may be spread\n     * out across several adjacent natural lines by escaping\n     * the line terminator sequence with a backslash character\n     * {@code \\}.  Note that a comment line cannot be extended\n     * in this manner; every natural line that is a comment must have\n     * its own comment indicator, as described below. Lines are read from\n     * input until the end of the stream is reached.\n     *\n     * \u003cp\u003e\n     * A natural line that contains only white space characters is\n     * considered blank and is ignored.  A comment line has an ASCII\n     * {@code \u0027#\u0027} or {@code \u0027!\u0027} as its first non-whitespace\n     * character; comment lines are also ignored and do not\n     * encode key-element information.  In addition to line\n     * terminators, this format considers the characters space\n     * ({@code \u0027 \u0027}, {@code \u0027\\u005Cu0020\u0027}), tab\n     * ({@code \u0027\\t\u0027}, {@code \u0027\\u005Cu0009\u0027}), and form feed\n     * ({@code \u0027\\f\u0027}, {@code \u0027\\u005Cu000C\u0027}) to be white\n     * space.\n     *\n     * \u003cp\u003e\n     * If a logical line is spread across several natural lines, the\n     * backslash escaping the line terminator sequence, the line\n     * terminator sequence, and any white space at the start of the\n     * following line have no effect on the key or element values.\n     * The remainder of the discussion of key and element parsing\n     * (when loading) will assume all the characters constituting\n     * the key and element appear on a single natural line after\n     * line continuation characters have been removed.  Note that\n     * it is \u003ci\u003enot\u003c/i\u003e sufficient to only examine the character\n     * preceding a line terminator sequence to decide if the line\n     * terminator is escaped; there must be an odd number of\n     * contiguous backslashes for the line terminator to be escaped.\n     * Since the input is processed from left to right, a\n     * non-zero even number of 2\u003ci\u003en\u003c/i\u003e contiguous backslashes\n     * before a line terminator (or elsewhere) encodes \u003ci\u003en\u003c/i\u003e\n     * backslashes after escape processing.\n     *\n     * \u003cp\u003e\n     * The key contains all of the characters in the line starting\n     * with the first non-whitespace character and up to, but not\n     * including, the first unescaped {@code \u0027\u003d\u0027},\n     * {@code \u0027:\u0027}, or white space character other than a line\n     * terminator. All of these key termination characters may be\n     * included in the key by escaping them with a preceding backslash\n     * character; for example,\u003cp\u003e\n     *\n     * {@code \\:\\\u003d}\u003cp\u003e\n     *\n     * would be the two-character key {@code \":\u003d\"}.  Line\n     * terminator characters can be included using {@code \\r} and\n     * {@code \\n} escape sequences.  Any white space after the\n     * key is skipped; if the first non-whitespace character after\n     * the key is {@code \u0027\u003d\u0027} or {@code \u0027:\u0027}, then it is\n     * ignored and any white space characters after it are also\n     * skipped.  All remaining characters on the line become part of\n     * the associated element string; if there are no remaining\n     * characters, the element is the empty string\n     * {@code \"\"}.  Once the raw character sequences\n     * constituting the key and element are identified, escape\n     * processing is performed as described above.\n     *\n     * \u003cp\u003e\n     * As an example, each of the following three lines specifies the key\n     * {@code \"Truth\"} and the associated element value\n     * {@code \"Beauty\"}:\n     * \u003cpre\u003e\n     * Truth \u003d Beauty\n     *  Truth:Beauty\n     * Truth                    :Beauty\n     * \u003c/pre\u003e\n     * As another example, the following three lines specify a single\n     * property:\n     * \u003cpre\u003e\n     * fruits                           apple, banana, pear, \\\n     *                                  cantaloupe, watermelon, \\\n     *                                  kiwi, mango\n     * \u003c/pre\u003e\n     * The key is {@code \"fruits\"} and the associated element is:\n     * \u003cpre\u003e\"apple, banana, pear, cantaloupe, watermelon, kiwi, mango\"\u003c/pre\u003e\n     * Note that a space appears before each {@code \\} so that a space\n     * will appear after each comma in the final result; the {@code \\},\n     * line terminator, and leading white space on the continuation line are\n     * merely discarded and are \u003ci\u003enot\u003c/i\u003e replaced by one or more other\n     * characters.\n     * \u003cp\u003e\n     * As a third example, the line:\n     * \u003cpre\u003echeeses\n     * \u003c/pre\u003e\n     * specifies that the key is {@code \"cheeses\"} and the associated\n     * element is the empty string {@code \"\"}.\n     * \u003cp\u003e\n     * \u003ca id\u003d\"unicodeescapes\"\u003e\u003c/a\u003e\n     * Characters in keys and elements can be represented in escape\n     * sequences similar to those used for character and string literals\n     * (see sections {@jls 3.3} and {@jls 3.10.6} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e).\n     *\n     * The differences from the character escape sequences and Unicode\n     * escapes used for characters and strings are:\n     *\n     * \u003cul\u003e\n     * \u003cli\u003e Octal escapes are not recognized.\n     *\n     * \u003cli\u003e The character sequence {@code \\b} does \u003ci\u003enot\u003c/i\u003e\n     * represent a backspace character.\n     *\n     * \u003cli\u003e The method does not treat a backslash character,\n     * {@code \\}, before a non-valid escape character as an\n     * error; the backslash is silently dropped.  For example, in a\n     * Java string the sequence {@code \"\\z\"} would cause a\n     * compile time error.  In contrast, this method silently drops\n     * the backslash.  Therefore, this method treats the two character\n     * sequence {@code \"\\b\"} as equivalent to the single\n     * character {@code \u0027b\u0027}.\n     *\n     * \u003cli\u003e Escapes are not necessary for single and double quotes;\n     * however, by the rule above, single and double quote characters\n     * preceded by a backslash still yield single and double quote\n     * characters, respectively.\n     *\n     * \u003cli\u003e Only a single \u0027u\u0027 character is allowed in a Unicode escape\n     * sequence.\n     *\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The specified stream remains open after this method returns.\n     *\n     * @param   reader   the input character stream.\n     * @throws  IOException  if an error occurred when reading from the\n     *          input stream.\n     * @throws  IllegalArgumentException if a malformed Unicode escape\n     *          appears in the input.\n     * @throws  NullPointerException if {@code reader} is null.\n     * @since   1.6\n     */\n    public synchronized void load(Reader reader) throws IOException {\n        Objects.requireNonNull(reader, \"reader parameter is null\");\n        load0(new LineReader(reader));\n    }\n\n    /**\n     * Reads a property list (key and element pairs) from the input\n     * byte stream. The input stream is in a simple line-oriented\n     * format as specified in\n     * {@link #load(java.io.Reader) load(Reader)} and is assumed to use\n     * the ISO 8859-1 character encoding; that is each byte is one Latin1\n     * character. Characters not in Latin1, and certain special characters,\n     * are represented in keys and elements using Unicode escapes as defined in\n     * section {@jls 3.3} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     * \u003cp\u003e\n     * The specified stream remains open after this method returns.\n     *\n     * @param      inStream   the input stream.\n     * @throws     IOException  if an error occurred when reading from the\n     *             input stream.\n     * @throws     IllegalArgumentException if the input stream contains a\n     *             malformed Unicode escape sequence.\n     * @throws     NullPointerException if {@code inStream} is null.\n     * @since 1.2\n     */\n    public synchronized void load(InputStream inStream) throws IOException {\n        Objects.requireNonNull(inStream, \"inStream parameter is null\");\n        load0(new LineReader(inStream));\n    }\n\n    private void load0(LineReader lr) throws IOException {\n        StringBuilder outBuffer \u003d new StringBuilder();\n        int limit;\n        int keyLen;\n        int valueStart;\n        boolean hasSep;\n        boolean precedingBackslash;\n\n        while ((limit \u003d lr.readLine()) \u003e\u003d 0) {\n            keyLen \u003d 0;\n            valueStart \u003d limit;\n            hasSep \u003d false;\n\n            //System.out.println(\"line\u003d\u003c\" + new String(lineBuf, 0, limit) + \"\u003e\");\n            precedingBackslash \u003d false;\n            while (keyLen \u003c limit) {\n                char c \u003d lr.lineBuf[keyLen];\n                //need check if escaped.\n                if ((c \u003d\u003d \u0027\u003d\u0027 ||  c \u003d\u003d \u0027:\u0027) \u0026\u0026 !precedingBackslash) {\n                    valueStart \u003d keyLen + 1;\n                    hasSep \u003d true;\n                    break;\n                } else if ((c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\t\u0027 ||  c \u003d\u003d \u0027\\f\u0027) \u0026\u0026 !precedingBackslash) {\n                    valueStart \u003d keyLen + 1;\n                    break;\n                }\n                if (c \u003d\u003d \u0027\\\\\u0027) {\n                    precedingBackslash \u003d !precedingBackslash;\n                } else {\n                    precedingBackslash \u003d false;\n                }\n                keyLen++;\n            }\n            while (valueStart \u003c limit) {\n                char c \u003d lr.lineBuf[valueStart];\n                if (c !\u003d \u0027 \u0027 \u0026\u0026 c !\u003d \u0027\\t\u0027 \u0026\u0026  c !\u003d \u0027\\f\u0027) {\n                    if (!hasSep \u0026\u0026 (c \u003d\u003d \u0027\u003d\u0027 ||  c \u003d\u003d \u0027:\u0027)) {\n                        hasSep \u003d true;\n                    } else {\n                        break;\n                    }\n                }\n                valueStart++;\n            }\n            String key \u003d loadConvert(lr.lineBuf, 0, keyLen, outBuffer);\n            String value \u003d loadConvert(lr.lineBuf, valueStart, limit - valueStart, outBuffer);\n            put(key, value);\n        }\n    }\n\n    /* Read in a \"logical line\" from an InputStream/Reader, skip all comment\n     * and blank lines and filter out those leading whitespace characters\n     * (\\u0020, \\u0009 and \\u000c) from the beginning of a \"natural line\".\n     * Method returns the char length of the \"logical line\" and stores\n     * the line in \"lineBuf\".\n     */\n    private static class LineReader {\n        LineReader(InputStream inStream) {\n            this.inStream \u003d inStream;\n            inByteBuf \u003d new byte[8192];\n        }\n\n        LineReader(Reader reader) {\n            this.reader \u003d reader;\n            inCharBuf \u003d new char[8192];\n        }\n\n        char[] lineBuf \u003d new char[1024];\n        private byte[] inByteBuf;\n        private char[] inCharBuf;\n        private int inLimit \u003d 0;\n        private int inOff \u003d 0;\n        private InputStream inStream;\n        private Reader reader;\n\n        int readLine() throws IOException {\n            // use locals to optimize for interpreted performance\n            int len \u003d 0;\n            int off \u003d inOff;\n            int limit \u003d inLimit;\n\n            boolean skipWhiteSpace \u003d true;\n            boolean appendedLineBegin \u003d false;\n            boolean precedingBackslash \u003d false;\n            boolean fromStream \u003d inStream !\u003d null;\n            byte[] byteBuf \u003d inByteBuf;\n            char[] charBuf \u003d inCharBuf;\n            char[] lineBuf \u003d this.lineBuf;\n            char c;\n\n            while (true) {\n                if (off \u003e\u003d limit) {\n                    inLimit \u003d limit \u003d fromStream ? inStream.read(byteBuf)\n                                                 : reader.read(charBuf);\n                    if (limit \u003c\u003d 0) {\n                        if (len \u003d\u003d 0) {\n                            return -1;\n                        }\n                        return precedingBackslash ? len - 1 : len;\n                    }\n                    off \u003d 0;\n                }\n\n                // (char)(byte \u0026 0xFF) is equivalent to calling a ISO8859-1 decoder.\n                c \u003d (fromStream) ? (char)(byteBuf[off++] \u0026 0xFF) : charBuf[off++];\n\n                if (skipWhiteSpace) {\n                    if (c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\t\u0027 || c \u003d\u003d \u0027\\f\u0027) {\n                        continue;\n                    }\n                    if (!appendedLineBegin \u0026\u0026 (c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\n\u0027)) {\n                        continue;\n                    }\n                    skipWhiteSpace \u003d false;\n                    appendedLineBegin \u003d false;\n\n                }\n                if (len \u003d\u003d 0) { // Still on a new logical line\n                    if (c \u003d\u003d \u0027#\u0027 || c \u003d\u003d \u0027!\u0027) {\n                        // Comment, quickly consume the rest of the line\n\n                        // When checking for new line characters a range check,\n                        // starting with the higher bound (\u0027\\r\u0027) means one less\n                        // branch in the common case.\n                        commentLoop: while (true) {\n                            if (fromStream) {\n                                byte b;\n                                while (off \u003c limit) {\n                                    b \u003d byteBuf[off++];\n                                    if (b \u003c\u003d \u0027\\r\u0027 \u0026\u0026 (b \u003d\u003d \u0027\\r\u0027 || b \u003d\u003d \u0027\\n\u0027))\n                                        break commentLoop;\n                                }\n                                if (off \u003d\u003d limit) {\n                                    inLimit \u003d limit \u003d inStream.read(byteBuf);\n                                    if (limit \u003c\u003d 0) { // EOF\n                                        return -1;\n                                    }\n                                    off \u003d 0;\n                                }\n                            } else {\n                                while (off \u003c limit) {\n                                    c \u003d charBuf[off++];\n                                    if (c \u003c\u003d \u0027\\r\u0027 \u0026\u0026 (c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\n\u0027))\n                                        break commentLoop;\n                                }\n                                if (off \u003d\u003d limit) {\n                                    inLimit \u003d limit \u003d reader.read(charBuf);\n                                    if (limit \u003c\u003d 0) { // EOF\n                                        return -1;\n                                    }\n                                    off \u003d 0;\n                                }\n                            }\n                        }\n                        skipWhiteSpace \u003d true;\n                        continue;\n                    }\n                }\n\n                if (c !\u003d \u0027\\n\u0027 \u0026\u0026 c !\u003d \u0027\\r\u0027) {\n                    lineBuf[len++] \u003d c;\n                    if (len \u003d\u003d lineBuf.length) {\n                        lineBuf \u003d new char[ArraysSupport.newLength(len, 1, len)];\n                        System.arraycopy(this.lineBuf, 0, lineBuf, 0, len);\n                        this.lineBuf \u003d lineBuf;\n                    }\n                    // flip the preceding backslash flag\n                    precedingBackslash \u003d (c \u003d\u003d \u0027\\\\\u0027) ? !precedingBackslash : false;\n                } else {\n                    // reached EOL\n                    if (len \u003d\u003d 0) {\n                        skipWhiteSpace \u003d true;\n                        continue;\n                    }\n                    if (off \u003e\u003d limit) {\n                        inLimit \u003d limit \u003d fromStream ? inStream.read(byteBuf)\n                                                     : reader.read(charBuf);\n                        off \u003d 0;\n                        if (limit \u003c\u003d 0) { // EOF\n                            return precedingBackslash ? len - 1 : len;\n                        }\n                    }\n                    if (precedingBackslash) {\n                        // backslash at EOL is not part of the line\n                        len -\u003d 1;\n                        // skip leading whitespace characters in the following line\n                        skipWhiteSpace \u003d true;\n                        appendedLineBegin \u003d true;\n                        precedingBackslash \u003d false;\n                        // take care not to include any subsequent \\n\n                        if (c \u003d\u003d \u0027\\r\u0027) {\n                            if (fromStream) {\n                                if (byteBuf[off] \u003d\u003d \u0027\\n\u0027) {\n                                    off++;\n                                }\n                            } else {\n                                if (charBuf[off] \u003d\u003d \u0027\\n\u0027) {\n                                    off++;\n                                }\n                            }\n                        }\n                    } else {\n                        inOff \u003d off;\n                        return len;\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n     * Converts encoded \u0026#92;uxxxx to unicode chars\n     * and changes special saved chars to their original forms\n     */\n    private String loadConvert(char[] in, int off, int len, StringBuilder out) {\n        char aChar;\n        int end \u003d off + len;\n        int start \u003d off;\n        while (off \u003c end) {\n            aChar \u003d in[off++];\n            if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                break;\n            }\n        }\n        if (off \u003d\u003d end) { // No backslash\n            return new String(in, start, len);\n        }\n\n        // backslash found at off - 1, reset the shared buffer, rewind offset\n        out.setLength(0);\n        off--;\n        out.append(in, start, off - start);\n\n        while (off \u003c end) {\n            aChar \u003d in[off++];\n            if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                // No need to bounds check since LineReader::readLine excludes\n                // unescaped \\s at the end of the line\n                aChar \u003d in[off++];\n                if(aChar \u003d\u003d \u0027u\u0027) {\n                    // Read the xxxx\n                    if (off \u003e end - 4)\n                        throw new IllegalArgumentException(\n                                     \"Malformed \\\\uxxxx encoding.\");\n                    int value \u003d 0;\n                    for (int i \u003d 0; i \u003c 4; i++) {\n                        aChar \u003d in[off++];\n                        value \u003d switch (aChar) {\n                            case \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027 -\u003e (value \u003c\u003c 4) + aChar - \u00270\u0027;\n                            case \u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027, \u0027f\u0027                     -\u003e (value \u003c\u003c 4) + 10 + aChar - \u0027a\u0027;\n                            case \u0027A\u0027, \u0027B\u0027, \u0027C\u0027, \u0027D\u0027, \u0027E\u0027, \u0027F\u0027                     -\u003e (value \u003c\u003c 4) + 10 + aChar - \u0027A\u0027;\n                            default -\u003e throw new IllegalArgumentException(\"Malformed \\\\uxxxx encoding.\");\n                        };\n                    }\n                    out.append((char)value);\n                } else {\n                    if (aChar \u003d\u003d \u0027t\u0027) aChar \u003d \u0027\\t\u0027;\n                    else if (aChar \u003d\u003d \u0027r\u0027) aChar \u003d \u0027\\r\u0027;\n                    else if (aChar \u003d\u003d \u0027n\u0027) aChar \u003d \u0027\\n\u0027;\n                    else if (aChar \u003d\u003d \u0027f\u0027) aChar \u003d \u0027\\f\u0027;\n                    out.append(aChar);\n                }\n            } else {\n                out.append(aChar);\n            }\n        }\n        return out.toString();\n    }\n\n    /*\n     * Converts unicodes to encoded \u0026#92;uxxxx and escapes\n     * special characters with a preceding slash\n     */\n    private String saveConvert(String theString,\n                               boolean escapeSpace,\n                               boolean escapeUnicode) {\n        int len \u003d theString.length();\n        int bufLen \u003d len * 2;\n        if (bufLen \u003c 0) {\n            bufLen \u003d Integer.MAX_VALUE;\n        }\n        StringBuilder outBuffer \u003d new StringBuilder(bufLen);\n        HexFormat hex \u003d HexFormat.of().withUpperCase();\n        for(int x\u003d0; x\u003clen; x++) {\n            char aChar \u003d theString.charAt(x);\n            // Handle common case first, selecting largest block that\n            // avoids the specials below\n            if ((aChar \u003e 61) \u0026\u0026 (aChar \u003c 127)) {\n                if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                    outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027\\\\\u0027);\n                    continue;\n                }\n                outBuffer.append(aChar);\n                continue;\n            }\n            switch(aChar) {\n                case \u0027 \u0027:\n                    if (x \u003d\u003d 0 || escapeSpace)\n                        outBuffer.append(\u0027\\\\\u0027);\n                    outBuffer.append(\u0027 \u0027);\n                    break;\n                case \u0027\\t\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027t\u0027);\n                          break;\n                case \u0027\\n\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027n\u0027);\n                          break;\n                case \u0027\\r\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027r\u0027);\n                          break;\n                case \u0027\\f\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027f\u0027);\n                          break;\n                case \u0027\u003d\u0027: // Fall through\n                case \u0027:\u0027: // Fall through\n                case \u0027#\u0027: // Fall through\n                case \u0027!\u0027:\n                    outBuffer.append(\u0027\\\\\u0027); outBuffer.append(aChar);\n                    break;\n                default:\n                    if (((aChar \u003c 0x0020) || (aChar \u003e 0x007e)) \u0026 escapeUnicode ) {\n                        outBuffer.append(\"\\\\u\");\n                        outBuffer.append(hex.toHexDigits(aChar));\n                    } else {\n                        outBuffer.append(aChar);\n                    }\n            }\n        }\n        return outBuffer.toString();\n    }\n\n    private static void writeComments(BufferedWriter bw, String comments)\n        throws IOException {\n        HexFormat hex \u003d HexFormat.of().withUpperCase();\n        bw.write(\"#\");\n        int len \u003d comments.length();\n        int current \u003d 0;\n        int last \u003d 0;\n        while (current \u003c len) {\n            char c \u003d comments.charAt(current);\n            if (c \u003e \u0027\\u00ff\u0027 || c \u003d\u003d \u0027\\n\u0027 || c \u003d\u003d \u0027\\r\u0027) {\n                if (last !\u003d current)\n                    bw.write(comments.substring(last, current));\n                if (c \u003e \u0027\\u00ff\u0027) {\n                    bw.write(\"\\\\u\");\n                    bw.write(hex.toHexDigits(c));\n                } else {\n                    bw.newLine();\n                    if (c \u003d\u003d \u0027\\r\u0027 \u0026\u0026\n                        current !\u003d len - 1 \u0026\u0026\n                        comments.charAt(current + 1) \u003d\u003d \u0027\\n\u0027) {\n                        current++;\n                    }\n                    if (current \u003d\u003d len - 1 ||\n                        (comments.charAt(current + 1) !\u003d \u0027#\u0027 \u0026\u0026\n                        comments.charAt(current + 1) !\u003d \u0027!\u0027))\n                        bw.write(\"#\");\n                }\n                last \u003d current + 1;\n            }\n            current++;\n        }\n        if (last !\u003d current)\n            bw.write(comments.substring(last, current));\n        bw.newLine();\n    }\n\n    /**\n     * Calls the {@code store(OutputStream out, String comments)} method\n     * and suppresses IOExceptions that were thrown.\n     *\n     * @deprecated This method does not throw an IOException if an I/O error\n     * occurs while saving the property list.  The preferred way to save a\n     * properties list is via the {@code store(OutputStream out,\n     * String comments)} method or the\n     * {@code storeToXML(OutputStream os, String comment)} method.\n     *\n     * @param   out      an output stream.\n     * @param   comments   a description of the property list.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not\n     *             {@code Strings}.\n     */\n    @Deprecated\n    public void save(OutputStream out, String comments)  {\n        try {\n            store(out, comments);\n        } catch (IOException e) {\n        }\n    }\n\n    /**\n     * Writes this property list (key and element pairs) in this\n     * {@code Properties} table to the output character stream in a\n     * format suitable for using the {@link #load(java.io.Reader) load(Reader)}\n     * method.\n     * \u003cp\u003e\n     * Properties from the defaults table of this {@code Properties}\n     * table (if any) are \u003ci\u003enot\u003c/i\u003e written out by this method.\n     * \u003cp\u003e\n     * If the comments argument is not null, then an ASCII {@code #}\n     * character, the comments string, and a line separator are first written\n     * to the output stream. Thus, the {@code comments} can serve as an\n     * identifying comment. Any one of a line feed ({@code \\n}), a carriage\n     * return ({@code \\r}), or a carriage return followed immediately by a line feed\n     * ({@code \\r\\n}) in comments is replaced by a\n     * {@link System#lineSeparator() line separator} and if the next\n     * character in comments is not character {@code #} or character {@code !} then\n     * an ASCII {@code #} is written out after that line separator.\n     * \u003cp\u003e\n     * If the {@systemProperty java.properties.date} is set on the command line\n     * and is non-empty (as determined by {@link String#isEmpty()  String.isEmpty}),\n     * a comment line is written as follows.\n     * First, a {@code #} character is written, followed by the contents\n     * of the property, followed by a line separator. Any line terminator characters\n     * in the value of the system property are treated the same way as noted above\n     * for the comments argument.\n     * If the system property is not set or is empty, a comment line is written\n     * as follows.\n     * First, a {@code #} character is written, followed by the current date and time\n     * formatted as if by the {@link Date#toString() Date.toString} method,\n     * followed by a line separator.\n     * \u003cp\u003e\n     * Then every entry in this {@code Properties} table is\n     * written out, one per line. For each entry the key string is\n     * written, then an ASCII {@code \u003d}, then the associated\n     * element string. For the key, all space characters are\n     * written with a preceding {@code \\} character.  For the\n     * element, leading space characters, but not embedded or trailing\n     * space characters, are written with a preceding {@code \\}\n     * character. The key and element characters {@code #},\n     * {@code !}, {@code \u003d}, and {@code :} are written\n     * with a preceding backslash to ensure that they are properly loaded.\n     * \u003cp\u003e\n     * After the entries have been written, the output stream is flushed.\n     * The output stream remains open after this method returns.\n     *\n     * @implSpec The keys and elements are written in the natural sort order\n     * of the keys in the {@code entrySet()} unless {@code entrySet()} is\n     * overridden by a subclass to return a different value than {@code super.entrySet()}.\n     *\n     * @param   writer      an output character stream writer.\n     * @param   comments   a description of the property list.\n     * @throws     IOException if writing this property list to the specified\n     *             output stream throws an {@code IOException}.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not {@code Strings}.\n     * @throws     NullPointerException  if {@code writer} is null.\n     * @since 1.6\n     */\n    public void store(Writer writer, String comments)\n        throws IOException\n    {\n        store0((writer instanceof BufferedWriter)?(BufferedWriter)writer\n                                                 : new BufferedWriter(writer),\n               comments,\n               false);\n    }\n\n    /**\n     * Writes this property list (key and element pairs) in this\n     * {@code Properties} table to the output stream in a format suitable\n     * for loading into a {@code Properties} table using the\n     * {@link #load(InputStream) load(InputStream)} method.\n     * \u003cp\u003e\n     * Properties from the defaults table of this {@code Properties}\n     * table (if any) are \u003ci\u003enot\u003c/i\u003e written out by this method.\n     * \u003cp\u003e\n     * This method outputs the comments, properties keys and values in\n     * the same format as specified in\n     * {@link #store(java.io.Writer, java.lang.String) store(Writer)},\n     * with the following differences:\n     * \u003cul\u003e\n     * \u003cli\u003eThe stream is written using the ISO 8859-1 character encoding.\n     *\n     * \u003cli\u003eCharacters not in Latin-1 in the comments are written as\n     * {@code \\u005Cu}\u003ci\u003exxxx\u003c/i\u003e for their appropriate unicode\n     * hexadecimal value \u003ci\u003exxxx\u003c/i\u003e.\n     *\n     * \u003cli\u003eCharacters less than {@code \\u005Cu0020} and characters greater\n     * than {@code \\u005Cu007E} in property keys or values are written\n     * as {@code \\u005Cu}\u003ci\u003exxxx\u003c/i\u003e for the appropriate hexadecimal\n     * value \u003ci\u003exxxx\u003c/i\u003e.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * After the entries have been written, the output stream is flushed.\n     * The output stream remains open after this method returns.\n     *\n     * @param   out      an output stream.\n     * @param   comments   a description of the property list.\n     * @throws     IOException if writing this property list to the specified\n     *             output stream throws an {@code IOException}.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not {@code Strings}.\n     * @throws     NullPointerException  if {@code out} is null.\n     * @since 1.2\n     */\n    public void store(OutputStream out, String comments)\n        throws IOException\n    {\n        store0(new BufferedWriter(new OutputStreamWriter(out, ISO_8859_1.INSTANCE)),\n               comments,\n               true);\n    }\n\n    private void store0(BufferedWriter bw, String comments, boolean escUnicode)\n        throws IOException\n    {\n        if (comments !\u003d null) {\n            writeComments(bw, comments);\n        }\n        writeDateComment(bw);\n\n        synchronized (this) {\n            @SuppressWarnings(\"unchecked\")\n            Collection\u003cMap.Entry\u003cString, String\u003e\u003e entries \u003d (Set\u003cMap.Entry\u003cString, String\u003e\u003e) (Set) entrySet();\n            // entrySet() can be overridden by subclasses. Here we check to see if\n            // the returned instance type is the one returned by the Properties.entrySet()\n            // implementation. If yes, then we sort those entries in the natural order\n            // of their key. Else, we consider that the subclassed implementation may\n            // potentially have returned a differently ordered entries and so we just\n            // use the iteration order of the returned instance.\n            if (entries instanceof Collections.SynchronizedSet\u003c?\u003e ss\n                    \u0026\u0026 ss.c instanceof EntrySet) {\n                entries \u003d new ArrayList\u003c\u003e(entries);\n                ((List\u003cMap.Entry\u003cString, String\u003e\u003e) entries).sort(Map.Entry.comparingByKey());\n            }\n            for (Map.Entry\u003cString, String\u003e e : entries) {\n                String key \u003d e.getKey();\n                String val \u003d e.getValue();\n                key \u003d saveConvert(key, true, escUnicode);\n                /* No need to escape embedded and trailing spaces for value, hence\n                 * pass false to flag.\n                 */\n                val \u003d saveConvert(val, false, escUnicode);\n                bw.write(key + \"\u003d\" + val);\n                bw.newLine();\n            }\n        }\n        bw.flush();\n    }\n\n    private static void writeDateComment(BufferedWriter bw) throws IOException {\n        // value of java.properties.date system property isn\u0027t sensitive\n        // and so doesn\u0027t need any security manager checks to make the value accessible\n        // to the callers\n        String sysPropVal \u003d StaticProperty.javaPropertiesDate();\n        if (sysPropVal !\u003d null \u0026\u0026 !sysPropVal.isEmpty()) {\n            writeComments(bw, sysPropVal);\n        } else {\n            bw.write(\"#\" + new Date());\n            bw.newLine();\n        }\n    }\n\n    /**\n     * Loads all of the properties represented by the XML document on the\n     * specified input stream into this properties table.\n     *\n     * \u003cp\u003eThe XML document must have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     * Furthermore, the document must satisfy the properties DTD described\n     * above.\n     *\n     * \u003cp\u003e An implementation is required to read XML documents that use the\n     * \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An implementation may\n     * support additional encodings.\n     *\n     * \u003cp\u003eThe specified stream is closed after this method returns.\n     *\n     * @param in the input stream from which to read the XML document.\n     * @throws IOException if reading from the specified input stream\n     *         results in an {@code IOException}.\n     * @throws java.io.UnsupportedEncodingException if the document\u0027s encoding\n     *         declaration can be read and it specifies an encoding that is not\n     *         supported\n     * @throws InvalidPropertiesFormatException Data on input stream does not\n     *         constitute a valid XML document with the mandated document type.\n     * @throws NullPointerException if {@code in} is null.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #storeToXML(OutputStream, String, String)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 1.5\n     */\n    public synchronized void loadFromXML(InputStream in)\n        throws IOException, InvalidPropertiesFormatException\n    {\n        Objects.requireNonNull(in);\n        PropertiesDefaultHandler handler \u003d new PropertiesDefaultHandler();\n        handler.load(this, in);\n        in.close();\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table.\n     *\n     * \u003cp\u003e An invocation of this method of the form {@code props.storeToXML(os,\n     * comment)} behaves in exactly the same way as the invocation\n     * {@code props.storeToXML(os, comment, \"UTF-8\");}.\n     *\n     * @param os the output stream on which to emit the XML document.\n     * @param comment a description of the property list, or {@code null}\n     *        if no comment is desired.\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws NullPointerException if {@code os} is null.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not\n     *         {@code Strings}.\n     * @see    #loadFromXML(InputStream)\n     * @since 1.5\n     */\n    public void storeToXML(OutputStream os, String comment)\n        throws IOException\n    {\n        storeToXML(os, comment, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table, using the specified encoding.\n     *\n     * \u003cp\u003eThe XML document will have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003eIf the specified comment is {@code null} then no comment\n     * will be stored in the document.\n     *\n     * \u003cp\u003e An implementation is required to support writing of XML documents\n     * that use the \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An\n     * implementation may support additional encodings.\n     *\n     * \u003cp\u003eThe specified stream remains open after this method returns.\n     *\n     * \u003cp\u003eThis method behaves the same as\n     * {@linkplain #storeToXML(OutputStream os, String comment, Charset charset)}\n     * except that it will {@linkplain java.nio.charset.Charset#forName look up the charset}\n     * using the given encoding name.\n     *\n     * @param os        the output stream on which to emit the XML document.\n     * @param comment   a description of the property list, or {@code null}\n     *                  if no comment is desired.\n     * @param  encoding the name of a supported\n     *                  \u003ca href\u003d\"../lang/package-summary.html#charenc\"\u003e\n     *                  character encoding\u003c/a\u003e\n     *\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws java.io.UnsupportedEncodingException if the encoding is not\n     *         supported by the implementation.\n     * @throws NullPointerException if {@code os} is {@code null},\n     *         or if {@code encoding} is {@code null}.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not {@code Strings}.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #loadFromXML(InputStream)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 1.5\n     */\n    public void storeToXML(OutputStream os, String comment, String encoding)\n        throws IOException {\n        Objects.requireNonNull(os);\n        Objects.requireNonNull(encoding);\n\n        try {\n            Charset charset \u003d Charset.forName(encoding);\n            storeToXML(os, comment, charset);\n        } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {\n            throw new UnsupportedEncodingException(encoding);\n        }\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table, using the specified encoding.\n     *\n     * \u003cp\u003eThe XML document will have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003eIf the specified comment is {@code null} then no comment\n     * will be stored in the document.\n     *\n     * \u003cp\u003e An implementation is required to support writing of XML documents\n     * that use the \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An\n     * implementation may support additional encodings.\n     *\n     * \u003cp\u003e Unmappable characters for the specified charset will be encoded as\n     * numeric character references.\n     *\n     * \u003cp\u003eThe specified stream remains open after this method returns.\n     *\n     * @param os        the output stream on which to emit the XML document.\n     * @param comment   a description of the property list, or {@code null}\n     *                  if no comment is desired.\n     * @param charset   the charset\n     *\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws NullPointerException if {@code os} or {@code charset} is {@code null}.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not {@code Strings}.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #loadFromXML(InputStream)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 10\n     */\n    public void storeToXML(OutputStream os, String comment, Charset charset)\n        throws IOException {\n        Objects.requireNonNull(os, \"OutputStream\");\n        Objects.requireNonNull(charset, \"Charset\");\n        PropertiesDefaultHandler handler \u003d new PropertiesDefaultHandler();\n        handler.store(this, os, comment, charset);\n    }\n\n    /**\n     * Searches for the property with the specified key in this property list.\n     * If the key is not found in this property list, the default property list,\n     * and its defaults, recursively, are then checked. The method returns\n     * {@code null} if the property is not found.\n     *\n     * @param   key   the property key.\n     * @return  the value in this property list with the specified key value.\n     * @see     #setProperty\n     * @see     #defaults\n     */\n    public String getProperty(String key) {\n        Object oval \u003d map.get(key);\n        String sval \u003d (oval instanceof String) ? (String)oval : null;\n        Properties defaults;\n        return ((sval \u003d\u003d null) \u0026\u0026 ((defaults \u003d this.defaults) !\u003d null)) ? defaults.getProperty(key) : sval;\n    }\n\n    /**\n     * Searches for the property with the specified key in this property list.\n     * If the key is not found in this property list, the default property list,\n     * and its defaults, recursively, are then checked. The method returns the\n     * default value argument if the property is not found.\n     *\n     * @param   key            the hashtable key.\n     * @param   defaultValue   a default value.\n     *\n     * @return  the value in this property list with the specified key value.\n     * @see     #setProperty\n     * @see     #defaults\n     */\n    public String getProperty(String key, String defaultValue) {\n        String val \u003d getProperty(key);\n        return (val \u003d\u003d null) ? defaultValue : val;\n    }\n\n    /**\n     * Returns an enumeration of all the keys in this property list,\n     * including distinct keys in the default property list if a key\n     * of the same name has not already been found from the main\n     * properties list.\n     *\n     * @return  an enumeration of all the keys in this property list, including\n     *          the keys in the default property list.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     * @see     java.util.Enumeration\n     * @see     java.util.Properties#defaults\n     * @see     #stringPropertyNames\n     */\n    public Enumeration\u003c?\u003e propertyNames() {\n        Hashtable\u003cString,Object\u003e h \u003d new Hashtable\u003c\u003e();\n        enumerate(h);\n        return h.keys();\n    }\n\n    /**\n     * Returns an unmodifiable set of keys from this property list\n     * where the key and its corresponding value are strings,\n     * including distinct keys in the default property list if a key\n     * of the same name has not already been found from the main\n     * properties list.  Properties whose key or value is not\n     * of type {@code String} are omitted.\n     * \u003cp\u003e\n     * The returned set is not backed by this {@code Properties} object.\n     * Changes to this {@code Properties} object are not reflected in the\n     * returned set.\n     *\n     * @return  an unmodifiable set of keys in this property list where\n     *          the key and its corresponding value are strings,\n     *          including the keys in the default property list.\n     * @see     java.util.Properties#defaults\n     * @since   1.6\n     */\n    public Set\u003cString\u003e stringPropertyNames() {\n        Map\u003cString, String\u003e h \u003d new HashMap\u003c\u003e();\n        enumerateStringProperties(h);\n        return Collections.unmodifiableSet(h.keySet());\n    }\n\n    /**\n     * Prints this property list out to the specified output stream.\n     * This method is useful for debugging.\n     *\n     * @param   out   an output stream.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     */\n    public void list(PrintStream out) {\n        out.println(\"-- listing properties --\");\n        Map\u003cString, Object\u003e h \u003d new HashMap\u003c\u003e();\n        enumerate(h);\n        for (Map.Entry\u003cString, Object\u003e e : h.entrySet()) {\n            String key \u003d e.getKey();\n            String val \u003d (String)e.getValue();\n            if (val.length() \u003e 40) {\n                val \u003d val.substring(0, 37) + \"...\";\n            }\n            out.println(key + \"\u003d\" + val);\n        }\n    }\n\n    /**\n     * Prints this property list out to the specified output stream.\n     * This method is useful for debugging.\n     *\n     * @param   out   an output stream.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     * @since   1.1\n     */\n    /*\n     * Rather than use an anonymous inner class to share common code, this\n     * method is duplicated in order to ensure that a non-1.1 compiler can\n     * compile this file.\n     */\n    public void list(PrintWriter out) {\n        out.println(\"-- listing properties --\");\n        Map\u003cString, Object\u003e h \u003d new HashMap\u003c\u003e();\n        enumerate(h);\n        for (Map.Entry\u003cString, Object\u003e e : h.entrySet()) {\n            String key \u003d e.getKey();\n            String val \u003d (String)e.getValue();\n            if (val.length() \u003e 40) {\n                val \u003d val.substring(0, 37) + \"...\";\n            }\n            out.println(key + \"\u003d\" + val);\n        }\n    }\n\n    /**\n     * Enumerates all key/value pairs into the specified Map.\n     * @param h the Map\n     * @throws ClassCastException if any of the property keys\n     *         is not of String type.\n     */\n    private void enumerate(Map\u003cString, Object\u003e h) {\n        if (defaults !\u003d null) {\n            defaults.enumerate(h);\n        }\n        for (Map.Entry\u003cObject, Object\u003e e : entrySet()) {\n            String key \u003d (String)e.getKey();\n            h.put(key, e.getValue());\n        }\n    }\n\n    /**\n     * Enumerates all key/value pairs into the specified Map\n     * and omits the property if the key or value is not a string.\n     * @param h the Map\n     */\n    private void enumerateStringProperties(Map\u003cString, String\u003e h) {\n        if (defaults !\u003d null) {\n            defaults.enumerateStringProperties(h);\n        }\n        for (Map.Entry\u003cObject, Object\u003e e : entrySet()) {\n            Object k \u003d e.getKey();\n            Object v \u003d e.getValue();\n            if (k instanceof String \u0026\u0026 v instanceof String) {\n                h.put((String) k, (String) v);\n            }\n        }\n    }\n\n    //\n    // Hashtable methods overridden and delegated to a ConcurrentHashMap instance\n\n    @Override\n    public int size() {\n        return map.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    @Override\n    public Enumeration\u003cObject\u003e keys() {\n        // CHM.keys() returns Iterator w/ remove() - instead wrap keySet()\n        return Collections.enumeration(map.keySet());\n    }\n\n    @Override\n    public Enumeration\u003cObject\u003e elements() {\n        // CHM.elements() returns Iterator w/ remove() - instead wrap values()\n        return Collections.enumeration(map.values());\n    }\n\n    @Override\n    public boolean contains(Object value) {\n        return map.contains(value);\n    }\n\n    @Override\n    public boolean containsValue(Object value) {\n        return map.containsValue(value);\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return map.containsKey(key);\n    }\n\n    @Override\n    public Object get(Object key) {\n        return map.get(key);\n    }\n\n    @Override\n    public synchronized Object put(Object key, Object value) {\n        return map.put(key, value);\n    }\n\n    @Override\n    public synchronized Object remove(Object key) {\n        return map.remove(key);\n    }\n\n    @Override\n    public synchronized void putAll(Map\u003c?, ?\u003e t) {\n        map.putAll(t);\n    }\n\n    @Override\n    public synchronized void clear() {\n        map.clear();\n    }\n\n    @Override\n    public synchronized String toString() {\n        return map.toString();\n    }\n\n    @Override\n    public Set\u003cObject\u003e keySet() {\n        return Collections.synchronizedSet(map.keySet(), this);\n    }\n\n    @Override\n    public Collection\u003cObject\u003e values() {\n        return Collections.synchronizedCollection(map.values(), this);\n    }\n\n    @Override\n    public Set\u003cMap.Entry\u003cObject, Object\u003e\u003e entrySet() {\n        return Collections.synchronizedSet(new EntrySet(map.entrySet()), this);\n    }\n\n    /*\n     * Properties.entrySet() should not support add/addAll, however\n     * ConcurrentHashMap.entrySet() provides add/addAll.  This class wraps the\n     * Set returned from CHM, changing add/addAll to throw UOE.\n     */\n    private static class EntrySet implements Set\u003cMap.Entry\u003cObject, Object\u003e\u003e {\n        private Set\u003cMap.Entry\u003cObject,Object\u003e\u003e entrySet;\n\n        private EntrySet(Set\u003cMap.Entry\u003cObject, Object\u003e\u003e entrySet) {\n            this.entrySet \u003d entrySet;\n        }\n\n        @Override public int size() { return entrySet.size(); }\n        @Override public boolean isEmpty() { return entrySet.isEmpty(); }\n        @Override public boolean contains(Object o) { return entrySet.contains(o); }\n        @Override public Object[] toArray() { return entrySet.toArray(); }\n        @Override public \u003cT\u003e T[] toArray(T[] a) { return entrySet.toArray(a); }\n        @Override public void clear() { entrySet.clear(); }\n        @Override public boolean remove(Object o) { return entrySet.remove(o); }\n\n        @Override\n        public boolean add(Map.Entry\u003cObject, Object\u003e e) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean addAll(Collection\u003c? extends Map.Entry\u003cObject, Object\u003e\u003e c) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean containsAll(Collection\u003c?\u003e c) {\n            return entrySet.containsAll(c);\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            return o \u003d\u003d this || entrySet.equals(o);\n        }\n\n        @Override\n        public int hashCode() {\n            return entrySet.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return entrySet.toString();\n        }\n\n        @Override\n        public boolean removeAll(Collection\u003c?\u003e c) {\n            return entrySet.removeAll(c);\n        }\n\n        @Override\n        public boolean retainAll(Collection\u003c?\u003e c) {\n            return entrySet.retainAll(c);\n        }\n\n        @Override\n        public Iterator\u003cMap.Entry\u003cObject, Object\u003e\u003e iterator() {\n            return entrySet.iterator();\n        }\n    }\n\n    @Override\n    public synchronized boolean equals(Object o) {\n        return map.equals(o);\n    }\n\n    @Override\n    public synchronized int hashCode() {\n        return map.hashCode();\n    }\n\n    @Override\n    public Object getOrDefault(Object key, Object defaultValue) {\n        return map.getOrDefault(key, defaultValue);\n    }\n\n    @Override\n    public synchronized void forEach(BiConsumer\u003c? super Object, ? super Object\u003e action) {\n        map.forEach(action);\n    }\n\n    @Override\n    public synchronized void replaceAll(BiFunction\u003c? super Object, ? super Object, ?\u003e function) {\n        map.replaceAll(function);\n    }\n\n    @Override\n    public synchronized Object putIfAbsent(Object key, Object value) {\n        return map.putIfAbsent(key, value);\n    }\n\n    @Override\n    public synchronized boolean remove(Object key, Object value) {\n        return map.remove(key, value);\n    }\n\n    @Override\n    public synchronized boolean replace(Object key, Object oldValue, Object newValue) {\n        return map.replace(key, oldValue, newValue);\n    }\n\n    @Override\n    public synchronized Object replace(Object key, Object value) {\n        return map.replace(key, value);\n    }\n\n    @Override\n    public synchronized Object computeIfAbsent(Object key,\n            Function\u003c? super Object, ?\u003e mappingFunction) {\n        return map.computeIfAbsent(key, mappingFunction);\n    }\n\n    @Override\n    public synchronized Object computeIfPresent(Object key,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.computeIfPresent(key, remappingFunction);\n    }\n\n    @Override\n    public synchronized Object compute(Object key,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.compute(key, remappingFunction);\n    }\n\n    @Override\n    public synchronized Object merge(Object key, Object value,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.merge(key, value, remappingFunction);\n    }\n\n    //\n    // Special Hashtable methods\n\n    @Override\n    protected void rehash() { /* no-op */ }\n\n    @Override\n    public synchronized Object clone() {\n        Properties clone \u003d (Properties) cloneHashtable();\n        clone.map \u003d new ConcurrentHashMap\u003c\u003e(map);\n        return clone;\n    }\n\n    //\n    // Hashtable serialization overrides\n    // (these should emit and consume Hashtable-compatible stream)\n\n    @Override\n    void writeHashtable(ObjectOutputStream s) throws IOException {\n        var map \u003d this.map;\n        List\u003cObject\u003e entryStack \u003d new ArrayList\u003c\u003e(map.size() * 2); // an estimate\n\n        for (Map.Entry\u003cObject, Object\u003e entry : map.entrySet()) {\n            entryStack.add(entry.getValue());\n            entryStack.add(entry.getKey());\n        }\n\n        // Write out the simulated threshold, loadfactor\n        float loadFactor \u003d 0.75f;\n        int count \u003d entryStack.size() / 2;\n        int length \u003d (int)(count / loadFactor) + (count / 20) + 3;\n        if (length \u003e count \u0026\u0026 (length \u0026 1) \u003d\u003d 0) {\n            length--;\n        }\n        synchronized (map) { // in case of multiple concurrent serializations\n            defaultWriteHashtable(s, length, loadFactor);\n        }\n\n        // Write out simulated length and real count of elements\n        s.writeInt(length);\n        s.writeInt(count);\n\n        // Write out the key/value objects from the stacked entries\n        for (int i \u003d entryStack.size() - 1; i \u003e\u003d 0; i--) {\n            s.writeObject(entryStack.get(i));\n        }\n    }\n\n    @Override\n    void readHashtable(ObjectInputStream s) throws IOException,\n            ClassNotFoundException {\n        // Read in the threshold and loadfactor\n        s.defaultReadObject();\n\n        // Read the original length of the array and number of elements\n        int origlength \u003d s.readInt();\n        int elements \u003d s.readInt();\n\n        // Validate # of elements\n        if (elements \u003c 0) {\n            throw new StreamCorruptedException(\"Illegal # of Elements: \" + elements);\n        }\n\n        // Constructing the backing map will lazily create an array when the first element is\n        // added, so check it before construction. Note that CHM\u0027s constructor takes a size\n        // that is the number of elements to be stored -- not the table size -- so it must be\n        // inflated by the default load factor of 0.75, then inflated to the next power of two.\n        // (CHM uses the same power-of-two computation as HashMap, and HashMap.tableSizeFor is\n        // accessible here.) Check Map.Entry[].class since it\u0027s the nearest public type to\n        // what is actually created.\n        SharedSecrets.getJavaObjectInputStreamAccess()\n                     .checkArray(s, Map.Entry[].class, HashMap.tableSizeFor((int)(elements / 0.75)));\n\n        // create CHM of appropriate capacity\n        var map \u003d new ConcurrentHashMap\u003c\u003e(elements);\n\n        // Read all the key/value objects\n        for (; elements \u003e 0; elements--) {\n            Object key \u003d s.readObject();\n            Object value \u003d s.readObject();\n            map.put(key, value);\n        }\n        this.map \u003d map;\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

Π°ΠΏΡ€. 25, 2024 2:42:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/util/Properties.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.04.25 14:42:01 INFO  compiling bestgame (1 scala source)
2024.04.25 14:42:01 INFO  time: compiled bestgame in 98ms
2024.04.25 14:42:44 INFO  compiling bestgame (1 scala source)
2024.04.25 14:42:44 INFO  time: compiled bestgame in 96ms
2024.04.25 14:42:47 INFO  compiling bestgame (1 scala source)
2024.04.25 14:42:47 INFO  time: compiled bestgame in 0.14s
2024.04.25 14:42:55 INFO  compiling bestgame (1 scala source)
2024.04.25 14:42:55 INFO  time: compiled bestgame in 0.11s
2024.04.25 14:43:02 INFO  compiling bestgame (1 scala source)
2024.04.25 14:43:02 INFO  time: compiled bestgame in 88ms
2024.04.25 14:43:10 INFO  compiling bestgame (1 scala source)
2024.04.25 14:43:10 INFO  time: compiled bestgame in 91ms
Π°ΠΏΡ€. 25, 2024 2:43:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5906
Π°ΠΏΡ€. 25, 2024 2:43:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5916
Π°ΠΏΡ€. 25, 2024 2:46:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5962
Π°ΠΏΡ€. 25, 2024 2:46:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5978
Π°ΠΏΡ€. 25, 2024 2:46:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5987
Π°ΠΏΡ€. 25, 2024 2:47:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5989
Π°ΠΏΡ€. 25, 2024 2:47:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6005
Π°ΠΏΡ€. 25, 2024 2:47:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6016
Π°ΠΏΡ€. 25, 2024 2:47:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6018
2024.04.25 14:47:21 INFO  compiling bestgame (1 scala source)
2024.04.25 14:47:24 INFO  time: compiled bestgame in 2.89s
Π°ΠΏΡ€. 25, 2024 2:47:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6056
Π°ΠΏΡ€. 25, 2024 2:47:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6070
Π°ΠΏΡ€. 25, 2024 2:47:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6080
Π°ΠΏΡ€. 25, 2024 2:47:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6090
Π°ΠΏΡ€. 25, 2024 2:48:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6099
2024.04.25 14:48:25 INFO  compiling bestgame (1 scala source)
2024.04.25 14:48:25 INFO  time: compiled bestgame in 0.3s
2024.04.25 14:48:26 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.25 14:48:28 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.25 14:48:28 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.25 14:48:29 INFO  compiling bestgame (1 scala source)
2024.04.25 14:48:29 INFO  time: compiled bestgame in 0.55s
2024.04.25 14:48:39 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.sql/java/sql/SQLException.java

Uri: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.sql/java/sql/SQLException.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1570)
```

Π°ΠΏΡ€. 25, 2024 2:48:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.sql/java/sql/SQLException.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.sql;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n\n/**\n * \u003cP\u003eAn exception that provides information on a database access\n * error or other errors.\n *\n * \u003cP\u003eEach {@code SQLException} provides several kinds of information:\n * \u003cUL\u003e\n *   \u003cLI\u003e a string describing the error.  This is used as the Java Exception\n *       message, available via the method {@code getMessage}.\n *   \u003cLI\u003e a \"SQLstate\" string, which follows either the XOPEN SQLstate conventions\n *        or the SQL:2003 conventions.\n *       The values of the SQLState string are described in the appropriate spec.\n *       The {@code DatabaseMetaData} method {@code getSQLStateType}\n *       can be used to discover whether the driver returns the XOPEN type or\n *       the SQL:2003 type.\n *   \u003cLI\u003e an integer error code that is specific to each vendor.  Normally this will\n *       be the actual error code returned by the underlying database.\n *   \u003cLI\u003e a chain to a next Exception.  This can be used to provide additional\n *       error information.\n *   \u003cLI\u003e the causal relationship, if any for this {@code SQLException}.\n * \u003c/UL\u003e\n *\n * @since 1.1\n */\npublic class SQLException extends java.lang.Exception\n                          implements Iterable\u003cThrowable\u003e {\n\n    /**\n     *  Constructs a {@code SQLException} object with a given\n     * {@code reason}, {@code SQLState}  and\n     * {@code vendorCode}.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method.\n     *\n     * @param reason a description of the exception\n     * @param SQLState an XOPEN or SQL:2003 code identifying the exception\n     * @param vendorCode a database vendor-specific exception code\n     */\n    public SQLException(String reason, String SQLState, int vendorCode) {\n        super(reason);\n        this.SQLState \u003d SQLState;\n        this.vendorCode \u003d vendorCode;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                DriverManager.println(\"SQLState(\" + SQLState +\n                                                \") vendor code(\" + vendorCode + \")\");\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason} and {@code SQLState}.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method. The vendor code\n     * is initialized to 0.\n     *\n     * @param reason a description of the exception\n     * @param SQLState an XOPEN or SQL:2003 code identifying the exception\n     */\n    public SQLException(String reason, String SQLState) {\n        super(reason);\n        this.SQLState \u003d SQLState;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n                DriverManager.println(\"SQLException: SQLState(\" + SQLState + \")\");\n            }\n        }\n    }\n\n    /**\n     *  Constructs a {@code SQLException} object with a given\n     * {@code reason}. The  {@code SQLState}  is initialized to\n     * {@code null} and the vendor code is initialized to 0.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method.\n     *\n     * @param reason a description of the exception\n     */\n    public SQLException(String reason) {\n        super(reason);\n        this.SQLState \u003d null;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object.\n     * The {@code reason}, {@code SQLState} are initialized\n     * to {@code null} and the vendor code is initialized to 0.\n     *\n     * The {@code cause} is not initialized, and may subsequently be\n     * initialized by a call to the\n     * {@link Throwable#initCause(java.lang.Throwable)} method.\n     *\n     */\n    public SQLException() {\n        super();\n        this.SQLState \u003d null;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     *  Constructs a {@code SQLException} object with a given\n     * {@code cause}.\n     * The {@code SQLState} is initialized\n     * to {@code null} and the vendor code is initialized to 0.\n     * The {@code reason}  is initialized to {@code null} if\n     * {@code cause\u003d\u003dnull} or to {@code cause.toString()} if\n     * {@code cause!\u003dnull}.\n     *\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the {@code getCause()} method);\n     * may be null indicating the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(Throwable cause) {\n        super(cause);\n\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason} and  {@code cause}.\n     * The {@code SQLState} is  initialized to {@code null}\n     * and the vendor code is initialized to 0.\n     *\n     * @param reason a description of the exception.\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the {@code getCause()} method);\n     * may be null indicating the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(String reason, Throwable cause) {\n        super(reason,cause);\n\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                    printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason}, {@code SQLState} and  {@code cause}.\n     * The vendor code is initialized to 0.\n     *\n     * @param reason a description of the exception.\n     * @param sqlState an XOPEN or SQL:2003 code identifying the exception\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the\n     * {@code getCause()} method); may be null indicating\n     *     the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(String reason, String sqlState, Throwable cause) {\n        super(reason,cause);\n\n        this.SQLState \u003d sqlState;\n        this.vendorCode \u003d 0;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                printStackTrace(DriverManager.getLogWriter());\n                DriverManager.println(\"SQLState(\" + SQLState + \")\");\n            }\n        }\n    }\n\n    /**\n     * Constructs a {@code SQLException} object with a given\n     * {@code reason}, {@code SQLState}, {@code vendorCode}\n     * and  {@code cause}.\n     *\n     * @param reason a description of the exception\n     * @param sqlState an XOPEN or SQL:2003 code identifying the exception\n     * @param vendorCode a database vendor-specific exception code\n     * @param cause the underlying reason for this {@code SQLException}\n     * (which is saved for later retrieval by the {@code getCause()} method);\n     * may be null indicating the cause is non-existent or unknown.\n     * @since 1.6\n     */\n    public SQLException(String reason, String sqlState, int vendorCode, Throwable cause) {\n        super(reason,cause);\n\n        this.SQLState \u003d sqlState;\n        this.vendorCode \u003d vendorCode;\n        if (!(this instanceof SQLWarning)) {\n            if (DriverManager.getLogWriter() !\u003d null) {\n                DriverManager.println(\"SQLState(\" + SQLState +\n                                                \") vendor code(\" + vendorCode + \")\");\n                printStackTrace(DriverManager.getLogWriter());\n            }\n        }\n    }\n\n    /**\n     * Retrieves the SQLState for this {@code SQLException} object.\n     *\n     * @return the SQLState value\n     */\n    public String getSQLState() {\n        return (SQLState);\n    }\n\n    /**\n     * Retrieves the vendor-specific exception code\n     * for this {@code SQLException} object.\n     *\n     * @return the vendor\u0027s error code\n     */\n    public int getErrorCode() {\n        return (vendorCode);\n    }\n\n    /**\n     * Retrieves the exception chained to this\n     * {@code SQLException} object by setNextException(SQLException ex).\n     *\n     * @return the next {@code SQLException} object in the chain;\n     *         {@code null} if there are none\n     * @see #setNextException\n     */\n    public SQLException getNextException() {\n        return (next);\n    }\n\n    /**\n     * Adds an {@code SQLException} object to the end of the chain.\n     *\n     * @param ex the new exception that will be added to the end of\n     *            the {@code SQLException} chain\n     * @see #getNextException\n     */\n    public void setNextException(SQLException ex) {\n\n        SQLException current \u003d this;\n        for(;;) {\n            SQLException next\u003dcurrent.next;\n            if (next !\u003d null) {\n                current \u003d next;\n                continue;\n            }\n\n            if (nextUpdater.compareAndSet(current,null,ex)) {\n                return;\n            }\n            current\u003dcurrent.next;\n        }\n    }\n\n    /**\n     * Returns an iterator over the chained SQLExceptions.  The iterator will\n     * be used to iterate over each SQLException and its underlying cause\n     * (if any).\n     *\n     * @return an iterator over the chained SQLExceptions and causes in the proper\n     * order\n     *\n     * @since 1.6\n     */\n    public Iterator\u003cThrowable\u003e iterator() {\n\n       return new Iterator\u003cThrowable\u003e() {\n\n           SQLException firstException \u003d SQLException.this;\n           SQLException nextException \u003d firstException.getNextException();\n           Throwable cause \u003d firstException.getCause();\n\n           public boolean hasNext() {\n               if(firstException !\u003d null || nextException !\u003d null || cause !\u003d null)\n                   return true;\n               return false;\n           }\n\n           public Throwable next() {\n               Throwable throwable \u003d null;\n               if(firstException !\u003d null){\n                   throwable \u003d firstException;\n                   firstException \u003d null;\n               }\n               else if(cause !\u003d null){\n                   throwable \u003d cause;\n                   cause \u003d cause.getCause();\n               }\n               else if(nextException !\u003d null){\n                   throwable \u003d nextException;\n                   cause \u003d nextException.getCause();\n                   nextException \u003d nextException.getNextException();\n               }\n               else\n                   throw new NoSuchElementException();\n               return throwable;\n           }\n\n           public void remove() {\n               throw new UnsupportedOperationException();\n           }\n\n       };\n\n    }\n\n    /**\n         * @serial\n         */\n    private String SQLState;\n\n        /**\n         * @serial\n         */\n    private int vendorCode;\n\n        /**\n         * @serial\n         */\n    private volatile SQLException next;\n\n    private static final AtomicReferenceFieldUpdater\u003cSQLException,SQLException\u003e nextUpdater \u003d\n            AtomicReferenceFieldUpdater.newUpdater(SQLException.class,SQLException.class,\"next\");\n\n    private static final long serialVersionUID \u003d 2135244094396331484L;\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

Π°ΠΏΡ€. 25, 2024 2:48:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.sql/java/sql/SQLException.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.sql/java/sql/SQLException.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.04.25 14:49:07 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\DataBaseManager.scala
scala.meta.tokenizers.TokenizeException: <input>:10: error: unclosed string literal
  ConnectionPool.singleton(s"jdbc:postgresql://${ENVars.DB.dbHost}:${/gamedb", "postgres", "123")
                                                                                               ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:560)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:379)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 14:49:26 INFO  compiling bestgame (1 scala source)
2024.04.25 14:49:26 INFO  time: compiled bestgame in 0.46s
Π°ΠΏΡ€. 25, 2024 2:49:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6466
2024.04.25 14:50:00 INFO  compiling bestgame (2 scala sources)
2024.04.25 14:50:00 INFO  time: compiled bestgame in 0.2s
2024.04.25 14:50:08 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\DataBaseManager.scala
scala.meta.tokenizers.TokenizeException: <input>:10: error: unclosed string literal
  ConnectionPool.singleton(s"jdbc:postgresql://${ENVars.DB.dbHost}:${ENVars.DB.dbPort}/$", "postgres", "123")
                                                                                                           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:560)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:379)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 14:50:39 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\DataBaseManager.scala
scala.meta.tokenizers.TokenizeException: <input>:10: error: unclosed string literal
  ConnectionPool.singleton(s"jdbc:postgresql://${ENVars.DB.dbHost}:${ENVars.DB.dbPort}/${ENVars.DB.dbName}", s"${ENVars.DB.dbUser}", "1)
                                                                                                                                     ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:560)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:379)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 14:50:52 INFO  compiling bestgame (1 scala source)
2024.04.25 14:50:52 INFO  time: compiled bestgame in 0.21s
2024.04.25 14:52:38 INFO  compiling bestgame (1 scala source)
2024.04.25 14:52:41 INFO  time: compiled bestgame in 2.82s
Π°ΠΏΡ€. 25, 2024 2:53:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6999
2024.04.25 14:53:48 INFO  compiling bestgame (1 scala source)
2024.04.25 14:53:48 INFO  time: compiled bestgame in 0.65s
Π°ΠΏΡ€. 25, 2024 2:55:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7033
2024.04.25 14:55:32 INFO  compiling bestgame (1 scala source)
2024.04.25 14:55:33 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 14:55:33 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 14:55:33 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 14:55:33 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 14:55:32 INFO  time: compiled bestgame in 0.22s
2024.04.25 14:58:07 INFO  running 'C:\Program Files\Java\jdk-22\bin\java.exe -Djline.terminal=jline.UnsupportedTerminal -Dsbt.log.noformat=true -Dfile.encoding=UTF-8 -jar C:\Users\yidtdr\AppData\Local\Temp\metals16663873048167941770\sbt-launch.jar -Dbloop.export-jar-classifiers=sources bloopInstall'
2024.04.25 14:58:09 INFO  [info] welcome to sbt 1.9.9 (Oracle Corporation Java 22)
2024.04.25 14:58:09 INFO  [info] loading settings for project bestgame-build-build from metals.sbt ...
2024.04.25 14:58:11 INFO  [info] loading project definition from D:\bestgame\project\project
2024.04.25 14:58:11 INFO  [info] loading settings for project bestgame-build from metals.sbt ...
2024.04.25 14:58:13 INFO  [info] loading project definition from D:\bestgame\project
2024.04.25 14:58:16 INFO  [success] Generated .bloop\bestgame-build.json
2024.04.25 14:58:16 INFO  [success] Total time: 3 s, completed 25 Π°ΠΏΡ€. 2024β€―Π³., 14:58:16
2024.04.25 14:58:16 INFO  [info] loading settings for project bestgame from build.sbt ...
2024.04.25 14:58:16 INFO  [info] set current project to my-zio-project (in build file:/D:/bestgame/)
2024.04.25 14:58:19 INFO  [success] Generated .bloop\bestgame.json
2024.04.25 14:58:19 INFO  [success] Generated .bloop\bestgame-test.json
2024.04.25 14:58:19 INFO  [success] Total time: 2 s, completed 25 Π°ΠΏΡ€. 2024β€―Π³., 14:58:19
2024.04.25 14:58:19 INFO  time: ran 'sbt bloopInstall' in 11s
2024.04.25 14:58:19 INFO  Disconnecting from Bloop session...
2024.04.25 14:58:19 INFO  Shut down connection with build server.
2024.04.25 14:58:19 INFO  Shut down connection with build server.
2024.04.25 14:58:19 INFO  Attempting to connect to the build server...
2024.04.25 14:58:19 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.25 14:58:19 INFO  Attempting to connect to the build server...
2024.04.25 14:58:19 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.25 14:58:19 INFO  time: Connected to build server in 0.23s
2024.04.25 14:58:19 INFO  Connected to Build server: Bloop v1.5.17
2024.04.25 14:58:21 INFO  compiling bestgame (1 scala source)
2024.04.25 14:58:21 INFO  time: compiled bestgame in 0.17s
2024.04.25 14:58:32 INFO  time: indexed workspace in 12s
2024.04.25 14:58:32 INFO  compiling bestgame (1 scala source)
2024.04.25 14:58:38 INFO  time: compiled bestgame in 6.49s
2024.04.25 14:58:38 INFO  compiling bestgame (1 scala source)
2024.04.25 14:58:38 INFO  time: compiled bestgame in 45ms
2024.04.25 14:58:55 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java

Uri: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1570)
```

Π°ΠΏΡ€. 25, 2024 2:58:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/util/Properties.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1995, 2021, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.util;\n\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.StreamCorruptedException;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\nimport jdk.internal.util.StaticProperty;\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.UTF_8;\n\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.ArraysSupport;\nimport jdk.internal.util.xml.PropertiesDefaultHandler;\n\n/**\n * The {@code Properties} class represents a persistent set of\n * properties. The {@code Properties} can be saved to a stream\n * or loaded from a stream. Each key and its corresponding value in\n * the property list is a string.\n * \u003cp\u003e\n * A property list can contain another property list as its\n * \"defaults\"; this second property list is searched if\n * the property key is not found in the original property list.\n * \u003cp\u003e\n * Because {@code Properties} inherits from {@code Hashtable}, the\n * {@code put} and {@code putAll} methods can be applied to a\n * {@code Properties} object.  Their use is strongly discouraged as they\n * allow the caller to insert entries whose keys or values are not\n * {@code Strings}.  The {@code setProperty} method should be used\n * instead.  If the {@code store} or {@code save} method is called\n * on a \"compromised\" {@code Properties} object that contains a\n * non-{@code String} key or value, the call will fail. Similarly,\n * the call to the {@code propertyNames} or {@code list} method\n * will fail if it is called on a \"compromised\" {@code Properties}\n * object that contains a non-{@code String} key.\n *\n * \u003cp\u003e\n * The iterators returned by the {@code iterator} method of this class\u0027s\n * \"collection views\" (that is, {@code entrySet()}, {@code keySet()}, and\n * {@code values()}) may not fail-fast (unlike the Hashtable implementation).\n * These iterators are guaranteed to traverse elements as they existed upon\n * construction exactly once, and may (but are not guaranteed to) reflect any\n * modifications subsequent to construction.\n * \u003cp\u003e\n * The {@link #load(java.io.Reader) load(Reader)} {@code /}\n * {@link #store(java.io.Writer, java.lang.String) store(Writer, String)}\n * methods load and store properties from and to a character based stream\n * in a simple line-oriented format specified below.\n *\n * The {@link #load(java.io.InputStream) load(InputStream)} {@code /}\n * {@link #store(java.io.OutputStream, java.lang.String) store(OutputStream, String)}\n * methods work the same way as the load(Reader)/store(Writer, String) pair, except\n * the input/output stream is encoded in ISO 8859-1 character encoding.\n * Characters that cannot be directly represented in this encoding can be written using\n * Unicode escapes as defined in section {@jls 3.3} of\n * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e;\n * only a single \u0027u\u0027 character is allowed in an escape\n * sequence.\n *\n * \u003cp\u003e The {@link #loadFromXML(InputStream)} and {@link\n * #storeToXML(OutputStream, String, String)} methods load and store properties\n * in a simple XML format.  By default the UTF-8 character encoding is used,\n * however a specific encoding may be specified if required. Implementations\n * are required to support UTF-8 and UTF-16 and may support other encodings.\n * An XML properties document has the following DOCTYPE declaration:\n *\n * \u003cpre\u003e\n * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n * \u003c/pre\u003e\n * Note that the system URI (http://java.sun.com/dtd/properties.dtd) is\n * \u003ci\u003enot\u003c/i\u003e accessed when exporting or importing properties; it merely\n * serves as a string to uniquely identify the DTD, which is:\n * \u003cpre\u003e\n *    \u0026lt;?xml version\u003d\"1.0\" encoding\u003d\"UTF-8\"?\u0026gt;\n *\n *    \u0026lt;!-- DTD for properties --\u0026gt;\n *\n *    \u0026lt;!ELEMENT properties ( comment?, entry* ) \u0026gt;\n *\n *    \u0026lt;!ATTLIST properties version CDATA #FIXED \"1.0\"\u0026gt;\n *\n *    \u0026lt;!ELEMENT comment (#PCDATA) \u0026gt;\n *\n *    \u0026lt;!ELEMENT entry (#PCDATA) \u0026gt;\n *\n *    \u0026lt;!ATTLIST entry key CDATA #REQUIRED\u0026gt;\n * \u003c/pre\u003e\n *\n * \u003cp\u003eThis class is thread-safe: multiple threads can share a single\n * {@code Properties} object without the need for external synchronization.\n *\n * @apiNote\n * The {@code Properties} class does not inherit the concept of a load factor\n * from its superclass, {@code Hashtable}.\n *\n * @author  Arthur van Hoff\n * @author  Michael McCloskey\n * @author  Xueming Shen\n * @since   1.0\n */\npublic class Properties extends Hashtable\u003cObject,Object\u003e {\n    /**\n     * use serialVersionUID from JDK 1.1.X for interoperability\n     */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d 4112578634029874840L;\n\n    private static final Unsafe UNSAFE \u003d Unsafe.getUnsafe();\n\n    /**\n     * A property list that contains default values for any keys not\n     * found in this property list.\n     *\n     * @serial\n     */\n    protected volatile Properties defaults;\n\n    /**\n     * Properties does not store values in its inherited Hashtable, but instead\n     * in an internal ConcurrentHashMap.  Synchronization is omitted from\n     * simple read operations.  Writes and bulk operations remain synchronized,\n     * as in Hashtable.\n     */\n    private transient volatile ConcurrentHashMap\u003cObject, Object\u003e map;\n\n    /**\n     * Creates an empty property list with no default values.\n     *\n     * @implNote The initial capacity of a {@code Properties} object created\n     * with this constructor is unspecified.\n     */\n    public Properties() {\n        this(null, 8);\n    }\n\n    /**\n     * Creates an empty property list with no default values, and with an\n     * initial size accommodating the specified number of elements without the\n     * need to dynamically resize.\n     *\n     * @param  initialCapacity the {@code Properties} will be sized to\n     *         accommodate this many elements\n     * @throws IllegalArgumentException if the initial capacity is less than\n     *         zero.\n     */\n    public Properties(int initialCapacity) {\n        this(null, initialCapacity);\n    }\n\n    /**\n     * Creates an empty property list with the specified defaults.\n     *\n     * @implNote The initial capacity of a {@code Properties} object created\n     * with this constructor is unspecified.\n     *\n     * @param   defaults   the defaults.\n     */\n    public Properties(Properties defaults) {\n        this(defaults, 8);\n    }\n\n    private Properties(Properties defaults, int initialCapacity) {\n        // use package-private constructor to\n        // initialize unused fields with dummy values\n        super((Void) null);\n        map \u003d new ConcurrentHashMap\u003c\u003e(initialCapacity);\n        this.defaults \u003d defaults;\n\n        // Ensure writes can\u0027t be reordered\n        UNSAFE.storeFence();\n    }\n\n    /**\n     * Calls the {@code Hashtable} method {@code put}. Provided for\n     * parallelism with the {@code getProperty} method. Enforces use of\n     * strings for property keys and values. The value returned is the\n     * result of the {@code Hashtable} call to {@code put}.\n     *\n     * @param key the key to be placed into this property list.\n     * @param value the value corresponding to {@code key}.\n     * @return     the previous value of the specified key in this property\n     *             list, or {@code null} if it did not have one.\n     * @see #getProperty\n     * @since    1.2\n     */\n    public synchronized Object setProperty(String key, String value) {\n        return put(key, value);\n    }\n\n\n    /**\n     * Reads a property list (key and element pairs) from the input\n     * character stream in a simple line-oriented format.\n     * \u003cp\u003e\n     * Properties are processed in terms of lines. There are two\n     * kinds of lines, \u003ci\u003enatural lines\u003c/i\u003e and \u003ci\u003elogical lines\u003c/i\u003e.\n     * A natural line is defined as a line of\n     * characters that is terminated either by a set of line terminator\n     * characters ({@code \\n} or {@code \\r} or {@code \\r\\n})\n     * or by the end of the stream. A natural line may be either a blank line,\n     * a comment line, or hold all or some of a key-element pair. A logical\n     * line holds all the data of a key-element pair, which may be spread\n     * out across several adjacent natural lines by escaping\n     * the line terminator sequence with a backslash character\n     * {@code \\}.  Note that a comment line cannot be extended\n     * in this manner; every natural line that is a comment must have\n     * its own comment indicator, as described below. Lines are read from\n     * input until the end of the stream is reached.\n     *\n     * \u003cp\u003e\n     * A natural line that contains only white space characters is\n     * considered blank and is ignored.  A comment line has an ASCII\n     * {@code \u0027#\u0027} or {@code \u0027!\u0027} as its first non-whitespace\n     * character; comment lines are also ignored and do not\n     * encode key-element information.  In addition to line\n     * terminators, this format considers the characters space\n     * ({@code \u0027 \u0027}, {@code \u0027\\u005Cu0020\u0027}), tab\n     * ({@code \u0027\\t\u0027}, {@code \u0027\\u005Cu0009\u0027}), and form feed\n     * ({@code \u0027\\f\u0027}, {@code \u0027\\u005Cu000C\u0027}) to be white\n     * space.\n     *\n     * \u003cp\u003e\n     * If a logical line is spread across several natural lines, the\n     * backslash escaping the line terminator sequence, the line\n     * terminator sequence, and any white space at the start of the\n     * following line have no effect on the key or element values.\n     * The remainder of the discussion of key and element parsing\n     * (when loading) will assume all the characters constituting\n     * the key and element appear on a single natural line after\n     * line continuation characters have been removed.  Note that\n     * it is \u003ci\u003enot\u003c/i\u003e sufficient to only examine the character\n     * preceding a line terminator sequence to decide if the line\n     * terminator is escaped; there must be an odd number of\n     * contiguous backslashes for the line terminator to be escaped.\n     * Since the input is processed from left to right, a\n     * non-zero even number of 2\u003ci\u003en\u003c/i\u003e contiguous backslashes\n     * before a line terminator (or elsewhere) encodes \u003ci\u003en\u003c/i\u003e\n     * backslashes after escape processing.\n     *\n     * \u003cp\u003e\n     * The key contains all of the characters in the line starting\n     * with the first non-whitespace character and up to, but not\n     * including, the first unescaped {@code \u0027\u003d\u0027},\n     * {@code \u0027:\u0027}, or white space character other than a line\n     * terminator. All of these key termination characters may be\n     * included in the key by escaping them with a preceding backslash\n     * character; for example,\u003cp\u003e\n     *\n     * {@code \\:\\\u003d}\u003cp\u003e\n     *\n     * would be the two-character key {@code \":\u003d\"}.  Line\n     * terminator characters can be included using {@code \\r} and\n     * {@code \\n} escape sequences.  Any white space after the\n     * key is skipped; if the first non-whitespace character after\n     * the key is {@code \u0027\u003d\u0027} or {@code \u0027:\u0027}, then it is\n     * ignored and any white space characters after it are also\n     * skipped.  All remaining characters on the line become part of\n     * the associated element string; if there are no remaining\n     * characters, the element is the empty string\n     * {@code \"\"}.  Once the raw character sequences\n     * constituting the key and element are identified, escape\n     * processing is performed as described above.\n     *\n     * \u003cp\u003e\n     * As an example, each of the following three lines specifies the key\n     * {@code \"Truth\"} and the associated element value\n     * {@code \"Beauty\"}:\n     * \u003cpre\u003e\n     * Truth \u003d Beauty\n     *  Truth:Beauty\n     * Truth                    :Beauty\n     * \u003c/pre\u003e\n     * As another example, the following three lines specify a single\n     * property:\n     * \u003cpre\u003e\n     * fruits                           apple, banana, pear, \\\n     *                                  cantaloupe, watermelon, \\\n     *                                  kiwi, mango\n     * \u003c/pre\u003e\n     * The key is {@code \"fruits\"} and the associated element is:\n     * \u003cpre\u003e\"apple, banana, pear, cantaloupe, watermelon, kiwi, mango\"\u003c/pre\u003e\n     * Note that a space appears before each {@code \\} so that a space\n     * will appear after each comma in the final result; the {@code \\},\n     * line terminator, and leading white space on the continuation line are\n     * merely discarded and are \u003ci\u003enot\u003c/i\u003e replaced by one or more other\n     * characters.\n     * \u003cp\u003e\n     * As a third example, the line:\n     * \u003cpre\u003echeeses\n     * \u003c/pre\u003e\n     * specifies that the key is {@code \"cheeses\"} and the associated\n     * element is the empty string {@code \"\"}.\n     * \u003cp\u003e\n     * \u003ca id\u003d\"unicodeescapes\"\u003e\u003c/a\u003e\n     * Characters in keys and elements can be represented in escape\n     * sequences similar to those used for character and string literals\n     * (see sections {@jls 3.3} and {@jls 3.10.6} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e).\n     *\n     * The differences from the character escape sequences and Unicode\n     * escapes used for characters and strings are:\n     *\n     * \u003cul\u003e\n     * \u003cli\u003e Octal escapes are not recognized.\n     *\n     * \u003cli\u003e The character sequence {@code \\b} does \u003ci\u003enot\u003c/i\u003e\n     * represent a backspace character.\n     *\n     * \u003cli\u003e The method does not treat a backslash character,\n     * {@code \\}, before a non-valid escape character as an\n     * error; the backslash is silently dropped.  For example, in a\n     * Java string the sequence {@code \"\\z\"} would cause a\n     * compile time error.  In contrast, this method silently drops\n     * the backslash.  Therefore, this method treats the two character\n     * sequence {@code \"\\b\"} as equivalent to the single\n     * character {@code \u0027b\u0027}.\n     *\n     * \u003cli\u003e Escapes are not necessary for single and double quotes;\n     * however, by the rule above, single and double quote characters\n     * preceded by a backslash still yield single and double quote\n     * characters, respectively.\n     *\n     * \u003cli\u003e Only a single \u0027u\u0027 character is allowed in a Unicode escape\n     * sequence.\n     *\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The specified stream remains open after this method returns.\n     *\n     * @param   reader   the input character stream.\n     * @throws  IOException  if an error occurred when reading from the\n     *          input stream.\n     * @throws  IllegalArgumentException if a malformed Unicode escape\n     *          appears in the input.\n     * @throws  NullPointerException if {@code reader} is null.\n     * @since   1.6\n     */\n    public synchronized void load(Reader reader) throws IOException {\n        Objects.requireNonNull(reader, \"reader parameter is null\");\n        load0(new LineReader(reader));\n    }\n\n    /**\n     * Reads a property list (key and element pairs) from the input\n     * byte stream. The input stream is in a simple line-oriented\n     * format as specified in\n     * {@link #load(java.io.Reader) load(Reader)} and is assumed to use\n     * the ISO 8859-1 character encoding; that is each byte is one Latin1\n     * character. Characters not in Latin1, and certain special characters,\n     * are represented in keys and elements using Unicode escapes as defined in\n     * section {@jls 3.3} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     * \u003cp\u003e\n     * The specified stream remains open after this method returns.\n     *\n     * @param      inStream   the input stream.\n     * @throws     IOException  if an error occurred when reading from the\n     *             input stream.\n     * @throws     IllegalArgumentException if the input stream contains a\n     *             malformed Unicode escape sequence.\n     * @throws     NullPointerException if {@code inStream} is null.\n     * @since 1.2\n     */\n    public synchronized void load(InputStream inStream) throws IOException {\n        Objects.requireNonNull(inStream, \"inStream parameter is null\");\n        load0(new LineReader(inStream));\n    }\n\n    private void load0(LineReader lr) throws IOException {\n        StringBuilder outBuffer \u003d new StringBuilder();\n        int limit;\n        int keyLen;\n        int valueStart;\n        boolean hasSep;\n        boolean precedingBackslash;\n\n        while ((limit \u003d lr.readLine()) \u003e\u003d 0) {\n            keyLen \u003d 0;\n            valueStart \u003d limit;\n            hasSep \u003d false;\n\n            //System.out.println(\"line\u003d\u003c\" + new String(lineBuf, 0, limit) + \"\u003e\");\n            precedingBackslash \u003d false;\n            while (keyLen \u003c limit) {\n                char c \u003d lr.lineBuf[keyLen];\n                //need check if escaped.\n                if ((c \u003d\u003d \u0027\u003d\u0027 ||  c \u003d\u003d \u0027:\u0027) \u0026\u0026 !precedingBackslash) {\n                    valueStart \u003d keyLen + 1;\n                    hasSep \u003d true;\n                    break;\n                } else if ((c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\t\u0027 ||  c \u003d\u003d \u0027\\f\u0027) \u0026\u0026 !precedingBackslash) {\n                    valueStart \u003d keyLen + 1;\n                    break;\n                }\n                if (c \u003d\u003d \u0027\\\\\u0027) {\n                    precedingBackslash \u003d !precedingBackslash;\n                } else {\n                    precedingBackslash \u003d false;\n                }\n                keyLen++;\n            }\n            while (valueStart \u003c limit) {\n                char c \u003d lr.lineBuf[valueStart];\n                if (c !\u003d \u0027 \u0027 \u0026\u0026 c !\u003d \u0027\\t\u0027 \u0026\u0026  c !\u003d \u0027\\f\u0027) {\n                    if (!hasSep \u0026\u0026 (c \u003d\u003d \u0027\u003d\u0027 ||  c \u003d\u003d \u0027:\u0027)) {\n                        hasSep \u003d true;\n                    } else {\n                        break;\n                    }\n                }\n                valueStart++;\n            }\n            String key \u003d loadConvert(lr.lineBuf, 0, keyLen, outBuffer);\n            String value \u003d loadConvert(lr.lineBuf, valueStart, limit - valueStart, outBuffer);\n            put(key, value);\n        }\n    }\n\n    /* Read in a \"logical line\" from an InputStream/Reader, skip all comment\n     * and blank lines and filter out those leading whitespace characters\n     * (\\u0020, \\u0009 and \\u000c) from the beginning of a \"natural line\".\n     * Method returns the char length of the \"logical line\" and stores\n     * the line in \"lineBuf\".\n     */\n    private static class LineReader {\n        LineReader(InputStream inStream) {\n            this.inStream \u003d inStream;\n            inByteBuf \u003d new byte[8192];\n        }\n\n        LineReader(Reader reader) {\n            this.reader \u003d reader;\n            inCharBuf \u003d new char[8192];\n        }\n\n        char[] lineBuf \u003d new char[1024];\n        private byte[] inByteBuf;\n        private char[] inCharBuf;\n        private int inLimit \u003d 0;\n        private int inOff \u003d 0;\n        private InputStream inStream;\n        private Reader reader;\n\n        int readLine() throws IOException {\n            // use locals to optimize for interpreted performance\n            int len \u003d 0;\n            int off \u003d inOff;\n            int limit \u003d inLimit;\n\n            boolean skipWhiteSpace \u003d true;\n            boolean appendedLineBegin \u003d false;\n            boolean precedingBackslash \u003d false;\n            boolean fromStream \u003d inStream !\u003d null;\n            byte[] byteBuf \u003d inByteBuf;\n            char[] charBuf \u003d inCharBuf;\n            char[] lineBuf \u003d this.lineBuf;\n            char c;\n\n            while (true) {\n                if (off \u003e\u003d limit) {\n                    inLimit \u003d limit \u003d fromStream ? inStream.read(byteBuf)\n                                                 : reader.read(charBuf);\n                    if (limit \u003c\u003d 0) {\n                        if (len \u003d\u003d 0) {\n                            return -1;\n                        }\n                        return precedingBackslash ? len - 1 : len;\n                    }\n                    off \u003d 0;\n                }\n\n                // (char)(byte \u0026 0xFF) is equivalent to calling a ISO8859-1 decoder.\n                c \u003d (fromStream) ? (char)(byteBuf[off++] \u0026 0xFF) : charBuf[off++];\n\n                if (skipWhiteSpace) {\n                    if (c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\t\u0027 || c \u003d\u003d \u0027\\f\u0027) {\n                        continue;\n                    }\n                    if (!appendedLineBegin \u0026\u0026 (c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\n\u0027)) {\n                        continue;\n                    }\n                    skipWhiteSpace \u003d false;\n                    appendedLineBegin \u003d false;\n\n                }\n                if (len \u003d\u003d 0) { // Still on a new logical line\n                    if (c \u003d\u003d \u0027#\u0027 || c \u003d\u003d \u0027!\u0027) {\n                        // Comment, quickly consume the rest of the line\n\n                        // When checking for new line characters a range check,\n                        // starting with the higher bound (\u0027\\r\u0027) means one less\n                        // branch in the common case.\n                        commentLoop: while (true) {\n                            if (fromStream) {\n                                byte b;\n                                while (off \u003c limit) {\n                                    b \u003d byteBuf[off++];\n                                    if (b \u003c\u003d \u0027\\r\u0027 \u0026\u0026 (b \u003d\u003d \u0027\\r\u0027 || b \u003d\u003d \u0027\\n\u0027))\n                                        break commentLoop;\n                                }\n                                if (off \u003d\u003d limit) {\n                                    inLimit \u003d limit \u003d inStream.read(byteBuf);\n                                    if (limit \u003c\u003d 0) { // EOF\n                                        return -1;\n                                    }\n                                    off \u003d 0;\n                                }\n                            } else {\n                                while (off \u003c limit) {\n                                    c \u003d charBuf[off++];\n                                    if (c \u003c\u003d \u0027\\r\u0027 \u0026\u0026 (c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\n\u0027))\n                                        break commentLoop;\n                                }\n                                if (off \u003d\u003d limit) {\n                                    inLimit \u003d limit \u003d reader.read(charBuf);\n                                    if (limit \u003c\u003d 0) { // EOF\n                                        return -1;\n                                    }\n                                    off \u003d 0;\n                                }\n                            }\n                        }\n                        skipWhiteSpace \u003d true;\n                        continue;\n                    }\n                }\n\n                if (c !\u003d \u0027\\n\u0027 \u0026\u0026 c !\u003d \u0027\\r\u0027) {\n                    lineBuf[len++] \u003d c;\n                    if (len \u003d\u003d lineBuf.length) {\n                        lineBuf \u003d new char[ArraysSupport.newLength(len, 1, len)];\n                        System.arraycopy(this.lineBuf, 0, lineBuf, 0, len);\n                        this.lineBuf \u003d lineBuf;\n                    }\n                    // flip the preceding backslash flag\n                    precedingBackslash \u003d (c \u003d\u003d \u0027\\\\\u0027) ? !precedingBackslash : false;\n                } else {\n                    // reached EOL\n                    if (len \u003d\u003d 0) {\n                        skipWhiteSpace \u003d true;\n                        continue;\n                    }\n                    if (off \u003e\u003d limit) {\n                        inLimit \u003d limit \u003d fromStream ? inStream.read(byteBuf)\n                                                     : reader.read(charBuf);\n                        off \u003d 0;\n                        if (limit \u003c\u003d 0) { // EOF\n                            return precedingBackslash ? len - 1 : len;\n                        }\n                    }\n                    if (precedingBackslash) {\n                        // backslash at EOL is not part of the line\n                        len -\u003d 1;\n                        // skip leading whitespace characters in the following line\n                        skipWhiteSpace \u003d true;\n                        appendedLineBegin \u003d true;\n                        precedingBackslash \u003d false;\n                        // take care not to include any subsequent \\n\n                        if (c \u003d\u003d \u0027\\r\u0027) {\n                            if (fromStream) {\n                                if (byteBuf[off] \u003d\u003d \u0027\\n\u0027) {\n                                    off++;\n                                }\n                            } else {\n                                if (charBuf[off] \u003d\u003d \u0027\\n\u0027) {\n                                    off++;\n                                }\n                            }\n                        }\n                    } else {\n                        inOff \u003d off;\n                        return len;\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n     * Converts encoded \u0026#92;uxxxx to unicode chars\n     * and changes special saved chars to their original forms\n     */\n    private String loadConvert(char[] in, int off, int len, StringBuilder out) {\n        char aChar;\n        int end \u003d off + len;\n        int start \u003d off;\n        while (off \u003c end) {\n            aChar \u003d in[off++];\n            if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                break;\n            }\n        }\n        if (off \u003d\u003d end) { // No backslash\n            return new String(in, start, len);\n        }\n\n        // backslash found at off - 1, reset the shared buffer, rewind offset\n        out.setLength(0);\n        off--;\n        out.append(in, start, off - start);\n\n        while (off \u003c end) {\n            aChar \u003d in[off++];\n            if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                // No need to bounds check since LineReader::readLine excludes\n                // unescaped \\s at the end of the line\n                aChar \u003d in[off++];\n                if(aChar \u003d\u003d \u0027u\u0027) {\n                    // Read the xxxx\n                    if (off \u003e end - 4)\n                        throw new IllegalArgumentException(\n                                     \"Malformed \\\\uxxxx encoding.\");\n                    int value \u003d 0;\n                    for (int i \u003d 0; i \u003c 4; i++) {\n                        aChar \u003d in[off++];\n                        value \u003d switch (aChar) {\n                            case \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027 -\u003e (value \u003c\u003c 4) + aChar - \u00270\u0027;\n                            case \u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027, \u0027f\u0027                     -\u003e (value \u003c\u003c 4) + 10 + aChar - \u0027a\u0027;\n                            case \u0027A\u0027, \u0027B\u0027, \u0027C\u0027, \u0027D\u0027, \u0027E\u0027, \u0027F\u0027                     -\u003e (value \u003c\u003c 4) + 10 + aChar - \u0027A\u0027;\n                            default -\u003e throw new IllegalArgumentException(\"Malformed \\\\uxxxx encoding.\");\n                        };\n                    }\n                    out.append((char)value);\n                } else {\n                    if (aChar \u003d\u003d \u0027t\u0027) aChar \u003d \u0027\\t\u0027;\n                    else if (aChar \u003d\u003d \u0027r\u0027) aChar \u003d \u0027\\r\u0027;\n                    else if (aChar \u003d\u003d \u0027n\u0027) aChar \u003d \u0027\\n\u0027;\n                    else if (aChar \u003d\u003d \u0027f\u0027) aChar \u003d \u0027\\f\u0027;\n                    out.append(aChar);\n                }\n            } else {\n                out.append(aChar);\n            }\n        }\n        return out.toString();\n    }\n\n    /*\n     * Converts unicodes to encoded \u0026#92;uxxxx and escapes\n     * special characters with a preceding slash\n     */\n    private String saveConvert(String theString,\n                               boolean escapeSpace,\n                               boolean escapeUnicode) {\n        int len \u003d theString.length();\n        int bufLen \u003d len * 2;\n        if (bufLen \u003c 0) {\n            bufLen \u003d Integer.MAX_VALUE;\n        }\n        StringBuilder outBuffer \u003d new StringBuilder(bufLen);\n        HexFormat hex \u003d HexFormat.of().withUpperCase();\n        for(int x\u003d0; x\u003clen; x++) {\n            char aChar \u003d theString.charAt(x);\n            // Handle common case first, selecting largest block that\n            // avoids the specials below\n            if ((aChar \u003e 61) \u0026\u0026 (aChar \u003c 127)) {\n                if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                    outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027\\\\\u0027);\n                    continue;\n                }\n                outBuffer.append(aChar);\n                continue;\n            }\n            switch(aChar) {\n                case \u0027 \u0027:\n                    if (x \u003d\u003d 0 || escapeSpace)\n                        outBuffer.append(\u0027\\\\\u0027);\n                    outBuffer.append(\u0027 \u0027);\n                    break;\n                case \u0027\\t\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027t\u0027);\n                          break;\n                case \u0027\\n\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027n\u0027);\n                          break;\n                case \u0027\\r\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027r\u0027);\n                          break;\n                case \u0027\\f\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027f\u0027);\n                          break;\n                case \u0027\u003d\u0027: // Fall through\n                case \u0027:\u0027: // Fall through\n                case \u0027#\u0027: // Fall through\n                case \u0027!\u0027:\n                    outBuffer.append(\u0027\\\\\u0027); outBuffer.append(aChar);\n                    break;\n                default:\n                    if (((aChar \u003c 0x0020) || (aChar \u003e 0x007e)) \u0026 escapeUnicode ) {\n                        outBuffer.append(\"\\\\u\");\n                        outBuffer.append(hex.toHexDigits(aChar));\n                    } else {\n                        outBuffer.append(aChar);\n                    }\n            }\n        }\n        return outBuffer.toString();\n    }\n\n    private static void writeComments(BufferedWriter bw, String comments)\n        throws IOException {\n        HexFormat hex \u003d HexFormat.of().withUpperCase();\n        bw.write(\"#\");\n        int len \u003d comments.length();\n        int current \u003d 0;\n        int last \u003d 0;\n        while (current \u003c len) {\n            char c \u003d comments.charAt(current);\n            if (c \u003e \u0027\\u00ff\u0027 || c \u003d\u003d \u0027\\n\u0027 || c \u003d\u003d \u0027\\r\u0027) {\n                if (last !\u003d current)\n                    bw.write(comments.substring(last, current));\n                if (c \u003e \u0027\\u00ff\u0027) {\n                    bw.write(\"\\\\u\");\n                    bw.write(hex.toHexDigits(c));\n                } else {\n                    bw.newLine();\n                    if (c \u003d\u003d \u0027\\r\u0027 \u0026\u0026\n                        current !\u003d len - 1 \u0026\u0026\n                        comments.charAt(current + 1) \u003d\u003d \u0027\\n\u0027) {\n                        current++;\n                    }\n                    if (current \u003d\u003d len - 1 ||\n                        (comments.charAt(current + 1) !\u003d \u0027#\u0027 \u0026\u0026\n                        comments.charAt(current + 1) !\u003d \u0027!\u0027))\n                        bw.write(\"#\");\n                }\n                last \u003d current + 1;\n            }\n            current++;\n        }\n        if (last !\u003d current)\n            bw.write(comments.substring(last, current));\n        bw.newLine();\n    }\n\n    /**\n     * Calls the {@code store(OutputStream out, String comments)} method\n     * and suppresses IOExceptions that were thrown.\n     *\n     * @deprecated This method does not throw an IOException if an I/O error\n     * occurs while saving the property list.  The preferred way to save a\n     * properties list is via the {@code store(OutputStream out,\n     * String comments)} method or the\n     * {@code storeToXML(OutputStream os, String comment)} method.\n     *\n     * @param   out      an output stream.\n     * @param   comments   a description of the property list.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not\n     *             {@code Strings}.\n     */\n    @Deprecated\n    public void save(OutputStream out, String comments)  {\n        try {\n            store(out, comments);\n        } catch (IOException e) {\n        }\n    }\n\n    /**\n     * Writes this property list (key and element pairs) in this\n     * {@code Properties} table to the output character stream in a\n     * format suitable for using the {@link #load(java.io.Reader) load(Reader)}\n     * method.\n     * \u003cp\u003e\n     * Properties from the defaults table of this {@code Properties}\n     * table (if any) are \u003ci\u003enot\u003c/i\u003e written out by this method.\n     * \u003cp\u003e\n     * If the comments argument is not null, then an ASCII {@code #}\n     * character, the comments string, and a line separator are first written\n     * to the output stream. Thus, the {@code comments} can serve as an\n     * identifying comment. Any one of a line feed ({@code \\n}), a carriage\n     * return ({@code \\r}), or a carriage return followed immediately by a line feed\n     * ({@code \\r\\n}) in comments is replaced by a\n     * {@link System#lineSeparator() line separator} and if the next\n     * character in comments is not character {@code #} or character {@code !} then\n     * an ASCII {@code #} is written out after that line separator.\n     * \u003cp\u003e\n     * If the {@systemProperty java.properties.date} is set on the command line\n     * and is non-empty (as determined by {@link String#isEmpty()  String.isEmpty}),\n     * a comment line is written as follows.\n     * First, a {@code #} character is written, followed by the contents\n     * of the property, followed by a line separator. Any line terminator characters\n     * in the value of the system property are treated the same way as noted above\n     * for the comments argument.\n     * If the system property is not set or is empty, a comment line is written\n     * as follows.\n     * First, a {@code #} character is written, followed by the current date and time\n     * formatted as if by the {@link Date#toString() Date.toString} method,\n     * followed by a line separator.\n     * \u003cp\u003e\n     * Then every entry in this {@code Properties} table is\n     * written out, one per line. For each entry the key string is\n     * written, then an ASCII {@code \u003d}, then the associated\n     * element string. For the key, all space characters are\n     * written with a preceding {@code \\} character.  For the\n     * element, leading space characters, but not embedded or trailing\n     * space characters, are written with a preceding {@code \\}\n     * character. The key and element characters {@code #},\n     * {@code !}, {@code \u003d}, and {@code :} are written\n     * with a preceding backslash to ensure that they are properly loaded.\n     * \u003cp\u003e\n     * After the entries have been written, the output stream is flushed.\n     * The output stream remains open after this method returns.\n     *\n     * @implSpec The keys and elements are written in the natural sort order\n     * of the keys in the {@code entrySet()} unless {@code entrySet()} is\n     * overridden by a subclass to return a different value than {@code super.entrySet()}.\n     *\n     * @param   writer      an output character stream writer.\n     * @param   comments   a description of the property list.\n     * @throws     IOException if writing this property list to the specified\n     *             output stream throws an {@code IOException}.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not {@code Strings}.\n     * @throws     NullPointerException  if {@code writer} is null.\n     * @since 1.6\n     */\n    public void store(Writer writer, String comments)\n        throws IOException\n    {\n        store0((writer instanceof BufferedWriter)?(BufferedWriter)writer\n                                                 : new BufferedWriter(writer),\n               comments,\n               false);\n    }\n\n    /**\n     * Writes this property list (key and element pairs) in this\n     * {@code Properties} table to the output stream in a format suitable\n     * for loading into a {@code Properties} table using the\n     * {@link #load(InputStream) load(InputStream)} method.\n     * \u003cp\u003e\n     * Properties from the defaults table of this {@code Properties}\n     * table (if any) are \u003ci\u003enot\u003c/i\u003e written out by this method.\n     * \u003cp\u003e\n     * This method outputs the comments, properties keys and values in\n     * the same format as specified in\n     * {@link #store(java.io.Writer, java.lang.String) store(Writer)},\n     * with the following differences:\n     * \u003cul\u003e\n     * \u003cli\u003eThe stream is written using the ISO 8859-1 character encoding.\n     *\n     * \u003cli\u003eCharacters not in Latin-1 in the comments are written as\n     * {@code \\u005Cu}\u003ci\u003exxxx\u003c/i\u003e for their appropriate unicode\n     * hexadecimal value \u003ci\u003exxxx\u003c/i\u003e.\n     *\n     * \u003cli\u003eCharacters less than {@code \\u005Cu0020} and characters greater\n     * than {@code \\u005Cu007E} in property keys or values are written\n     * as {@code \\u005Cu}\u003ci\u003exxxx\u003c/i\u003e for the appropriate hexadecimal\n     * value \u003ci\u003exxxx\u003c/i\u003e.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * After the entries have been written, the output stream is flushed.\n     * The output stream remains open after this method returns.\n     *\n     * @param   out      an output stream.\n     * @param   comments   a description of the property list.\n     * @throws     IOException if writing this property list to the specified\n     *             output stream throws an {@code IOException}.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not {@code Strings}.\n     * @throws     NullPointerException  if {@code out} is null.\n     * @since 1.2\n     */\n    public void store(OutputStream out, String comments)\n        throws IOException\n    {\n        store0(new BufferedWriter(new OutputStreamWriter(out, ISO_8859_1.INSTANCE)),\n               comments,\n               true);\n    }\n\n    private void store0(BufferedWriter bw, String comments, boolean escUnicode)\n        throws IOException\n    {\n        if (comments !\u003d null) {\n            writeComments(bw, comments);\n        }\n        writeDateComment(bw);\n\n        synchronized (this) {\n            @SuppressWarnings(\"unchecked\")\n            Collection\u003cMap.Entry\u003cString, String\u003e\u003e entries \u003d (Set\u003cMap.Entry\u003cString, String\u003e\u003e) (Set) entrySet();\n            // entrySet() can be overridden by subclasses. Here we check to see if\n            // the returned instance type is the one returned by the Properties.entrySet()\n            // implementation. If yes, then we sort those entries in the natural order\n            // of their key. Else, we consider that the subclassed implementation may\n            // potentially have returned a differently ordered entries and so we just\n            // use the iteration order of the returned instance.\n            if (entries instanceof Collections.SynchronizedSet\u003c?\u003e ss\n                    \u0026\u0026 ss.c instanceof EntrySet) {\n                entries \u003d new ArrayList\u003c\u003e(entries);\n                ((List\u003cMap.Entry\u003cString, String\u003e\u003e) entries).sort(Map.Entry.comparingByKey());\n            }\n            for (Map.Entry\u003cString, String\u003e e : entries) {\n                String key \u003d e.getKey();\n                String val \u003d e.getValue();\n                key \u003d saveConvert(key, true, escUnicode);\n                /* No need to escape embedded and trailing spaces for value, hence\n                 * pass false to flag.\n                 */\n                val \u003d saveConvert(val, false, escUnicode);\n                bw.write(key + \"\u003d\" + val);\n                bw.newLine();\n            }\n        }\n        bw.flush();\n    }\n\n    private static void writeDateComment(BufferedWriter bw) throws IOException {\n        // value of java.properties.date system property isn\u0027t sensitive\n        // and so doesn\u0027t need any security manager checks to make the value accessible\n        // to the callers\n        String sysPropVal \u003d StaticProperty.javaPropertiesDate();\n        if (sysPropVal !\u003d null \u0026\u0026 !sysPropVal.isEmpty()) {\n            writeComments(bw, sysPropVal);\n        } else {\n            bw.write(\"#\" + new Date());\n            bw.newLine();\n        }\n    }\n\n    /**\n     * Loads all of the properties represented by the XML document on the\n     * specified input stream into this properties table.\n     *\n     * \u003cp\u003eThe XML document must have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     * Furthermore, the document must satisfy the properties DTD described\n     * above.\n     *\n     * \u003cp\u003e An implementation is required to read XML documents that use the\n     * \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An implementation may\n     * support additional encodings.\n     *\n     * \u003cp\u003eThe specified stream is closed after this method returns.\n     *\n     * @param in the input stream from which to read the XML document.\n     * @throws IOException if reading from the specified input stream\n     *         results in an {@code IOException}.\n     * @throws java.io.UnsupportedEncodingException if the document\u0027s encoding\n     *         declaration can be read and it specifies an encoding that is not\n     *         supported\n     * @throws InvalidPropertiesFormatException Data on input stream does not\n     *         constitute a valid XML document with the mandated document type.\n     * @throws NullPointerException if {@code in} is null.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #storeToXML(OutputStream, String, String)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 1.5\n     */\n    public synchronized void loadFromXML(InputStream in)\n        throws IOException, InvalidPropertiesFormatException\n    {\n        Objects.requireNonNull(in);\n        PropertiesDefaultHandler handler \u003d new PropertiesDefaultHandler();\n        handler.load(this, in);\n        in.close();\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table.\n     *\n     * \u003cp\u003e An invocation of this method of the form {@code props.storeToXML(os,\n     * comment)} behaves in exactly the same way as the invocation\n     * {@code props.storeToXML(os, comment, \"UTF-8\");}.\n     *\n     * @param os the output stream on which to emit the XML document.\n     * @param comment a description of the property list, or {@code null}\n     *        if no comment is desired.\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws NullPointerException if {@code os} is null.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not\n     *         {@code Strings}.\n     * @see    #loadFromXML(InputStream)\n     * @since 1.5\n     */\n    public void storeToXML(OutputStream os, String comment)\n        throws IOException\n    {\n        storeToXML(os, comment, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table, using the specified encoding.\n     *\n     * \u003cp\u003eThe XML document will have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003eIf the specified comment is {@code null} then no comment\n     * will be stored in the document.\n     *\n     * \u003cp\u003e An implementation is required to support writing of XML documents\n     * that use the \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An\n     * implementation may support additional encodings.\n     *\n     * \u003cp\u003eThe specified stream remains open after this method returns.\n     *\n     * \u003cp\u003eThis method behaves the same as\n     * {@linkplain #storeToXML(OutputStream os, String comment, Charset charset)}\n     * except that it will {@linkplain java.nio.charset.Charset#forName look up the charset}\n     * using the given encoding name.\n     *\n     * @param os        the output stream on which to emit the XML document.\n     * @param comment   a description of the property list, or {@code null}\n     *                  if no comment is desired.\n     * @param  encoding the name of a supported\n     *                  \u003ca href\u003d\"../lang/package-summary.html#charenc\"\u003e\n     *                  character encoding\u003c/a\u003e\n     *\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws java.io.UnsupportedEncodingException if the encoding is not\n     *         supported by the implementation.\n     * @throws NullPointerException if {@code os} is {@code null},\n     *         or if {@code encoding} is {@code null}.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not {@code Strings}.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #loadFromXML(InputStream)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 1.5\n     */\n    public void storeToXML(OutputStream os, String comment, String encoding)\n        throws IOException {\n        Objects.requireNonNull(os);\n        Objects.requireNonNull(encoding);\n\n        try {\n            Charset charset \u003d Charset.forName(encoding);\n            storeToXML(os, comment, charset);\n        } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {\n            throw new UnsupportedEncodingException(encoding);\n        }\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table, using the specified encoding.\n     *\n     * \u003cp\u003eThe XML document will have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003eIf the specified comment is {@code null} then no comment\n     * will be stored in the document.\n     *\n     * \u003cp\u003e An implementation is required to support writing of XML documents\n     * that use the \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An\n     * implementation may support additional encodings.\n     *\n     * \u003cp\u003e Unmappable characters for the specified charset will be encoded as\n     * numeric character references.\n     *\n     * \u003cp\u003eThe specified stream remains open after this method returns.\n     *\n     * @param os        the output stream on which to emit the XML document.\n     * @param comment   a description of the property list, or {@code null}\n     *                  if no comment is desired.\n     * @param charset   the charset\n     *\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws NullPointerException if {@code os} or {@code charset} is {@code null}.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not {@code Strings}.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #loadFromXML(InputStream)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 10\n     */\n    public void storeToXML(OutputStream os, String comment, Charset charset)\n        throws IOException {\n        Objects.requireNonNull(os, \"OutputStream\");\n        Objects.requireNonNull(charset, \"Charset\");\n        PropertiesDefaultHandler handler \u003d new PropertiesDefaultHandler();\n        handler.store(this, os, comment, charset);\n    }\n\n    /**\n     * Searches for the property with the specified key in this property list.\n     * If the key is not found in this property list, the default property list,\n     * and its defaults, recursively, are then checked. The method returns\n     * {@code null} if the property is not found.\n     *\n     * @param   key   the property key.\n     * @return  the value in this property list with the specified key value.\n     * @see     #setProperty\n     * @see     #defaults\n     */\n    public String getProperty(String key) {\n        Object oval \u003d map.get(key);\n        String sval \u003d (oval instanceof String) ? (String)oval : null;\n        Properties defaults;\n        return ((sval \u003d\u003d null) \u0026\u0026 ((defaults \u003d this.defaults) !\u003d null)) ? defaults.getProperty(key) : sval;\n    }\n\n    /**\n     * Searches for the property with the specified key in this property list.\n     * If the key is not found in this property list, the default property list,\n     * and its defaults, recursively, are then checked. The method returns the\n     * default value argument if the property is not found.\n     *\n     * @param   key            the hashtable key.\n     * @param   defaultValue   a default value.\n     *\n     * @return  the value in this property list with the specified key value.\n     * @see     #setProperty\n     * @see     #defaults\n     */\n    public String getProperty(String key, String defaultValue) {\n        String val \u003d getProperty(key);\n        return (val \u003d\u003d null) ? defaultValue : val;\n    }\n\n    /**\n     * Returns an enumeration of all the keys in this property list,\n     * including distinct keys in the default property list if a key\n     * of the same name has not already been found from the main\n     * properties list.\n     *\n     * @return  an enumeration of all the keys in this property list, including\n     *          the keys in the default property list.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     * @see     java.util.Enumeration\n     * @see     java.util.Properties#defaults\n     * @see     #stringPropertyNames\n     */\n    public Enumeration\u003c?\u003e propertyNames() {\n        Hashtable\u003cString,Object\u003e h \u003d new Hashtable\u003c\u003e();\n        enumerate(h);\n        return h.keys();\n    }\n\n    /**\n     * Returns an unmodifiable set of keys from this property list\n     * where the key and its corresponding value are strings,\n     * including distinct keys in the default property list if a key\n     * of the same name has not already been found from the main\n     * properties list.  Properties whose key or value is not\n     * of type {@code String} are omitted.\n     * \u003cp\u003e\n     * The returned set is not backed by this {@code Properties} object.\n     * Changes to this {@code Properties} object are not reflected in the\n     * returned set.\n     *\n     * @return  an unmodifiable set of keys in this property list where\n     *          the key and its corresponding value are strings,\n     *          including the keys in the default property list.\n     * @see     java.util.Properties#defaults\n     * @since   1.6\n     */\n    public Set\u003cString\u003e stringPropertyNames() {\n        Map\u003cString, String\u003e h \u003d new HashMap\u003c\u003e();\n        enumerateStringProperties(h);\n        return Collections.unmodifiableSet(h.keySet());\n    }\n\n    /**\n     * Prints this property list out to the specified output stream.\n     * This method is useful for debugging.\n     *\n     * @param   out   an output stream.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     */\n    public void list(PrintStream out) {\n        out.println(\"-- listing properties --\");\n        Map\u003cString, Object\u003e h \u003d new HashMap\u003c\u003e();\n        enumerate(h);\n        for (Map.Entry\u003cString, Object\u003e e : h.entrySet()) {\n            String key \u003d e.getKey();\n            String val \u003d (String)e.getValue();\n            if (val.length() \u003e 40) {\n                val \u003d val.substring(0, 37) + \"...\";\n            }\n            out.println(key + \"\u003d\" + val);\n        }\n    }\n\n    /**\n     * Prints this property list out to the specified output stream.\n     * This method is useful for debugging.\n     *\n     * @param   out   an output stream.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     * @since   1.1\n     */\n    /*\n     * Rather than use an anonymous inner class to share common code, this\n     * method is duplicated in order to ensure that a non-1.1 compiler can\n     * compile this file.\n     */\n    public void list(PrintWriter out) {\n        out.println(\"-- listing properties --\");\n        Map\u003cString, Object\u003e h \u003d new HashMap\u003c\u003e();\n        enumerate(h);\n        for (Map.Entry\u003cString, Object\u003e e : h.entrySet()) {\n            String key \u003d e.getKey();\n            String val \u003d (String)e.getValue();\n            if (val.length() \u003e 40) {\n                val \u003d val.substring(0, 37) + \"...\";\n            }\n            out.println(key + \"\u003d\" + val);\n        }\n    }\n\n    /**\n     * Enumerates all key/value pairs into the specified Map.\n     * @param h the Map\n     * @throws ClassCastException if any of the property keys\n     *         is not of String type.\n     */\n    private void enumerate(Map\u003cString, Object\u003e h) {\n        if (defaults !\u003d null) {\n            defaults.enumerate(h);\n        }\n        for (Map.Entry\u003cObject, Object\u003e e : entrySet()) {\n            String key \u003d (String)e.getKey();\n            h.put(key, e.getValue());\n        }\n    }\n\n    /**\n     * Enumerates all key/value pairs into the specified Map\n     * and omits the property if the key or value is not a string.\n     * @param h the Map\n     */\n    private void enumerateStringProperties(Map\u003cString, String\u003e h) {\n        if (defaults !\u003d null) {\n            defaults.enumerateStringProperties(h);\n        }\n        for (Map.Entry\u003cObject, Object\u003e e : entrySet()) {\n            Object k \u003d e.getKey();\n            Object v \u003d e.getValue();\n            if (k instanceof String \u0026\u0026 v instanceof String) {\n                h.put((String) k, (String) v);\n            }\n        }\n    }\n\n    //\n    // Hashtable methods overridden and delegated to a ConcurrentHashMap instance\n\n    @Override\n    public int size() {\n        return map.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    @Override\n    public Enumeration\u003cObject\u003e keys() {\n        // CHM.keys() returns Iterator w/ remove() - instead wrap keySet()\n        return Collections.enumeration(map.keySet());\n    }\n\n    @Override\n    public Enumeration\u003cObject\u003e elements() {\n        // CHM.elements() returns Iterator w/ remove() - instead wrap values()\n        return Collections.enumeration(map.values());\n    }\n\n    @Override\n    public boolean contains(Object value) {\n        return map.contains(value);\n    }\n\n    @Override\n    public boolean containsValue(Object value) {\n        return map.containsValue(value);\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return map.containsKey(key);\n    }\n\n    @Override\n    public Object get(Object key) {\n        return map.get(key);\n    }\n\n    @Override\n    public synchronized Object put(Object key, Object value) {\n        return map.put(key, value);\n    }\n\n    @Override\n    public synchronized Object remove(Object key) {\n        return map.remove(key);\n    }\n\n    @Override\n    public synchronized void putAll(Map\u003c?, ?\u003e t) {\n        map.putAll(t);\n    }\n\n    @Override\n    public synchronized void clear() {\n        map.clear();\n    }\n\n    @Override\n    public synchronized String toString() {\n        return map.toString();\n    }\n\n    @Override\n    public Set\u003cObject\u003e keySet() {\n        return Collections.synchronizedSet(map.keySet(), this);\n    }\n\n    @Override\n    public Collection\u003cObject\u003e values() {\n        return Collections.synchronizedCollection(map.values(), this);\n    }\n\n    @Override\n    public Set\u003cMap.Entry\u003cObject, Object\u003e\u003e entrySet() {\n        return Collections.synchronizedSet(new EntrySet(map.entrySet()), this);\n    }\n\n    /*\n     * Properties.entrySet() should not support add/addAll, however\n     * ConcurrentHashMap.entrySet() provides add/addAll.  This class wraps the\n     * Set returned from CHM, changing add/addAll to throw UOE.\n     */\n    private static class EntrySet implements Set\u003cMap.Entry\u003cObject, Object\u003e\u003e {\n        private Set\u003cMap.Entry\u003cObject,Object\u003e\u003e entrySet;\n\n        private EntrySet(Set\u003cMap.Entry\u003cObject, Object\u003e\u003e entrySet) {\n            this.entrySet \u003d entrySet;\n        }\n\n        @Override public int size() { return entrySet.size(); }\n        @Override public boolean isEmpty() { return entrySet.isEmpty(); }\n        @Override public boolean contains(Object o) { return entrySet.contains(o); }\n        @Override public Object[] toArray() { return entrySet.toArray(); }\n        @Override public \u003cT\u003e T[] toArray(T[] a) { return entrySet.toArray(a); }\n        @Override public void clear() { entrySet.clear(); }\n        @Override public boolean remove(Object o) { return entrySet.remove(o); }\n\n        @Override\n        public boolean add(Map.Entry\u003cObject, Object\u003e e) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean addAll(Collection\u003c? extends Map.Entry\u003cObject, Object\u003e\u003e c) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean containsAll(Collection\u003c?\u003e c) {\n            return entrySet.containsAll(c);\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            return o \u003d\u003d this || entrySet.equals(o);\n        }\n\n        @Override\n        public int hashCode() {\n            return entrySet.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return entrySet.toString();\n        }\n\n        @Override\n        public boolean removeAll(Collection\u003c?\u003e c) {\n            return entrySet.removeAll(c);\n        }\n\n        @Override\n        public boolean retainAll(Collection\u003c?\u003e c) {\n            return entrySet.retainAll(c);\n        }\n\n        @Override\n        public Iterator\u003cMap.Entry\u003cObject, Object\u003e\u003e iterator() {\n            return entrySet.iterator();\n        }\n    }\n\n    @Override\n    public synchronized boolean equals(Object o) {\n        return map.equals(o);\n    }\n\n    @Override\n    public synchronized int hashCode() {\n        return map.hashCode();\n    }\n\n    @Override\n    public Object getOrDefault(Object key, Object defaultValue) {\n        return map.getOrDefault(key, defaultValue);\n    }\n\n    @Override\n    public synchronized void forEach(BiConsumer\u003c? super Object, ? super Object\u003e action) {\n        map.forEach(action);\n    }\n\n    @Override\n    public synchronized void replaceAll(BiFunction\u003c? super Object, ? super Object, ?\u003e function) {\n        map.replaceAll(function);\n    }\n\n    @Override\n    public synchronized Object putIfAbsent(Object key, Object value) {\n        return map.putIfAbsent(key, value);\n    }\n\n    @Override\n    public synchronized boolean remove(Object key, Object value) {\n        return map.remove(key, value);\n    }\n\n    @Override\n    public synchronized boolean replace(Object key, Object oldValue, Object newValue) {\n        return map.replace(key, oldValue, newValue);\n    }\n\n    @Override\n    public synchronized Object replace(Object key, Object value) {\n        return map.replace(key, value);\n    }\n\n    @Override\n    public synchronized Object computeIfAbsent(Object key,\n            Function\u003c? super Object, ?\u003e mappingFunction) {\n        return map.computeIfAbsent(key, mappingFunction);\n    }\n\n    @Override\n    public synchronized Object computeIfPresent(Object key,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.computeIfPresent(key, remappingFunction);\n    }\n\n    @Override\n    public synchronized Object compute(Object key,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.compute(key, remappingFunction);\n    }\n\n    @Override\n    public synchronized Object merge(Object key, Object value,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.merge(key, value, remappingFunction);\n    }\n\n    //\n    // Special Hashtable methods\n\n    @Override\n    protected void rehash() { /* no-op */ }\n\n    @Override\n    public synchronized Object clone() {\n        Properties clone \u003d (Properties) cloneHashtable();\n        clone.map \u003d new ConcurrentHashMap\u003c\u003e(map);\n        return clone;\n    }\n\n    //\n    // Hashtable serialization overrides\n    // (these should emit and consume Hashtable-compatible stream)\n\n    @Override\n    void writeHashtable(ObjectOutputStream s) throws IOException {\n        var map \u003d this.map;\n        List\u003cObject\u003e entryStack \u003d new ArrayList\u003c\u003e(map.size() * 2); // an estimate\n\n        for (Map.Entry\u003cObject, Object\u003e entry : map.entrySet()) {\n            entryStack.add(entry.getValue());\n            entryStack.add(entry.getKey());\n        }\n\n        // Write out the simulated threshold, loadfactor\n        float loadFactor \u003d 0.75f;\n        int count \u003d entryStack.size() / 2;\n        int length \u003d (int)(count / loadFactor) + (count / 20) + 3;\n        if (length \u003e count \u0026\u0026 (length \u0026 1) \u003d\u003d 0) {\n            length--;\n        }\n        synchronized (map) { // in case of multiple concurrent serializations\n            defaultWriteHashtable(s, length, loadFactor);\n        }\n\n        // Write out simulated length and real count of elements\n        s.writeInt(length);\n        s.writeInt(count);\n\n        // Write out the key/value objects from the stacked entries\n        for (int i \u003d entryStack.size() - 1; i \u003e\u003d 0; i--) {\n            s.writeObject(entryStack.get(i));\n        }\n    }\n\n    @Override\n    void readHashtable(ObjectInputStream s) throws IOException,\n            ClassNotFoundException {\n        // Read in the threshold and loadfactor\n        s.defaultReadObject();\n\n        // Read the original length of the array and number of elements\n        int origlength \u003d s.readInt();\n        int elements \u003d s.readInt();\n\n        // Validate # of elements\n        if (elements \u003c 0) {\n            throw new StreamCorruptedException(\"Illegal # of Elements: \" + elements);\n        }\n\n        // Constructing the backing map will lazily create an array when the first element is\n        // added, so check it before construction. Note that CHM\u0027s constructor takes a size\n        // that is the number of elements to be stored -- not the table size -- so it must be\n        // inflated by the default load factor of 0.75, then inflated to the next power of two.\n        // (CHM uses the same power-of-two computation as HashMap, and HashMap.tableSizeFor is\n        // accessible here.) Check Map.Entry[].class since it\u0027s the nearest public type to\n        // what is actually created.\n        SharedSecrets.getJavaObjectInputStreamAccess()\n                     .checkArray(s, Map.Entry[].class, HashMap.tableSizeFor((int)(elements / 0.75)));\n\n        // create CHM of appropriate capacity\n        var map \u003d new ConcurrentHashMap\u003c\u003e(elements);\n\n        // Read all the key/value objects\n        for (; elements \u003e 0; elements--) {\n            Object key \u003d s.readObject();\n            Object value \u003d s.readObject();\n            map.put(key, value);\n        }\n        this.map \u003d map;\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

Π°ΠΏΡ€. 25, 2024 2:58:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/util/Properties.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.04.25 14:58:57 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java

Uri: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1570)
```

Π°ΠΏΡ€. 25, 2024 2:58:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/util/Properties.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1995, 2021, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.util;\n\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.StreamCorruptedException;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\nimport jdk.internal.util.StaticProperty;\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.UTF_8;\n\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.ArraysSupport;\nimport jdk.internal.util.xml.PropertiesDefaultHandler;\n\n/**\n * The {@code Properties} class represents a persistent set of\n * properties. The {@code Properties} can be saved to a stream\n * or loaded from a stream. Each key and its corresponding value in\n * the property list is a string.\n * \u003cp\u003e\n * A property list can contain another property list as its\n * \"defaults\"; this second property list is searched if\n * the property key is not found in the original property list.\n * \u003cp\u003e\n * Because {@code Properties} inherits from {@code Hashtable}, the\n * {@code put} and {@code putAll} methods can be applied to a\n * {@code Properties} object.  Their use is strongly discouraged as they\n * allow the caller to insert entries whose keys or values are not\n * {@code Strings}.  The {@code setProperty} method should be used\n * instead.  If the {@code store} or {@code save} method is called\n * on a \"compromised\" {@code Properties} object that contains a\n * non-{@code String} key or value, the call will fail. Similarly,\n * the call to the {@code propertyNames} or {@code list} method\n * will fail if it is called on a \"compromised\" {@code Properties}\n * object that contains a non-{@code String} key.\n *\n * \u003cp\u003e\n * The iterators returned by the {@code iterator} method of this class\u0027s\n * \"collection views\" (that is, {@code entrySet()}, {@code keySet()}, and\n * {@code values()}) may not fail-fast (unlike the Hashtable implementation).\n * These iterators are guaranteed to traverse elements as they existed upon\n * construction exactly once, and may (but are not guaranteed to) reflect any\n * modifications subsequent to construction.\n * \u003cp\u003e\n * The {@link #load(java.io.Reader) load(Reader)} {@code /}\n * {@link #store(java.io.Writer, java.lang.String) store(Writer, String)}\n * methods load and store properties from and to a character based stream\n * in a simple line-oriented format specified below.\n *\n * The {@link #load(java.io.InputStream) load(InputStream)} {@code /}\n * {@link #store(java.io.OutputStream, java.lang.String) store(OutputStream, String)}\n * methods work the same way as the load(Reader)/store(Writer, String) pair, except\n * the input/output stream is encoded in ISO 8859-1 character encoding.\n * Characters that cannot be directly represented in this encoding can be written using\n * Unicode escapes as defined in section {@jls 3.3} of\n * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e;\n * only a single \u0027u\u0027 character is allowed in an escape\n * sequence.\n *\n * \u003cp\u003e The {@link #loadFromXML(InputStream)} and {@link\n * #storeToXML(OutputStream, String, String)} methods load and store properties\n * in a simple XML format.  By default the UTF-8 character encoding is used,\n * however a specific encoding may be specified if required. Implementations\n * are required to support UTF-8 and UTF-16 and may support other encodings.\n * An XML properties document has the following DOCTYPE declaration:\n *\n * \u003cpre\u003e\n * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n * \u003c/pre\u003e\n * Note that the system URI (http://java.sun.com/dtd/properties.dtd) is\n * \u003ci\u003enot\u003c/i\u003e accessed when exporting or importing properties; it merely\n * serves as a string to uniquely identify the DTD, which is:\n * \u003cpre\u003e\n *    \u0026lt;?xml version\u003d\"1.0\" encoding\u003d\"UTF-8\"?\u0026gt;\n *\n *    \u0026lt;!-- DTD for properties --\u0026gt;\n *\n *    \u0026lt;!ELEMENT properties ( comment?, entry* ) \u0026gt;\n *\n *    \u0026lt;!ATTLIST properties version CDATA #FIXED \"1.0\"\u0026gt;\n *\n *    \u0026lt;!ELEMENT comment (#PCDATA) \u0026gt;\n *\n *    \u0026lt;!ELEMENT entry (#PCDATA) \u0026gt;\n *\n *    \u0026lt;!ATTLIST entry key CDATA #REQUIRED\u0026gt;\n * \u003c/pre\u003e\n *\n * \u003cp\u003eThis class is thread-safe: multiple threads can share a single\n * {@code Properties} object without the need for external synchronization.\n *\n * @apiNote\n * The {@code Properties} class does not inherit the concept of a load factor\n * from its superclass, {@code Hashtable}.\n *\n * @author  Arthur van Hoff\n * @author  Michael McCloskey\n * @author  Xueming Shen\n * @since   1.0\n */\npublic class Properties extends Hashtable\u003cObject,Object\u003e {\n    /**\n     * use serialVersionUID from JDK 1.1.X for interoperability\n     */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d 4112578634029874840L;\n\n    private static final Unsafe UNSAFE \u003d Unsafe.getUnsafe();\n\n    /**\n     * A property list that contains default values for any keys not\n     * found in this property list.\n     *\n     * @serial\n     */\n    protected volatile Properties defaults;\n\n    /**\n     * Properties does not store values in its inherited Hashtable, but instead\n     * in an internal ConcurrentHashMap.  Synchronization is omitted from\n     * simple read operations.  Writes and bulk operations remain synchronized,\n     * as in Hashtable.\n     */\n    private transient volatile ConcurrentHashMap\u003cObject, Object\u003e map;\n\n    /**\n     * Creates an empty property list with no default values.\n     *\n     * @implNote The initial capacity of a {@code Properties} object created\n     * with this constructor is unspecified.\n     */\n    public Properties() {\n        this(null, 8);\n    }\n\n    /**\n     * Creates an empty property list with no default values, and with an\n     * initial size accommodating the specified number of elements without the\n     * need to dynamically resize.\n     *\n     * @param  initialCapacity the {@code Properties} will be sized to\n     *         accommodate this many elements\n     * @throws IllegalArgumentException if the initial capacity is less than\n     *         zero.\n     */\n    public Properties(int initialCapacity) {\n        this(null, initialCapacity);\n    }\n\n    /**\n     * Creates an empty property list with the specified defaults.\n     *\n     * @implNote The initial capacity of a {@code Properties} object created\n     * with this constructor is unspecified.\n     *\n     * @param   defaults   the defaults.\n     */\n    public Properties(Properties defaults) {\n        this(defaults, 8);\n    }\n\n    private Properties(Properties defaults, int initialCapacity) {\n        // use package-private constructor to\n        // initialize unused fields with dummy values\n        super((Void) null);\n        map \u003d new ConcurrentHashMap\u003c\u003e(initialCapacity);\n        this.defaults \u003d defaults;\n\n        // Ensure writes can\u0027t be reordered\n        UNSAFE.storeFence();\n    }\n\n    /**\n     * Calls the {@code Hashtable} method {@code put}. Provided for\n     * parallelism with the {@code getProperty} method. Enforces use of\n     * strings for property keys and values. The value returned is the\n     * result of the {@code Hashtable} call to {@code put}.\n     *\n     * @param key the key to be placed into this property list.\n     * @param value the value corresponding to {@code key}.\n     * @return     the previous value of the specified key in this property\n     *             list, or {@code null} if it did not have one.\n     * @see #getProperty\n     * @since    1.2\n     */\n    public synchronized Object setProperty(String key, String value) {\n        return put(key, value);\n    }\n\n\n    /**\n     * Reads a property list (key and element pairs) from the input\n     * character stream in a simple line-oriented format.\n     * \u003cp\u003e\n     * Properties are processed in terms of lines. There are two\n     * kinds of lines, \u003ci\u003enatural lines\u003c/i\u003e and \u003ci\u003elogical lines\u003c/i\u003e.\n     * A natural line is defined as a line of\n     * characters that is terminated either by a set of line terminator\n     * characters ({@code \\n} or {@code \\r} or {@code \\r\\n})\n     * or by the end of the stream. A natural line may be either a blank line,\n     * a comment line, or hold all or some of a key-element pair. A logical\n     * line holds all the data of a key-element pair, which may be spread\n     * out across several adjacent natural lines by escaping\n     * the line terminator sequence with a backslash character\n     * {@code \\}.  Note that a comment line cannot be extended\n     * in this manner; every natural line that is a comment must have\n     * its own comment indicator, as described below. Lines are read from\n     * input until the end of the stream is reached.\n     *\n     * \u003cp\u003e\n     * A natural line that contains only white space characters is\n     * considered blank and is ignored.  A comment line has an ASCII\n     * {@code \u0027#\u0027} or {@code \u0027!\u0027} as its first non-whitespace\n     * character; comment lines are also ignored and do not\n     * encode key-element information.  In addition to line\n     * terminators, this format considers the characters space\n     * ({@code \u0027 \u0027}, {@code \u0027\\u005Cu0020\u0027}), tab\n     * ({@code \u0027\\t\u0027}, {@code \u0027\\u005Cu0009\u0027}), and form feed\n     * ({@code \u0027\\f\u0027}, {@code \u0027\\u005Cu000C\u0027}) to be white\n     * space.\n     *\n     * \u003cp\u003e\n     * If a logical line is spread across several natural lines, the\n     * backslash escaping the line terminator sequence, the line\n     * terminator sequence, and any white space at the start of the\n     * following line have no effect on the key or element values.\n     * The remainder of the discussion of key and element parsing\n     * (when loading) will assume all the characters constituting\n     * the key and element appear on a single natural line after\n     * line continuation characters have been removed.  Note that\n     * it is \u003ci\u003enot\u003c/i\u003e sufficient to only examine the character\n     * preceding a line terminator sequence to decide if the line\n     * terminator is escaped; there must be an odd number of\n     * contiguous backslashes for the line terminator to be escaped.\n     * Since the input is processed from left to right, a\n     * non-zero even number of 2\u003ci\u003en\u003c/i\u003e contiguous backslashes\n     * before a line terminator (or elsewhere) encodes \u003ci\u003en\u003c/i\u003e\n     * backslashes after escape processing.\n     *\n     * \u003cp\u003e\n     * The key contains all of the characters in the line starting\n     * with the first non-whitespace character and up to, but not\n     * including, the first unescaped {@code \u0027\u003d\u0027},\n     * {@code \u0027:\u0027}, or white space character other than a line\n     * terminator. All of these key termination characters may be\n     * included in the key by escaping them with a preceding backslash\n     * character; for example,\u003cp\u003e\n     *\n     * {@code \\:\\\u003d}\u003cp\u003e\n     *\n     * would be the two-character key {@code \":\u003d\"}.  Line\n     * terminator characters can be included using {@code \\r} and\n     * {@code \\n} escape sequences.  Any white space after the\n     * key is skipped; if the first non-whitespace character after\n     * the key is {@code \u0027\u003d\u0027} or {@code \u0027:\u0027}, then it is\n     * ignored and any white space characters after it are also\n     * skipped.  All remaining characters on the line become part of\n     * the associated element string; if there are no remaining\n     * characters, the element is the empty string\n     * {@code \"\"}.  Once the raw character sequences\n     * constituting the key and element are identified, escape\n     * processing is performed as described above.\n     *\n     * \u003cp\u003e\n     * As an example, each of the following three lines specifies the key\n     * {@code \"Truth\"} and the associated element value\n     * {@code \"Beauty\"}:\n     * \u003cpre\u003e\n     * Truth \u003d Beauty\n     *  Truth:Beauty\n     * Truth                    :Beauty\n     * \u003c/pre\u003e\n     * As another example, the following three lines specify a single\n     * property:\n     * \u003cpre\u003e\n     * fruits                           apple, banana, pear, \\\n     *                                  cantaloupe, watermelon, \\\n     *                                  kiwi, mango\n     * \u003c/pre\u003e\n     * The key is {@code \"fruits\"} and the associated element is:\n     * \u003cpre\u003e\"apple, banana, pear, cantaloupe, watermelon, kiwi, mango\"\u003c/pre\u003e\n     * Note that a space appears before each {@code \\} so that a space\n     * will appear after each comma in the final result; the {@code \\},\n     * line terminator, and leading white space on the continuation line are\n     * merely discarded and are \u003ci\u003enot\u003c/i\u003e replaced by one or more other\n     * characters.\n     * \u003cp\u003e\n     * As a third example, the line:\n     * \u003cpre\u003echeeses\n     * \u003c/pre\u003e\n     * specifies that the key is {@code \"cheeses\"} and the associated\n     * element is the empty string {@code \"\"}.\n     * \u003cp\u003e\n     * \u003ca id\u003d\"unicodeescapes\"\u003e\u003c/a\u003e\n     * Characters in keys and elements can be represented in escape\n     * sequences similar to those used for character and string literals\n     * (see sections {@jls 3.3} and {@jls 3.10.6} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e).\n     *\n     * The differences from the character escape sequences and Unicode\n     * escapes used for characters and strings are:\n     *\n     * \u003cul\u003e\n     * \u003cli\u003e Octal escapes are not recognized.\n     *\n     * \u003cli\u003e The character sequence {@code \\b} does \u003ci\u003enot\u003c/i\u003e\n     * represent a backspace character.\n     *\n     * \u003cli\u003e The method does not treat a backslash character,\n     * {@code \\}, before a non-valid escape character as an\n     * error; the backslash is silently dropped.  For example, in a\n     * Java string the sequence {@code \"\\z\"} would cause a\n     * compile time error.  In contrast, this method silently drops\n     * the backslash.  Therefore, this method treats the two character\n     * sequence {@code \"\\b\"} as equivalent to the single\n     * character {@code \u0027b\u0027}.\n     *\n     * \u003cli\u003e Escapes are not necessary for single and double quotes;\n     * however, by the rule above, single and double quote characters\n     * preceded by a backslash still yield single and double quote\n     * characters, respectively.\n     *\n     * \u003cli\u003e Only a single \u0027u\u0027 character is allowed in a Unicode escape\n     * sequence.\n     *\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The specified stream remains open after this method returns.\n     *\n     * @param   reader   the input character stream.\n     * @throws  IOException  if an error occurred when reading from the\n     *          input stream.\n     * @throws  IllegalArgumentException if a malformed Unicode escape\n     *          appears in the input.\n     * @throws  NullPointerException if {@code reader} is null.\n     * @since   1.6\n     */\n    public synchronized void load(Reader reader) throws IOException {\n        Objects.requireNonNull(reader, \"reader parameter is null\");\n        load0(new LineReader(reader));\n    }\n\n    /**\n     * Reads a property list (key and element pairs) from the input\n     * byte stream. The input stream is in a simple line-oriented\n     * format as specified in\n     * {@link #load(java.io.Reader) load(Reader)} and is assumed to use\n     * the ISO 8859-1 character encoding; that is each byte is one Latin1\n     * character. Characters not in Latin1, and certain special characters,\n     * are represented in keys and elements using Unicode escapes as defined in\n     * section {@jls 3.3} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     * \u003cp\u003e\n     * The specified stream remains open after this method returns.\n     *\n     * @param      inStream   the input stream.\n     * @throws     IOException  if an error occurred when reading from the\n     *             input stream.\n     * @throws     IllegalArgumentException if the input stream contains a\n     *             malformed Unicode escape sequence.\n     * @throws     NullPointerException if {@code inStream} is null.\n     * @since 1.2\n     */\n    public synchronized void load(InputStream inStream) throws IOException {\n        Objects.requireNonNull(inStream, \"inStream parameter is null\");\n        load0(new LineReader(inStream));\n    }\n\n    private void load0(LineReader lr) throws IOException {\n        StringBuilder outBuffer \u003d new StringBuilder();\n        int limit;\n        int keyLen;\n        int valueStart;\n        boolean hasSep;\n        boolean precedingBackslash;\n\n        while ((limit \u003d lr.readLine()) \u003e\u003d 0) {\n            keyLen \u003d 0;\n            valueStart \u003d limit;\n            hasSep \u003d false;\n\n            //System.out.println(\"line\u003d\u003c\" + new String(lineBuf, 0, limit) + \"\u003e\");\n            precedingBackslash \u003d false;\n            while (keyLen \u003c limit) {\n                char c \u003d lr.lineBuf[keyLen];\n                //need check if escaped.\n                if ((c \u003d\u003d \u0027\u003d\u0027 ||  c \u003d\u003d \u0027:\u0027) \u0026\u0026 !precedingBackslash) {\n                    valueStart \u003d keyLen + 1;\n                    hasSep \u003d true;\n                    break;\n                } else if ((c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\t\u0027 ||  c \u003d\u003d \u0027\\f\u0027) \u0026\u0026 !precedingBackslash) {\n                    valueStart \u003d keyLen + 1;\n                    break;\n                }\n                if (c \u003d\u003d \u0027\\\\\u0027) {\n                    precedingBackslash \u003d !precedingBackslash;\n                } else {\n                    precedingBackslash \u003d false;\n                }\n                keyLen++;\n            }\n            while (valueStart \u003c limit) {\n                char c \u003d lr.lineBuf[valueStart];\n                if (c !\u003d \u0027 \u0027 \u0026\u0026 c !\u003d \u0027\\t\u0027 \u0026\u0026  c !\u003d \u0027\\f\u0027) {\n                    if (!hasSep \u0026\u0026 (c \u003d\u003d \u0027\u003d\u0027 ||  c \u003d\u003d \u0027:\u0027)) {\n                        hasSep \u003d true;\n                    } else {\n                        break;\n                    }\n                }\n                valueStart++;\n            }\n            String key \u003d loadConvert(lr.lineBuf, 0, keyLen, outBuffer);\n            String value \u003d loadConvert(lr.lineBuf, valueStart, limit - valueStart, outBuffer);\n            put(key, value);\n        }\n    }\n\n    /* Read in a \"logical line\" from an InputStream/Reader, skip all comment\n     * and blank lines and filter out those leading whitespace characters\n     * (\\u0020, \\u0009 and \\u000c) from the beginning of a \"natural line\".\n     * Method returns the char length of the \"logical line\" and stores\n     * the line in \"lineBuf\".\n     */\n    private static class LineReader {\n        LineReader(InputStream inStream) {\n            this.inStream \u003d inStream;\n            inByteBuf \u003d new byte[8192];\n        }\n\n        LineReader(Reader reader) {\n            this.reader \u003d reader;\n            inCharBuf \u003d new char[8192];\n        }\n\n        char[] lineBuf \u003d new char[1024];\n        private byte[] inByteBuf;\n        private char[] inCharBuf;\n        private int inLimit \u003d 0;\n        private int inOff \u003d 0;\n        private InputStream inStream;\n        private Reader reader;\n\n        int readLine() throws IOException {\n            // use locals to optimize for interpreted performance\n            int len \u003d 0;\n            int off \u003d inOff;\n            int limit \u003d inLimit;\n\n            boolean skipWhiteSpace \u003d true;\n            boolean appendedLineBegin \u003d false;\n            boolean precedingBackslash \u003d false;\n            boolean fromStream \u003d inStream !\u003d null;\n            byte[] byteBuf \u003d inByteBuf;\n            char[] charBuf \u003d inCharBuf;\n            char[] lineBuf \u003d this.lineBuf;\n            char c;\n\n            while (true) {\n                if (off \u003e\u003d limit) {\n                    inLimit \u003d limit \u003d fromStream ? inStream.read(byteBuf)\n                                                 : reader.read(charBuf);\n                    if (limit \u003c\u003d 0) {\n                        if (len \u003d\u003d 0) {\n                            return -1;\n                        }\n                        return precedingBackslash ? len - 1 : len;\n                    }\n                    off \u003d 0;\n                }\n\n                // (char)(byte \u0026 0xFF) is equivalent to calling a ISO8859-1 decoder.\n                c \u003d (fromStream) ? (char)(byteBuf[off++] \u0026 0xFF) : charBuf[off++];\n\n                if (skipWhiteSpace) {\n                    if (c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\t\u0027 || c \u003d\u003d \u0027\\f\u0027) {\n                        continue;\n                    }\n                    if (!appendedLineBegin \u0026\u0026 (c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\n\u0027)) {\n                        continue;\n                    }\n                    skipWhiteSpace \u003d false;\n                    appendedLineBegin \u003d false;\n\n                }\n                if (len \u003d\u003d 0) { // Still on a new logical line\n                    if (c \u003d\u003d \u0027#\u0027 || c \u003d\u003d \u0027!\u0027) {\n                        // Comment, quickly consume the rest of the line\n\n                        // When checking for new line characters a range check,\n                        // starting with the higher bound (\u0027\\r\u0027) means one less\n                        // branch in the common case.\n                        commentLoop: while (true) {\n                            if (fromStream) {\n                                byte b;\n                                while (off \u003c limit) {\n                                    b \u003d byteBuf[off++];\n                                    if (b \u003c\u003d \u0027\\r\u0027 \u0026\u0026 (b \u003d\u003d \u0027\\r\u0027 || b \u003d\u003d \u0027\\n\u0027))\n                                        break commentLoop;\n                                }\n                                if (off \u003d\u003d limit) {\n                                    inLimit \u003d limit \u003d inStream.read(byteBuf);\n                                    if (limit \u003c\u003d 0) { // EOF\n                                        return -1;\n                                    }\n                                    off \u003d 0;\n                                }\n                            } else {\n                                while (off \u003c limit) {\n                                    c \u003d charBuf[off++];\n                                    if (c \u003c\u003d \u0027\\r\u0027 \u0026\u0026 (c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\n\u0027))\n                                        break commentLoop;\n                                }\n                                if (off \u003d\u003d limit) {\n                                    inLimit \u003d limit \u003d reader.read(charBuf);\n                                    if (limit \u003c\u003d 0) { // EOF\n                                        return -1;\n                                    }\n                                    off \u003d 0;\n                                }\n                            }\n                        }\n                        skipWhiteSpace \u003d true;\n                        continue;\n                    }\n                }\n\n                if (c !\u003d \u0027\\n\u0027 \u0026\u0026 c !\u003d \u0027\\r\u0027) {\n                    lineBuf[len++] \u003d c;\n                    if (len \u003d\u003d lineBuf.length) {\n                        lineBuf \u003d new char[ArraysSupport.newLength(len, 1, len)];\n                        System.arraycopy(this.lineBuf, 0, lineBuf, 0, len);\n                        this.lineBuf \u003d lineBuf;\n                    }\n                    // flip the preceding backslash flag\n                    precedingBackslash \u003d (c \u003d\u003d \u0027\\\\\u0027) ? !precedingBackslash : false;\n                } else {\n                    // reached EOL\n                    if (len \u003d\u003d 0) {\n                        skipWhiteSpace \u003d true;\n                        continue;\n                    }\n                    if (off \u003e\u003d limit) {\n                        inLimit \u003d limit \u003d fromStream ? inStream.read(byteBuf)\n                                                     : reader.read(charBuf);\n                        off \u003d 0;\n                        if (limit \u003c\u003d 0) { // EOF\n                            return precedingBackslash ? len - 1 : len;\n                        }\n                    }\n                    if (precedingBackslash) {\n                        // backslash at EOL is not part of the line\n                        len -\u003d 1;\n                        // skip leading whitespace characters in the following line\n                        skipWhiteSpace \u003d true;\n                        appendedLineBegin \u003d true;\n                        precedingBackslash \u003d false;\n                        // take care not to include any subsequent \\n\n                        if (c \u003d\u003d \u0027\\r\u0027) {\n                            if (fromStream) {\n                                if (byteBuf[off] \u003d\u003d \u0027\\n\u0027) {\n                                    off++;\n                                }\n                            } else {\n                                if (charBuf[off] \u003d\u003d \u0027\\n\u0027) {\n                                    off++;\n                                }\n                            }\n                        }\n                    } else {\n                        inOff \u003d off;\n                        return len;\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n     * Converts encoded \u0026#92;uxxxx to unicode chars\n     * and changes special saved chars to their original forms\n     */\n    private String loadConvert(char[] in, int off, int len, StringBuilder out) {\n        char aChar;\n        int end \u003d off + len;\n        int start \u003d off;\n        while (off \u003c end) {\n            aChar \u003d in[off++];\n            if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                break;\n            }\n        }\n        if (off \u003d\u003d end) { // No backslash\n            return new String(in, start, len);\n        }\n\n        // backslash found at off - 1, reset the shared buffer, rewind offset\n        out.setLength(0);\n        off--;\n        out.append(in, start, off - start);\n\n        while (off \u003c end) {\n            aChar \u003d in[off++];\n            if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                // No need to bounds check since LineReader::readLine excludes\n                // unescaped \\s at the end of the line\n                aChar \u003d in[off++];\n                if(aChar \u003d\u003d \u0027u\u0027) {\n                    // Read the xxxx\n                    if (off \u003e end - 4)\n                        throw new IllegalArgumentException(\n                                     \"Malformed \\\\uxxxx encoding.\");\n                    int value \u003d 0;\n                    for (int i \u003d 0; i \u003c 4; i++) {\n                        aChar \u003d in[off++];\n                        value \u003d switch (aChar) {\n                            case \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027 -\u003e (value \u003c\u003c 4) + aChar - \u00270\u0027;\n                            case \u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027, \u0027f\u0027                     -\u003e (value \u003c\u003c 4) + 10 + aChar - \u0027a\u0027;\n                            case \u0027A\u0027, \u0027B\u0027, \u0027C\u0027, \u0027D\u0027, \u0027E\u0027, \u0027F\u0027                     -\u003e (value \u003c\u003c 4) + 10 + aChar - \u0027A\u0027;\n                            default -\u003e throw new IllegalArgumentException(\"Malformed \\\\uxxxx encoding.\");\n                        };\n                    }\n                    out.append((char)value);\n                } else {\n                    if (aChar \u003d\u003d \u0027t\u0027) aChar \u003d \u0027\\t\u0027;\n                    else if (aChar \u003d\u003d \u0027r\u0027) aChar \u003d \u0027\\r\u0027;\n                    else if (aChar \u003d\u003d \u0027n\u0027) aChar \u003d \u0027\\n\u0027;\n                    else if (aChar \u003d\u003d \u0027f\u0027) aChar \u003d \u0027\\f\u0027;\n                    out.append(aChar);\n                }\n            } else {\n                out.append(aChar);\n            }\n        }\n        return out.toString();\n    }\n\n    /*\n     * Converts unicodes to encoded \u0026#92;uxxxx and escapes\n     * special characters with a preceding slash\n     */\n    private String saveConvert(String theString,\n                               boolean escapeSpace,\n                               boolean escapeUnicode) {\n        int len \u003d theString.length();\n        int bufLen \u003d len * 2;\n        if (bufLen \u003c 0) {\n            bufLen \u003d Integer.MAX_VALUE;\n        }\n        StringBuilder outBuffer \u003d new StringBuilder(bufLen);\n        HexFormat hex \u003d HexFormat.of().withUpperCase();\n        for(int x\u003d0; x\u003clen; x++) {\n            char aChar \u003d theString.charAt(x);\n            // Handle common case first, selecting largest block that\n            // avoids the specials below\n            if ((aChar \u003e 61) \u0026\u0026 (aChar \u003c 127)) {\n                if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                    outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027\\\\\u0027);\n                    continue;\n                }\n                outBuffer.append(aChar);\n                continue;\n            }\n            switch(aChar) {\n                case \u0027 \u0027:\n                    if (x \u003d\u003d 0 || escapeSpace)\n                        outBuffer.append(\u0027\\\\\u0027);\n                    outBuffer.append(\u0027 \u0027);\n                    break;\n                case \u0027\\t\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027t\u0027);\n                          break;\n                case \u0027\\n\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027n\u0027);\n                          break;\n                case \u0027\\r\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027r\u0027);\n                          break;\n                case \u0027\\f\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027f\u0027);\n                          break;\n                case \u0027\u003d\u0027: // Fall through\n                case \u0027:\u0027: // Fall through\n                case \u0027#\u0027: // Fall through\n                case \u0027!\u0027:\n                    outBuffer.append(\u0027\\\\\u0027); outBuffer.append(aChar);\n                    break;\n                default:\n                    if (((aChar \u003c 0x0020) || (aChar \u003e 0x007e)) \u0026 escapeUnicode ) {\n                        outBuffer.append(\"\\\\u\");\n                        outBuffer.append(hex.toHexDigits(aChar));\n                    } else {\n                        outBuffer.append(aChar);\n                    }\n            }\n        }\n        return outBuffer.toString();\n    }\n\n    private static void writeComments(BufferedWriter bw, String comments)\n        throws IOException {\n        HexFormat hex \u003d HexFormat.of().withUpperCase();\n        bw.write(\"#\");\n        int len \u003d comments.length();\n        int current \u003d 0;\n        int last \u003d 0;\n        while (current \u003c len) {\n            char c \u003d comments.charAt(current);\n            if (c \u003e \u0027\\u00ff\u0027 || c \u003d\u003d \u0027\\n\u0027 || c \u003d\u003d \u0027\\r\u0027) {\n                if (last !\u003d current)\n                    bw.write(comments.substring(last, current));\n                if (c \u003e \u0027\\u00ff\u0027) {\n                    bw.write(\"\\\\u\");\n                    bw.write(hex.toHexDigits(c));\n                } else {\n                    bw.newLine();\n                    if (c \u003d\u003d \u0027\\r\u0027 \u0026\u0026\n                        current !\u003d len - 1 \u0026\u0026\n                        comments.charAt(current + 1) \u003d\u003d \u0027\\n\u0027) {\n                        current++;\n                    }\n                    if (current \u003d\u003d len - 1 ||\n                        (comments.charAt(current + 1) !\u003d \u0027#\u0027 \u0026\u0026\n                        comments.charAt(current + 1) !\u003d \u0027!\u0027))\n                        bw.write(\"#\");\n                }\n                last \u003d current + 1;\n            }\n            current++;\n        }\n        if (last !\u003d current)\n            bw.write(comments.substring(last, current));\n        bw.newLine();\n    }\n\n    /**\n     * Calls the {@code store(OutputStream out, String comments)} method\n     * and suppresses IOExceptions that were thrown.\n     *\n     * @deprecated This method does not throw an IOException if an I/O error\n     * occurs while saving the property list.  The preferred way to save a\n     * properties list is via the {@code store(OutputStream out,\n     * String comments)} method or the\n     * {@code storeToXML(OutputStream os, String comment)} method.\n     *\n     * @param   out      an output stream.\n     * @param   comments   a description of the property list.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not\n     *             {@code Strings}.\n     */\n    @Deprecated\n    public void save(OutputStream out, String comments)  {\n        try {\n            store(out, comments);\n        } catch (IOException e) {\n        }\n    }\n\n    /**\n     * Writes this property list (key and element pairs) in this\n     * {@code Properties} table to the output character stream in a\n     * format suitable for using the {@link #load(java.io.Reader) load(Reader)}\n     * method.\n     * \u003cp\u003e\n     * Properties from the defaults table of this {@code Properties}\n     * table (if any) are \u003ci\u003enot\u003c/i\u003e written out by this method.\n     * \u003cp\u003e\n     * If the comments argument is not null, then an ASCII {@code #}\n     * character, the comments string, and a line separator are first written\n     * to the output stream. Thus, the {@code comments} can serve as an\n     * identifying comment. Any one of a line feed ({@code \\n}), a carriage\n     * return ({@code \\r}), or a carriage return followed immediately by a line feed\n     * ({@code \\r\\n}) in comments is replaced by a\n     * {@link System#lineSeparator() line separator} and if the next\n     * character in comments is not character {@code #} or character {@code !} then\n     * an ASCII {@code #} is written out after that line separator.\n     * \u003cp\u003e\n     * If the {@systemProperty java.properties.date} is set on the command line\n     * and is non-empty (as determined by {@link String#isEmpty()  String.isEmpty}),\n     * a comment line is written as follows.\n     * First, a {@code #} character is written, followed by the contents\n     * of the property, followed by a line separator. Any line terminator characters\n     * in the value of the system property are treated the same way as noted above\n     * for the comments argument.\n     * If the system property is not set or is empty, a comment line is written\n     * as follows.\n     * First, a {@code #} character is written, followed by the current date and time\n     * formatted as if by the {@link Date#toString() Date.toString} method,\n     * followed by a line separator.\n     * \u003cp\u003e\n     * Then every entry in this {@code Properties} table is\n     * written out, one per line. For each entry the key string is\n     * written, then an ASCII {@code \u003d}, then the associated\n     * element string. For the key, all space characters are\n     * written with a preceding {@code \\} character.  For the\n     * element, leading space characters, but not embedded or trailing\n     * space characters, are written with a preceding {@code \\}\n     * character. The key and element characters {@code #},\n     * {@code !}, {@code \u003d}, and {@code :} are written\n     * with a preceding backslash to ensure that they are properly loaded.\n     * \u003cp\u003e\n     * After the entries have been written, the output stream is flushed.\n     * The output stream remains open after this method returns.\n     *\n     * @implSpec The keys and elements are written in the natural sort order\n     * of the keys in the {@code entrySet()} unless {@code entrySet()} is\n     * overridden by a subclass to return a different value than {@code super.entrySet()}.\n     *\n     * @param   writer      an output character stream writer.\n     * @param   comments   a description of the property list.\n     * @throws     IOException if writing this property list to the specified\n     *             output stream throws an {@code IOException}.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not {@code Strings}.\n     * @throws     NullPointerException  if {@code writer} is null.\n     * @since 1.6\n     */\n    public void store(Writer writer, String comments)\n        throws IOException\n    {\n        store0((writer instanceof BufferedWriter)?(BufferedWriter)writer\n                                                 : new BufferedWriter(writer),\n               comments,\n               false);\n    }\n\n    /**\n     * Writes this property list (key and element pairs) in this\n     * {@code Properties} table to the output stream in a format suitable\n     * for loading into a {@code Properties} table using the\n     * {@link #load(InputStream) load(InputStream)} method.\n     * \u003cp\u003e\n     * Properties from the defaults table of this {@code Properties}\n     * table (if any) are \u003ci\u003enot\u003c/i\u003e written out by this method.\n     * \u003cp\u003e\n     * This method outputs the comments, properties keys and values in\n     * the same format as specified in\n     * {@link #store(java.io.Writer, java.lang.String) store(Writer)},\n     * with the following differences:\n     * \u003cul\u003e\n     * \u003cli\u003eThe stream is written using the ISO 8859-1 character encoding.\n     *\n     * \u003cli\u003eCharacters not in Latin-1 in the comments are written as\n     * {@code \\u005Cu}\u003ci\u003exxxx\u003c/i\u003e for their appropriate unicode\n     * hexadecimal value \u003ci\u003exxxx\u003c/i\u003e.\n     *\n     * \u003cli\u003eCharacters less than {@code \\u005Cu0020} and characters greater\n     * than {@code \\u005Cu007E} in property keys or values are written\n     * as {@code \\u005Cu}\u003ci\u003exxxx\u003c/i\u003e for the appropriate hexadecimal\n     * value \u003ci\u003exxxx\u003c/i\u003e.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * After the entries have been written, the output stream is flushed.\n     * The output stream remains open after this method returns.\n     *\n     * @param   out      an output stream.\n     * @param   comments   a description of the property list.\n     * @throws     IOException if writing this property list to the specified\n     *             output stream throws an {@code IOException}.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not {@code Strings}.\n     * @throws     NullPointerException  if {@code out} is null.\n     * @since 1.2\n     */\n    public void store(OutputStream out, String comments)\n        throws IOException\n    {\n        store0(new BufferedWriter(new OutputStreamWriter(out, ISO_8859_1.INSTANCE)),\n               comments,\n               true);\n    }\n\n    private void store0(BufferedWriter bw, String comments, boolean escUnicode)\n        throws IOException\n    {\n        if (comments !\u003d null) {\n            writeComments(bw, comments);\n        }\n        writeDateComment(bw);\n\n        synchronized (this) {\n            @SuppressWarnings(\"unchecked\")\n            Collection\u003cMap.Entry\u003cString, String\u003e\u003e entries \u003d (Set\u003cMap.Entry\u003cString, String\u003e\u003e) (Set) entrySet();\n            // entrySet() can be overridden by subclasses. Here we check to see if\n            // the returned instance type is the one returned by the Properties.entrySet()\n            // implementation. If yes, then we sort those entries in the natural order\n            // of their key. Else, we consider that the subclassed implementation may\n            // potentially have returned a differently ordered entries and so we just\n            // use the iteration order of the returned instance.\n            if (entries instanceof Collections.SynchronizedSet\u003c?\u003e ss\n                    \u0026\u0026 ss.c instanceof EntrySet) {\n                entries \u003d new ArrayList\u003c\u003e(entries);\n                ((List\u003cMap.Entry\u003cString, String\u003e\u003e) entries).sort(Map.Entry.comparingByKey());\n            }\n            for (Map.Entry\u003cString, String\u003e e : entries) {\n                String key \u003d e.getKey();\n                String val \u003d e.getValue();\n                key \u003d saveConvert(key, true, escUnicode);\n                /* No need to escape embedded and trailing spaces for value, hence\n                 * pass false to flag.\n                 */\n                val \u003d saveConvert(val, false, escUnicode);\n                bw.write(key + \"\u003d\" + val);\n                bw.newLine();\n            }\n        }\n        bw.flush();\n    }\n\n    private static void writeDateComment(BufferedWriter bw) throws IOException {\n        // value of java.properties.date system property isn\u0027t sensitive\n        // and so doesn\u0027t need any security manager checks to make the value accessible\n        // to the callers\n        String sysPropVal \u003d StaticProperty.javaPropertiesDate();\n        if (sysPropVal !\u003d null \u0026\u0026 !sysPropVal.isEmpty()) {\n            writeComments(bw, sysPropVal);\n        } else {\n            bw.write(\"#\" + new Date());\n            bw.newLine();\n        }\n    }\n\n    /**\n     * Loads all of the properties represented by the XML document on the\n     * specified input stream into this properties table.\n     *\n     * \u003cp\u003eThe XML document must have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     * Furthermore, the document must satisfy the properties DTD described\n     * above.\n     *\n     * \u003cp\u003e An implementation is required to read XML documents that use the\n     * \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An implementation may\n     * support additional encodings.\n     *\n     * \u003cp\u003eThe specified stream is closed after this method returns.\n     *\n     * @param in the input stream from which to read the XML document.\n     * @throws IOException if reading from the specified input stream\n     *         results in an {@code IOException}.\n     * @throws java.io.UnsupportedEncodingException if the document\u0027s encoding\n     *         declaration can be read and it specifies an encoding that is not\n     *         supported\n     * @throws InvalidPropertiesFormatException Data on input stream does not\n     *         constitute a valid XML document with the mandated document type.\n     * @throws NullPointerException if {@code in} is null.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #storeToXML(OutputStream, String, String)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 1.5\n     */\n    public synchronized void loadFromXML(InputStream in)\n        throws IOException, InvalidPropertiesFormatException\n    {\n        Objects.requireNonNull(in);\n        PropertiesDefaultHandler handler \u003d new PropertiesDefaultHandler();\n        handler.load(this, in);\n        in.close();\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table.\n     *\n     * \u003cp\u003e An invocation of this method of the form {@code props.storeToXML(os,\n     * comment)} behaves in exactly the same way as the invocation\n     * {@code props.storeToXML(os, comment, \"UTF-8\");}.\n     *\n     * @param os the output stream on which to emit the XML document.\n     * @param comment a description of the property list, or {@code null}\n     *        if no comment is desired.\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws NullPointerException if {@code os} is null.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not\n     *         {@code Strings}.\n     * @see    #loadFromXML(InputStream)\n     * @since 1.5\n     */\n    public void storeToXML(OutputStream os, String comment)\n        throws IOException\n    {\n        storeToXML(os, comment, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table, using the specified encoding.\n     *\n     * \u003cp\u003eThe XML document will have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003eIf the specified comment is {@code null} then no comment\n     * will be stored in the document.\n     *\n     * \u003cp\u003e An implementation is required to support writing of XML documents\n     * that use the \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An\n     * implementation may support additional encodings.\n     *\n     * \u003cp\u003eThe specified stream remains open after this method returns.\n     *\n     * \u003cp\u003eThis method behaves the same as\n     * {@linkplain #storeToXML(OutputStream os, String comment, Charset charset)}\n     * except that it will {@linkplain java.nio.charset.Charset#forName look up the charset}\n     * using the given encoding name.\n     *\n     * @param os        the output stream on which to emit the XML document.\n     * @param comment   a description of the property list, or {@code null}\n     *                  if no comment is desired.\n     * @param  encoding the name of a supported\n     *                  \u003ca href\u003d\"../lang/package-summary.html#charenc\"\u003e\n     *                  character encoding\u003c/a\u003e\n     *\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws java.io.UnsupportedEncodingException if the encoding is not\n     *         supported by the implementation.\n     * @throws NullPointerException if {@code os} is {@code null},\n     *         or if {@code encoding} is {@code null}.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not {@code Strings}.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #loadFromXML(InputStream)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 1.5\n     */\n    public void storeToXML(OutputStream os, String comment, String encoding)\n        throws IOException {\n        Objects.requireNonNull(os);\n        Objects.requireNonNull(encoding);\n\n        try {\n            Charset charset \u003d Charset.forName(encoding);\n            storeToXML(os, comment, charset);\n        } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {\n            throw new UnsupportedEncodingException(encoding);\n        }\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table, using the specified encoding.\n     *\n     * \u003cp\u003eThe XML document will have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003eIf the specified comment is {@code null} then no comment\n     * will be stored in the document.\n     *\n     * \u003cp\u003e An implementation is required to support writing of XML documents\n     * that use the \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An\n     * implementation may support additional encodings.\n     *\n     * \u003cp\u003e Unmappable characters for the specified charset will be encoded as\n     * numeric character references.\n     *\n     * \u003cp\u003eThe specified stream remains open after this method returns.\n     *\n     * @param os        the output stream on which to emit the XML document.\n     * @param comment   a description of the property list, or {@code null}\n     *                  if no comment is desired.\n     * @param charset   the charset\n     *\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws NullPointerException if {@code os} or {@code charset} is {@code null}.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not {@code Strings}.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #loadFromXML(InputStream)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 10\n     */\n    public void storeToXML(OutputStream os, String comment, Charset charset)\n        throws IOException {\n        Objects.requireNonNull(os, \"OutputStream\");\n        Objects.requireNonNull(charset, \"Charset\");\n        PropertiesDefaultHandler handler \u003d new PropertiesDefaultHandler();\n        handler.store(this, os, comment, charset);\n    }\n\n    /**\n     * Searches for the property with the specified key in this property list.\n     * If the key is not found in this property list, the default property list,\n     * and its defaults, recursively, are then checked. The method returns\n     * {@code null} if the property is not found.\n     *\n     * @param   key   the property key.\n     * @return  the value in this property list with the specified key value.\n     * @see     #setProperty\n     * @see     #defaults\n     */\n    public String getProperty(String key) {\n        Object oval \u003d map.get(key);\n        String sval \u003d (oval instanceof String) ? (String)oval : null;\n        Properties defaults;\n        return ((sval \u003d\u003d null) \u0026\u0026 ((defaults \u003d this.defaults) !\u003d null)) ? defaults.getProperty(key) : sval;\n    }\n\n    /**\n     * Searches for the property with the specified key in this property list.\n     * If the key is not found in this property list, the default property list,\n     * and its defaults, recursively, are then checked. The method returns the\n     * default value argument if the property is not found.\n     *\n     * @param   key            the hashtable key.\n     * @param   defaultValue   a default value.\n     *\n     * @return  the value in this property list with the specified key value.\n     * @see     #setProperty\n     * @see     #defaults\n     */\n    public String getProperty(String key, String defaultValue) {\n        String val \u003d getProperty(key);\n        return (val \u003d\u003d null) ? defaultValue : val;\n    }\n\n    /**\n     * Returns an enumeration of all the keys in this property list,\n     * including distinct keys in the default property list if a key\n     * of the same name has not already been found from the main\n     * properties list.\n     *\n     * @return  an enumeration of all the keys in this property list, including\n     *          the keys in the default property list.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     * @see     java.util.Enumeration\n     * @see     java.util.Properties#defaults\n     * @see     #stringPropertyNames\n     */\n    public Enumeration\u003c?\u003e propertyNames() {\n        Hashtable\u003cString,Object\u003e h \u003d new Hashtable\u003c\u003e();\n        enumerate(h);\n        return h.keys();\n    }\n\n    /**\n     * Returns an unmodifiable set of keys from this property list\n     * where the key and its corresponding value are strings,\n     * including distinct keys in the default property list if a key\n     * of the same name has not already been found from the main\n     * properties list.  Properties whose key or value is not\n     * of type {@code String} are omitted.\n     * \u003cp\u003e\n     * The returned set is not backed by this {@code Properties} object.\n     * Changes to this {@code Properties} object are not reflected in the\n     * returned set.\n     *\n     * @return  an unmodifiable set of keys in this property list where\n     *          the key and its corresponding value are strings,\n     *          including the keys in the default property list.\n     * @see     java.util.Properties#defaults\n     * @since   1.6\n     */\n    public Set\u003cString\u003e stringPropertyNames() {\n        Map\u003cString, String\u003e h \u003d new HashMap\u003c\u003e();\n        enumerateStringProperties(h);\n        return Collections.unmodifiableSet(h.keySet());\n    }\n\n    /**\n     * Prints this property list out to the specified output stream.\n     * This method is useful for debugging.\n     *\n     * @param   out   an output stream.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     */\n    public void list(PrintStream out) {\n        out.println(\"-- listing properties --\");\n        Map\u003cString, Object\u003e h \u003d new HashMap\u003c\u003e();\n        enumerate(h);\n        for (Map.Entry\u003cString, Object\u003e e : h.entrySet()) {\n            String key \u003d e.getKey();\n            String val \u003d (String)e.getValue();\n            if (val.length() \u003e 40) {\n                val \u003d val.substring(0, 37) + \"...\";\n            }\n            out.println(key + \"\u003d\" + val);\n        }\n    }\n\n    /**\n     * Prints this property list out to the specified output stream.\n     * This method is useful for debugging.\n     *\n     * @param   out   an output stream.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     * @since   1.1\n     */\n    /*\n     * Rather than use an anonymous inner class to share common code, this\n     * method is duplicated in order to ensure that a non-1.1 compiler can\n     * compile this file.\n     */\n    public void list(PrintWriter out) {\n        out.println(\"-- listing properties --\");\n        Map\u003cString, Object\u003e h \u003d new HashMap\u003c\u003e();\n        enumerate(h);\n        for (Map.Entry\u003cString, Object\u003e e : h.entrySet()) {\n            String key \u003d e.getKey();\n            String val \u003d (String)e.getValue();\n            if (val.length() \u003e 40) {\n                val \u003d val.substring(0, 37) + \"...\";\n            }\n            out.println(key + \"\u003d\" + val);\n        }\n    }\n\n    /**\n     * Enumerates all key/value pairs into the specified Map.\n     * @param h the Map\n     * @throws ClassCastException if any of the property keys\n     *         is not of String type.\n     */\n    private void enumerate(Map\u003cString, Object\u003e h) {\n        if (defaults !\u003d null) {\n            defaults.enumerate(h);\n        }\n        for (Map.Entry\u003cObject, Object\u003e e : entrySet()) {\n            String key \u003d (String)e.getKey();\n            h.put(key, e.getValue());\n        }\n    }\n\n    /**\n     * Enumerates all key/value pairs into the specified Map\n     * and omits the property if the key or value is not a string.\n     * @param h the Map\n     */\n    private void enumerateStringProperties(Map\u003cString, String\u003e h) {\n        if (defaults !\u003d null) {\n            defaults.enumerateStringProperties(h);\n        }\n        for (Map.Entry\u003cObject, Object\u003e e : entrySet()) {\n            Object k \u003d e.getKey();\n            Object v \u003d e.getValue();\n            if (k instanceof String \u0026\u0026 v instanceof String) {\n                h.put((String) k, (String) v);\n            }\n        }\n    }\n\n    //\n    // Hashtable methods overridden and delegated to a ConcurrentHashMap instance\n\n    @Override\n    public int size() {\n        return map.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    @Override\n    public Enumeration\u003cObject\u003e keys() {\n        // CHM.keys() returns Iterator w/ remove() - instead wrap keySet()\n        return Collections.enumeration(map.keySet());\n    }\n\n    @Override\n    public Enumeration\u003cObject\u003e elements() {\n        // CHM.elements() returns Iterator w/ remove() - instead wrap values()\n        return Collections.enumeration(map.values());\n    }\n\n    @Override\n    public boolean contains(Object value) {\n        return map.contains(value);\n    }\n\n    @Override\n    public boolean containsValue(Object value) {\n        return map.containsValue(value);\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return map.containsKey(key);\n    }\n\n    @Override\n    public Object get(Object key) {\n        return map.get(key);\n    }\n\n    @Override\n    public synchronized Object put(Object key, Object value) {\n        return map.put(key, value);\n    }\n\n    @Override\n    public synchronized Object remove(Object key) {\n        return map.remove(key);\n    }\n\n    @Override\n    public synchronized void putAll(Map\u003c?, ?\u003e t) {\n        map.putAll(t);\n    }\n\n    @Override\n    public synchronized void clear() {\n        map.clear();\n    }\n\n    @Override\n    public synchronized String toString() {\n        return map.toString();\n    }\n\n    @Override\n    public Set\u003cObject\u003e keySet() {\n        return Collections.synchronizedSet(map.keySet(), this);\n    }\n\n    @Override\n    public Collection\u003cObject\u003e values() {\n        return Collections.synchronizedCollection(map.values(), this);\n    }\n\n    @Override\n    public Set\u003cMap.Entry\u003cObject, Object\u003e\u003e entrySet() {\n        return Collections.synchronizedSet(new EntrySet(map.entrySet()), this);\n    }\n\n    /*\n     * Properties.entrySet() should not support add/addAll, however\n     * ConcurrentHashMap.entrySet() provides add/addAll.  This class wraps the\n     * Set returned from CHM, changing add/addAll to throw UOE.\n     */\n    private static class EntrySet implements Set\u003cMap.Entry\u003cObject, Object\u003e\u003e {\n        private Set\u003cMap.Entry\u003cObject,Object\u003e\u003e entrySet;\n\n        private EntrySet(Set\u003cMap.Entry\u003cObject, Object\u003e\u003e entrySet) {\n            this.entrySet \u003d entrySet;\n        }\n\n        @Override public int size() { return entrySet.size(); }\n        @Override public boolean isEmpty() { return entrySet.isEmpty(); }\n        @Override public boolean contains(Object o) { return entrySet.contains(o); }\n        @Override public Object[] toArray() { return entrySet.toArray(); }\n        @Override public \u003cT\u003e T[] toArray(T[] a) { return entrySet.toArray(a); }\n        @Override public void clear() { entrySet.clear(); }\n        @Override public boolean remove(Object o) { return entrySet.remove(o); }\n\n        @Override\n        public boolean add(Map.Entry\u003cObject, Object\u003e e) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean addAll(Collection\u003c? extends Map.Entry\u003cObject, Object\u003e\u003e c) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean containsAll(Collection\u003c?\u003e c) {\n            return entrySet.containsAll(c);\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            return o \u003d\u003d this || entrySet.equals(o);\n        }\n\n        @Override\n        public int hashCode() {\n            return entrySet.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return entrySet.toString();\n        }\n\n        @Override\n        public boolean removeAll(Collection\u003c?\u003e c) {\n            return entrySet.removeAll(c);\n        }\n\n        @Override\n        public boolean retainAll(Collection\u003c?\u003e c) {\n            return entrySet.retainAll(c);\n        }\n\n        @Override\n        public Iterator\u003cMap.Entry\u003cObject, Object\u003e\u003e iterator() {\n            return entrySet.iterator();\n        }\n    }\n\n    @Override\n    public synchronized boolean equals(Object o) {\n        return map.equals(o);\n    }\n\n    @Override\n    public synchronized int hashCode() {\n        return map.hashCode();\n    }\n\n    @Override\n    public Object getOrDefault(Object key, Object defaultValue) {\n        return map.getOrDefault(key, defaultValue);\n    }\n\n    @Override\n    public synchronized void forEach(BiConsumer\u003c? super Object, ? super Object\u003e action) {\n        map.forEach(action);\n    }\n\n    @Override\n    public synchronized void replaceAll(BiFunction\u003c? super Object, ? super Object, ?\u003e function) {\n        map.replaceAll(function);\n    }\n\n    @Override\n    public synchronized Object putIfAbsent(Object key, Object value) {\n        return map.putIfAbsent(key, value);\n    }\n\n    @Override\n    public synchronized boolean remove(Object key, Object value) {\n        return map.remove(key, value);\n    }\n\n    @Override\n    public synchronized boolean replace(Object key, Object oldValue, Object newValue) {\n        return map.replace(key, oldValue, newValue);\n    }\n\n    @Override\n    public synchronized Object replace(Object key, Object value) {\n        return map.replace(key, value);\n    }\n\n    @Override\n    public synchronized Object computeIfAbsent(Object key,\n            Function\u003c? super Object, ?\u003e mappingFunction) {\n        return map.computeIfAbsent(key, mappingFunction);\n    }\n\n    @Override\n    public synchronized Object computeIfPresent(Object key,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.computeIfPresent(key, remappingFunction);\n    }\n\n    @Override\n    public synchronized Object compute(Object key,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.compute(key, remappingFunction);\n    }\n\n    @Override\n    public synchronized Object merge(Object key, Object value,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.merge(key, value, remappingFunction);\n    }\n\n    //\n    // Special Hashtable methods\n\n    @Override\n    protected void rehash() { /* no-op */ }\n\n    @Override\n    public synchronized Object clone() {\n        Properties clone \u003d (Properties) cloneHashtable();\n        clone.map \u003d new ConcurrentHashMap\u003c\u003e(map);\n        return clone;\n    }\n\n    //\n    // Hashtable serialization overrides\n    // (these should emit and consume Hashtable-compatible stream)\n\n    @Override\n    void writeHashtable(ObjectOutputStream s) throws IOException {\n        var map \u003d this.map;\n        List\u003cObject\u003e entryStack \u003d new ArrayList\u003c\u003e(map.size() * 2); // an estimate\n\n        for (Map.Entry\u003cObject, Object\u003e entry : map.entrySet()) {\n            entryStack.add(entry.getValue());\n            entryStack.add(entry.getKey());\n        }\n\n        // Write out the simulated threshold, loadfactor\n        float loadFactor \u003d 0.75f;\n        int count \u003d entryStack.size() / 2;\n        int length \u003d (int)(count / loadFactor) + (count / 20) + 3;\n        if (length \u003e count \u0026\u0026 (length \u0026 1) \u003d\u003d 0) {\n            length--;\n        }\n        synchronized (map) { // in case of multiple concurrent serializations\n            defaultWriteHashtable(s, length, loadFactor);\n        }\n\n        // Write out simulated length and real count of elements\n        s.writeInt(length);\n        s.writeInt(count);\n\n        // Write out the key/value objects from the stacked entries\n        for (int i \u003d entryStack.size() - 1; i \u003e\u003d 0; i--) {\n            s.writeObject(entryStack.get(i));\n        }\n    }\n\n    @Override\n    void readHashtable(ObjectInputStream s) throws IOException,\n            ClassNotFoundException {\n        // Read in the threshold and loadfactor\n        s.defaultReadObject();\n\n        // Read the original length of the array and number of elements\n        int origlength \u003d s.readInt();\n        int elements \u003d s.readInt();\n\n        // Validate # of elements\n        if (elements \u003c 0) {\n            throw new StreamCorruptedException(\"Illegal # of Elements: \" + elements);\n        }\n\n        // Constructing the backing map will lazily create an array when the first element is\n        // added, so check it before construction. Note that CHM\u0027s constructor takes a size\n        // that is the number of elements to be stored -- not the table size -- so it must be\n        // inflated by the default load factor of 0.75, then inflated to the next power of two.\n        // (CHM uses the same power-of-two computation as HashMap, and HashMap.tableSizeFor is\n        // accessible here.) Check Map.Entry[].class since it\u0027s the nearest public type to\n        // what is actually created.\n        SharedSecrets.getJavaObjectInputStreamAccess()\n                     .checkArray(s, Map.Entry[].class, HashMap.tableSizeFor((int)(elements / 0.75)));\n\n        // create CHM of appropriate capacity\n        var map \u003d new ConcurrentHashMap\u003c\u003e(elements);\n\n        // Read all the key/value objects\n        for (; elements \u003e 0; elements--) {\n            Object key \u003d s.readObject();\n            Object value \u003d s.readObject();\n            map.put(key, value);\n        }\n        this.map \u003d map;\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

Π°ΠΏΡ€. 25, 2024 2:58:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/util/Properties.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.04.25 14:59:00 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java

Uri: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1570)
```

Π°ΠΏΡ€. 25, 2024 2:59:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/util/Properties.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1995, 2021, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.util;\n\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.StreamCorruptedException;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\nimport jdk.internal.util.StaticProperty;\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.UTF_8;\n\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.ArraysSupport;\nimport jdk.internal.util.xml.PropertiesDefaultHandler;\n\n/**\n * The {@code Properties} class represents a persistent set of\n * properties. The {@code Properties} can be saved to a stream\n * or loaded from a stream. Each key and its corresponding value in\n * the property list is a string.\n * \u003cp\u003e\n * A property list can contain another property list as its\n * \"defaults\"; this second property list is searched if\n * the property key is not found in the original property list.\n * \u003cp\u003e\n * Because {@code Properties} inherits from {@code Hashtable}, the\n * {@code put} and {@code putAll} methods can be applied to a\n * {@code Properties} object.  Their use is strongly discouraged as they\n * allow the caller to insert entries whose keys or values are not\n * {@code Strings}.  The {@code setProperty} method should be used\n * instead.  If the {@code store} or {@code save} method is called\n * on a \"compromised\" {@code Properties} object that contains a\n * non-{@code String} key or value, the call will fail. Similarly,\n * the call to the {@code propertyNames} or {@code list} method\n * will fail if it is called on a \"compromised\" {@code Properties}\n * object that contains a non-{@code String} key.\n *\n * \u003cp\u003e\n * The iterators returned by the {@code iterator} method of this class\u0027s\n * \"collection views\" (that is, {@code entrySet()}, {@code keySet()}, and\n * {@code values()}) may not fail-fast (unlike the Hashtable implementation).\n * These iterators are guaranteed to traverse elements as they existed upon\n * construction exactly once, and may (but are not guaranteed to) reflect any\n * modifications subsequent to construction.\n * \u003cp\u003e\n * The {@link #load(java.io.Reader) load(Reader)} {@code /}\n * {@link #store(java.io.Writer, java.lang.String) store(Writer, String)}\n * methods load and store properties from and to a character based stream\n * in a simple line-oriented format specified below.\n *\n * The {@link #load(java.io.InputStream) load(InputStream)} {@code /}\n * {@link #store(java.io.OutputStream, java.lang.String) store(OutputStream, String)}\n * methods work the same way as the load(Reader)/store(Writer, String) pair, except\n * the input/output stream is encoded in ISO 8859-1 character encoding.\n * Characters that cannot be directly represented in this encoding can be written using\n * Unicode escapes as defined in section {@jls 3.3} of\n * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e;\n * only a single \u0027u\u0027 character is allowed in an escape\n * sequence.\n *\n * \u003cp\u003e The {@link #loadFromXML(InputStream)} and {@link\n * #storeToXML(OutputStream, String, String)} methods load and store properties\n * in a simple XML format.  By default the UTF-8 character encoding is used,\n * however a specific encoding may be specified if required. Implementations\n * are required to support UTF-8 and UTF-16 and may support other encodings.\n * An XML properties document has the following DOCTYPE declaration:\n *\n * \u003cpre\u003e\n * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n * \u003c/pre\u003e\n * Note that the system URI (http://java.sun.com/dtd/properties.dtd) is\n * \u003ci\u003enot\u003c/i\u003e accessed when exporting or importing properties; it merely\n * serves as a string to uniquely identify the DTD, which is:\n * \u003cpre\u003e\n *    \u0026lt;?xml version\u003d\"1.0\" encoding\u003d\"UTF-8\"?\u0026gt;\n *\n *    \u0026lt;!-- DTD for properties --\u0026gt;\n *\n *    \u0026lt;!ELEMENT properties ( comment?, entry* ) \u0026gt;\n *\n *    \u0026lt;!ATTLIST properties version CDATA #FIXED \"1.0\"\u0026gt;\n *\n *    \u0026lt;!ELEMENT comment (#PCDATA) \u0026gt;\n *\n *    \u0026lt;!ELEMENT entry (#PCDATA) \u0026gt;\n *\n *    \u0026lt;!ATTLIST entry key CDATA #REQUIRED\u0026gt;\n * \u003c/pre\u003e\n *\n * \u003cp\u003eThis class is thread-safe: multiple threads can share a single\n * {@code Properties} object without the need for external synchronization.\n *\n * @apiNote\n * The {@code Properties} class does not inherit the concept of a load factor\n * from its superclass, {@code Hashtable}.\n *\n * @author  Arthur van Hoff\n * @author  Michael McCloskey\n * @author  Xueming Shen\n * @since   1.0\n */\npublic class Properties extends Hashtable\u003cObject,Object\u003e {\n    /**\n     * use serialVersionUID from JDK 1.1.X for interoperability\n     */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d 4112578634029874840L;\n\n    private static final Unsafe UNSAFE \u003d Unsafe.getUnsafe();\n\n    /**\n     * A property list that contains default values for any keys not\n     * found in this property list.\n     *\n     * @serial\n     */\n    protected volatile Properties defaults;\n\n    /**\n     * Properties does not store values in its inherited Hashtable, but instead\n     * in an internal ConcurrentHashMap.  Synchronization is omitted from\n     * simple read operations.  Writes and bulk operations remain synchronized,\n     * as in Hashtable.\n     */\n    private transient volatile ConcurrentHashMap\u003cObject, Object\u003e map;\n\n    /**\n     * Creates an empty property list with no default values.\n     *\n     * @implNote The initial capacity of a {@code Properties} object created\n     * with this constructor is unspecified.\n     */\n    public Properties() {\n        this(null, 8);\n    }\n\n    /**\n     * Creates an empty property list with no default values, and with an\n     * initial size accommodating the specified number of elements without the\n     * need to dynamically resize.\n     *\n     * @param  initialCapacity the {@code Properties} will be sized to\n     *         accommodate this many elements\n     * @throws IllegalArgumentException if the initial capacity is less than\n     *         zero.\n     */\n    public Properties(int initialCapacity) {\n        this(null, initialCapacity);\n    }\n\n    /**\n     * Creates an empty property list with the specified defaults.\n     *\n     * @implNote The initial capacity of a {@code Properties} object created\n     * with this constructor is unspecified.\n     *\n     * @param   defaults   the defaults.\n     */\n    public Properties(Properties defaults) {\n        this(defaults, 8);\n    }\n\n    private Properties(Properties defaults, int initialCapacity) {\n        // use package-private constructor to\n        // initialize unused fields with dummy values\n        super((Void) null);\n        map \u003d new ConcurrentHashMap\u003c\u003e(initialCapacity);\n        this.defaults \u003d defaults;\n\n        // Ensure writes can\u0027t be reordered\n        UNSAFE.storeFence();\n    }\n\n    /**\n     * Calls the {@code Hashtable} method {@code put}. Provided for\n     * parallelism with the {@code getProperty} method. Enforces use of\n     * strings for property keys and values. The value returned is the\n     * result of the {@code Hashtable} call to {@code put}.\n     *\n     * @param key the key to be placed into this property list.\n     * @param value the value corresponding to {@code key}.\n     * @return     the previous value of the specified key in this property\n     *             list, or {@code null} if it did not have one.\n     * @see #getProperty\n     * @since    1.2\n     */\n    public synchronized Object setProperty(String key, String value) {\n        return put(key, value);\n    }\n\n\n    /**\n     * Reads a property list (key and element pairs) from the input\n     * character stream in a simple line-oriented format.\n     * \u003cp\u003e\n     * Properties are processed in terms of lines. There are two\n     * kinds of lines, \u003ci\u003enatural lines\u003c/i\u003e and \u003ci\u003elogical lines\u003c/i\u003e.\n     * A natural line is defined as a line of\n     * characters that is terminated either by a set of line terminator\n     * characters ({@code \\n} or {@code \\r} or {@code \\r\\n})\n     * or by the end of the stream. A natural line may be either a blank line,\n     * a comment line, or hold all or some of a key-element pair. A logical\n     * line holds all the data of a key-element pair, which may be spread\n     * out across several adjacent natural lines by escaping\n     * the line terminator sequence with a backslash character\n     * {@code \\}.  Note that a comment line cannot be extended\n     * in this manner; every natural line that is a comment must have\n     * its own comment indicator, as described below. Lines are read from\n     * input until the end of the stream is reached.\n     *\n     * \u003cp\u003e\n     * A natural line that contains only white space characters is\n     * considered blank and is ignored.  A comment line has an ASCII\n     * {@code \u0027#\u0027} or {@code \u0027!\u0027} as its first non-whitespace\n     * character; comment lines are also ignored and do not\n     * encode key-element information.  In addition to line\n     * terminators, this format considers the characters space\n     * ({@code \u0027 \u0027}, {@code \u0027\\u005Cu0020\u0027}), tab\n     * ({@code \u0027\\t\u0027}, {@code \u0027\\u005Cu0009\u0027}), and form feed\n     * ({@code \u0027\\f\u0027}, {@code \u0027\\u005Cu000C\u0027}) to be white\n     * space.\n     *\n     * \u003cp\u003e\n     * If a logical line is spread across several natural lines, the\n     * backslash escaping the line terminator sequence, the line\n     * terminator sequence, and any white space at the start of the\n     * following line have no effect on the key or element values.\n     * The remainder of the discussion of key and element parsing\n     * (when loading) will assume all the characters constituting\n     * the key and element appear on a single natural line after\n     * line continuation characters have been removed.  Note that\n     * it is \u003ci\u003enot\u003c/i\u003e sufficient to only examine the character\n     * preceding a line terminator sequence to decide if the line\n     * terminator is escaped; there must be an odd number of\n     * contiguous backslashes for the line terminator to be escaped.\n     * Since the input is processed from left to right, a\n     * non-zero even number of 2\u003ci\u003en\u003c/i\u003e contiguous backslashes\n     * before a line terminator (or elsewhere) encodes \u003ci\u003en\u003c/i\u003e\n     * backslashes after escape processing.\n     *\n     * \u003cp\u003e\n     * The key contains all of the characters in the line starting\n     * with the first non-whitespace character and up to, but not\n     * including, the first unescaped {@code \u0027\u003d\u0027},\n     * {@code \u0027:\u0027}, or white space character other than a line\n     * terminator. All of these key termination characters may be\n     * included in the key by escaping them with a preceding backslash\n     * character; for example,\u003cp\u003e\n     *\n     * {@code \\:\\\u003d}\u003cp\u003e\n     *\n     * would be the two-character key {@code \":\u003d\"}.  Line\n     * terminator characters can be included using {@code \\r} and\n     * {@code \\n} escape sequences.  Any white space after the\n     * key is skipped; if the first non-whitespace character after\n     * the key is {@code \u0027\u003d\u0027} or {@code \u0027:\u0027}, then it is\n     * ignored and any white space characters after it are also\n     * skipped.  All remaining characters on the line become part of\n     * the associated element string; if there are no remaining\n     * characters, the element is the empty string\n     * {@code \"\"}.  Once the raw character sequences\n     * constituting the key and element are identified, escape\n     * processing is performed as described above.\n     *\n     * \u003cp\u003e\n     * As an example, each of the following three lines specifies the key\n     * {@code \"Truth\"} and the associated element value\n     * {@code \"Beauty\"}:\n     * \u003cpre\u003e\n     * Truth \u003d Beauty\n     *  Truth:Beauty\n     * Truth                    :Beauty\n     * \u003c/pre\u003e\n     * As another example, the following three lines specify a single\n     * property:\n     * \u003cpre\u003e\n     * fruits                           apple, banana, pear, \\\n     *                                  cantaloupe, watermelon, \\\n     *                                  kiwi, mango\n     * \u003c/pre\u003e\n     * The key is {@code \"fruits\"} and the associated element is:\n     * \u003cpre\u003e\"apple, banana, pear, cantaloupe, watermelon, kiwi, mango\"\u003c/pre\u003e\n     * Note that a space appears before each {@code \\} so that a space\n     * will appear after each comma in the final result; the {@code \\},\n     * line terminator, and leading white space on the continuation line are\n     * merely discarded and are \u003ci\u003enot\u003c/i\u003e replaced by one or more other\n     * characters.\n     * \u003cp\u003e\n     * As a third example, the line:\n     * \u003cpre\u003echeeses\n     * \u003c/pre\u003e\n     * specifies that the key is {@code \"cheeses\"} and the associated\n     * element is the empty string {@code \"\"}.\n     * \u003cp\u003e\n     * \u003ca id\u003d\"unicodeescapes\"\u003e\u003c/a\u003e\n     * Characters in keys and elements can be represented in escape\n     * sequences similar to those used for character and string literals\n     * (see sections {@jls 3.3} and {@jls 3.10.6} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e).\n     *\n     * The differences from the character escape sequences and Unicode\n     * escapes used for characters and strings are:\n     *\n     * \u003cul\u003e\n     * \u003cli\u003e Octal escapes are not recognized.\n     *\n     * \u003cli\u003e The character sequence {@code \\b} does \u003ci\u003enot\u003c/i\u003e\n     * represent a backspace character.\n     *\n     * \u003cli\u003e The method does not treat a backslash character,\n     * {@code \\}, before a non-valid escape character as an\n     * error; the backslash is silently dropped.  For example, in a\n     * Java string the sequence {@code \"\\z\"} would cause a\n     * compile time error.  In contrast, this method silently drops\n     * the backslash.  Therefore, this method treats the two character\n     * sequence {@code \"\\b\"} as equivalent to the single\n     * character {@code \u0027b\u0027}.\n     *\n     * \u003cli\u003e Escapes are not necessary for single and double quotes;\n     * however, by the rule above, single and double quote characters\n     * preceded by a backslash still yield single and double quote\n     * characters, respectively.\n     *\n     * \u003cli\u003e Only a single \u0027u\u0027 character is allowed in a Unicode escape\n     * sequence.\n     *\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The specified stream remains open after this method returns.\n     *\n     * @param   reader   the input character stream.\n     * @throws  IOException  if an error occurred when reading from the\n     *          input stream.\n     * @throws  IllegalArgumentException if a malformed Unicode escape\n     *          appears in the input.\n     * @throws  NullPointerException if {@code reader} is null.\n     * @since   1.6\n     */\n    public synchronized void load(Reader reader) throws IOException {\n        Objects.requireNonNull(reader, \"reader parameter is null\");\n        load0(new LineReader(reader));\n    }\n\n    /**\n     * Reads a property list (key and element pairs) from the input\n     * byte stream. The input stream is in a simple line-oriented\n     * format as specified in\n     * {@link #load(java.io.Reader) load(Reader)} and is assumed to use\n     * the ISO 8859-1 character encoding; that is each byte is one Latin1\n     * character. Characters not in Latin1, and certain special characters,\n     * are represented in keys and elements using Unicode escapes as defined in\n     * section {@jls 3.3} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     * \u003cp\u003e\n     * The specified stream remains open after this method returns.\n     *\n     * @param      inStream   the input stream.\n     * @throws     IOException  if an error occurred when reading from the\n     *             input stream.\n     * @throws     IllegalArgumentException if the input stream contains a\n     *             malformed Unicode escape sequence.\n     * @throws     NullPointerException if {@code inStream} is null.\n     * @since 1.2\n     */\n    public synchronized void load(InputStream inStream) throws IOException {\n        Objects.requireNonNull(inStream, \"inStream parameter is null\");\n        load0(new LineReader(inStream));\n    }\n\n    private void load0(LineReader lr) throws IOException {\n        StringBuilder outBuffer \u003d new StringBuilder();\n        int limit;\n        int keyLen;\n        int valueStart;\n        boolean hasSep;\n        boolean precedingBackslash;\n\n        while ((limit \u003d lr.readLine()) \u003e\u003d 0) {\n            keyLen \u003d 0;\n            valueStart \u003d limit;\n            hasSep \u003d false;\n\n            //System.out.println(\"line\u003d\u003c\" + new String(lineBuf, 0, limit) + \"\u003e\");\n            precedingBackslash \u003d false;\n            while (keyLen \u003c limit) {\n                char c \u003d lr.lineBuf[keyLen];\n                //need check if escaped.\n                if ((c \u003d\u003d \u0027\u003d\u0027 ||  c \u003d\u003d \u0027:\u0027) \u0026\u0026 !precedingBackslash) {\n                    valueStart \u003d keyLen + 1;\n                    hasSep \u003d true;\n                    break;\n                } else if ((c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\t\u0027 ||  c \u003d\u003d \u0027\\f\u0027) \u0026\u0026 !precedingBackslash) {\n                    valueStart \u003d keyLen + 1;\n                    break;\n                }\n                if (c \u003d\u003d \u0027\\\\\u0027) {\n                    precedingBackslash \u003d !precedingBackslash;\n                } else {\n                    precedingBackslash \u003d false;\n                }\n                keyLen++;\n            }\n            while (valueStart \u003c limit) {\n                char c \u003d lr.lineBuf[valueStart];\n                if (c !\u003d \u0027 \u0027 \u0026\u0026 c !\u003d \u0027\\t\u0027 \u0026\u0026  c !\u003d \u0027\\f\u0027) {\n                    if (!hasSep \u0026\u0026 (c \u003d\u003d \u0027\u003d\u0027 ||  c \u003d\u003d \u0027:\u0027)) {\n                        hasSep \u003d true;\n                    } else {\n                        break;\n                    }\n                }\n                valueStart++;\n            }\n            String key \u003d loadConvert(lr.lineBuf, 0, keyLen, outBuffer);\n            String value \u003d loadConvert(lr.lineBuf, valueStart, limit - valueStart, outBuffer);\n            put(key, value);\n        }\n    }\n\n    /* Read in a \"logical line\" from an InputStream/Reader, skip all comment\n     * and blank lines and filter out those leading whitespace characters\n     * (\\u0020, \\u0009 and \\u000c) from the beginning of a \"natural line\".\n     * Method returns the char length of the \"logical line\" and stores\n     * the line in \"lineBuf\".\n     */\n    private static class LineReader {\n        LineReader(InputStream inStream) {\n            this.inStream \u003d inStream;\n            inByteBuf \u003d new byte[8192];\n        }\n\n        LineReader(Reader reader) {\n            this.reader \u003d reader;\n            inCharBuf \u003d new char[8192];\n        }\n\n        char[] lineBuf \u003d new char[1024];\n        private byte[] inByteBuf;\n        private char[] inCharBuf;\n        private int inLimit \u003d 0;\n        private int inOff \u003d 0;\n        private InputStream inStream;\n        private Reader reader;\n\n        int readLine() throws IOException {\n            // use locals to optimize for interpreted performance\n            int len \u003d 0;\n            int off \u003d inOff;\n            int limit \u003d inLimit;\n\n            boolean skipWhiteSpace \u003d true;\n            boolean appendedLineBegin \u003d false;\n            boolean precedingBackslash \u003d false;\n            boolean fromStream \u003d inStream !\u003d null;\n            byte[] byteBuf \u003d inByteBuf;\n            char[] charBuf \u003d inCharBuf;\n            char[] lineBuf \u003d this.lineBuf;\n            char c;\n\n            while (true) {\n                if (off \u003e\u003d limit) {\n                    inLimit \u003d limit \u003d fromStream ? inStream.read(byteBuf)\n                                                 : reader.read(charBuf);\n                    if (limit \u003c\u003d 0) {\n                        if (len \u003d\u003d 0) {\n                            return -1;\n                        }\n                        return precedingBackslash ? len - 1 : len;\n                    }\n                    off \u003d 0;\n                }\n\n                // (char)(byte \u0026 0xFF) is equivalent to calling a ISO8859-1 decoder.\n                c \u003d (fromStream) ? (char)(byteBuf[off++] \u0026 0xFF) : charBuf[off++];\n\n                if (skipWhiteSpace) {\n                    if (c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\t\u0027 || c \u003d\u003d \u0027\\f\u0027) {\n                        continue;\n                    }\n                    if (!appendedLineBegin \u0026\u0026 (c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\n\u0027)) {\n                        continue;\n                    }\n                    skipWhiteSpace \u003d false;\n                    appendedLineBegin \u003d false;\n\n                }\n                if (len \u003d\u003d 0) { // Still on a new logical line\n                    if (c \u003d\u003d \u0027#\u0027 || c \u003d\u003d \u0027!\u0027) {\n                        // Comment, quickly consume the rest of the line\n\n                        // When checking for new line characters a range check,\n                        // starting with the higher bound (\u0027\\r\u0027) means one less\n                        // branch in the common case.\n                        commentLoop: while (true) {\n                            if (fromStream) {\n                                byte b;\n                                while (off \u003c limit) {\n                                    b \u003d byteBuf[off++];\n                                    if (b \u003c\u003d \u0027\\r\u0027 \u0026\u0026 (b \u003d\u003d \u0027\\r\u0027 || b \u003d\u003d \u0027\\n\u0027))\n                                        break commentLoop;\n                                }\n                                if (off \u003d\u003d limit) {\n                                    inLimit \u003d limit \u003d inStream.read(byteBuf);\n                                    if (limit \u003c\u003d 0) { // EOF\n                                        return -1;\n                                    }\n                                    off \u003d 0;\n                                }\n                            } else {\n                                while (off \u003c limit) {\n                                    c \u003d charBuf[off++];\n                                    if (c \u003c\u003d \u0027\\r\u0027 \u0026\u0026 (c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\n\u0027))\n                                        break commentLoop;\n                                }\n                                if (off \u003d\u003d limit) {\n                                    inLimit \u003d limit \u003d reader.read(charBuf);\n                                    if (limit \u003c\u003d 0) { // EOF\n                                        return -1;\n                                    }\n                                    off \u003d 0;\n                                }\n                            }\n                        }\n                        skipWhiteSpace \u003d true;\n                        continue;\n                    }\n                }\n\n                if (c !\u003d \u0027\\n\u0027 \u0026\u0026 c !\u003d \u0027\\r\u0027) {\n                    lineBuf[len++] \u003d c;\n                    if (len \u003d\u003d lineBuf.length) {\n                        lineBuf \u003d new char[ArraysSupport.newLength(len, 1, len)];\n                        System.arraycopy(this.lineBuf, 0, lineBuf, 0, len);\n                        this.lineBuf \u003d lineBuf;\n                    }\n                    // flip the preceding backslash flag\n                    precedingBackslash \u003d (c \u003d\u003d \u0027\\\\\u0027) ? !precedingBackslash : false;\n                } else {\n                    // reached EOL\n                    if (len \u003d\u003d 0) {\n                        skipWhiteSpace \u003d true;\n                        continue;\n                    }\n                    if (off \u003e\u003d limit) {\n                        inLimit \u003d limit \u003d fromStream ? inStream.read(byteBuf)\n                                                     : reader.read(charBuf);\n                        off \u003d 0;\n                        if (limit \u003c\u003d 0) { // EOF\n                            return precedingBackslash ? len - 1 : len;\n                        }\n                    }\n                    if (precedingBackslash) {\n                        // backslash at EOL is not part of the line\n                        len -\u003d 1;\n                        // skip leading whitespace characters in the following line\n                        skipWhiteSpace \u003d true;\n                        appendedLineBegin \u003d true;\n                        precedingBackslash \u003d false;\n                        // take care not to include any subsequent \\n\n                        if (c \u003d\u003d \u0027\\r\u0027) {\n                            if (fromStream) {\n                                if (byteBuf[off] \u003d\u003d \u0027\\n\u0027) {\n                                    off++;\n                                }\n                            } else {\n                                if (charBuf[off] \u003d\u003d \u0027\\n\u0027) {\n                                    off++;\n                                }\n                            }\n                        }\n                    } else {\n                        inOff \u003d off;\n                        return len;\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n     * Converts encoded \u0026#92;uxxxx to unicode chars\n     * and changes special saved chars to their original forms\n     */\n    private String loadConvert(char[] in, int off, int len, StringBuilder out) {\n        char aChar;\n        int end \u003d off + len;\n        int start \u003d off;\n        while (off \u003c end) {\n            aChar \u003d in[off++];\n            if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                break;\n            }\n        }\n        if (off \u003d\u003d end) { // No backslash\n            return new String(in, start, len);\n        }\n\n        // backslash found at off - 1, reset the shared buffer, rewind offset\n        out.setLength(0);\n        off--;\n        out.append(in, start, off - start);\n\n        while (off \u003c end) {\n            aChar \u003d in[off++];\n            if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                // No need to bounds check since LineReader::readLine excludes\n                // unescaped \\s at the end of the line\n                aChar \u003d in[off++];\n                if(aChar \u003d\u003d \u0027u\u0027) {\n                    // Read the xxxx\n                    if (off \u003e end - 4)\n                        throw new IllegalArgumentException(\n                                     \"Malformed \\\\uxxxx encoding.\");\n                    int value \u003d 0;\n                    for (int i \u003d 0; i \u003c 4; i++) {\n                        aChar \u003d in[off++];\n                        value \u003d switch (aChar) {\n                            case \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027 -\u003e (value \u003c\u003c 4) + aChar - \u00270\u0027;\n                            case \u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027, \u0027f\u0027                     -\u003e (value \u003c\u003c 4) + 10 + aChar - \u0027a\u0027;\n                            case \u0027A\u0027, \u0027B\u0027, \u0027C\u0027, \u0027D\u0027, \u0027E\u0027, \u0027F\u0027                     -\u003e (value \u003c\u003c 4) + 10 + aChar - \u0027A\u0027;\n                            default -\u003e throw new IllegalArgumentException(\"Malformed \\\\uxxxx encoding.\");\n                        };\n                    }\n                    out.append((char)value);\n                } else {\n                    if (aChar \u003d\u003d \u0027t\u0027) aChar \u003d \u0027\\t\u0027;\n                    else if (aChar \u003d\u003d \u0027r\u0027) aChar \u003d \u0027\\r\u0027;\n                    else if (aChar \u003d\u003d \u0027n\u0027) aChar \u003d \u0027\\n\u0027;\n                    else if (aChar \u003d\u003d \u0027f\u0027) aChar \u003d \u0027\\f\u0027;\n                    out.append(aChar);\n                }\n            } else {\n                out.append(aChar);\n            }\n        }\n        return out.toString();\n    }\n\n    /*\n     * Converts unicodes to encoded \u0026#92;uxxxx and escapes\n     * special characters with a preceding slash\n     */\n    private String saveConvert(String theString,\n                               boolean escapeSpace,\n                               boolean escapeUnicode) {\n        int len \u003d theString.length();\n        int bufLen \u003d len * 2;\n        if (bufLen \u003c 0) {\n            bufLen \u003d Integer.MAX_VALUE;\n        }\n        StringBuilder outBuffer \u003d new StringBuilder(bufLen);\n        HexFormat hex \u003d HexFormat.of().withUpperCase();\n        for(int x\u003d0; x\u003clen; x++) {\n            char aChar \u003d theString.charAt(x);\n            // Handle common case first, selecting largest block that\n            // avoids the specials below\n            if ((aChar \u003e 61) \u0026\u0026 (aChar \u003c 127)) {\n                if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                    outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027\\\\\u0027);\n                    continue;\n                }\n                outBuffer.append(aChar);\n                continue;\n            }\n            switch(aChar) {\n                case \u0027 \u0027:\n                    if (x \u003d\u003d 0 || escapeSpace)\n                        outBuffer.append(\u0027\\\\\u0027);\n                    outBuffer.append(\u0027 \u0027);\n                    break;\n                case \u0027\\t\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027t\u0027);\n                          break;\n                case \u0027\\n\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027n\u0027);\n                          break;\n                case \u0027\\r\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027r\u0027);\n                          break;\n                case \u0027\\f\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027f\u0027);\n                          break;\n                case \u0027\u003d\u0027: // Fall through\n                case \u0027:\u0027: // Fall through\n                case \u0027#\u0027: // Fall through\n                case \u0027!\u0027:\n                    outBuffer.append(\u0027\\\\\u0027); outBuffer.append(aChar);\n                    break;\n                default:\n                    if (((aChar \u003c 0x0020) || (aChar \u003e 0x007e)) \u0026 escapeUnicode ) {\n                        outBuffer.append(\"\\\\u\");\n                        outBuffer.append(hex.toHexDigits(aChar));\n                    } else {\n                        outBuffer.append(aChar);\n                    }\n            }\n        }\n        return outBuffer.toString();\n    }\n\n    private static void writeComments(BufferedWriter bw, String comments)\n        throws IOException {\n        HexFormat hex \u003d HexFormat.of().withUpperCase();\n        bw.write(\"#\");\n        int len \u003d comments.length();\n        int current \u003d 0;\n        int last \u003d 0;\n        while (current \u003c len) {\n            char c \u003d comments.charAt(current);\n            if (c \u003e \u0027\\u00ff\u0027 || c \u003d\u003d \u0027\\n\u0027 || c \u003d\u003d \u0027\\r\u0027) {\n                if (last !\u003d current)\n                    bw.write(comments.substring(last, current));\n                if (c \u003e \u0027\\u00ff\u0027) {\n                    bw.write(\"\\\\u\");\n                    bw.write(hex.toHexDigits(c));\n                } else {\n                    bw.newLine();\n                    if (c \u003d\u003d \u0027\\r\u0027 \u0026\u0026\n                        current !\u003d len - 1 \u0026\u0026\n                        comments.charAt(current + 1) \u003d\u003d \u0027\\n\u0027) {\n                        current++;\n                    }\n                    if (current \u003d\u003d len - 1 ||\n                        (comments.charAt(current + 1) !\u003d \u0027#\u0027 \u0026\u0026\n                        comments.charAt(current + 1) !\u003d \u0027!\u0027))\n                        bw.write(\"#\");\n                }\n                last \u003d current + 1;\n            }\n            current++;\n        }\n        if (last !\u003d current)\n            bw.write(comments.substring(last, current));\n        bw.newLine();\n    }\n\n    /**\n     * Calls the {@code store(OutputStream out, String comments)} method\n     * and suppresses IOExceptions that were thrown.\n     *\n     * @deprecated This method does not throw an IOException if an I/O error\n     * occurs while saving the property list.  The preferred way to save a\n     * properties list is via the {@code store(OutputStream out,\n     * String comments)} method or the\n     * {@code storeToXML(OutputStream os, String comment)} method.\n     *\n     * @param   out      an output stream.\n     * @param   comments   a description of the property list.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not\n     *             {@code Strings}.\n     */\n    @Deprecated\n    public void save(OutputStream out, String comments)  {\n        try {\n            store(out, comments);\n        } catch (IOException e) {\n        }\n    }\n\n    /**\n     * Writes this property list (key and element pairs) in this\n     * {@code Properties} table to the output character stream in a\n     * format suitable for using the {@link #load(java.io.Reader) load(Reader)}\n     * method.\n     * \u003cp\u003e\n     * Properties from the defaults table of this {@code Properties}\n     * table (if any) are \u003ci\u003enot\u003c/i\u003e written out by this method.\n     * \u003cp\u003e\n     * If the comments argument is not null, then an ASCII {@code #}\n     * character, the comments string, and a line separator are first written\n     * to the output stream. Thus, the {@code comments} can serve as an\n     * identifying comment. Any one of a line feed ({@code \\n}), a carriage\n     * return ({@code \\r}), or a carriage return followed immediately by a line feed\n     * ({@code \\r\\n}) in comments is replaced by a\n     * {@link System#lineSeparator() line separator} and if the next\n     * character in comments is not character {@code #} or character {@code !} then\n     * an ASCII {@code #} is written out after that line separator.\n     * \u003cp\u003e\n     * If the {@systemProperty java.properties.date} is set on the command line\n     * and is non-empty (as determined by {@link String#isEmpty()  String.isEmpty}),\n     * a comment line is written as follows.\n     * First, a {@code #} character is written, followed by the contents\n     * of the property, followed by a line separator. Any line terminator characters\n     * in the value of the system property are treated the same way as noted above\n     * for the comments argument.\n     * If the system property is not set or is empty, a comment line is written\n     * as follows.\n     * First, a {@code #} character is written, followed by the current date and time\n     * formatted as if by the {@link Date#toString() Date.toString} method,\n     * followed by a line separator.\n     * \u003cp\u003e\n     * Then every entry in this {@code Properties} table is\n     * written out, one per line. For each entry the key string is\n     * written, then an ASCII {@code \u003d}, then the associated\n     * element string. For the key, all space characters are\n     * written with a preceding {@code \\} character.  For the\n     * element, leading space characters, but not embedded or trailing\n     * space characters, are written with a preceding {@code \\}\n     * character. The key and element characters {@code #},\n     * {@code !}, {@code \u003d}, and {@code :} are written\n     * with a preceding backslash to ensure that they are properly loaded.\n     * \u003cp\u003e\n     * After the entries have been written, the output stream is flushed.\n     * The output stream remains open after this method returns.\n     *\n     * @implSpec The keys and elements are written in the natural sort order\n     * of the keys in the {@code entrySet()} unless {@code entrySet()} is\n     * overridden by a subclass to return a different value than {@code super.entrySet()}.\n     *\n     * @param   writer      an output character stream writer.\n     * @param   comments   a description of the property list.\n     * @throws     IOException if writing this property list to the specified\n     *             output stream throws an {@code IOException}.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not {@code Strings}.\n     * @throws     NullPointerException  if {@code writer} is null.\n     * @since 1.6\n     */\n    public void store(Writer writer, String comments)\n        throws IOException\n    {\n        store0((writer instanceof BufferedWriter)?(BufferedWriter)writer\n                                                 : new BufferedWriter(writer),\n               comments,\n               false);\n    }\n\n    /**\n     * Writes this property list (key and element pairs) in this\n     * {@code Properties} table to the output stream in a format suitable\n     * for loading into a {@code Properties} table using the\n     * {@link #load(InputStream) load(InputStream)} method.\n     * \u003cp\u003e\n     * Properties from the defaults table of this {@code Properties}\n     * table (if any) are \u003ci\u003enot\u003c/i\u003e written out by this method.\n     * \u003cp\u003e\n     * This method outputs the comments, properties keys and values in\n     * the same format as specified in\n     * {@link #store(java.io.Writer, java.lang.String) store(Writer)},\n     * with the following differences:\n     * \u003cul\u003e\n     * \u003cli\u003eThe stream is written using the ISO 8859-1 character encoding.\n     *\n     * \u003cli\u003eCharacters not in Latin-1 in the comments are written as\n     * {@code \\u005Cu}\u003ci\u003exxxx\u003c/i\u003e for their appropriate unicode\n     * hexadecimal value \u003ci\u003exxxx\u003c/i\u003e.\n     *\n     * \u003cli\u003eCharacters less than {@code \\u005Cu0020} and characters greater\n     * than {@code \\u005Cu007E} in property keys or values are written\n     * as {@code \\u005Cu}\u003ci\u003exxxx\u003c/i\u003e for the appropriate hexadecimal\n     * value \u003ci\u003exxxx\u003c/i\u003e.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * After the entries have been written, the output stream is flushed.\n     * The output stream remains open after this method returns.\n     *\n     * @param   out      an output stream.\n     * @param   comments   a description of the property list.\n     * @throws     IOException if writing this property list to the specified\n     *             output stream throws an {@code IOException}.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not {@code Strings}.\n     * @throws     NullPointerException  if {@code out} is null.\n     * @since 1.2\n     */\n    public void store(OutputStream out, String comments)\n        throws IOException\n    {\n        store0(new BufferedWriter(new OutputStreamWriter(out, ISO_8859_1.INSTANCE)),\n               comments,\n               true);\n    }\n\n    private void store0(BufferedWriter bw, String comments, boolean escUnicode)\n        throws IOException\n    {\n        if (comments !\u003d null) {\n            writeComments(bw, comments);\n        }\n        writeDateComment(bw);\n\n        synchronized (this) {\n            @SuppressWarnings(\"unchecked\")\n            Collection\u003cMap.Entry\u003cString, String\u003e\u003e entries \u003d (Set\u003cMap.Entry\u003cString, String\u003e\u003e) (Set) entrySet();\n            // entrySet() can be overridden by subclasses. Here we check to see if\n            // the returned instance type is the one returned by the Properties.entrySet()\n            // implementation. If yes, then we sort those entries in the natural order\n            // of their key. Else, we consider that the subclassed implementation may\n            // potentially have returned a differently ordered entries and so we just\n            // use the iteration order of the returned instance.\n            if (entries instanceof Collections.SynchronizedSet\u003c?\u003e ss\n                    \u0026\u0026 ss.c instanceof EntrySet) {\n                entries \u003d new ArrayList\u003c\u003e(entries);\n                ((List\u003cMap.Entry\u003cString, String\u003e\u003e) entries).sort(Map.Entry.comparingByKey());\n            }\n            for (Map.Entry\u003cString, String\u003e e : entries) {\n                String key \u003d e.getKey();\n                String val \u003d e.getValue();\n                key \u003d saveConvert(key, true, escUnicode);\n                /* No need to escape embedded and trailing spaces for value, hence\n                 * pass false to flag.\n                 */\n                val \u003d saveConvert(val, false, escUnicode);\n                bw.write(key + \"\u003d\" + val);\n                bw.newLine();\n            }\n        }\n        bw.flush();\n    }\n\n    private static void writeDateComment(BufferedWriter bw) throws IOException {\n        // value of java.properties.date system property isn\u0027t sensitive\n        // and so doesn\u0027t need any security manager checks to make the value accessible\n        // to the callers\n        String sysPropVal \u003d StaticProperty.javaPropertiesDate();\n        if (sysPropVal !\u003d null \u0026\u0026 !sysPropVal.isEmpty()) {\n            writeComments(bw, sysPropVal);\n        } else {\n            bw.write(\"#\" + new Date());\n            bw.newLine();\n        }\n    }\n\n    /**\n     * Loads all of the properties represented by the XML document on the\n     * specified input stream into this properties table.\n     *\n     * \u003cp\u003eThe XML document must have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     * Furthermore, the document must satisfy the properties DTD described\n     * above.\n     *\n     * \u003cp\u003e An implementation is required to read XML documents that use the\n     * \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An implementation may\n     * support additional encodings.\n     *\n     * \u003cp\u003eThe specified stream is closed after this method returns.\n     *\n     * @param in the input stream from which to read the XML document.\n     * @throws IOException if reading from the specified input stream\n     *         results in an {@code IOException}.\n     * @throws java.io.UnsupportedEncodingException if the document\u0027s encoding\n     *         declaration can be read and it specifies an encoding that is not\n     *         supported\n     * @throws InvalidPropertiesFormatException Data on input stream does not\n     *         constitute a valid XML document with the mandated document type.\n     * @throws NullPointerException if {@code in} is null.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #storeToXML(OutputStream, String, String)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 1.5\n     */\n    public synchronized void loadFromXML(InputStream in)\n        throws IOException, InvalidPropertiesFormatException\n    {\n        Objects.requireNonNull(in);\n        PropertiesDefaultHandler handler \u003d new PropertiesDefaultHandler();\n        handler.load(this, in);\n        in.close();\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table.\n     *\n     * \u003cp\u003e An invocation of this method of the form {@code props.storeToXML(os,\n     * comment)} behaves in exactly the same way as the invocation\n     * {@code props.storeToXML(os, comment, \"UTF-8\");}.\n     *\n     * @param os the output stream on which to emit the XML document.\n     * @param comment a description of the property list, or {@code null}\n     *        if no comment is desired.\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws NullPointerException if {@code os} is null.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not\n     *         {@code Strings}.\n     * @see    #loadFromXML(InputStream)\n     * @since 1.5\n     */\n    public void storeToXML(OutputStream os, String comment)\n        throws IOException\n    {\n        storeToXML(os, comment, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table, using the specified encoding.\n     *\n     * \u003cp\u003eThe XML document will have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003eIf the specified comment is {@code null} then no comment\n     * will be stored in the document.\n     *\n     * \u003cp\u003e An implementation is required to support writing of XML documents\n     * that use the \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An\n     * implementation may support additional encodings.\n     *\n     * \u003cp\u003eThe specified stream remains open after this method returns.\n     *\n     * \u003cp\u003eThis method behaves the same as\n     * {@linkplain #storeToXML(OutputStream os, String comment, Charset charset)}\n     * except that it will {@linkplain java.nio.charset.Charset#forName look up the charset}\n     * using the given encoding name.\n     *\n     * @param os        the output stream on which to emit the XML document.\n     * @param comment   a description of the property list, or {@code null}\n     *                  if no comment is desired.\n     * @param  encoding the name of a supported\n     *                  \u003ca href\u003d\"../lang/package-summary.html#charenc\"\u003e\n     *                  character encoding\u003c/a\u003e\n     *\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws java.io.UnsupportedEncodingException if the encoding is not\n     *         supported by the implementation.\n     * @throws NullPointerException if {@code os} is {@code null},\n     *         or if {@code encoding} is {@code null}.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not {@code Strings}.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #loadFromXML(InputStream)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 1.5\n     */\n    public void storeToXML(OutputStream os, String comment, String encoding)\n        throws IOException {\n        Objects.requireNonNull(os);\n        Objects.requireNonNull(encoding);\n\n        try {\n            Charset charset \u003d Charset.forName(encoding);\n            storeToXML(os, comment, charset);\n        } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {\n            throw new UnsupportedEncodingException(encoding);\n        }\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table, using the specified encoding.\n     *\n     * \u003cp\u003eThe XML document will have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003eIf the specified comment is {@code null} then no comment\n     * will be stored in the document.\n     *\n     * \u003cp\u003e An implementation is required to support writing of XML documents\n     * that use the \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An\n     * implementation may support additional encodings.\n     *\n     * \u003cp\u003e Unmappable characters for the specified charset will be encoded as\n     * numeric character references.\n     *\n     * \u003cp\u003eThe specified stream remains open after this method returns.\n     *\n     * @param os        the output stream on which to emit the XML document.\n     * @param comment   a description of the property list, or {@code null}\n     *                  if no comment is desired.\n     * @param charset   the charset\n     *\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws NullPointerException if {@code os} or {@code charset} is {@code null}.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not {@code Strings}.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #loadFromXML(InputStream)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 10\n     */\n    public void storeToXML(OutputStream os, String comment, Charset charset)\n        throws IOException {\n        Objects.requireNonNull(os, \"OutputStream\");\n        Objects.requireNonNull(charset, \"Charset\");\n        PropertiesDefaultHandler handler \u003d new PropertiesDefaultHandler();\n        handler.store(this, os, comment, charset);\n    }\n\n    /**\n     * Searches for the property with the specified key in this property list.\n     * If the key is not found in this property list, the default property list,\n     * and its defaults, recursively, are then checked. The method returns\n     * {@code null} if the property is not found.\n     *\n     * @param   key   the property key.\n     * @return  the value in this property list with the specified key value.\n     * @see     #setProperty\n     * @see     #defaults\n     */\n    public String getProperty(String key) {\n        Object oval \u003d map.get(key);\n        String sval \u003d (oval instanceof String) ? (String)oval : null;\n        Properties defaults;\n        return ((sval \u003d\u003d null) \u0026\u0026 ((defaults \u003d this.defaults) !\u003d null)) ? defaults.getProperty(key) : sval;\n    }\n\n    /**\n     * Searches for the property with the specified key in this property list.\n     * If the key is not found in this property list, the default property list,\n     * and its defaults, recursively, are then checked. The method returns the\n     * default value argument if the property is not found.\n     *\n     * @param   key            the hashtable key.\n     * @param   defaultValue   a default value.\n     *\n     * @return  the value in this property list with the specified key value.\n     * @see     #setProperty\n     * @see     #defaults\n     */\n    public String getProperty(String key, String defaultValue) {\n        String val \u003d getProperty(key);\n        return (val \u003d\u003d null) ? defaultValue : val;\n    }\n\n    /**\n     * Returns an enumeration of all the keys in this property list,\n     * including distinct keys in the default property list if a key\n     * of the same name has not already been found from the main\n     * properties list.\n     *\n     * @return  an enumeration of all the keys in this property list, including\n     *          the keys in the default property list.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     * @see     java.util.Enumeration\n     * @see     java.util.Properties#defaults\n     * @see     #stringPropertyNames\n     */\n    public Enumeration\u003c?\u003e propertyNames() {\n        Hashtable\u003cString,Object\u003e h \u003d new Hashtable\u003c\u003e();\n        enumerate(h);\n        return h.keys();\n    }\n\n    /**\n     * Returns an unmodifiable set of keys from this property list\n     * where the key and its corresponding value are strings,\n     * including distinct keys in the default property list if a key\n     * of the same name has not already been found from the main\n     * properties list.  Properties whose key or value is not\n     * of type {@code String} are omitted.\n     * \u003cp\u003e\n     * The returned set is not backed by this {@code Properties} object.\n     * Changes to this {@code Properties} object are not reflected in the\n     * returned set.\n     *\n     * @return  an unmodifiable set of keys in this property list where\n     *          the key and its corresponding value are strings,\n     *          including the keys in the default property list.\n     * @see     java.util.Properties#defaults\n     * @since   1.6\n     */\n    public Set\u003cString\u003e stringPropertyNames() {\n        Map\u003cString, String\u003e h \u003d new HashMap\u003c\u003e();\n        enumerateStringProperties(h);\n        return Collections.unmodifiableSet(h.keySet());\n    }\n\n    /**\n     * Prints this property list out to the specified output stream.\n     * This method is useful for debugging.\n     *\n     * @param   out   an output stream.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     */\n    public void list(PrintStream out) {\n        out.println(\"-- listing properties --\");\n        Map\u003cString, Object\u003e h \u003d new HashMap\u003c\u003e();\n        enumerate(h);\n        for (Map.Entry\u003cString, Object\u003e e : h.entrySet()) {\n            String key \u003d e.getKey();\n            String val \u003d (String)e.getValue();\n            if (val.length() \u003e 40) {\n                val \u003d val.substring(0, 37) + \"...\";\n            }\n            out.println(key + \"\u003d\" + val);\n        }\n    }\n\n    /**\n     * Prints this property list out to the specified output stream.\n     * This method is useful for debugging.\n     *\n     * @param   out   an output stream.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     * @since   1.1\n     */\n    /*\n     * Rather than use an anonymous inner class to share common code, this\n     * method is duplicated in order to ensure that a non-1.1 compiler can\n     * compile this file.\n     */\n    public void list(PrintWriter out) {\n        out.println(\"-- listing properties --\");\n        Map\u003cString, Object\u003e h \u003d new HashMap\u003c\u003e();\n        enumerate(h);\n        for (Map.Entry\u003cString, Object\u003e e : h.entrySet()) {\n            String key \u003d e.getKey();\n            String val \u003d (String)e.getValue();\n            if (val.length() \u003e 40) {\n                val \u003d val.substring(0, 37) + \"...\";\n            }\n            out.println(key + \"\u003d\" + val);\n        }\n    }\n\n    /**\n     * Enumerates all key/value pairs into the specified Map.\n     * @param h the Map\n     * @throws ClassCastException if any of the property keys\n     *         is not of String type.\n     */\n    private void enumerate(Map\u003cString, Object\u003e h) {\n        if (defaults !\u003d null) {\n            defaults.enumerate(h);\n        }\n        for (Map.Entry\u003cObject, Object\u003e e : entrySet()) {\n            String key \u003d (String)e.getKey();\n            h.put(key, e.getValue());\n        }\n    }\n\n    /**\n     * Enumerates all key/value pairs into the specified Map\n     * and omits the property if the key or value is not a string.\n     * @param h the Map\n     */\n    private void enumerateStringProperties(Map\u003cString, String\u003e h) {\n        if (defaults !\u003d null) {\n            defaults.enumerateStringProperties(h);\n        }\n        for (Map.Entry\u003cObject, Object\u003e e : entrySet()) {\n            Object k \u003d e.getKey();\n            Object v \u003d e.getValue();\n            if (k instanceof String \u0026\u0026 v instanceof String) {\n                h.put((String) k, (String) v);\n            }\n        }\n    }\n\n    //\n    // Hashtable methods overridden and delegated to a ConcurrentHashMap instance\n\n    @Override\n    public int size() {\n        return map.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    @Override\n    public Enumeration\u003cObject\u003e keys() {\n        // CHM.keys() returns Iterator w/ remove() - instead wrap keySet()\n        return Collections.enumeration(map.keySet());\n    }\n\n    @Override\n    public Enumeration\u003cObject\u003e elements() {\n        // CHM.elements() returns Iterator w/ remove() - instead wrap values()\n        return Collections.enumeration(map.values());\n    }\n\n    @Override\n    public boolean contains(Object value) {\n        return map.contains(value);\n    }\n\n    @Override\n    public boolean containsValue(Object value) {\n        return map.containsValue(value);\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return map.containsKey(key);\n    }\n\n    @Override\n    public Object get(Object key) {\n        return map.get(key);\n    }\n\n    @Override\n    public synchronized Object put(Object key, Object value) {\n        return map.put(key, value);\n    }\n\n    @Override\n    public synchronized Object remove(Object key) {\n        return map.remove(key);\n    }\n\n    @Override\n    public synchronized void putAll(Map\u003c?, ?\u003e t) {\n        map.putAll(t);\n    }\n\n    @Override\n    public synchronized void clear() {\n        map.clear();\n    }\n\n    @Override\n    public synchronized String toString() {\n        return map.toString();\n    }\n\n    @Override\n    public Set\u003cObject\u003e keySet() {\n        return Collections.synchronizedSet(map.keySet(), this);\n    }\n\n    @Override\n    public Collection\u003cObject\u003e values() {\n        return Collections.synchronizedCollection(map.values(), this);\n    }\n\n    @Override\n    public Set\u003cMap.Entry\u003cObject, Object\u003e\u003e entrySet() {\n        return Collections.synchronizedSet(new EntrySet(map.entrySet()), this);\n    }\n\n    /*\n     * Properties.entrySet() should not support add/addAll, however\n     * ConcurrentHashMap.entrySet() provides add/addAll.  This class wraps the\n     * Set returned from CHM, changing add/addAll to throw UOE.\n     */\n    private static class EntrySet implements Set\u003cMap.Entry\u003cObject, Object\u003e\u003e {\n        private Set\u003cMap.Entry\u003cObject,Object\u003e\u003e entrySet;\n\n        private EntrySet(Set\u003cMap.Entry\u003cObject, Object\u003e\u003e entrySet) {\n            this.entrySet \u003d entrySet;\n        }\n\n        @Override public int size() { return entrySet.size(); }\n        @Override public boolean isEmpty() { return entrySet.isEmpty(); }\n        @Override public boolean contains(Object o) { return entrySet.contains(o); }\n        @Override public Object[] toArray() { return entrySet.toArray(); }\n        @Override public \u003cT\u003e T[] toArray(T[] a) { return entrySet.toArray(a); }\n        @Override public void clear() { entrySet.clear(); }\n        @Override public boolean remove(Object o) { return entrySet.remove(o); }\n\n        @Override\n        public boolean add(Map.Entry\u003cObject, Object\u003e e) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean addAll(Collection\u003c? extends Map.Entry\u003cObject, Object\u003e\u003e c) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean containsAll(Collection\u003c?\u003e c) {\n            return entrySet.containsAll(c);\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            return o \u003d\u003d this || entrySet.equals(o);\n        }\n\n        @Override\n        public int hashCode() {\n            return entrySet.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return entrySet.toString();\n        }\n\n        @Override\n        public boolean removeAll(Collection\u003c?\u003e c) {\n            return entrySet.removeAll(c);\n        }\n\n        @Override\n        public boolean retainAll(Collection\u003c?\u003e c) {\n            return entrySet.retainAll(c);\n        }\n\n        @Override\n        public Iterator\u003cMap.Entry\u003cObject, Object\u003e\u003e iterator() {\n            return entrySet.iterator();\n        }\n    }\n\n    @Override\n    public synchronized boolean equals(Object o) {\n        return map.equals(o);\n    }\n\n    @Override\n    public synchronized int hashCode() {\n        return map.hashCode();\n    }\n\n    @Override\n    public Object getOrDefault(Object key, Object defaultValue) {\n        return map.getOrDefault(key, defaultValue);\n    }\n\n    @Override\n    public synchronized void forEach(BiConsumer\u003c? super Object, ? super Object\u003e action) {\n        map.forEach(action);\n    }\n\n    @Override\n    public synchronized void replaceAll(BiFunction\u003c? super Object, ? super Object, ?\u003e function) {\n        map.replaceAll(function);\n    }\n\n    @Override\n    public synchronized Object putIfAbsent(Object key, Object value) {\n        return map.putIfAbsent(key, value);\n    }\n\n    @Override\n    public synchronized boolean remove(Object key, Object value) {\n        return map.remove(key, value);\n    }\n\n    @Override\n    public synchronized boolean replace(Object key, Object oldValue, Object newValue) {\n        return map.replace(key, oldValue, newValue);\n    }\n\n    @Override\n    public synchronized Object replace(Object key, Object value) {\n        return map.replace(key, value);\n    }\n\n    @Override\n    public synchronized Object computeIfAbsent(Object key,\n            Function\u003c? super Object, ?\u003e mappingFunction) {\n        return map.computeIfAbsent(key, mappingFunction);\n    }\n\n    @Override\n    public synchronized Object computeIfPresent(Object key,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.computeIfPresent(key, remappingFunction);\n    }\n\n    @Override\n    public synchronized Object compute(Object key,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.compute(key, remappingFunction);\n    }\n\n    @Override\n    public synchronized Object merge(Object key, Object value,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.merge(key, value, remappingFunction);\n    }\n\n    //\n    // Special Hashtable methods\n\n    @Override\n    protected void rehash() { /* no-op */ }\n\n    @Override\n    public synchronized Object clone() {\n        Properties clone \u003d (Properties) cloneHashtable();\n        clone.map \u003d new ConcurrentHashMap\u003c\u003e(map);\n        return clone;\n    }\n\n    //\n    // Hashtable serialization overrides\n    // (these should emit and consume Hashtable-compatible stream)\n\n    @Override\n    void writeHashtable(ObjectOutputStream s) throws IOException {\n        var map \u003d this.map;\n        List\u003cObject\u003e entryStack \u003d new ArrayList\u003c\u003e(map.size() * 2); // an estimate\n\n        for (Map.Entry\u003cObject, Object\u003e entry : map.entrySet()) {\n            entryStack.add(entry.getValue());\n            entryStack.add(entry.getKey());\n        }\n\n        // Write out the simulated threshold, loadfactor\n        float loadFactor \u003d 0.75f;\n        int count \u003d entryStack.size() / 2;\n        int length \u003d (int)(count / loadFactor) + (count / 20) + 3;\n        if (length \u003e count \u0026\u0026 (length \u0026 1) \u003d\u003d 0) {\n            length--;\n        }\n        synchronized (map) { // in case of multiple concurrent serializations\n            defaultWriteHashtable(s, length, loadFactor);\n        }\n\n        // Write out simulated length and real count of elements\n        s.writeInt(length);\n        s.writeInt(count);\n\n        // Write out the key/value objects from the stacked entries\n        for (int i \u003d entryStack.size() - 1; i \u003e\u003d 0; i--) {\n            s.writeObject(entryStack.get(i));\n        }\n    }\n\n    @Override\n    void readHashtable(ObjectInputStream s) throws IOException,\n            ClassNotFoundException {\n        // Read in the threshold and loadfactor\n        s.defaultReadObject();\n\n        // Read the original length of the array and number of elements\n        int origlength \u003d s.readInt();\n        int elements \u003d s.readInt();\n\n        // Validate # of elements\n        if (elements \u003c 0) {\n            throw new StreamCorruptedException(\"Illegal # of Elements: \" + elements);\n        }\n\n        // Constructing the backing map will lazily create an array when the first element is\n        // added, so check it before construction. Note that CHM\u0027s constructor takes a size\n        // that is the number of elements to be stored -- not the table size -- so it must be\n        // inflated by the default load factor of 0.75, then inflated to the next power of two.\n        // (CHM uses the same power-of-two computation as HashMap, and HashMap.tableSizeFor is\n        // accessible here.) Check Map.Entry[].class since it\u0027s the nearest public type to\n        // what is actually created.\n        SharedSecrets.getJavaObjectInputStreamAccess()\n                     .checkArray(s, Map.Entry[].class, HashMap.tableSizeFor((int)(elements / 0.75)));\n\n        // create CHM of appropriate capacity\n        var map \u003d new ConcurrentHashMap\u003c\u003e(elements);\n\n        // Read all the key/value objects\n        for (; elements \u003e 0; elements--) {\n            Object key \u003d s.readObject();\n            Object value \u003d s.readObject();\n            map.put(key, value);\n        }\n        this.map \u003d map;\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

Π°ΠΏΡ€. 25, 2024 2:59:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/util/Properties.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.04.25 14:59:02 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java

Uri: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1570)
```

Π°ΠΏΡ€. 25, 2024 2:59:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/util/Properties.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1995, 2021, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.util;\n\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.StreamCorruptedException;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\nimport jdk.internal.util.StaticProperty;\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.UTF_8;\n\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.ArraysSupport;\nimport jdk.internal.util.xml.PropertiesDefaultHandler;\n\n/**\n * The {@code Properties} class represents a persistent set of\n * properties. The {@code Properties} can be saved to a stream\n * or loaded from a stream. Each key and its corresponding value in\n * the property list is a string.\n * \u003cp\u003e\n * A property list can contain another property list as its\n * \"defaults\"; this second property list is searched if\n * the property key is not found in the original property list.\n * \u003cp\u003e\n * Because {@code Properties} inherits from {@code Hashtable}, the\n * {@code put} and {@code putAll} methods can be applied to a\n * {@code Properties} object.  Their use is strongly discouraged as they\n * allow the caller to insert entries whose keys or values are not\n * {@code Strings}.  The {@code setProperty} method should be used\n * instead.  If the {@code store} or {@code save} method is called\n * on a \"compromised\" {@code Properties} object that contains a\n * non-{@code String} key or value, the call will fail. Similarly,\n * the call to the {@code propertyNames} or {@code list} method\n * will fail if it is called on a \"compromised\" {@code Properties}\n * object that contains a non-{@code String} key.\n *\n * \u003cp\u003e\n * The iterators returned by the {@code iterator} method of this class\u0027s\n * \"collection views\" (that is, {@code entrySet()}, {@code keySet()}, and\n * {@code values()}) may not fail-fast (unlike the Hashtable implementation).\n * These iterators are guaranteed to traverse elements as they existed upon\n * construction exactly once, and may (but are not guaranteed to) reflect any\n * modifications subsequent to construction.\n * \u003cp\u003e\n * The {@link #load(java.io.Reader) load(Reader)} {@code /}\n * {@link #store(java.io.Writer, java.lang.String) store(Writer, String)}\n * methods load and store properties from and to a character based stream\n * in a simple line-oriented format specified below.\n *\n * The {@link #load(java.io.InputStream) load(InputStream)} {@code /}\n * {@link #store(java.io.OutputStream, java.lang.String) store(OutputStream, String)}\n * methods work the same way as the load(Reader)/store(Writer, String) pair, except\n * the input/output stream is encoded in ISO 8859-1 character encoding.\n * Characters that cannot be directly represented in this encoding can be written using\n * Unicode escapes as defined in section {@jls 3.3} of\n * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e;\n * only a single \u0027u\u0027 character is allowed in an escape\n * sequence.\n *\n * \u003cp\u003e The {@link #loadFromXML(InputStream)} and {@link\n * #storeToXML(OutputStream, String, String)} methods load and store properties\n * in a simple XML format.  By default the UTF-8 character encoding is used,\n * however a specific encoding may be specified if required. Implementations\n * are required to support UTF-8 and UTF-16 and may support other encodings.\n * An XML properties document has the following DOCTYPE declaration:\n *\n * \u003cpre\u003e\n * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n * \u003c/pre\u003e\n * Note that the system URI (http://java.sun.com/dtd/properties.dtd) is\n * \u003ci\u003enot\u003c/i\u003e accessed when exporting or importing properties; it merely\n * serves as a string to uniquely identify the DTD, which is:\n * \u003cpre\u003e\n *    \u0026lt;?xml version\u003d\"1.0\" encoding\u003d\"UTF-8\"?\u0026gt;\n *\n *    \u0026lt;!-- DTD for properties --\u0026gt;\n *\n *    \u0026lt;!ELEMENT properties ( comment?, entry* ) \u0026gt;\n *\n *    \u0026lt;!ATTLIST properties version CDATA #FIXED \"1.0\"\u0026gt;\n *\n *    \u0026lt;!ELEMENT comment (#PCDATA) \u0026gt;\n *\n *    \u0026lt;!ELEMENT entry (#PCDATA) \u0026gt;\n *\n *    \u0026lt;!ATTLIST entry key CDATA #REQUIRED\u0026gt;\n * \u003c/pre\u003e\n *\n * \u003cp\u003eThis class is thread-safe: multiple threads can share a single\n * {@code Properties} object without the need for external synchronization.\n *\n * @apiNote\n * The {@code Properties} class does not inherit the concept of a load factor\n * from its superclass, {@code Hashtable}.\n *\n * @author  Arthur van Hoff\n * @author  Michael McCloskey\n * @author  Xueming Shen\n * @since   1.0\n */\npublic class Properties extends Hashtable\u003cObject,Object\u003e {\n    /**\n     * use serialVersionUID from JDK 1.1.X for interoperability\n     */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d 4112578634029874840L;\n\n    private static final Unsafe UNSAFE \u003d Unsafe.getUnsafe();\n\n    /**\n     * A property list that contains default values for any keys not\n     * found in this property list.\n     *\n     * @serial\n     */\n    protected volatile Properties defaults;\n\n    /**\n     * Properties does not store values in its inherited Hashtable, but instead\n     * in an internal ConcurrentHashMap.  Synchronization is omitted from\n     * simple read operations.  Writes and bulk operations remain synchronized,\n     * as in Hashtable.\n     */\n    private transient volatile ConcurrentHashMap\u003cObject, Object\u003e map;\n\n    /**\n     * Creates an empty property list with no default values.\n     *\n     * @implNote The initial capacity of a {@code Properties} object created\n     * with this constructor is unspecified.\n     */\n    public Properties() {\n        this(null, 8);\n    }\n\n    /**\n     * Creates an empty property list with no default values, and with an\n     * initial size accommodating the specified number of elements without the\n     * need to dynamically resize.\n     *\n     * @param  initialCapacity the {@code Properties} will be sized to\n     *         accommodate this many elements\n     * @throws IllegalArgumentException if the initial capacity is less than\n     *         zero.\n     */\n    public Properties(int initialCapacity) {\n        this(null, initialCapacity);\n    }\n\n    /**\n     * Creates an empty property list with the specified defaults.\n     *\n     * @implNote The initial capacity of a {@code Properties} object created\n     * with this constructor is unspecified.\n     *\n     * @param   defaults   the defaults.\n     */\n    public Properties(Properties defaults) {\n        this(defaults, 8);\n    }\n\n    private Properties(Properties defaults, int initialCapacity) {\n        // use package-private constructor to\n        // initialize unused fields with dummy values\n        super((Void) null);\n        map \u003d new ConcurrentHashMap\u003c\u003e(initialCapacity);\n        this.defaults \u003d defaults;\n\n        // Ensure writes can\u0027t be reordered\n        UNSAFE.storeFence();\n    }\n\n    /**\n     * Calls the {@code Hashtable} method {@code put}. Provided for\n     * parallelism with the {@code getProperty} method. Enforces use of\n     * strings for property keys and values. The value returned is the\n     * result of the {@code Hashtable} call to {@code put}.\n     *\n     * @param key the key to be placed into this property list.\n     * @param value the value corresponding to {@code key}.\n     * @return     the previous value of the specified key in this property\n     *             list, or {@code null} if it did not have one.\n     * @see #getProperty\n     * @since    1.2\n     */\n    public synchronized Object setProperty(String key, String value) {\n        return put(key, value);\n    }\n\n\n    /**\n     * Reads a property list (key and element pairs) from the input\n     * character stream in a simple line-oriented format.\n     * \u003cp\u003e\n     * Properties are processed in terms of lines. There are two\n     * kinds of lines, \u003ci\u003enatural lines\u003c/i\u003e and \u003ci\u003elogical lines\u003c/i\u003e.\n     * A natural line is defined as a line of\n     * characters that is terminated either by a set of line terminator\n     * characters ({@code \\n} or {@code \\r} or {@code \\r\\n})\n     * or by the end of the stream. A natural line may be either a blank line,\n     * a comment line, or hold all or some of a key-element pair. A logical\n     * line holds all the data of a key-element pair, which may be spread\n     * out across several adjacent natural lines by escaping\n     * the line terminator sequence with a backslash character\n     * {@code \\}.  Note that a comment line cannot be extended\n     * in this manner; every natural line that is a comment must have\n     * its own comment indicator, as described below. Lines are read from\n     * input until the end of the stream is reached.\n     *\n     * \u003cp\u003e\n     * A natural line that contains only white space characters is\n     * considered blank and is ignored.  A comment line has an ASCII\n     * {@code \u0027#\u0027} or {@code \u0027!\u0027} as its first non-whitespace\n     * character; comment lines are also ignored and do not\n     * encode key-element information.  In addition to line\n     * terminators, this format considers the characters space\n     * ({@code \u0027 \u0027}, {@code \u0027\\u005Cu0020\u0027}), tab\n     * ({@code \u0027\\t\u0027}, {@code \u0027\\u005Cu0009\u0027}), and form feed\n     * ({@code \u0027\\f\u0027}, {@code \u0027\\u005Cu000C\u0027}) to be white\n     * space.\n     *\n     * \u003cp\u003e\n     * If a logical line is spread across several natural lines, the\n     * backslash escaping the line terminator sequence, the line\n     * terminator sequence, and any white space at the start of the\n     * following line have no effect on the key or element values.\n     * The remainder of the discussion of key and element parsing\n     * (when loading) will assume all the characters constituting\n     * the key and element appear on a single natural line after\n     * line continuation characters have been removed.  Note that\n     * it is \u003ci\u003enot\u003c/i\u003e sufficient to only examine the character\n     * preceding a line terminator sequence to decide if the line\n     * terminator is escaped; there must be an odd number of\n     * contiguous backslashes for the line terminator to be escaped.\n     * Since the input is processed from left to right, a\n     * non-zero even number of 2\u003ci\u003en\u003c/i\u003e contiguous backslashes\n     * before a line terminator (or elsewhere) encodes \u003ci\u003en\u003c/i\u003e\n     * backslashes after escape processing.\n     *\n     * \u003cp\u003e\n     * The key contains all of the characters in the line starting\n     * with the first non-whitespace character and up to, but not\n     * including, the first unescaped {@code \u0027\u003d\u0027},\n     * {@code \u0027:\u0027}, or white space character other than a line\n     * terminator. All of these key termination characters may be\n     * included in the key by escaping them with a preceding backslash\n     * character; for example,\u003cp\u003e\n     *\n     * {@code \\:\\\u003d}\u003cp\u003e\n     *\n     * would be the two-character key {@code \":\u003d\"}.  Line\n     * terminator characters can be included using {@code \\r} and\n     * {@code \\n} escape sequences.  Any white space after the\n     * key is skipped; if the first non-whitespace character after\n     * the key is {@code \u0027\u003d\u0027} or {@code \u0027:\u0027}, then it is\n     * ignored and any white space characters after it are also\n     * skipped.  All remaining characters on the line become part of\n     * the associated element string; if there are no remaining\n     * characters, the element is the empty string\n     * {@code \"\"}.  Once the raw character sequences\n     * constituting the key and element are identified, escape\n     * processing is performed as described above.\n     *\n     * \u003cp\u003e\n     * As an example, each of the following three lines specifies the key\n     * {@code \"Truth\"} and the associated element value\n     * {@code \"Beauty\"}:\n     * \u003cpre\u003e\n     * Truth \u003d Beauty\n     *  Truth:Beauty\n     * Truth                    :Beauty\n     * \u003c/pre\u003e\n     * As another example, the following three lines specify a single\n     * property:\n     * \u003cpre\u003e\n     * fruits                           apple, banana, pear, \\\n     *                                  cantaloupe, watermelon, \\\n     *                                  kiwi, mango\n     * \u003c/pre\u003e\n     * The key is {@code \"fruits\"} and the associated element is:\n     * \u003cpre\u003e\"apple, banana, pear, cantaloupe, watermelon, kiwi, mango\"\u003c/pre\u003e\n     * Note that a space appears before each {@code \\} so that a space\n     * will appear after each comma in the final result; the {@code \\},\n     * line terminator, and leading white space on the continuation line are\n     * merely discarded and are \u003ci\u003enot\u003c/i\u003e replaced by one or more other\n     * characters.\n     * \u003cp\u003e\n     * As a third example, the line:\n     * \u003cpre\u003echeeses\n     * \u003c/pre\u003e\n     * specifies that the key is {@code \"cheeses\"} and the associated\n     * element is the empty string {@code \"\"}.\n     * \u003cp\u003e\n     * \u003ca id\u003d\"unicodeescapes\"\u003e\u003c/a\u003e\n     * Characters in keys and elements can be represented in escape\n     * sequences similar to those used for character and string literals\n     * (see sections {@jls 3.3} and {@jls 3.10.6} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e).\n     *\n     * The differences from the character escape sequences and Unicode\n     * escapes used for characters and strings are:\n     *\n     * \u003cul\u003e\n     * \u003cli\u003e Octal escapes are not recognized.\n     *\n     * \u003cli\u003e The character sequence {@code \\b} does \u003ci\u003enot\u003c/i\u003e\n     * represent a backspace character.\n     *\n     * \u003cli\u003e The method does not treat a backslash character,\n     * {@code \\}, before a non-valid escape character as an\n     * error; the backslash is silently dropped.  For example, in a\n     * Java string the sequence {@code \"\\z\"} would cause a\n     * compile time error.  In contrast, this method silently drops\n     * the backslash.  Therefore, this method treats the two character\n     * sequence {@code \"\\b\"} as equivalent to the single\n     * character {@code \u0027b\u0027}.\n     *\n     * \u003cli\u003e Escapes are not necessary for single and double quotes;\n     * however, by the rule above, single and double quote characters\n     * preceded by a backslash still yield single and double quote\n     * characters, respectively.\n     *\n     * \u003cli\u003e Only a single \u0027u\u0027 character is allowed in a Unicode escape\n     * sequence.\n     *\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The specified stream remains open after this method returns.\n     *\n     * @param   reader   the input character stream.\n     * @throws  IOException  if an error occurred when reading from the\n     *          input stream.\n     * @throws  IllegalArgumentException if a malformed Unicode escape\n     *          appears in the input.\n     * @throws  NullPointerException if {@code reader} is null.\n     * @since   1.6\n     */\n    public synchronized void load(Reader reader) throws IOException {\n        Objects.requireNonNull(reader, \"reader parameter is null\");\n        load0(new LineReader(reader));\n    }\n\n    /**\n     * Reads a property list (key and element pairs) from the input\n     * byte stream. The input stream is in a simple line-oriented\n     * format as specified in\n     * {@link #load(java.io.Reader) load(Reader)} and is assumed to use\n     * the ISO 8859-1 character encoding; that is each byte is one Latin1\n     * character. Characters not in Latin1, and certain special characters,\n     * are represented in keys and elements using Unicode escapes as defined in\n     * section {@jls 3.3} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     * \u003cp\u003e\n     * The specified stream remains open after this method returns.\n     *\n     * @param      inStream   the input stream.\n     * @throws     IOException  if an error occurred when reading from the\n     *             input stream.\n     * @throws     IllegalArgumentException if the input stream contains a\n     *             malformed Unicode escape sequence.\n     * @throws     NullPointerException if {@code inStream} is null.\n     * @since 1.2\n     */\n    public synchronized void load(InputStream inStream) throws IOException {\n        Objects.requireNonNull(inStream, \"inStream parameter is null\");\n        load0(new LineReader(inStream));\n    }\n\n    private void load0(LineReader lr) throws IOException {\n        StringBuilder outBuffer \u003d new StringBuilder();\n        int limit;\n        int keyLen;\n        int valueStart;\n        boolean hasSep;\n        boolean precedingBackslash;\n\n        while ((limit \u003d lr.readLine()) \u003e\u003d 0) {\n            keyLen \u003d 0;\n            valueStart \u003d limit;\n            hasSep \u003d false;\n\n            //System.out.println(\"line\u003d\u003c\" + new String(lineBuf, 0, limit) + \"\u003e\");\n            precedingBackslash \u003d false;\n            while (keyLen \u003c limit) {\n                char c \u003d lr.lineBuf[keyLen];\n                //need check if escaped.\n                if ((c \u003d\u003d \u0027\u003d\u0027 ||  c \u003d\u003d \u0027:\u0027) \u0026\u0026 !precedingBackslash) {\n                    valueStart \u003d keyLen + 1;\n                    hasSep \u003d true;\n                    break;\n                } else if ((c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\t\u0027 ||  c \u003d\u003d \u0027\\f\u0027) \u0026\u0026 !precedingBackslash) {\n                    valueStart \u003d keyLen + 1;\n                    break;\n                }\n                if (c \u003d\u003d \u0027\\\\\u0027) {\n                    precedingBackslash \u003d !precedingBackslash;\n                } else {\n                    precedingBackslash \u003d false;\n                }\n                keyLen++;\n            }\n            while (valueStart \u003c limit) {\n                char c \u003d lr.lineBuf[valueStart];\n                if (c !\u003d \u0027 \u0027 \u0026\u0026 c !\u003d \u0027\\t\u0027 \u0026\u0026  c !\u003d \u0027\\f\u0027) {\n                    if (!hasSep \u0026\u0026 (c \u003d\u003d \u0027\u003d\u0027 ||  c \u003d\u003d \u0027:\u0027)) {\n                        hasSep \u003d true;\n                    } else {\n                        break;\n                    }\n                }\n                valueStart++;\n            }\n            String key \u003d loadConvert(lr.lineBuf, 0, keyLen, outBuffer);\n            String value \u003d loadConvert(lr.lineBuf, valueStart, limit - valueStart, outBuffer);\n            put(key, value);\n        }\n    }\n\n    /* Read in a \"logical line\" from an InputStream/Reader, skip all comment\n     * and blank lines and filter out those leading whitespace characters\n     * (\\u0020, \\u0009 and \\u000c) from the beginning of a \"natural line\".\n     * Method returns the char length of the \"logical line\" and stores\n     * the line in \"lineBuf\".\n     */\n    private static class LineReader {\n        LineReader(InputStream inStream) {\n            this.inStream \u003d inStream;\n            inByteBuf \u003d new byte[8192];\n        }\n\n        LineReader(Reader reader) {\n            this.reader \u003d reader;\n            inCharBuf \u003d new char[8192];\n        }\n\n        char[] lineBuf \u003d new char[1024];\n        private byte[] inByteBuf;\n        private char[] inCharBuf;\n        private int inLimit \u003d 0;\n        private int inOff \u003d 0;\n        private InputStream inStream;\n        private Reader reader;\n\n        int readLine() throws IOException {\n            // use locals to optimize for interpreted performance\n            int len \u003d 0;\n            int off \u003d inOff;\n            int limit \u003d inLimit;\n\n            boolean skipWhiteSpace \u003d true;\n            boolean appendedLineBegin \u003d false;\n            boolean precedingBackslash \u003d false;\n            boolean fromStream \u003d inStream !\u003d null;\n            byte[] byteBuf \u003d inByteBuf;\n            char[] charBuf \u003d inCharBuf;\n            char[] lineBuf \u003d this.lineBuf;\n            char c;\n\n            while (true) {\n                if (off \u003e\u003d limit) {\n                    inLimit \u003d limit \u003d fromStream ? inStream.read(byteBuf)\n                                                 : reader.read(charBuf);\n                    if (limit \u003c\u003d 0) {\n                        if (len \u003d\u003d 0) {\n                            return -1;\n                        }\n                        return precedingBackslash ? len - 1 : len;\n                    }\n                    off \u003d 0;\n                }\n\n                // (char)(byte \u0026 0xFF) is equivalent to calling a ISO8859-1 decoder.\n                c \u003d (fromStream) ? (char)(byteBuf[off++] \u0026 0xFF) : charBuf[off++];\n\n                if (skipWhiteSpace) {\n                    if (c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\t\u0027 || c \u003d\u003d \u0027\\f\u0027) {\n                        continue;\n                    }\n                    if (!appendedLineBegin \u0026\u0026 (c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\n\u0027)) {\n                        continue;\n                    }\n                    skipWhiteSpace \u003d false;\n                    appendedLineBegin \u003d false;\n\n                }\n                if (len \u003d\u003d 0) { // Still on a new logical line\n                    if (c \u003d\u003d \u0027#\u0027 || c \u003d\u003d \u0027!\u0027) {\n                        // Comment, quickly consume the rest of the line\n\n                        // When checking for new line characters a range check,\n                        // starting with the higher bound (\u0027\\r\u0027) means one less\n                        // branch in the common case.\n                        commentLoop: while (true) {\n                            if (fromStream) {\n                                byte b;\n                                while (off \u003c limit) {\n                                    b \u003d byteBuf[off++];\n                                    if (b \u003c\u003d \u0027\\r\u0027 \u0026\u0026 (b \u003d\u003d \u0027\\r\u0027 || b \u003d\u003d \u0027\\n\u0027))\n                                        break commentLoop;\n                                }\n                                if (off \u003d\u003d limit) {\n                                    inLimit \u003d limit \u003d inStream.read(byteBuf);\n                                    if (limit \u003c\u003d 0) { // EOF\n                                        return -1;\n                                    }\n                                    off \u003d 0;\n                                }\n                            } else {\n                                while (off \u003c limit) {\n                                    c \u003d charBuf[off++];\n                                    if (c \u003c\u003d \u0027\\r\u0027 \u0026\u0026 (c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\n\u0027))\n                                        break commentLoop;\n                                }\n                                if (off \u003d\u003d limit) {\n                                    inLimit \u003d limit \u003d reader.read(charBuf);\n                                    if (limit \u003c\u003d 0) { // EOF\n                                        return -1;\n                                    }\n                                    off \u003d 0;\n                                }\n                            }\n                        }\n                        skipWhiteSpace \u003d true;\n                        continue;\n                    }\n                }\n\n                if (c !\u003d \u0027\\n\u0027 \u0026\u0026 c !\u003d \u0027\\r\u0027) {\n                    lineBuf[len++] \u003d c;\n                    if (len \u003d\u003d lineBuf.length) {\n                        lineBuf \u003d new char[ArraysSupport.newLength(len, 1, len)];\n                        System.arraycopy(this.lineBuf, 0, lineBuf, 0, len);\n                        this.lineBuf \u003d lineBuf;\n                    }\n                    // flip the preceding backslash flag\n                    precedingBackslash \u003d (c \u003d\u003d \u0027\\\\\u0027) ? !precedingBackslash : false;\n                } else {\n                    // reached EOL\n                    if (len \u003d\u003d 0) {\n                        skipWhiteSpace \u003d true;\n                        continue;\n                    }\n                    if (off \u003e\u003d limit) {\n                        inLimit \u003d limit \u003d fromStream ? inStream.read(byteBuf)\n                                                     : reader.read(charBuf);\n                        off \u003d 0;\n                        if (limit \u003c\u003d 0) { // EOF\n                            return precedingBackslash ? len - 1 : len;\n                        }\n                    }\n                    if (precedingBackslash) {\n                        // backslash at EOL is not part of the line\n                        len -\u003d 1;\n                        // skip leading whitespace characters in the following line\n                        skipWhiteSpace \u003d true;\n                        appendedLineBegin \u003d true;\n                        precedingBackslash \u003d false;\n                        // take care not to include any subsequent \\n\n                        if (c \u003d\u003d \u0027\\r\u0027) {\n                            if (fromStream) {\n                                if (byteBuf[off] \u003d\u003d \u0027\\n\u0027) {\n                                    off++;\n                                }\n                            } else {\n                                if (charBuf[off] \u003d\u003d \u0027\\n\u0027) {\n                                    off++;\n                                }\n                            }\n                        }\n                    } else {\n                        inOff \u003d off;\n                        return len;\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n     * Converts encoded \u0026#92;uxxxx to unicode chars\n     * and changes special saved chars to their original forms\n     */\n    private String loadConvert(char[] in, int off, int len, StringBuilder out) {\n        char aChar;\n        int end \u003d off + len;\n        int start \u003d off;\n        while (off \u003c end) {\n            aChar \u003d in[off++];\n            if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                break;\n            }\n        }\n        if (off \u003d\u003d end) { // No backslash\n            return new String(in, start, len);\n        }\n\n        // backslash found at off - 1, reset the shared buffer, rewind offset\n        out.setLength(0);\n        off--;\n        out.append(in, start, off - start);\n\n        while (off \u003c end) {\n            aChar \u003d in[off++];\n            if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                // No need to bounds check since LineReader::readLine excludes\n                // unescaped \\s at the end of the line\n                aChar \u003d in[off++];\n                if(aChar \u003d\u003d \u0027u\u0027) {\n                    // Read the xxxx\n                    if (off \u003e end - 4)\n                        throw new IllegalArgumentException(\n                                     \"Malformed \\\\uxxxx encoding.\");\n                    int value \u003d 0;\n                    for (int i \u003d 0; i \u003c 4; i++) {\n                        aChar \u003d in[off++];\n                        value \u003d switch (aChar) {\n                            case \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027 -\u003e (value \u003c\u003c 4) + aChar - \u00270\u0027;\n                            case \u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027, \u0027f\u0027                     -\u003e (value \u003c\u003c 4) + 10 + aChar - \u0027a\u0027;\n                            case \u0027A\u0027, \u0027B\u0027, \u0027C\u0027, \u0027D\u0027, \u0027E\u0027, \u0027F\u0027                     -\u003e (value \u003c\u003c 4) + 10 + aChar - \u0027A\u0027;\n                            default -\u003e throw new IllegalArgumentException(\"Malformed \\\\uxxxx encoding.\");\n                        };\n                    }\n                    out.append((char)value);\n                } else {\n                    if (aChar \u003d\u003d \u0027t\u0027) aChar \u003d \u0027\\t\u0027;\n                    else if (aChar \u003d\u003d \u0027r\u0027) aChar \u003d \u0027\\r\u0027;\n                    else if (aChar \u003d\u003d \u0027n\u0027) aChar \u003d \u0027\\n\u0027;\n                    else if (aChar \u003d\u003d \u0027f\u0027) aChar \u003d \u0027\\f\u0027;\n                    out.append(aChar);\n                }\n            } else {\n                out.append(aChar);\n            }\n        }\n        return out.toString();\n    }\n\n    /*\n     * Converts unicodes to encoded \u0026#92;uxxxx and escapes\n     * special characters with a preceding slash\n     */\n    private String saveConvert(String theString,\n                               boolean escapeSpace,\n                               boolean escapeUnicode) {\n        int len \u003d theString.length();\n        int bufLen \u003d len * 2;\n        if (bufLen \u003c 0) {\n            bufLen \u003d Integer.MAX_VALUE;\n        }\n        StringBuilder outBuffer \u003d new StringBuilder(bufLen);\n        HexFormat hex \u003d HexFormat.of().withUpperCase();\n        for(int x\u003d0; x\u003clen; x++) {\n            char aChar \u003d theString.charAt(x);\n            // Handle common case first, selecting largest block that\n            // avoids the specials below\n            if ((aChar \u003e 61) \u0026\u0026 (aChar \u003c 127)) {\n                if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                    outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027\\\\\u0027);\n                    continue;\n                }\n                outBuffer.append(aChar);\n                continue;\n            }\n            switch(aChar) {\n                case \u0027 \u0027:\n                    if (x \u003d\u003d 0 || escapeSpace)\n                        outBuffer.append(\u0027\\\\\u0027);\n                    outBuffer.append(\u0027 \u0027);\n                    break;\n                case \u0027\\t\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027t\u0027);\n                          break;\n                case \u0027\\n\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027n\u0027);\n                          break;\n                case \u0027\\r\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027r\u0027);\n                          break;\n                case \u0027\\f\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027f\u0027);\n                          break;\n                case \u0027\u003d\u0027: // Fall through\n                case \u0027:\u0027: // Fall through\n                case \u0027#\u0027: // Fall through\n                case \u0027!\u0027:\n                    outBuffer.append(\u0027\\\\\u0027); outBuffer.append(aChar);\n                    break;\n                default:\n                    if (((aChar \u003c 0x0020) || (aChar \u003e 0x007e)) \u0026 escapeUnicode ) {\n                        outBuffer.append(\"\\\\u\");\n                        outBuffer.append(hex.toHexDigits(aChar));\n                    } else {\n                        outBuffer.append(aChar);\n                    }\n            }\n        }\n        return outBuffer.toString();\n    }\n\n    private static void writeComments(BufferedWriter bw, String comments)\n        throws IOException {\n        HexFormat hex \u003d HexFormat.of().withUpperCase();\n        bw.write(\"#\");\n        int len \u003d comments.length();\n        int current \u003d 0;\n        int last \u003d 0;\n        while (current \u003c len) {\n            char c \u003d comments.charAt(current);\n            if (c \u003e \u0027\\u00ff\u0027 || c \u003d\u003d \u0027\\n\u0027 || c \u003d\u003d \u0027\\r\u0027) {\n                if (last !\u003d current)\n                    bw.write(comments.substring(last, current));\n                if (c \u003e \u0027\\u00ff\u0027) {\n                    bw.write(\"\\\\u\");\n                    bw.write(hex.toHexDigits(c));\n                } else {\n                    bw.newLine();\n                    if (c \u003d\u003d \u0027\\r\u0027 \u0026\u0026\n                        current !\u003d len - 1 \u0026\u0026\n                        comments.charAt(current + 1) \u003d\u003d \u0027\\n\u0027) {\n                        current++;\n                    }\n                    if (current \u003d\u003d len - 1 ||\n                        (comments.charAt(current + 1) !\u003d \u0027#\u0027 \u0026\u0026\n                        comments.charAt(current + 1) !\u003d \u0027!\u0027))\n                        bw.write(\"#\");\n                }\n                last \u003d current + 1;\n            }\n            current++;\n        }\n        if (last !\u003d current)\n            bw.write(comments.substring(last, current));\n        bw.newLine();\n    }\n\n    /**\n     * Calls the {@code store(OutputStream out, String comments)} method\n     * and suppresses IOExceptions that were thrown.\n     *\n     * @deprecated This method does not throw an IOException if an I/O error\n     * occurs while saving the property list.  The preferred way to save a\n     * properties list is via the {@code store(OutputStream out,\n     * String comments)} method or the\n     * {@code storeToXML(OutputStream os, String comment)} method.\n     *\n     * @param   out      an output stream.\n     * @param   comments   a description of the property list.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not\n     *             {@code Strings}.\n     */\n    @Deprecated\n    public void save(OutputStream out, String comments)  {\n        try {\n            store(out, comments);\n        } catch (IOException e) {\n        }\n    }\n\n    /**\n     * Writes this property list (key and element pairs) in this\n     * {@code Properties} table to the output character stream in a\n     * format suitable for using the {@link #load(java.io.Reader) load(Reader)}\n     * method.\n     * \u003cp\u003e\n     * Properties from the defaults table of this {@code Properties}\n     * table (if any) are \u003ci\u003enot\u003c/i\u003e written out by this method.\n     * \u003cp\u003e\n     * If the comments argument is not null, then an ASCII {@code #}\n     * character, the comments string, and a line separator are first written\n     * to the output stream. Thus, the {@code comments} can serve as an\n     * identifying comment. Any one of a line feed ({@code \\n}), a carriage\n     * return ({@code \\r}), or a carriage return followed immediately by a line feed\n     * ({@code \\r\\n}) in comments is replaced by a\n     * {@link System#lineSeparator() line separator} and if the next\n     * character in comments is not character {@code #} or character {@code !} then\n     * an ASCII {@code #} is written out after that line separator.\n     * \u003cp\u003e\n     * If the {@systemProperty java.properties.date} is set on the command line\n     * and is non-empty (as determined by {@link String#isEmpty()  String.isEmpty}),\n     * a comment line is written as follows.\n     * First, a {@code #} character is written, followed by the contents\n     * of the property, followed by a line separator. Any line terminator characters\n     * in the value of the system property are treated the same way as noted above\n     * for the comments argument.\n     * If the system property is not set or is empty, a comment line is written\n     * as follows.\n     * First, a {@code #} character is written, followed by the current date and time\n     * formatted as if by the {@link Date#toString() Date.toString} method,\n     * followed by a line separator.\n     * \u003cp\u003e\n     * Then every entry in this {@code Properties} table is\n     * written out, one per line. For each entry the key string is\n     * written, then an ASCII {@code \u003d}, then the associated\n     * element string. For the key, all space characters are\n     * written with a preceding {@code \\} character.  For the\n     * element, leading space characters, but not embedded or trailing\n     * space characters, are written with a preceding {@code \\}\n     * character. The key and element characters {@code #},\n     * {@code !}, {@code \u003d}, and {@code :} are written\n     * with a preceding backslash to ensure that they are properly loaded.\n     * \u003cp\u003e\n     * After the entries have been written, the output stream is flushed.\n     * The output stream remains open after this method returns.\n     *\n     * @implSpec The keys and elements are written in the natural sort order\n     * of the keys in the {@code entrySet()} unless {@code entrySet()} is\n     * overridden by a subclass to return a different value than {@code super.entrySet()}.\n     *\n     * @param   writer      an output character stream writer.\n     * @param   comments   a description of the property list.\n     * @throws     IOException if writing this property list to the specified\n     *             output stream throws an {@code IOException}.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not {@code Strings}.\n     * @throws     NullPointerException  if {@code writer} is null.\n     * @since 1.6\n     */\n    public void store(Writer writer, String comments)\n        throws IOException\n    {\n        store0((writer instanceof BufferedWriter)?(BufferedWriter)writer\n                                                 : new BufferedWriter(writer),\n               comments,\n               false);\n    }\n\n    /**\n     * Writes this property list (key and element pairs) in this\n     * {@code Properties} table to the output stream in a format suitable\n     * for loading into a {@code Properties} table using the\n     * {@link #load(InputStream) load(InputStream)} method.\n     * \u003cp\u003e\n     * Properties from the defaults table of this {@code Properties}\n     * table (if any) are \u003ci\u003enot\u003c/i\u003e written out by this method.\n     * \u003cp\u003e\n     * This method outputs the comments, properties keys and values in\n     * the same format as specified in\n     * {@link #store(java.io.Writer, java.lang.String) store(Writer)},\n     * with the following differences:\n     * \u003cul\u003e\n     * \u003cli\u003eThe stream is written using the ISO 8859-1 character encoding.\n     *\n     * \u003cli\u003eCharacters not in Latin-1 in the comments are written as\n     * {@code \\u005Cu}\u003ci\u003exxxx\u003c/i\u003e for their appropriate unicode\n     * hexadecimal value \u003ci\u003exxxx\u003c/i\u003e.\n     *\n     * \u003cli\u003eCharacters less than {@code \\u005Cu0020} and characters greater\n     * than {@code \\u005Cu007E} in property keys or values are written\n     * as {@code \\u005Cu}\u003ci\u003exxxx\u003c/i\u003e for the appropriate hexadecimal\n     * value \u003ci\u003exxxx\u003c/i\u003e.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * After the entries have been written, the output stream is flushed.\n     * The output stream remains open after this method returns.\n     *\n     * @param   out      an output stream.\n     * @param   comments   a description of the property list.\n     * @throws     IOException if writing this property list to the specified\n     *             output stream throws an {@code IOException}.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not {@code Strings}.\n     * @throws     NullPointerException  if {@code out} is null.\n     * @since 1.2\n     */\n    public void store(OutputStream out, String comments)\n        throws IOException\n    {\n        store0(new BufferedWriter(new OutputStreamWriter(out, ISO_8859_1.INSTANCE)),\n               comments,\n               true);\n    }\n\n    private void store0(BufferedWriter bw, String comments, boolean escUnicode)\n        throws IOException\n    {\n        if (comments !\u003d null) {\n            writeComments(bw, comments);\n        }\n        writeDateComment(bw);\n\n        synchronized (this) {\n            @SuppressWarnings(\"unchecked\")\n            Collection\u003cMap.Entry\u003cString, String\u003e\u003e entries \u003d (Set\u003cMap.Entry\u003cString, String\u003e\u003e) (Set) entrySet();\n            // entrySet() can be overridden by subclasses. Here we check to see if\n            // the returned instance type is the one returned by the Properties.entrySet()\n            // implementation. If yes, then we sort those entries in the natural order\n            // of their key. Else, we consider that the subclassed implementation may\n            // potentially have returned a differently ordered entries and so we just\n            // use the iteration order of the returned instance.\n            if (entries instanceof Collections.SynchronizedSet\u003c?\u003e ss\n                    \u0026\u0026 ss.c instanceof EntrySet) {\n                entries \u003d new ArrayList\u003c\u003e(entries);\n                ((List\u003cMap.Entry\u003cString, String\u003e\u003e) entries).sort(Map.Entry.comparingByKey());\n            }\n            for (Map.Entry\u003cString, String\u003e e : entries) {\n                String key \u003d e.getKey();\n                String val \u003d e.getValue();\n                key \u003d saveConvert(key, true, escUnicode);\n                /* No need to escape embedded and trailing spaces for value, hence\n                 * pass false to flag.\n                 */\n                val \u003d saveConvert(val, false, escUnicode);\n                bw.write(key + \"\u003d\" + val);\n                bw.newLine();\n            }\n        }\n        bw.flush();\n    }\n\n    private static void writeDateComment(BufferedWriter bw) throws IOException {\n        // value of java.properties.date system property isn\u0027t sensitive\n        // and so doesn\u0027t need any security manager checks to make the value accessible\n        // to the callers\n        String sysPropVal \u003d StaticProperty.javaPropertiesDate();\n        if (sysPropVal !\u003d null \u0026\u0026 !sysPropVal.isEmpty()) {\n            writeComments(bw, sysPropVal);\n        } else {\n            bw.write(\"#\" + new Date());\n            bw.newLine();\n        }\n    }\n\n    /**\n     * Loads all of the properties represented by the XML document on the\n     * specified input stream into this properties table.\n     *\n     * \u003cp\u003eThe XML document must have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     * Furthermore, the document must satisfy the properties DTD described\n     * above.\n     *\n     * \u003cp\u003e An implementation is required to read XML documents that use the\n     * \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An implementation may\n     * support additional encodings.\n     *\n     * \u003cp\u003eThe specified stream is closed after this method returns.\n     *\n     * @param in the input stream from which to read the XML document.\n     * @throws IOException if reading from the specified input stream\n     *         results in an {@code IOException}.\n     * @throws java.io.UnsupportedEncodingException if the document\u0027s encoding\n     *         declaration can be read and it specifies an encoding that is not\n     *         supported\n     * @throws InvalidPropertiesFormatException Data on input stream does not\n     *         constitute a valid XML document with the mandated document type.\n     * @throws NullPointerException if {@code in} is null.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #storeToXML(OutputStream, String, String)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 1.5\n     */\n    public synchronized void loadFromXML(InputStream in)\n        throws IOException, InvalidPropertiesFormatException\n    {\n        Objects.requireNonNull(in);\n        PropertiesDefaultHandler handler \u003d new PropertiesDefaultHandler();\n        handler.load(this, in);\n        in.close();\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table.\n     *\n     * \u003cp\u003e An invocation of this method of the form {@code props.storeToXML(os,\n     * comment)} behaves in exactly the same way as the invocation\n     * {@code props.storeToXML(os, comment, \"UTF-8\");}.\n     *\n     * @param os the output stream on which to emit the XML document.\n     * @param comment a description of the property list, or {@code null}\n     *        if no comment is desired.\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws NullPointerException if {@code os} is null.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not\n     *         {@code Strings}.\n     * @see    #loadFromXML(InputStream)\n     * @since 1.5\n     */\n    public void storeToXML(OutputStream os, String comment)\n        throws IOException\n    {\n        storeToXML(os, comment, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table, using the specified encoding.\n     *\n     * \u003cp\u003eThe XML document will have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003eIf the specified comment is {@code null} then no comment\n     * will be stored in the document.\n     *\n     * \u003cp\u003e An implementation is required to support writing of XML documents\n     * that use the \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An\n     * implementation may support additional encodings.\n     *\n     * \u003cp\u003eThe specified stream remains open after this method returns.\n     *\n     * \u003cp\u003eThis method behaves the same as\n     * {@linkplain #storeToXML(OutputStream os, String comment, Charset charset)}\n     * except that it will {@linkplain java.nio.charset.Charset#forName look up the charset}\n     * using the given encoding name.\n     *\n     * @param os        the output stream on which to emit the XML document.\n     * @param comment   a description of the property list, or {@code null}\n     *                  if no comment is desired.\n     * @param  encoding the name of a supported\n     *                  \u003ca href\u003d\"../lang/package-summary.html#charenc\"\u003e\n     *                  character encoding\u003c/a\u003e\n     *\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws java.io.UnsupportedEncodingException if the encoding is not\n     *         supported by the implementation.\n     * @throws NullPointerException if {@code os} is {@code null},\n     *         or if {@code encoding} is {@code null}.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not {@code Strings}.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #loadFromXML(InputStream)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 1.5\n     */\n    public void storeToXML(OutputStream os, String comment, String encoding)\n        throws IOException {\n        Objects.requireNonNull(os);\n        Objects.requireNonNull(encoding);\n\n        try {\n            Charset charset \u003d Charset.forName(encoding);\n            storeToXML(os, comment, charset);\n        } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {\n            throw new UnsupportedEncodingException(encoding);\n        }\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table, using the specified encoding.\n     *\n     * \u003cp\u003eThe XML document will have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003eIf the specified comment is {@code null} then no comment\n     * will be stored in the document.\n     *\n     * \u003cp\u003e An implementation is required to support writing of XML documents\n     * that use the \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An\n     * implementation may support additional encodings.\n     *\n     * \u003cp\u003e Unmappable characters for the specified charset will be encoded as\n     * numeric character references.\n     *\n     * \u003cp\u003eThe specified stream remains open after this method returns.\n     *\n     * @param os        the output stream on which to emit the XML document.\n     * @param comment   a description of the property list, or {@code null}\n     *                  if no comment is desired.\n     * @param charset   the charset\n     *\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws NullPointerException if {@code os} or {@code charset} is {@code null}.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not {@code Strings}.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #loadFromXML(InputStream)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 10\n     */\n    public void storeToXML(OutputStream os, String comment, Charset charset)\n        throws IOException {\n        Objects.requireNonNull(os, \"OutputStream\");\n        Objects.requireNonNull(charset, \"Charset\");\n        PropertiesDefaultHandler handler \u003d new PropertiesDefaultHandler();\n        handler.store(this, os, comment, charset);\n    }\n\n    /**\n     * Searches for the property with the specified key in this property list.\n     * If the key is not found in this property list, the default property list,\n     * and its defaults, recursively, are then checked. The method returns\n     * {@code null} if the property is not found.\n     *\n     * @param   key   the property key.\n     * @return  the value in this property list with the specified key value.\n     * @see     #setProperty\n     * @see     #defaults\n     */\n    public String getProperty(String key) {\n        Object oval \u003d map.get(key);\n        String sval \u003d (oval instanceof String) ? (String)oval : null;\n        Properties defaults;\n        return ((sval \u003d\u003d null) \u0026\u0026 ((defaults \u003d this.defaults) !\u003d null)) ? defaults.getProperty(key) : sval;\n    }\n\n    /**\n     * Searches for the property with the specified key in this property list.\n     * If the key is not found in this property list, the default property list,\n     * and its defaults, recursively, are then checked. The method returns the\n     * default value argument if the property is not found.\n     *\n     * @param   key            the hashtable key.\n     * @param   defaultValue   a default value.\n     *\n     * @return  the value in this property list with the specified key value.\n     * @see     #setProperty\n     * @see     #defaults\n     */\n    public String getProperty(String key, String defaultValue) {\n        String val \u003d getProperty(key);\n        return (val \u003d\u003d null) ? defaultValue : val;\n    }\n\n    /**\n     * Returns an enumeration of all the keys in this property list,\n     * including distinct keys in the default property list if a key\n     * of the same name has not already been found from the main\n     * properties list.\n     *\n     * @return  an enumeration of all the keys in this property list, including\n     *          the keys in the default property list.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     * @see     java.util.Enumeration\n     * @see     java.util.Properties#defaults\n     * @see     #stringPropertyNames\n     */\n    public Enumeration\u003c?\u003e propertyNames() {\n        Hashtable\u003cString,Object\u003e h \u003d new Hashtable\u003c\u003e();\n        enumerate(h);\n        return h.keys();\n    }\n\n    /**\n     * Returns an unmodifiable set of keys from this property list\n     * where the key and its corresponding value are strings,\n     * including distinct keys in the default property list if a key\n     * of the same name has not already been found from the main\n     * properties list.  Properties whose key or value is not\n     * of type {@code String} are omitted.\n     * \u003cp\u003e\n     * The returned set is not backed by this {@code Properties} object.\n     * Changes to this {@code Properties} object are not reflected in the\n     * returned set.\n     *\n     * @return  an unmodifiable set of keys in this property list where\n     *          the key and its corresponding value are strings,\n     *          including the keys in the default property list.\n     * @see     java.util.Properties#defaults\n     * @since   1.6\n     */\n    public Set\u003cString\u003e stringPropertyNames() {\n        Map\u003cString, String\u003e h \u003d new HashMap\u003c\u003e();\n        enumerateStringProperties(h);\n        return Collections.unmodifiableSet(h.keySet());\n    }\n\n    /**\n     * Prints this property list out to the specified output stream.\n     * This method is useful for debugging.\n     *\n     * @param   out   an output stream.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     */\n    public void list(PrintStream out) {\n        out.println(\"-- listing properties --\");\n        Map\u003cString, Object\u003e h \u003d new HashMap\u003c\u003e();\n        enumerate(h);\n        for (Map.Entry\u003cString, Object\u003e e : h.entrySet()) {\n            String key \u003d e.getKey();\n            String val \u003d (String)e.getValue();\n            if (val.length() \u003e 40) {\n                val \u003d val.substring(0, 37) + \"...\";\n            }\n            out.println(key + \"\u003d\" + val);\n        }\n    }\n\n    /**\n     * Prints this property list out to the specified output stream.\n     * This method is useful for debugging.\n     *\n     * @param   out   an output stream.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     * @since   1.1\n     */\n    /*\n     * Rather than use an anonymous inner class to share common code, this\n     * method is duplicated in order to ensure that a non-1.1 compiler can\n     * compile this file.\n     */\n    public void list(PrintWriter out) {\n        out.println(\"-- listing properties --\");\n        Map\u003cString, Object\u003e h \u003d new HashMap\u003c\u003e();\n        enumerate(h);\n        for (Map.Entry\u003cString, Object\u003e e : h.entrySet()) {\n            String key \u003d e.getKey();\n            String val \u003d (String)e.getValue();\n            if (val.length() \u003e 40) {\n                val \u003d val.substring(0, 37) + \"...\";\n            }\n            out.println(key + \"\u003d\" + val);\n        }\n    }\n\n    /**\n     * Enumerates all key/value pairs into the specified Map.\n     * @param h the Map\n     * @throws ClassCastException if any of the property keys\n     *         is not of String type.\n     */\n    private void enumerate(Map\u003cString, Object\u003e h) {\n        if (defaults !\u003d null) {\n            defaults.enumerate(h);\n        }\n        for (Map.Entry\u003cObject, Object\u003e e : entrySet()) {\n            String key \u003d (String)e.getKey();\n            h.put(key, e.getValue());\n        }\n    }\n\n    /**\n     * Enumerates all key/value pairs into the specified Map\n     * and omits the property if the key or value is not a string.\n     * @param h the Map\n     */\n    private void enumerateStringProperties(Map\u003cString, String\u003e h) {\n        if (defaults !\u003d null) {\n            defaults.enumerateStringProperties(h);\n        }\n        for (Map.Entry\u003cObject, Object\u003e e : entrySet()) {\n            Object k \u003d e.getKey();\n            Object v \u003d e.getValue();\n            if (k instanceof String \u0026\u0026 v instanceof String) {\n                h.put((String) k, (String) v);\n            }\n        }\n    }\n\n    //\n    // Hashtable methods overridden and delegated to a ConcurrentHashMap instance\n\n    @Override\n    public int size() {\n        return map.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    @Override\n    public Enumeration\u003cObject\u003e keys() {\n        // CHM.keys() returns Iterator w/ remove() - instead wrap keySet()\n        return Collections.enumeration(map.keySet());\n    }\n\n    @Override\n    public Enumeration\u003cObject\u003e elements() {\n        // CHM.elements() returns Iterator w/ remove() - instead wrap values()\n        return Collections.enumeration(map.values());\n    }\n\n    @Override\n    public boolean contains(Object value) {\n        return map.contains(value);\n    }\n\n    @Override\n    public boolean containsValue(Object value) {\n        return map.containsValue(value);\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return map.containsKey(key);\n    }\n\n    @Override\n    public Object get(Object key) {\n        return map.get(key);\n    }\n\n    @Override\n    public synchronized Object put(Object key, Object value) {\n        return map.put(key, value);\n    }\n\n    @Override\n    public synchronized Object remove(Object key) {\n        return map.remove(key);\n    }\n\n    @Override\n    public synchronized void putAll(Map\u003c?, ?\u003e t) {\n        map.putAll(t);\n    }\n\n    @Override\n    public synchronized void clear() {\n        map.clear();\n    }\n\n    @Override\n    public synchronized String toString() {\n        return map.toString();\n    }\n\n    @Override\n    public Set\u003cObject\u003e keySet() {\n        return Collections.synchronizedSet(map.keySet(), this);\n    }\n\n    @Override\n    public Collection\u003cObject\u003e values() {\n        return Collections.synchronizedCollection(map.values(), this);\n    }\n\n    @Override\n    public Set\u003cMap.Entry\u003cObject, Object\u003e\u003e entrySet() {\n        return Collections.synchronizedSet(new EntrySet(map.entrySet()), this);\n    }\n\n    /*\n     * Properties.entrySet() should not support add/addAll, however\n     * ConcurrentHashMap.entrySet() provides add/addAll.  This class wraps the\n     * Set returned from CHM, changing add/addAll to throw UOE.\n     */\n    private static class EntrySet implements Set\u003cMap.Entry\u003cObject, Object\u003e\u003e {\n        private Set\u003cMap.Entry\u003cObject,Object\u003e\u003e entrySet;\n\n        private EntrySet(Set\u003cMap.Entry\u003cObject, Object\u003e\u003e entrySet) {\n            this.entrySet \u003d entrySet;\n        }\n\n        @Override public int size() { return entrySet.size(); }\n        @Override public boolean isEmpty() { return entrySet.isEmpty(); }\n        @Override public boolean contains(Object o) { return entrySet.contains(o); }\n        @Override public Object[] toArray() { return entrySet.toArray(); }\n        @Override public \u003cT\u003e T[] toArray(T[] a) { return entrySet.toArray(a); }\n        @Override public void clear() { entrySet.clear(); }\n        @Override public boolean remove(Object o) { return entrySet.remove(o); }\n\n        @Override\n        public boolean add(Map.Entry\u003cObject, Object\u003e e) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean addAll(Collection\u003c? extends Map.Entry\u003cObject, Object\u003e\u003e c) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean containsAll(Collection\u003c?\u003e c) {\n            return entrySet.containsAll(c);\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            return o \u003d\u003d this || entrySet.equals(o);\n        }\n\n        @Override\n        public int hashCode() {\n            return entrySet.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return entrySet.toString();\n        }\n\n        @Override\n        public boolean removeAll(Collection\u003c?\u003e c) {\n            return entrySet.removeAll(c);\n        }\n\n        @Override\n        public boolean retainAll(Collection\u003c?\u003e c) {\n            return entrySet.retainAll(c);\n        }\n\n        @Override\n        public Iterator\u003cMap.Entry\u003cObject, Object\u003e\u003e iterator() {\n            return entrySet.iterator();\n        }\n    }\n\n    @Override\n    public synchronized boolean equals(Object o) {\n        return map.equals(o);\n    }\n\n    @Override\n    public synchronized int hashCode() {\n        return map.hashCode();\n    }\n\n    @Override\n    public Object getOrDefault(Object key, Object defaultValue) {\n        return map.getOrDefault(key, defaultValue);\n    }\n\n    @Override\n    public synchronized void forEach(BiConsumer\u003c? super Object, ? super Object\u003e action) {\n        map.forEach(action);\n    }\n\n    @Override\n    public synchronized void replaceAll(BiFunction\u003c? super Object, ? super Object, ?\u003e function) {\n        map.replaceAll(function);\n    }\n\n    @Override\n    public synchronized Object putIfAbsent(Object key, Object value) {\n        return map.putIfAbsent(key, value);\n    }\n\n    @Override\n    public synchronized boolean remove(Object key, Object value) {\n        return map.remove(key, value);\n    }\n\n    @Override\n    public synchronized boolean replace(Object key, Object oldValue, Object newValue) {\n        return map.replace(key, oldValue, newValue);\n    }\n\n    @Override\n    public synchronized Object replace(Object key, Object value) {\n        return map.replace(key, value);\n    }\n\n    @Override\n    public synchronized Object computeIfAbsent(Object key,\n            Function\u003c? super Object, ?\u003e mappingFunction) {\n        return map.computeIfAbsent(key, mappingFunction);\n    }\n\n    @Override\n    public synchronized Object computeIfPresent(Object key,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.computeIfPresent(key, remappingFunction);\n    }\n\n    @Override\n    public synchronized Object compute(Object key,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.compute(key, remappingFunction);\n    }\n\n    @Override\n    public synchronized Object merge(Object key, Object value,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.merge(key, value, remappingFunction);\n    }\n\n    //\n    // Special Hashtable methods\n\n    @Override\n    protected void rehash() { /* no-op */ }\n\n    @Override\n    public synchronized Object clone() {\n        Properties clone \u003d (Properties) cloneHashtable();\n        clone.map \u003d new ConcurrentHashMap\u003c\u003e(map);\n        return clone;\n    }\n\n    //\n    // Hashtable serialization overrides\n    // (these should emit and consume Hashtable-compatible stream)\n\n    @Override\n    void writeHashtable(ObjectOutputStream s) throws IOException {\n        var map \u003d this.map;\n        List\u003cObject\u003e entryStack \u003d new ArrayList\u003c\u003e(map.size() * 2); // an estimate\n\n        for (Map.Entry\u003cObject, Object\u003e entry : map.entrySet()) {\n            entryStack.add(entry.getValue());\n            entryStack.add(entry.getKey());\n        }\n\n        // Write out the simulated threshold, loadfactor\n        float loadFactor \u003d 0.75f;\n        int count \u003d entryStack.size() / 2;\n        int length \u003d (int)(count / loadFactor) + (count / 20) + 3;\n        if (length \u003e count \u0026\u0026 (length \u0026 1) \u003d\u003d 0) {\n            length--;\n        }\n        synchronized (map) { // in case of multiple concurrent serializations\n            defaultWriteHashtable(s, length, loadFactor);\n        }\n\n        // Write out simulated length and real count of elements\n        s.writeInt(length);\n        s.writeInt(count);\n\n        // Write out the key/value objects from the stacked entries\n        for (int i \u003d entryStack.size() - 1; i \u003e\u003d 0; i--) {\n            s.writeObject(entryStack.get(i));\n        }\n    }\n\n    @Override\n    void readHashtable(ObjectInputStream s) throws IOException,\n            ClassNotFoundException {\n        // Read in the threshold and loadfactor\n        s.defaultReadObject();\n\n        // Read the original length of the array and number of elements\n        int origlength \u003d s.readInt();\n        int elements \u003d s.readInt();\n\n        // Validate # of elements\n        if (elements \u003c 0) {\n            throw new StreamCorruptedException(\"Illegal # of Elements: \" + elements);\n        }\n\n        // Constructing the backing map will lazily create an array when the first element is\n        // added, so check it before construction. Note that CHM\u0027s constructor takes a size\n        // that is the number of elements to be stored -- not the table size -- so it must be\n        // inflated by the default load factor of 0.75, then inflated to the next power of two.\n        // (CHM uses the same power-of-two computation as HashMap, and HashMap.tableSizeFor is\n        // accessible here.) Check Map.Entry[].class since it\u0027s the nearest public type to\n        // what is actually created.\n        SharedSecrets.getJavaObjectInputStreamAccess()\n                     .checkArray(s, Map.Entry[].class, HashMap.tableSizeFor((int)(elements / 0.75)));\n\n        // create CHM of appropriate capacity\n        var map \u003d new ConcurrentHashMap\u003c\u003e(elements);\n\n        // Read all the key/value objects\n        for (; elements \u003e 0; elements--) {\n            Object key \u003d s.readObject();\n            Object value \u003d s.readObject();\n            map.put(key, value);\n        }\n        this.map \u003d map;\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

Π°ΠΏΡ€. 25, 2024 2:59:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/util/Properties.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.04.25 14:59:05 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java

Uri: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1570)
```

Π°ΠΏΡ€. 25, 2024 2:59:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/util/Properties.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1995, 2021, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.util;\n\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.StreamCorruptedException;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\nimport jdk.internal.util.StaticProperty;\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.UTF_8;\n\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.ArraysSupport;\nimport jdk.internal.util.xml.PropertiesDefaultHandler;\n\n/**\n * The {@code Properties} class represents a persistent set of\n * properties. The {@code Properties} can be saved to a stream\n * or loaded from a stream. Each key and its corresponding value in\n * the property list is a string.\n * \u003cp\u003e\n * A property list can contain another property list as its\n * \"defaults\"; this second property list is searched if\n * the property key is not found in the original property list.\n * \u003cp\u003e\n * Because {@code Properties} inherits from {@code Hashtable}, the\n * {@code put} and {@code putAll} methods can be applied to a\n * {@code Properties} object.  Their use is strongly discouraged as they\n * allow the caller to insert entries whose keys or values are not\n * {@code Strings}.  The {@code setProperty} method should be used\n * instead.  If the {@code store} or {@code save} method is called\n * on a \"compromised\" {@code Properties} object that contains a\n * non-{@code String} key or value, the call will fail. Similarly,\n * the call to the {@code propertyNames} or {@code list} method\n * will fail if it is called on a \"compromised\" {@code Properties}\n * object that contains a non-{@code String} key.\n *\n * \u003cp\u003e\n * The iterators returned by the {@code iterator} method of this class\u0027s\n * \"collection views\" (that is, {@code entrySet()}, {@code keySet()}, and\n * {@code values()}) may not fail-fast (unlike the Hashtable implementation).\n * These iterators are guaranteed to traverse elements as they existed upon\n * construction exactly once, and may (but are not guaranteed to) reflect any\n * modifications subsequent to construction.\n * \u003cp\u003e\n * The {@link #load(java.io.Reader) load(Reader)} {@code /}\n * {@link #store(java.io.Writer, java.lang.String) store(Writer, String)}\n * methods load and store properties from and to a character based stream\n * in a simple line-oriented format specified below.\n *\n * The {@link #load(java.io.InputStream) load(InputStream)} {@code /}\n * {@link #store(java.io.OutputStream, java.lang.String) store(OutputStream, String)}\n * methods work the same way as the load(Reader)/store(Writer, String) pair, except\n * the input/output stream is encoded in ISO 8859-1 character encoding.\n * Characters that cannot be directly represented in this encoding can be written using\n * Unicode escapes as defined in section {@jls 3.3} of\n * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e;\n * only a single \u0027u\u0027 character is allowed in an escape\n * sequence.\n *\n * \u003cp\u003e The {@link #loadFromXML(InputStream)} and {@link\n * #storeToXML(OutputStream, String, String)} methods load and store properties\n * in a simple XML format.  By default the UTF-8 character encoding is used,\n * however a specific encoding may be specified if required. Implementations\n * are required to support UTF-8 and UTF-16 and may support other encodings.\n * An XML properties document has the following DOCTYPE declaration:\n *\n * \u003cpre\u003e\n * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n * \u003c/pre\u003e\n * Note that the system URI (http://java.sun.com/dtd/properties.dtd) is\n * \u003ci\u003enot\u003c/i\u003e accessed when exporting or importing properties; it merely\n * serves as a string to uniquely identify the DTD, which is:\n * \u003cpre\u003e\n *    \u0026lt;?xml version\u003d\"1.0\" encoding\u003d\"UTF-8\"?\u0026gt;\n *\n *    \u0026lt;!-- DTD for properties --\u0026gt;\n *\n *    \u0026lt;!ELEMENT properties ( comment?, entry* ) \u0026gt;\n *\n *    \u0026lt;!ATTLIST properties version CDATA #FIXED \"1.0\"\u0026gt;\n *\n *    \u0026lt;!ELEMENT comment (#PCDATA) \u0026gt;\n *\n *    \u0026lt;!ELEMENT entry (#PCDATA) \u0026gt;\n *\n *    \u0026lt;!ATTLIST entry key CDATA #REQUIRED\u0026gt;\n * \u003c/pre\u003e\n *\n * \u003cp\u003eThis class is thread-safe: multiple threads can share a single\n * {@code Properties} object without the need for external synchronization.\n *\n * @apiNote\n * The {@code Properties} class does not inherit the concept of a load factor\n * from its superclass, {@code Hashtable}.\n *\n * @author  Arthur van Hoff\n * @author  Michael McCloskey\n * @author  Xueming Shen\n * @since   1.0\n */\npublic class Properties extends Hashtable\u003cObject,Object\u003e {\n    /**\n     * use serialVersionUID from JDK 1.1.X for interoperability\n     */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d 4112578634029874840L;\n\n    private static final Unsafe UNSAFE \u003d Unsafe.getUnsafe();\n\n    /**\n     * A property list that contains default values for any keys not\n     * found in this property list.\n     *\n     * @serial\n     */\n    protected volatile Properties defaults;\n\n    /**\n     * Properties does not store values in its inherited Hashtable, but instead\n     * in an internal ConcurrentHashMap.  Synchronization is omitted from\n     * simple read operations.  Writes and bulk operations remain synchronized,\n     * as in Hashtable.\n     */\n    private transient volatile ConcurrentHashMap\u003cObject, Object\u003e map;\n\n    /**\n     * Creates an empty property list with no default values.\n     *\n     * @implNote The initial capacity of a {@code Properties} object created\n     * with this constructor is unspecified.\n     */\n    public Properties() {\n        this(null, 8);\n    }\n\n    /**\n     * Creates an empty property list with no default values, and with an\n     * initial size accommodating the specified number of elements without the\n     * need to dynamically resize.\n     *\n     * @param  initialCapacity the {@code Properties} will be sized to\n     *         accommodate this many elements\n     * @throws IllegalArgumentException if the initial capacity is less than\n     *         zero.\n     */\n    public Properties(int initialCapacity) {\n        this(null, initialCapacity);\n    }\n\n    /**\n     * Creates an empty property list with the specified defaults.\n     *\n     * @implNote The initial capacity of a {@code Properties} object created\n     * with this constructor is unspecified.\n     *\n     * @param   defaults   the defaults.\n     */\n    public Properties(Properties defaults) {\n        this(defaults, 8);\n    }\n\n    private Properties(Properties defaults, int initialCapacity) {\n        // use package-private constructor to\n        // initialize unused fields with dummy values\n        super((Void) null);\n        map \u003d new ConcurrentHashMap\u003c\u003e(initialCapacity);\n        this.defaults \u003d defaults;\n\n        // Ensure writes can\u0027t be reordered\n        UNSAFE.storeFence();\n    }\n\n    /**\n     * Calls the {@code Hashtable} method {@code put}. Provided for\n     * parallelism with the {@code getProperty} method. Enforces use of\n     * strings for property keys and values. The value returned is the\n     * result of the {@code Hashtable} call to {@code put}.\n     *\n     * @param key the key to be placed into this property list.\n     * @param value the value corresponding to {@code key}.\n     * @return     the previous value of the specified key in this property\n     *             list, or {@code null} if it did not have one.\n     * @see #getProperty\n     * @since    1.2\n     */\n    public synchronized Object setProperty(String key, String value) {\n        return put(key, value);\n    }\n\n\n    /**\n     * Reads a property list (key and element pairs) from the input\n     * character stream in a simple line-oriented format.\n     * \u003cp\u003e\n     * Properties are processed in terms of lines. There are two\n     * kinds of lines, \u003ci\u003enatural lines\u003c/i\u003e and \u003ci\u003elogical lines\u003c/i\u003e.\n     * A natural line is defined as a line of\n     * characters that is terminated either by a set of line terminator\n     * characters ({@code \\n} or {@code \\r} or {@code \\r\\n})\n     * or by the end of the stream. A natural line may be either a blank line,\n     * a comment line, or hold all or some of a key-element pair. A logical\n     * line holds all the data of a key-element pair, which may be spread\n     * out across several adjacent natural lines by escaping\n     * the line terminator sequence with a backslash character\n     * {@code \\}.  Note that a comment line cannot be extended\n     * in this manner; every natural line that is a comment must have\n     * its own comment indicator, as described below. Lines are read from\n     * input until the end of the stream is reached.\n     *\n     * \u003cp\u003e\n     * A natural line that contains only white space characters is\n     * considered blank and is ignored.  A comment line has an ASCII\n     * {@code \u0027#\u0027} or {@code \u0027!\u0027} as its first non-whitespace\n     * character; comment lines are also ignored and do not\n     * encode key-element information.  In addition to line\n     * terminators, this format considers the characters space\n     * ({@code \u0027 \u0027}, {@code \u0027\\u005Cu0020\u0027}), tab\n     * ({@code \u0027\\t\u0027}, {@code \u0027\\u005Cu0009\u0027}), and form feed\n     * ({@code \u0027\\f\u0027}, {@code \u0027\\u005Cu000C\u0027}) to be white\n     * space.\n     *\n     * \u003cp\u003e\n     * If a logical line is spread across several natural lines, the\n     * backslash escaping the line terminator sequence, the line\n     * terminator sequence, and any white space at the start of the\n     * following line have no effect on the key or element values.\n     * The remainder of the discussion of key and element parsing\n     * (when loading) will assume all the characters constituting\n     * the key and element appear on a single natural line after\n     * line continuation characters have been removed.  Note that\n     * it is \u003ci\u003enot\u003c/i\u003e sufficient to only examine the character\n     * preceding a line terminator sequence to decide if the line\n     * terminator is escaped; there must be an odd number of\n     * contiguous backslashes for the line terminator to be escaped.\n     * Since the input is processed from left to right, a\n     * non-zero even number of 2\u003ci\u003en\u003c/i\u003e contiguous backslashes\n     * before a line terminator (or elsewhere) encodes \u003ci\u003en\u003c/i\u003e\n     * backslashes after escape processing.\n     *\n     * \u003cp\u003e\n     * The key contains all of the characters in the line starting\n     * with the first non-whitespace character and up to, but not\n     * including, the first unescaped {@code \u0027\u003d\u0027},\n     * {@code \u0027:\u0027}, or white space character other than a line\n     * terminator. All of these key termination characters may be\n     * included in the key by escaping them with a preceding backslash\n     * character; for example,\u003cp\u003e\n     *\n     * {@code \\:\\\u003d}\u003cp\u003e\n     *\n     * would be the two-character key {@code \":\u003d\"}.  Line\n     * terminator characters can be included using {@code \\r} and\n     * {@code \\n} escape sequences.  Any white space after the\n     * key is skipped; if the first non-whitespace character after\n     * the key is {@code \u0027\u003d\u0027} or {@code \u0027:\u0027}, then it is\n     * ignored and any white space characters after it are also\n     * skipped.  All remaining characters on the line become part of\n     * the associated element string; if there are no remaining\n     * characters, the element is the empty string\n     * {@code \"\"}.  Once the raw character sequences\n     * constituting the key and element are identified, escape\n     * processing is performed as described above.\n     *\n     * \u003cp\u003e\n     * As an example, each of the following three lines specifies the key\n     * {@code \"Truth\"} and the associated element value\n     * {@code \"Beauty\"}:\n     * \u003cpre\u003e\n     * Truth \u003d Beauty\n     *  Truth:Beauty\n     * Truth                    :Beauty\n     * \u003c/pre\u003e\n     * As another example, the following three lines specify a single\n     * property:\n     * \u003cpre\u003e\n     * fruits                           apple, banana, pear, \\\n     *                                  cantaloupe, watermelon, \\\n     *                                  kiwi, mango\n     * \u003c/pre\u003e\n     * The key is {@code \"fruits\"} and the associated element is:\n     * \u003cpre\u003e\"apple, banana, pear, cantaloupe, watermelon, kiwi, mango\"\u003c/pre\u003e\n     * Note that a space appears before each {@code \\} so that a space\n     * will appear after each comma in the final result; the {@code \\},\n     * line terminator, and leading white space on the continuation line are\n     * merely discarded and are \u003ci\u003enot\u003c/i\u003e replaced by one or more other\n     * characters.\n     * \u003cp\u003e\n     * As a third example, the line:\n     * \u003cpre\u003echeeses\n     * \u003c/pre\u003e\n     * specifies that the key is {@code \"cheeses\"} and the associated\n     * element is the empty string {@code \"\"}.\n     * \u003cp\u003e\n     * \u003ca id\u003d\"unicodeescapes\"\u003e\u003c/a\u003e\n     * Characters in keys and elements can be represented in escape\n     * sequences similar to those used for character and string literals\n     * (see sections {@jls 3.3} and {@jls 3.10.6} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e).\n     *\n     * The differences from the character escape sequences and Unicode\n     * escapes used for characters and strings are:\n     *\n     * \u003cul\u003e\n     * \u003cli\u003e Octal escapes are not recognized.\n     *\n     * \u003cli\u003e The character sequence {@code \\b} does \u003ci\u003enot\u003c/i\u003e\n     * represent a backspace character.\n     *\n     * \u003cli\u003e The method does not treat a backslash character,\n     * {@code \\}, before a non-valid escape character as an\n     * error; the backslash is silently dropped.  For example, in a\n     * Java string the sequence {@code \"\\z\"} would cause a\n     * compile time error.  In contrast, this method silently drops\n     * the backslash.  Therefore, this method treats the two character\n     * sequence {@code \"\\b\"} as equivalent to the single\n     * character {@code \u0027b\u0027}.\n     *\n     * \u003cli\u003e Escapes are not necessary for single and double quotes;\n     * however, by the rule above, single and double quote characters\n     * preceded by a backslash still yield single and double quote\n     * characters, respectively.\n     *\n     * \u003cli\u003e Only a single \u0027u\u0027 character is allowed in a Unicode escape\n     * sequence.\n     *\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The specified stream remains open after this method returns.\n     *\n     * @param   reader   the input character stream.\n     * @throws  IOException  if an error occurred when reading from the\n     *          input stream.\n     * @throws  IllegalArgumentException if a malformed Unicode escape\n     *          appears in the input.\n     * @throws  NullPointerException if {@code reader} is null.\n     * @since   1.6\n     */\n    public synchronized void load(Reader reader) throws IOException {\n        Objects.requireNonNull(reader, \"reader parameter is null\");\n        load0(new LineReader(reader));\n    }\n\n    /**\n     * Reads a property list (key and element pairs) from the input\n     * byte stream. The input stream is in a simple line-oriented\n     * format as specified in\n     * {@link #load(java.io.Reader) load(Reader)} and is assumed to use\n     * the ISO 8859-1 character encoding; that is each byte is one Latin1\n     * character. Characters not in Latin1, and certain special characters,\n     * are represented in keys and elements using Unicode escapes as defined in\n     * section {@jls 3.3} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     * \u003cp\u003e\n     * The specified stream remains open after this method returns.\n     *\n     * @param      inStream   the input stream.\n     * @throws     IOException  if an error occurred when reading from the\n     *             input stream.\n     * @throws     IllegalArgumentException if the input stream contains a\n     *             malformed Unicode escape sequence.\n     * @throws     NullPointerException if {@code inStream} is null.\n     * @since 1.2\n     */\n    public synchronized void load(InputStream inStream) throws IOException {\n        Objects.requireNonNull(inStream, \"inStream parameter is null\");\n        load0(new LineReader(inStream));\n    }\n\n    private void load0(LineReader lr) throws IOException {\n        StringBuilder outBuffer \u003d new StringBuilder();\n        int limit;\n        int keyLen;\n        int valueStart;\n        boolean hasSep;\n        boolean precedingBackslash;\n\n        while ((limit \u003d lr.readLine()) \u003e\u003d 0) {\n            keyLen \u003d 0;\n            valueStart \u003d limit;\n            hasSep \u003d false;\n\n            //System.out.println(\"line\u003d\u003c\" + new String(lineBuf, 0, limit) + \"\u003e\");\n            precedingBackslash \u003d false;\n            while (keyLen \u003c limit) {\n                char c \u003d lr.lineBuf[keyLen];\n                //need check if escaped.\n                if ((c \u003d\u003d \u0027\u003d\u0027 ||  c \u003d\u003d \u0027:\u0027) \u0026\u0026 !precedingBackslash) {\n                    valueStart \u003d keyLen + 1;\n                    hasSep \u003d true;\n                    break;\n                } else if ((c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\t\u0027 ||  c \u003d\u003d \u0027\\f\u0027) \u0026\u0026 !precedingBackslash) {\n                    valueStart \u003d keyLen + 1;\n                    break;\n                }\n                if (c \u003d\u003d \u0027\\\\\u0027) {\n                    precedingBackslash \u003d !precedingBackslash;\n                } else {\n                    precedingBackslash \u003d false;\n                }\n                keyLen++;\n            }\n            while (valueStart \u003c limit) {\n                char c \u003d lr.lineBuf[valueStart];\n                if (c !\u003d \u0027 \u0027 \u0026\u0026 c !\u003d \u0027\\t\u0027 \u0026\u0026  c !\u003d \u0027\\f\u0027) {\n                    if (!hasSep \u0026\u0026 (c \u003d\u003d \u0027\u003d\u0027 ||  c \u003d\u003d \u0027:\u0027)) {\n                        hasSep \u003d true;\n                    } else {\n                        break;\n                    }\n                }\n                valueStart++;\n            }\n            String key \u003d loadConvert(lr.lineBuf, 0, keyLen, outBuffer);\n            String value \u003d loadConvert(lr.lineBuf, valueStart, limit - valueStart, outBuffer);\n            put(key, value);\n        }\n    }\n\n    /* Read in a \"logical line\" from an InputStream/Reader, skip all comment\n     * and blank lines and filter out those leading whitespace characters\n     * (\\u0020, \\u0009 and \\u000c) from the beginning of a \"natural line\".\n     * Method returns the char length of the \"logical line\" and stores\n     * the line in \"lineBuf\".\n     */\n    private static class LineReader {\n        LineReader(InputStream inStream) {\n            this.inStream \u003d inStream;\n            inByteBuf \u003d new byte[8192];\n        }\n\n        LineReader(Reader reader) {\n            this.reader \u003d reader;\n            inCharBuf \u003d new char[8192];\n        }\n\n        char[] lineBuf \u003d new char[1024];\n        private byte[] inByteBuf;\n        private char[] inCharBuf;\n        private int inLimit \u003d 0;\n        private int inOff \u003d 0;\n        private InputStream inStream;\n        private Reader reader;\n\n        int readLine() throws IOException {\n            // use locals to optimize for interpreted performance\n            int len \u003d 0;\n            int off \u003d inOff;\n            int limit \u003d inLimit;\n\n            boolean skipWhiteSpace \u003d true;\n            boolean appendedLineBegin \u003d false;\n            boolean precedingBackslash \u003d false;\n            boolean fromStream \u003d inStream !\u003d null;\n            byte[] byteBuf \u003d inByteBuf;\n            char[] charBuf \u003d inCharBuf;\n            char[] lineBuf \u003d this.lineBuf;\n            char c;\n\n            while (true) {\n                if (off \u003e\u003d limit) {\n                    inLimit \u003d limit \u003d fromStream ? inStream.read(byteBuf)\n                                                 : reader.read(charBuf);\n                    if (limit \u003c\u003d 0) {\n                        if (len \u003d\u003d 0) {\n                            return -1;\n                        }\n                        return precedingBackslash ? len - 1 : len;\n                    }\n                    off \u003d 0;\n                }\n\n                // (char)(byte \u0026 0xFF) is equivalent to calling a ISO8859-1 decoder.\n                c \u003d (fromStream) ? (char)(byteBuf[off++] \u0026 0xFF) : charBuf[off++];\n\n                if (skipWhiteSpace) {\n                    if (c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\t\u0027 || c \u003d\u003d \u0027\\f\u0027) {\n                        continue;\n                    }\n                    if (!appendedLineBegin \u0026\u0026 (c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\n\u0027)) {\n                        continue;\n                    }\n                    skipWhiteSpace \u003d false;\n                    appendedLineBegin \u003d false;\n\n                }\n                if (len \u003d\u003d 0) { // Still on a new logical line\n                    if (c \u003d\u003d \u0027#\u0027 || c \u003d\u003d \u0027!\u0027) {\n                        // Comment, quickly consume the rest of the line\n\n                        // When checking for new line characters a range check,\n                        // starting with the higher bound (\u0027\\r\u0027) means one less\n                        // branch in the common case.\n                        commentLoop: while (true) {\n                            if (fromStream) {\n                                byte b;\n                                while (off \u003c limit) {\n                                    b \u003d byteBuf[off++];\n                                    if (b \u003c\u003d \u0027\\r\u0027 \u0026\u0026 (b \u003d\u003d \u0027\\r\u0027 || b \u003d\u003d \u0027\\n\u0027))\n                                        break commentLoop;\n                                }\n                                if (off \u003d\u003d limit) {\n                                    inLimit \u003d limit \u003d inStream.read(byteBuf);\n                                    if (limit \u003c\u003d 0) { // EOF\n                                        return -1;\n                                    }\n                                    off \u003d 0;\n                                }\n                            } else {\n                                while (off \u003c limit) {\n                                    c \u003d charBuf[off++];\n                                    if (c \u003c\u003d \u0027\\r\u0027 \u0026\u0026 (c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\n\u0027))\n                                        break commentLoop;\n                                }\n                                if (off \u003d\u003d limit) {\n                                    inLimit \u003d limit \u003d reader.read(charBuf);\n                                    if (limit \u003c\u003d 0) { // EOF\n                                        return -1;\n                                    }\n                                    off \u003d 0;\n                                }\n                            }\n                        }\n                        skipWhiteSpace \u003d true;\n                        continue;\n                    }\n                }\n\n                if (c !\u003d \u0027\\n\u0027 \u0026\u0026 c !\u003d \u0027\\r\u0027) {\n                    lineBuf[len++] \u003d c;\n                    if (len \u003d\u003d lineBuf.length) {\n                        lineBuf \u003d new char[ArraysSupport.newLength(len, 1, len)];\n                        System.arraycopy(this.lineBuf, 0, lineBuf, 0, len);\n                        this.lineBuf \u003d lineBuf;\n                    }\n                    // flip the preceding backslash flag\n                    precedingBackslash \u003d (c \u003d\u003d \u0027\\\\\u0027) ? !precedingBackslash : false;\n                } else {\n                    // reached EOL\n                    if (len \u003d\u003d 0) {\n                        skipWhiteSpace \u003d true;\n                        continue;\n                    }\n                    if (off \u003e\u003d limit) {\n                        inLimit \u003d limit \u003d fromStream ? inStream.read(byteBuf)\n                                                     : reader.read(charBuf);\n                        off \u003d 0;\n                        if (limit \u003c\u003d 0) { // EOF\n                            return precedingBackslash ? len - 1 : len;\n                        }\n                    }\n                    if (precedingBackslash) {\n                        // backslash at EOL is not part of the line\n                        len -\u003d 1;\n                        // skip leading whitespace characters in the following line\n                        skipWhiteSpace \u003d true;\n                        appendedLineBegin \u003d true;\n                        precedingBackslash \u003d false;\n                        // take care not to include any subsequent \\n\n                        if (c \u003d\u003d \u0027\\r\u0027) {\n                            if (fromStream) {\n                                if (byteBuf[off] \u003d\u003d \u0027\\n\u0027) {\n                                    off++;\n                                }\n                            } else {\n                                if (charBuf[off] \u003d\u003d \u0027\\n\u0027) {\n                                    off++;\n                                }\n                            }\n                        }\n                    } else {\n                        inOff \u003d off;\n                        return len;\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n     * Converts encoded \u0026#92;uxxxx to unicode chars\n     * and changes special saved chars to their original forms\n     */\n    private String loadConvert(char[] in, int off, int len, StringBuilder out) {\n        char aChar;\n        int end \u003d off + len;\n        int start \u003d off;\n        while (off \u003c end) {\n            aChar \u003d in[off++];\n            if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                break;\n            }\n        }\n        if (off \u003d\u003d end) { // No backslash\n            return new String(in, start, len);\n        }\n\n        // backslash found at off - 1, reset the shared buffer, rewind offset\n        out.setLength(0);\n        off--;\n        out.append(in, start, off - start);\n\n        while (off \u003c end) {\n            aChar \u003d in[off++];\n            if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                // No need to bounds check since LineReader::readLine excludes\n                // unescaped \\s at the end of the line\n                aChar \u003d in[off++];\n                if(aChar \u003d\u003d \u0027u\u0027) {\n                    // Read the xxxx\n                    if (off \u003e end - 4)\n                        throw new IllegalArgumentException(\n                                     \"Malformed \\\\uxxxx encoding.\");\n                    int value \u003d 0;\n                    for (int i \u003d 0; i \u003c 4; i++) {\n                        aChar \u003d in[off++];\n                        value \u003d switch (aChar) {\n                            case \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027 -\u003e (value \u003c\u003c 4) + aChar - \u00270\u0027;\n                            case \u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027, \u0027f\u0027                     -\u003e (value \u003c\u003c 4) + 10 + aChar - \u0027a\u0027;\n                            case \u0027A\u0027, \u0027B\u0027, \u0027C\u0027, \u0027D\u0027, \u0027E\u0027, \u0027F\u0027                     -\u003e (value \u003c\u003c 4) + 10 + aChar - \u0027A\u0027;\n                            default -\u003e throw new IllegalArgumentException(\"Malformed \\\\uxxxx encoding.\");\n                        };\n                    }\n                    out.append((char)value);\n                } else {\n                    if (aChar \u003d\u003d \u0027t\u0027) aChar \u003d \u0027\\t\u0027;\n                    else if (aChar \u003d\u003d \u0027r\u0027) aChar \u003d \u0027\\r\u0027;\n                    else if (aChar \u003d\u003d \u0027n\u0027) aChar \u003d \u0027\\n\u0027;\n                    else if (aChar \u003d\u003d \u0027f\u0027) aChar \u003d \u0027\\f\u0027;\n                    out.append(aChar);\n                }\n            } else {\n                out.append(aChar);\n            }\n        }\n        return out.toString();\n    }\n\n    /*\n     * Converts unicodes to encoded \u0026#92;uxxxx and escapes\n     * special characters with a preceding slash\n     */\n    private String saveConvert(String theString,\n                               boolean escapeSpace,\n                               boolean escapeUnicode) {\n        int len \u003d theString.length();\n        int bufLen \u003d len * 2;\n        if (bufLen \u003c 0) {\n            bufLen \u003d Integer.MAX_VALUE;\n        }\n        StringBuilder outBuffer \u003d new StringBuilder(bufLen);\n        HexFormat hex \u003d HexFormat.of().withUpperCase();\n        for(int x\u003d0; x\u003clen; x++) {\n            char aChar \u003d theString.charAt(x);\n            // Handle common case first, selecting largest block that\n            // avoids the specials below\n            if ((aChar \u003e 61) \u0026\u0026 (aChar \u003c 127)) {\n                if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                    outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027\\\\\u0027);\n                    continue;\n                }\n                outBuffer.append(aChar);\n                continue;\n            }\n            switch(aChar) {\n                case \u0027 \u0027:\n                    if (x \u003d\u003d 0 || escapeSpace)\n                        outBuffer.append(\u0027\\\\\u0027);\n                    outBuffer.append(\u0027 \u0027);\n                    break;\n                case \u0027\\t\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027t\u0027);\n                          break;\n                case \u0027\\n\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027n\u0027);\n                          break;\n                case \u0027\\r\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027r\u0027);\n                          break;\n                case \u0027\\f\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027f\u0027);\n                          break;\n                case \u0027\u003d\u0027: // Fall through\n                case \u0027:\u0027: // Fall through\n                case \u0027#\u0027: // Fall through\n                case \u0027!\u0027:\n                    outBuffer.append(\u0027\\\\\u0027); outBuffer.append(aChar);\n                    break;\n                default:\n                    if (((aChar \u003c 0x0020) || (aChar \u003e 0x007e)) \u0026 escapeUnicode ) {\n                        outBuffer.append(\"\\\\u\");\n                        outBuffer.append(hex.toHexDigits(aChar));\n                    } else {\n                        outBuffer.append(aChar);\n                    }\n            }\n        }\n        return outBuffer.toString();\n    }\n\n    private static void writeComments(BufferedWriter bw, String comments)\n        throws IOException {\n        HexFormat hex \u003d HexFormat.of().withUpperCase();\n        bw.write(\"#\");\n        int len \u003d comments.length();\n        int current \u003d 0;\n        int last \u003d 0;\n        while (current \u003c len) {\n            char c \u003d comments.charAt(current);\n            if (c \u003e \u0027\\u00ff\u0027 || c \u003d\u003d \u0027\\n\u0027 || c \u003d\u003d \u0027\\r\u0027) {\n                if (last !\u003d current)\n                    bw.write(comments.substring(last, current));\n                if (c \u003e \u0027\\u00ff\u0027) {\n                    bw.write(\"\\\\u\");\n                    bw.write(hex.toHexDigits(c));\n                } else {\n                    bw.newLine();\n                    if (c \u003d\u003d \u0027\\r\u0027 \u0026\u0026\n                        current !\u003d len - 1 \u0026\u0026\n                        comments.charAt(current + 1) \u003d\u003d \u0027\\n\u0027) {\n                        current++;\n                    }\n                    if (current \u003d\u003d len - 1 ||\n                        (comments.charAt(current + 1) !\u003d \u0027#\u0027 \u0026\u0026\n                        comments.charAt(current + 1) !\u003d \u0027!\u0027))\n                        bw.write(\"#\");\n                }\n                last \u003d current + 1;\n            }\n            current++;\n        }\n        if (last !\u003d current)\n            bw.write(comments.substring(last, current));\n        bw.newLine();\n    }\n\n    /**\n     * Calls the {@code store(OutputStream out, String comments)} method\n     * and suppresses IOExceptions that were thrown.\n     *\n     * @deprecated This method does not throw an IOException if an I/O error\n     * occurs while saving the property list.  The preferred way to save a\n     * properties list is via the {@code store(OutputStream out,\n     * String comments)} method or the\n     * {@code storeToXML(OutputStream os, String comment)} method.\n     *\n     * @param   out      an output stream.\n     * @param   comments   a description of the property list.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not\n     *             {@code Strings}.\n     */\n    @Deprecated\n    public void save(OutputStream out, String comments)  {\n        try {\n            store(out, comments);\n        } catch (IOException e) {\n        }\n    }\n\n    /**\n     * Writes this property list (key and element pairs) in this\n     * {@code Properties} table to the output character stream in a\n     * format suitable for using the {@link #load(java.io.Reader) load(Reader)}\n     * method.\n     * \u003cp\u003e\n     * Properties from the defaults table of this {@code Properties}\n     * table (if any) are \u003ci\u003enot\u003c/i\u003e written out by this method.\n     * \u003cp\u003e\n     * If the comments argument is not null, then an ASCII {@code #}\n     * character, the comments string, and a line separator are first written\n     * to the output stream. Thus, the {@code comments} can serve as an\n     * identifying comment. Any one of a line feed ({@code \\n}), a carriage\n     * return ({@code \\r}), or a carriage return followed immediately by a line feed\n     * ({@code \\r\\n}) in comments is replaced by a\n     * {@link System#lineSeparator() line separator} and if the next\n     * character in comments is not character {@code #} or character {@code !} then\n     * an ASCII {@code #} is written out after that line separator.\n     * \u003cp\u003e\n     * If the {@systemProperty java.properties.date} is set on the command line\n     * and is non-empty (as determined by {@link String#isEmpty()  String.isEmpty}),\n     * a comment line is written as follows.\n     * First, a {@code #} character is written, followed by the contents\n     * of the property, followed by a line separator. Any line terminator characters\n     * in the value of the system property are treated the same way as noted above\n     * for the comments argument.\n     * If the system property is not set or is empty, a comment line is written\n     * as follows.\n     * First, a {@code #} character is written, followed by the current date and time\n     * formatted as if by the {@link Date#toString() Date.toString} method,\n     * followed by a line separator.\n     * \u003cp\u003e\n     * Then every entry in this {@code Properties} table is\n     * written out, one per line. For each entry the key string is\n     * written, then an ASCII {@code \u003d}, then the associated\n     * element string. For the key, all space characters are\n     * written with a preceding {@code \\} character.  For the\n     * element, leading space characters, but not embedded or trailing\n     * space characters, are written with a preceding {@code \\}\n     * character. The key and element characters {@code #},\n     * {@code !}, {@code \u003d}, and {@code :} are written\n     * with a preceding backslash to ensure that they are properly loaded.\n     * \u003cp\u003e\n     * After the entries have been written, the output stream is flushed.\n     * The output stream remains open after this method returns.\n     *\n     * @implSpec The keys and elements are written in the natural sort order\n     * of the keys in the {@code entrySet()} unless {@code entrySet()} is\n     * overridden by a subclass to return a different value than {@code super.entrySet()}.\n     *\n     * @param   writer      an output character stream writer.\n     * @param   comments   a description of the property list.\n     * @throws     IOException if writing this property list to the specified\n     *             output stream throws an {@code IOException}.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not {@code Strings}.\n     * @throws     NullPointerException  if {@code writer} is null.\n     * @since 1.6\n     */\n    public void store(Writer writer, String comments)\n        throws IOException\n    {\n        store0((writer instanceof BufferedWriter)?(BufferedWriter)writer\n                                                 : new BufferedWriter(writer),\n               comments,\n               false);\n    }\n\n    /**\n     * Writes this property list (key and element pairs) in this\n     * {@code Properties} table to the output stream in a format suitable\n     * for loading into a {@code Properties} table using the\n     * {@link #load(InputStream) load(InputStream)} method.\n     * \u003cp\u003e\n     * Properties from the defaults table of this {@code Properties}\n     * table (if any) are \u003ci\u003enot\u003c/i\u003e written out by this method.\n     * \u003cp\u003e\n     * This method outputs the comments, properties keys and values in\n     * the same format as specified in\n     * {@link #store(java.io.Writer, java.lang.String) store(Writer)},\n     * with the following differences:\n     * \u003cul\u003e\n     * \u003cli\u003eThe stream is written using the ISO 8859-1 character encoding.\n     *\n     * \u003cli\u003eCharacters not in Latin-1 in the comments are written as\n     * {@code \\u005Cu}\u003ci\u003exxxx\u003c/i\u003e for their appropriate unicode\n     * hexadecimal value \u003ci\u003exxxx\u003c/i\u003e.\n     *\n     * \u003cli\u003eCharacters less than {@code \\u005Cu0020} and characters greater\n     * than {@code \\u005Cu007E} in property keys or values are written\n     * as {@code \\u005Cu}\u003ci\u003exxxx\u003c/i\u003e for the appropriate hexadecimal\n     * value \u003ci\u003exxxx\u003c/i\u003e.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * After the entries have been written, the output stream is flushed.\n     * The output stream remains open after this method returns.\n     *\n     * @param   out      an output stream.\n     * @param   comments   a description of the property list.\n     * @throws     IOException if writing this property list to the specified\n     *             output stream throws an {@code IOException}.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not {@code Strings}.\n     * @throws     NullPointerException  if {@code out} is null.\n     * @since 1.2\n     */\n    public void store(OutputStream out, String comments)\n        throws IOException\n    {\n        store0(new BufferedWriter(new OutputStreamWriter(out, ISO_8859_1.INSTANCE)),\n               comments,\n               true);\n    }\n\n    private void store0(BufferedWriter bw, String comments, boolean escUnicode)\n        throws IOException\n    {\n        if (comments !\u003d null) {\n            writeComments(bw, comments);\n        }\n        writeDateComment(bw);\n\n        synchronized (this) {\n            @SuppressWarnings(\"unchecked\")\n            Collection\u003cMap.Entry\u003cString, String\u003e\u003e entries \u003d (Set\u003cMap.Entry\u003cString, String\u003e\u003e) (Set) entrySet();\n            // entrySet() can be overridden by subclasses. Here we check to see if\n            // the returned instance type is the one returned by the Properties.entrySet()\n            // implementation. If yes, then we sort those entries in the natural order\n            // of their key. Else, we consider that the subclassed implementation may\n            // potentially have returned a differently ordered entries and so we just\n            // use the iteration order of the returned instance.\n            if (entries instanceof Collections.SynchronizedSet\u003c?\u003e ss\n                    \u0026\u0026 ss.c instanceof EntrySet) {\n                entries \u003d new ArrayList\u003c\u003e(entries);\n                ((List\u003cMap.Entry\u003cString, String\u003e\u003e) entries).sort(Map.Entry.comparingByKey());\n            }\n            for (Map.Entry\u003cString, String\u003e e : entries) {\n                String key \u003d e.getKey();\n                String val \u003d e.getValue();\n                key \u003d saveConvert(key, true, escUnicode);\n                /* No need to escape embedded and trailing spaces for value, hence\n                 * pass false to flag.\n                 */\n                val \u003d saveConvert(val, false, escUnicode);\n                bw.write(key + \"\u003d\" + val);\n                bw.newLine();\n            }\n        }\n        bw.flush();\n    }\n\n    private static void writeDateComment(BufferedWriter bw) throws IOException {\n        // value of java.properties.date system property isn\u0027t sensitive\n        // and so doesn\u0027t need any security manager checks to make the value accessible\n        // to the callers\n        String sysPropVal \u003d StaticProperty.javaPropertiesDate();\n        if (sysPropVal !\u003d null \u0026\u0026 !sysPropVal.isEmpty()) {\n            writeComments(bw, sysPropVal);\n        } else {\n            bw.write(\"#\" + new Date());\n            bw.newLine();\n        }\n    }\n\n    /**\n     * Loads all of the properties represented by the XML document on the\n     * specified input stream into this properties table.\n     *\n     * \u003cp\u003eThe XML document must have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     * Furthermore, the document must satisfy the properties DTD described\n     * above.\n     *\n     * \u003cp\u003e An implementation is required to read XML documents that use the\n     * \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An implementation may\n     * support additional encodings.\n     *\n     * \u003cp\u003eThe specified stream is closed after this method returns.\n     *\n     * @param in the input stream from which to read the XML document.\n     * @throws IOException if reading from the specified input stream\n     *         results in an {@code IOException}.\n     * @throws java.io.UnsupportedEncodingException if the document\u0027s encoding\n     *         declaration can be read and it specifies an encoding that is not\n     *         supported\n     * @throws InvalidPropertiesFormatException Data on input stream does not\n     *         constitute a valid XML document with the mandated document type.\n     * @throws NullPointerException if {@code in} is null.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #storeToXML(OutputStream, String, String)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 1.5\n     */\n    public synchronized void loadFromXML(InputStream in)\n        throws IOException, InvalidPropertiesFormatException\n    {\n        Objects.requireNonNull(in);\n        PropertiesDefaultHandler handler \u003d new PropertiesDefaultHandler();\n        handler.load(this, in);\n        in.close();\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table.\n     *\n     * \u003cp\u003e An invocation of this method of the form {@code props.storeToXML(os,\n     * comment)} behaves in exactly the same way as the invocation\n     * {@code props.storeToXML(os, comment, \"UTF-8\");}.\n     *\n     * @param os the output stream on which to emit the XML document.\n     * @param comment a description of the property list, or {@code null}\n     *        if no comment is desired.\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws NullPointerException if {@code os} is null.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not\n     *         {@code Strings}.\n     * @see    #loadFromXML(InputStream)\n     * @since 1.5\n     */\n    public void storeToXML(OutputStream os, String comment)\n        throws IOException\n    {\n        storeToXML(os, comment, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table, using the specified encoding.\n     *\n     * \u003cp\u003eThe XML document will have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003eIf the specified comment is {@code null} then no comment\n     * will be stored in the document.\n     *\n     * \u003cp\u003e An implementation is required to support writing of XML documents\n     * that use the \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An\n     * implementation may support additional encodings.\n     *\n     * \u003cp\u003eThe specified stream remains open after this method returns.\n     *\n     * \u003cp\u003eThis method behaves the same as\n     * {@linkplain #storeToXML(OutputStream os, String comment, Charset charset)}\n     * except that it will {@linkplain java.nio.charset.Charset#forName look up the charset}\n     * using the given encoding name.\n     *\n     * @param os        the output stream on which to emit the XML document.\n     * @param comment   a description of the property list, or {@code null}\n     *                  if no comment is desired.\n     * @param  encoding the name of a supported\n     *                  \u003ca href\u003d\"../lang/package-summary.html#charenc\"\u003e\n     *                  character encoding\u003c/a\u003e\n     *\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws java.io.UnsupportedEncodingException if the encoding is not\n     *         supported by the implementation.\n     * @throws NullPointerException if {@code os} is {@code null},\n     *         or if {@code encoding} is {@code null}.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not {@code Strings}.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #loadFromXML(InputStream)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 1.5\n     */\n    public void storeToXML(OutputStream os, String comment, String encoding)\n        throws IOException {\n        Objects.requireNonNull(os);\n        Objects.requireNonNull(encoding);\n\n        try {\n            Charset charset \u003d Charset.forName(encoding);\n            storeToXML(os, comment, charset);\n        } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {\n            throw new UnsupportedEncodingException(encoding);\n        }\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table, using the specified encoding.\n     *\n     * \u003cp\u003eThe XML document will have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003eIf the specified comment is {@code null} then no comment\n     * will be stored in the document.\n     *\n     * \u003cp\u003e An implementation is required to support writing of XML documents\n     * that use the \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An\n     * implementation may support additional encodings.\n     *\n     * \u003cp\u003e Unmappable characters for the specified charset will be encoded as\n     * numeric character references.\n     *\n     * \u003cp\u003eThe specified stream remains open after this method returns.\n     *\n     * @param os        the output stream on which to emit the XML document.\n     * @param comment   a description of the property list, or {@code null}\n     *                  if no comment is desired.\n     * @param charset   the charset\n     *\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws NullPointerException if {@code os} or {@code charset} is {@code null}.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not {@code Strings}.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #loadFromXML(InputStream)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 10\n     */\n    public void storeToXML(OutputStream os, String comment, Charset charset)\n        throws IOException {\n        Objects.requireNonNull(os, \"OutputStream\");\n        Objects.requireNonNull(charset, \"Charset\");\n        PropertiesDefaultHandler handler \u003d new PropertiesDefaultHandler();\n        handler.store(this, os, comment, charset);\n    }\n\n    /**\n     * Searches for the property with the specified key in this property list.\n     * If the key is not found in this property list, the default property list,\n     * and its defaults, recursively, are then checked. The method returns\n     * {@code null} if the property is not found.\n     *\n     * @param   key   the property key.\n     * @return  the value in this property list with the specified key value.\n     * @see     #setProperty\n     * @see     #defaults\n     */\n    public String getProperty(String key) {\n        Object oval \u003d map.get(key);\n        String sval \u003d (oval instanceof String) ? (String)oval : null;\n        Properties defaults;\n        return ((sval \u003d\u003d null) \u0026\u0026 ((defaults \u003d this.defaults) !\u003d null)) ? defaults.getProperty(key) : sval;\n    }\n\n    /**\n     * Searches for the property with the specified key in this property list.\n     * If the key is not found in this property list, the default property list,\n     * and its defaults, recursively, are then checked. The method returns the\n     * default value argument if the property is not found.\n     *\n     * @param   key            the hashtable key.\n     * @param   defaultValue   a default value.\n     *\n     * @return  the value in this property list with the specified key value.\n     * @see     #setProperty\n     * @see     #defaults\n     */\n    public String getProperty(String key, String defaultValue) {\n        String val \u003d getProperty(key);\n        return (val \u003d\u003d null) ? defaultValue : val;\n    }\n\n    /**\n     * Returns an enumeration of all the keys in this property list,\n     * including distinct keys in the default property list if a key\n     * of the same name has not already been found from the main\n     * properties list.\n     *\n     * @return  an enumeration of all the keys in this property list, including\n     *          the keys in the default property list.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     * @see     java.util.Enumeration\n     * @see     java.util.Properties#defaults\n     * @see     #stringPropertyNames\n     */\n    public Enumeration\u003c?\u003e propertyNames() {\n        Hashtable\u003cString,Object\u003e h \u003d new Hashtable\u003c\u003e();\n        enumerate(h);\n        return h.keys();\n    }\n\n    /**\n     * Returns an unmodifiable set of keys from this property list\n     * where the key and its corresponding value are strings,\n     * including distinct keys in the default property list if a key\n     * of the same name has not already been found from the main\n     * properties list.  Properties whose key or value is not\n     * of type {@code String} are omitted.\n     * \u003cp\u003e\n     * The returned set is not backed by this {@code Properties} object.\n     * Changes to this {@code Properties} object are not reflected in the\n     * returned set.\n     *\n     * @return  an unmodifiable set of keys in this property list where\n     *          the key and its corresponding value are strings,\n     *          including the keys in the default property list.\n     * @see     java.util.Properties#defaults\n     * @since   1.6\n     */\n    public Set\u003cString\u003e stringPropertyNames() {\n        Map\u003cString, String\u003e h \u003d new HashMap\u003c\u003e();\n        enumerateStringProperties(h);\n        return Collections.unmodifiableSet(h.keySet());\n    }\n\n    /**\n     * Prints this property list out to the specified output stream.\n     * This method is useful for debugging.\n     *\n     * @param   out   an output stream.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     */\n    public void list(PrintStream out) {\n        out.println(\"-- listing properties --\");\n        Map\u003cString, Object\u003e h \u003d new HashMap\u003c\u003e();\n        enumerate(h);\n        for (Map.Entry\u003cString, Object\u003e e : h.entrySet()) {\n            String key \u003d e.getKey();\n            String val \u003d (String)e.getValue();\n            if (val.length() \u003e 40) {\n                val \u003d val.substring(0, 37) + \"...\";\n            }\n            out.println(key + \"\u003d\" + val);\n        }\n    }\n\n    /**\n     * Prints this property list out to the specified output stream.\n     * This method is useful for debugging.\n     *\n     * @param   out   an output stream.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     * @since   1.1\n     */\n    /*\n     * Rather than use an anonymous inner class to share common code, this\n     * method is duplicated in order to ensure that a non-1.1 compiler can\n     * compile this file.\n     */\n    public void list(PrintWriter out) {\n        out.println(\"-- listing properties --\");\n        Map\u003cString, Object\u003e h \u003d new HashMap\u003c\u003e();\n        enumerate(h);\n        for (Map.Entry\u003cString, Object\u003e e : h.entrySet()) {\n            String key \u003d e.getKey();\n            String val \u003d (String)e.getValue();\n            if (val.length() \u003e 40) {\n                val \u003d val.substring(0, 37) + \"...\";\n            }\n            out.println(key + \"\u003d\" + val);\n        }\n    }\n\n    /**\n     * Enumerates all key/value pairs into the specified Map.\n     * @param h the Map\n     * @throws ClassCastException if any of the property keys\n     *         is not of String type.\n     */\n    private void enumerate(Map\u003cString, Object\u003e h) {\n        if (defaults !\u003d null) {\n            defaults.enumerate(h);\n        }\n        for (Map.Entry\u003cObject, Object\u003e e : entrySet()) {\n            String key \u003d (String)e.getKey();\n            h.put(key, e.getValue());\n        }\n    }\n\n    /**\n     * Enumerates all key/value pairs into the specified Map\n     * and omits the property if the key or value is not a string.\n     * @param h the Map\n     */\n    private void enumerateStringProperties(Map\u003cString, String\u003e h) {\n        if (defaults !\u003d null) {\n            defaults.enumerateStringProperties(h);\n        }\n        for (Map.Entry\u003cObject, Object\u003e e : entrySet()) {\n            Object k \u003d e.getKey();\n            Object v \u003d e.getValue();\n            if (k instanceof String \u0026\u0026 v instanceof String) {\n                h.put((String) k, (String) v);\n            }\n        }\n    }\n\n    //\n    // Hashtable methods overridden and delegated to a ConcurrentHashMap instance\n\n    @Override\n    public int size() {\n        return map.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    @Override\n    public Enumeration\u003cObject\u003e keys() {\n        // CHM.keys() returns Iterator w/ remove() - instead wrap keySet()\n        return Collections.enumeration(map.keySet());\n    }\n\n    @Override\n    public Enumeration\u003cObject\u003e elements() {\n        // CHM.elements() returns Iterator w/ remove() - instead wrap values()\n        return Collections.enumeration(map.values());\n    }\n\n    @Override\n    public boolean contains(Object value) {\n        return map.contains(value);\n    }\n\n    @Override\n    public boolean containsValue(Object value) {\n        return map.containsValue(value);\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return map.containsKey(key);\n    }\n\n    @Override\n    public Object get(Object key) {\n        return map.get(key);\n    }\n\n    @Override\n    public synchronized Object put(Object key, Object value) {\n        return map.put(key, value);\n    }\n\n    @Override\n    public synchronized Object remove(Object key) {\n        return map.remove(key);\n    }\n\n    @Override\n    public synchronized void putAll(Map\u003c?, ?\u003e t) {\n        map.putAll(t);\n    }\n\n    @Override\n    public synchronized void clear() {\n        map.clear();\n    }\n\n    @Override\n    public synchronized String toString() {\n        return map.toString();\n    }\n\n    @Override\n    public Set\u003cObject\u003e keySet() {\n        return Collections.synchronizedSet(map.keySet(), this);\n    }\n\n    @Override\n    public Collection\u003cObject\u003e values() {\n        return Collections.synchronizedCollection(map.values(), this);\n    }\n\n    @Override\n    public Set\u003cMap.Entry\u003cObject, Object\u003e\u003e entrySet() {\n        return Collections.synchronizedSet(new EntrySet(map.entrySet()), this);\n    }\n\n    /*\n     * Properties.entrySet() should not support add/addAll, however\n     * ConcurrentHashMap.entrySet() provides add/addAll.  This class wraps the\n     * Set returned from CHM, changing add/addAll to throw UOE.\n     */\n    private static class EntrySet implements Set\u003cMap.Entry\u003cObject, Object\u003e\u003e {\n        private Set\u003cMap.Entry\u003cObject,Object\u003e\u003e entrySet;\n\n        private EntrySet(Set\u003cMap.Entry\u003cObject, Object\u003e\u003e entrySet) {\n            this.entrySet \u003d entrySet;\n        }\n\n        @Override public int size() { return entrySet.size(); }\n        @Override public boolean isEmpty() { return entrySet.isEmpty(); }\n        @Override public boolean contains(Object o) { return entrySet.contains(o); }\n        @Override public Object[] toArray() { return entrySet.toArray(); }\n        @Override public \u003cT\u003e T[] toArray(T[] a) { return entrySet.toArray(a); }\n        @Override public void clear() { entrySet.clear(); }\n        @Override public boolean remove(Object o) { return entrySet.remove(o); }\n\n        @Override\n        public boolean add(Map.Entry\u003cObject, Object\u003e e) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean addAll(Collection\u003c? extends Map.Entry\u003cObject, Object\u003e\u003e c) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean containsAll(Collection\u003c?\u003e c) {\n            return entrySet.containsAll(c);\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            return o \u003d\u003d this || entrySet.equals(o);\n        }\n\n        @Override\n        public int hashCode() {\n            return entrySet.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return entrySet.toString();\n        }\n\n        @Override\n        public boolean removeAll(Collection\u003c?\u003e c) {\n            return entrySet.removeAll(c);\n        }\n\n        @Override\n        public boolean retainAll(Collection\u003c?\u003e c) {\n            return entrySet.retainAll(c);\n        }\n\n        @Override\n        public Iterator\u003cMap.Entry\u003cObject, Object\u003e\u003e iterator() {\n            return entrySet.iterator();\n        }\n    }\n\n    @Override\n    public synchronized boolean equals(Object o) {\n        return map.equals(o);\n    }\n\n    @Override\n    public synchronized int hashCode() {\n        return map.hashCode();\n    }\n\n    @Override\n    public Object getOrDefault(Object key, Object defaultValue) {\n        return map.getOrDefault(key, defaultValue);\n    }\n\n    @Override\n    public synchronized void forEach(BiConsumer\u003c? super Object, ? super Object\u003e action) {\n        map.forEach(action);\n    }\n\n    @Override\n    public synchronized void replaceAll(BiFunction\u003c? super Object, ? super Object, ?\u003e function) {\n        map.replaceAll(function);\n    }\n\n    @Override\n    public synchronized Object putIfAbsent(Object key, Object value) {\n        return map.putIfAbsent(key, value);\n    }\n\n    @Override\n    public synchronized boolean remove(Object key, Object value) {\n        return map.remove(key, value);\n    }\n\n    @Override\n    public synchronized boolean replace(Object key, Object oldValue, Object newValue) {\n        return map.replace(key, oldValue, newValue);\n    }\n\n    @Override\n    public synchronized Object replace(Object key, Object value) {\n        return map.replace(key, value);\n    }\n\n    @Override\n    public synchronized Object computeIfAbsent(Object key,\n            Function\u003c? super Object, ?\u003e mappingFunction) {\n        return map.computeIfAbsent(key, mappingFunction);\n    }\n\n    @Override\n    public synchronized Object computeIfPresent(Object key,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.computeIfPresent(key, remappingFunction);\n    }\n\n    @Override\n    public synchronized Object compute(Object key,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.compute(key, remappingFunction);\n    }\n\n    @Override\n    public synchronized Object merge(Object key, Object value,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.merge(key, value, remappingFunction);\n    }\n\n    //\n    // Special Hashtable methods\n\n    @Override\n    protected void rehash() { /* no-op */ }\n\n    @Override\n    public synchronized Object clone() {\n        Properties clone \u003d (Properties) cloneHashtable();\n        clone.map \u003d new ConcurrentHashMap\u003c\u003e(map);\n        return clone;\n    }\n\n    //\n    // Hashtable serialization overrides\n    // (these should emit and consume Hashtable-compatible stream)\n\n    @Override\n    void writeHashtable(ObjectOutputStream s) throws IOException {\n        var map \u003d this.map;\n        List\u003cObject\u003e entryStack \u003d new ArrayList\u003c\u003e(map.size() * 2); // an estimate\n\n        for (Map.Entry\u003cObject, Object\u003e entry : map.entrySet()) {\n            entryStack.add(entry.getValue());\n            entryStack.add(entry.getKey());\n        }\n\n        // Write out the simulated threshold, loadfactor\n        float loadFactor \u003d 0.75f;\n        int count \u003d entryStack.size() / 2;\n        int length \u003d (int)(count / loadFactor) + (count / 20) + 3;\n        if (length \u003e count \u0026\u0026 (length \u0026 1) \u003d\u003d 0) {\n            length--;\n        }\n        synchronized (map) { // in case of multiple concurrent serializations\n            defaultWriteHashtable(s, length, loadFactor);\n        }\n\n        // Write out simulated length and real count of elements\n        s.writeInt(length);\n        s.writeInt(count);\n\n        // Write out the key/value objects from the stacked entries\n        for (int i \u003d entryStack.size() - 1; i \u003e\u003d 0; i--) {\n            s.writeObject(entryStack.get(i));\n        }\n    }\n\n    @Override\n    void readHashtable(ObjectInputStream s) throws IOException,\n            ClassNotFoundException {\n        // Read in the threshold and loadfactor\n        s.defaultReadObject();\n\n        // Read the original length of the array and number of elements\n        int origlength \u003d s.readInt();\n        int elements \u003d s.readInt();\n\n        // Validate # of elements\n        if (elements \u003c 0) {\n            throw new StreamCorruptedException(\"Illegal # of Elements: \" + elements);\n        }\n\n        // Constructing the backing map will lazily create an array when the first element is\n        // added, so check it before construction. Note that CHM\u0027s constructor takes a size\n        // that is the number of elements to be stored -- not the table size -- so it must be\n        // inflated by the default load factor of 0.75, then inflated to the next power of two.\n        // (CHM uses the same power-of-two computation as HashMap, and HashMap.tableSizeFor is\n        // accessible here.) Check Map.Entry[].class since it\u0027s the nearest public type to\n        // what is actually created.\n        SharedSecrets.getJavaObjectInputStreamAccess()\n                     .checkArray(s, Map.Entry[].class, HashMap.tableSizeFor((int)(elements / 0.75)));\n\n        // create CHM of appropriate capacity\n        var map \u003d new ConcurrentHashMap\u003c\u003e(elements);\n\n        // Read all the key/value objects\n        for (; elements \u003e 0; elements--) {\n            Object key \u003d s.readObject();\n            Object value \u003d s.readObject();\n            map.put(key, value);\n        }\n        this.map \u003d map;\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

Π°ΠΏΡ€. 25, 2024 2:59:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/util/Properties.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.04.25 14:59:08 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java

Uri: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1570)
```

Π°ΠΏΡ€. 25, 2024 2:59:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/util/Properties.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1995, 2021, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.util;\n\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.StreamCorruptedException;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\nimport jdk.internal.util.StaticProperty;\nimport sun.nio.cs.ISO_8859_1;\nimport sun.nio.cs.UTF_8;\n\nimport jdk.internal.access.SharedSecrets;\nimport jdk.internal.misc.Unsafe;\nimport jdk.internal.util.ArraysSupport;\nimport jdk.internal.util.xml.PropertiesDefaultHandler;\n\n/**\n * The {@code Properties} class represents a persistent set of\n * properties. The {@code Properties} can be saved to a stream\n * or loaded from a stream. Each key and its corresponding value in\n * the property list is a string.\n * \u003cp\u003e\n * A property list can contain another property list as its\n * \"defaults\"; this second property list is searched if\n * the property key is not found in the original property list.\n * \u003cp\u003e\n * Because {@code Properties} inherits from {@code Hashtable}, the\n * {@code put} and {@code putAll} methods can be applied to a\n * {@code Properties} object.  Their use is strongly discouraged as they\n * allow the caller to insert entries whose keys or values are not\n * {@code Strings}.  The {@code setProperty} method should be used\n * instead.  If the {@code store} or {@code save} method is called\n * on a \"compromised\" {@code Properties} object that contains a\n * non-{@code String} key or value, the call will fail. Similarly,\n * the call to the {@code propertyNames} or {@code list} method\n * will fail if it is called on a \"compromised\" {@code Properties}\n * object that contains a non-{@code String} key.\n *\n * \u003cp\u003e\n * The iterators returned by the {@code iterator} method of this class\u0027s\n * \"collection views\" (that is, {@code entrySet()}, {@code keySet()}, and\n * {@code values()}) may not fail-fast (unlike the Hashtable implementation).\n * These iterators are guaranteed to traverse elements as they existed upon\n * construction exactly once, and may (but are not guaranteed to) reflect any\n * modifications subsequent to construction.\n * \u003cp\u003e\n * The {@link #load(java.io.Reader) load(Reader)} {@code /}\n * {@link #store(java.io.Writer, java.lang.String) store(Writer, String)}\n * methods load and store properties from and to a character based stream\n * in a simple line-oriented format specified below.\n *\n * The {@link #load(java.io.InputStream) load(InputStream)} {@code /}\n * {@link #store(java.io.OutputStream, java.lang.String) store(OutputStream, String)}\n * methods work the same way as the load(Reader)/store(Writer, String) pair, except\n * the input/output stream is encoded in ISO 8859-1 character encoding.\n * Characters that cannot be directly represented in this encoding can be written using\n * Unicode escapes as defined in section {@jls 3.3} of\n * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e;\n * only a single \u0027u\u0027 character is allowed in an escape\n * sequence.\n *\n * \u003cp\u003e The {@link #loadFromXML(InputStream)} and {@link\n * #storeToXML(OutputStream, String, String)} methods load and store properties\n * in a simple XML format.  By default the UTF-8 character encoding is used,\n * however a specific encoding may be specified if required. Implementations\n * are required to support UTF-8 and UTF-16 and may support other encodings.\n * An XML properties document has the following DOCTYPE declaration:\n *\n * \u003cpre\u003e\n * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n * \u003c/pre\u003e\n * Note that the system URI (http://java.sun.com/dtd/properties.dtd) is\n * \u003ci\u003enot\u003c/i\u003e accessed when exporting or importing properties; it merely\n * serves as a string to uniquely identify the DTD, which is:\n * \u003cpre\u003e\n *    \u0026lt;?xml version\u003d\"1.0\" encoding\u003d\"UTF-8\"?\u0026gt;\n *\n *    \u0026lt;!-- DTD for properties --\u0026gt;\n *\n *    \u0026lt;!ELEMENT properties ( comment?, entry* ) \u0026gt;\n *\n *    \u0026lt;!ATTLIST properties version CDATA #FIXED \"1.0\"\u0026gt;\n *\n *    \u0026lt;!ELEMENT comment (#PCDATA) \u0026gt;\n *\n *    \u0026lt;!ELEMENT entry (#PCDATA) \u0026gt;\n *\n *    \u0026lt;!ATTLIST entry key CDATA #REQUIRED\u0026gt;\n * \u003c/pre\u003e\n *\n * \u003cp\u003eThis class is thread-safe: multiple threads can share a single\n * {@code Properties} object without the need for external synchronization.\n *\n * @apiNote\n * The {@code Properties} class does not inherit the concept of a load factor\n * from its superclass, {@code Hashtable}.\n *\n * @author  Arthur van Hoff\n * @author  Michael McCloskey\n * @author  Xueming Shen\n * @since   1.0\n */\npublic class Properties extends Hashtable\u003cObject,Object\u003e {\n    /**\n     * use serialVersionUID from JDK 1.1.X for interoperability\n     */\n    @java.io.Serial\n    private static final long serialVersionUID \u003d 4112578634029874840L;\n\n    private static final Unsafe UNSAFE \u003d Unsafe.getUnsafe();\n\n    /**\n     * A property list that contains default values for any keys not\n     * found in this property list.\n     *\n     * @serial\n     */\n    protected volatile Properties defaults;\n\n    /**\n     * Properties does not store values in its inherited Hashtable, but instead\n     * in an internal ConcurrentHashMap.  Synchronization is omitted from\n     * simple read operations.  Writes and bulk operations remain synchronized,\n     * as in Hashtable.\n     */\n    private transient volatile ConcurrentHashMap\u003cObject, Object\u003e map;\n\n    /**\n     * Creates an empty property list with no default values.\n     *\n     * @implNote The initial capacity of a {@code Properties} object created\n     * with this constructor is unspecified.\n     */\n    public Properties() {\n        this(null, 8);\n    }\n\n    /**\n     * Creates an empty property list with no default values, and with an\n     * initial size accommodating the specified number of elements without the\n     * need to dynamically resize.\n     *\n     * @param  initialCapacity the {@code Properties} will be sized to\n     *         accommodate this many elements\n     * @throws IllegalArgumentException if the initial capacity is less than\n     *         zero.\n     */\n    public Properties(int initialCapacity) {\n        this(null, initialCapacity);\n    }\n\n    /**\n     * Creates an empty property list with the specified defaults.\n     *\n     * @implNote The initial capacity of a {@code Properties} object created\n     * with this constructor is unspecified.\n     *\n     * @param   defaults   the defaults.\n     */\n    public Properties(Properties defaults) {\n        this(defaults, 8);\n    }\n\n    private Properties(Properties defaults, int initialCapacity) {\n        // use package-private constructor to\n        // initialize unused fields with dummy values\n        super((Void) null);\n        map \u003d new ConcurrentHashMap\u003c\u003e(initialCapacity);\n        this.defaults \u003d defaults;\n\n        // Ensure writes can\u0027t be reordered\n        UNSAFE.storeFence();\n    }\n\n    /**\n     * Calls the {@code Hashtable} method {@code put}. Provided for\n     * parallelism with the {@code getProperty} method. Enforces use of\n     * strings for property keys and values. The value returned is the\n     * result of the {@code Hashtable} call to {@code put}.\n     *\n     * @param key the key to be placed into this property list.\n     * @param value the value corresponding to {@code key}.\n     * @return     the previous value of the specified key in this property\n     *             list, or {@code null} if it did not have one.\n     * @see #getProperty\n     * @since    1.2\n     */\n    public synchronized Object setProperty(String key, String value) {\n        return put(key, value);\n    }\n\n\n    /**\n     * Reads a property list (key and element pairs) from the input\n     * character stream in a simple line-oriented format.\n     * \u003cp\u003e\n     * Properties are processed in terms of lines. There are two\n     * kinds of lines, \u003ci\u003enatural lines\u003c/i\u003e and \u003ci\u003elogical lines\u003c/i\u003e.\n     * A natural line is defined as a line of\n     * characters that is terminated either by a set of line terminator\n     * characters ({@code \\n} or {@code \\r} or {@code \\r\\n})\n     * or by the end of the stream. A natural line may be either a blank line,\n     * a comment line, or hold all or some of a key-element pair. A logical\n     * line holds all the data of a key-element pair, which may be spread\n     * out across several adjacent natural lines by escaping\n     * the line terminator sequence with a backslash character\n     * {@code \\}.  Note that a comment line cannot be extended\n     * in this manner; every natural line that is a comment must have\n     * its own comment indicator, as described below. Lines are read from\n     * input until the end of the stream is reached.\n     *\n     * \u003cp\u003e\n     * A natural line that contains only white space characters is\n     * considered blank and is ignored.  A comment line has an ASCII\n     * {@code \u0027#\u0027} or {@code \u0027!\u0027} as its first non-whitespace\n     * character; comment lines are also ignored and do not\n     * encode key-element information.  In addition to line\n     * terminators, this format considers the characters space\n     * ({@code \u0027 \u0027}, {@code \u0027\\u005Cu0020\u0027}), tab\n     * ({@code \u0027\\t\u0027}, {@code \u0027\\u005Cu0009\u0027}), and form feed\n     * ({@code \u0027\\f\u0027}, {@code \u0027\\u005Cu000C\u0027}) to be white\n     * space.\n     *\n     * \u003cp\u003e\n     * If a logical line is spread across several natural lines, the\n     * backslash escaping the line terminator sequence, the line\n     * terminator sequence, and any white space at the start of the\n     * following line have no effect on the key or element values.\n     * The remainder of the discussion of key and element parsing\n     * (when loading) will assume all the characters constituting\n     * the key and element appear on a single natural line after\n     * line continuation characters have been removed.  Note that\n     * it is \u003ci\u003enot\u003c/i\u003e sufficient to only examine the character\n     * preceding a line terminator sequence to decide if the line\n     * terminator is escaped; there must be an odd number of\n     * contiguous backslashes for the line terminator to be escaped.\n     * Since the input is processed from left to right, a\n     * non-zero even number of 2\u003ci\u003en\u003c/i\u003e contiguous backslashes\n     * before a line terminator (or elsewhere) encodes \u003ci\u003en\u003c/i\u003e\n     * backslashes after escape processing.\n     *\n     * \u003cp\u003e\n     * The key contains all of the characters in the line starting\n     * with the first non-whitespace character and up to, but not\n     * including, the first unescaped {@code \u0027\u003d\u0027},\n     * {@code \u0027:\u0027}, or white space character other than a line\n     * terminator. All of these key termination characters may be\n     * included in the key by escaping them with a preceding backslash\n     * character; for example,\u003cp\u003e\n     *\n     * {@code \\:\\\u003d}\u003cp\u003e\n     *\n     * would be the two-character key {@code \":\u003d\"}.  Line\n     * terminator characters can be included using {@code \\r} and\n     * {@code \\n} escape sequences.  Any white space after the\n     * key is skipped; if the first non-whitespace character after\n     * the key is {@code \u0027\u003d\u0027} or {@code \u0027:\u0027}, then it is\n     * ignored and any white space characters after it are also\n     * skipped.  All remaining characters on the line become part of\n     * the associated element string; if there are no remaining\n     * characters, the element is the empty string\n     * {@code \"\"}.  Once the raw character sequences\n     * constituting the key and element are identified, escape\n     * processing is performed as described above.\n     *\n     * \u003cp\u003e\n     * As an example, each of the following three lines specifies the key\n     * {@code \"Truth\"} and the associated element value\n     * {@code \"Beauty\"}:\n     * \u003cpre\u003e\n     * Truth \u003d Beauty\n     *  Truth:Beauty\n     * Truth                    :Beauty\n     * \u003c/pre\u003e\n     * As another example, the following three lines specify a single\n     * property:\n     * \u003cpre\u003e\n     * fruits                           apple, banana, pear, \\\n     *                                  cantaloupe, watermelon, \\\n     *                                  kiwi, mango\n     * \u003c/pre\u003e\n     * The key is {@code \"fruits\"} and the associated element is:\n     * \u003cpre\u003e\"apple, banana, pear, cantaloupe, watermelon, kiwi, mango\"\u003c/pre\u003e\n     * Note that a space appears before each {@code \\} so that a space\n     * will appear after each comma in the final result; the {@code \\},\n     * line terminator, and leading white space on the continuation line are\n     * merely discarded and are \u003ci\u003enot\u003c/i\u003e replaced by one or more other\n     * characters.\n     * \u003cp\u003e\n     * As a third example, the line:\n     * \u003cpre\u003echeeses\n     * \u003c/pre\u003e\n     * specifies that the key is {@code \"cheeses\"} and the associated\n     * element is the empty string {@code \"\"}.\n     * \u003cp\u003e\n     * \u003ca id\u003d\"unicodeescapes\"\u003e\u003c/a\u003e\n     * Characters in keys and elements can be represented in escape\n     * sequences similar to those used for character and string literals\n     * (see sections {@jls 3.3} and {@jls 3.10.6} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e).\n     *\n     * The differences from the character escape sequences and Unicode\n     * escapes used for characters and strings are:\n     *\n     * \u003cul\u003e\n     * \u003cli\u003e Octal escapes are not recognized.\n     *\n     * \u003cli\u003e The character sequence {@code \\b} does \u003ci\u003enot\u003c/i\u003e\n     * represent a backspace character.\n     *\n     * \u003cli\u003e The method does not treat a backslash character,\n     * {@code \\}, before a non-valid escape character as an\n     * error; the backslash is silently dropped.  For example, in a\n     * Java string the sequence {@code \"\\z\"} would cause a\n     * compile time error.  In contrast, this method silently drops\n     * the backslash.  Therefore, this method treats the two character\n     * sequence {@code \"\\b\"} as equivalent to the single\n     * character {@code \u0027b\u0027}.\n     *\n     * \u003cli\u003e Escapes are not necessary for single and double quotes;\n     * however, by the rule above, single and double quote characters\n     * preceded by a backslash still yield single and double quote\n     * characters, respectively.\n     *\n     * \u003cli\u003e Only a single \u0027u\u0027 character is allowed in a Unicode escape\n     * sequence.\n     *\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * The specified stream remains open after this method returns.\n     *\n     * @param   reader   the input character stream.\n     * @throws  IOException  if an error occurred when reading from the\n     *          input stream.\n     * @throws  IllegalArgumentException if a malformed Unicode escape\n     *          appears in the input.\n     * @throws  NullPointerException if {@code reader} is null.\n     * @since   1.6\n     */\n    public synchronized void load(Reader reader) throws IOException {\n        Objects.requireNonNull(reader, \"reader parameter is null\");\n        load0(new LineReader(reader));\n    }\n\n    /**\n     * Reads a property list (key and element pairs) from the input\n     * byte stream. The input stream is in a simple line-oriented\n     * format as specified in\n     * {@link #load(java.io.Reader) load(Reader)} and is assumed to use\n     * the ISO 8859-1 character encoding; that is each byte is one Latin1\n     * character. Characters not in Latin1, and certain special characters,\n     * are represented in keys and elements using Unicode escapes as defined in\n     * section {@jls 3.3} of\n     * \u003ccite\u003eThe Java Language Specification\u003c/cite\u003e.\n     * \u003cp\u003e\n     * The specified stream remains open after this method returns.\n     *\n     * @param      inStream   the input stream.\n     * @throws     IOException  if an error occurred when reading from the\n     *             input stream.\n     * @throws     IllegalArgumentException if the input stream contains a\n     *             malformed Unicode escape sequence.\n     * @throws     NullPointerException if {@code inStream} is null.\n     * @since 1.2\n     */\n    public synchronized void load(InputStream inStream) throws IOException {\n        Objects.requireNonNull(inStream, \"inStream parameter is null\");\n        load0(new LineReader(inStream));\n    }\n\n    private void load0(LineReader lr) throws IOException {\n        StringBuilder outBuffer \u003d new StringBuilder();\n        int limit;\n        int keyLen;\n        int valueStart;\n        boolean hasSep;\n        boolean precedingBackslash;\n\n        while ((limit \u003d lr.readLine()) \u003e\u003d 0) {\n            keyLen \u003d 0;\n            valueStart \u003d limit;\n            hasSep \u003d false;\n\n            //System.out.println(\"line\u003d\u003c\" + new String(lineBuf, 0, limit) + \"\u003e\");\n            precedingBackslash \u003d false;\n            while (keyLen \u003c limit) {\n                char c \u003d lr.lineBuf[keyLen];\n                //need check if escaped.\n                if ((c \u003d\u003d \u0027\u003d\u0027 ||  c \u003d\u003d \u0027:\u0027) \u0026\u0026 !precedingBackslash) {\n                    valueStart \u003d keyLen + 1;\n                    hasSep \u003d true;\n                    break;\n                } else if ((c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\t\u0027 ||  c \u003d\u003d \u0027\\f\u0027) \u0026\u0026 !precedingBackslash) {\n                    valueStart \u003d keyLen + 1;\n                    break;\n                }\n                if (c \u003d\u003d \u0027\\\\\u0027) {\n                    precedingBackslash \u003d !precedingBackslash;\n                } else {\n                    precedingBackslash \u003d false;\n                }\n                keyLen++;\n            }\n            while (valueStart \u003c limit) {\n                char c \u003d lr.lineBuf[valueStart];\n                if (c !\u003d \u0027 \u0027 \u0026\u0026 c !\u003d \u0027\\t\u0027 \u0026\u0026  c !\u003d \u0027\\f\u0027) {\n                    if (!hasSep \u0026\u0026 (c \u003d\u003d \u0027\u003d\u0027 ||  c \u003d\u003d \u0027:\u0027)) {\n                        hasSep \u003d true;\n                    } else {\n                        break;\n                    }\n                }\n                valueStart++;\n            }\n            String key \u003d loadConvert(lr.lineBuf, 0, keyLen, outBuffer);\n            String value \u003d loadConvert(lr.lineBuf, valueStart, limit - valueStart, outBuffer);\n            put(key, value);\n        }\n    }\n\n    /* Read in a \"logical line\" from an InputStream/Reader, skip all comment\n     * and blank lines and filter out those leading whitespace characters\n     * (\\u0020, \\u0009 and \\u000c) from the beginning of a \"natural line\".\n     * Method returns the char length of the \"logical line\" and stores\n     * the line in \"lineBuf\".\n     */\n    private static class LineReader {\n        LineReader(InputStream inStream) {\n            this.inStream \u003d inStream;\n            inByteBuf \u003d new byte[8192];\n        }\n\n        LineReader(Reader reader) {\n            this.reader \u003d reader;\n            inCharBuf \u003d new char[8192];\n        }\n\n        char[] lineBuf \u003d new char[1024];\n        private byte[] inByteBuf;\n        private char[] inCharBuf;\n        private int inLimit \u003d 0;\n        private int inOff \u003d 0;\n        private InputStream inStream;\n        private Reader reader;\n\n        int readLine() throws IOException {\n            // use locals to optimize for interpreted performance\n            int len \u003d 0;\n            int off \u003d inOff;\n            int limit \u003d inLimit;\n\n            boolean skipWhiteSpace \u003d true;\n            boolean appendedLineBegin \u003d false;\n            boolean precedingBackslash \u003d false;\n            boolean fromStream \u003d inStream !\u003d null;\n            byte[] byteBuf \u003d inByteBuf;\n            char[] charBuf \u003d inCharBuf;\n            char[] lineBuf \u003d this.lineBuf;\n            char c;\n\n            while (true) {\n                if (off \u003e\u003d limit) {\n                    inLimit \u003d limit \u003d fromStream ? inStream.read(byteBuf)\n                                                 : reader.read(charBuf);\n                    if (limit \u003c\u003d 0) {\n                        if (len \u003d\u003d 0) {\n                            return -1;\n                        }\n                        return precedingBackslash ? len - 1 : len;\n                    }\n                    off \u003d 0;\n                }\n\n                // (char)(byte \u0026 0xFF) is equivalent to calling a ISO8859-1 decoder.\n                c \u003d (fromStream) ? (char)(byteBuf[off++] \u0026 0xFF) : charBuf[off++];\n\n                if (skipWhiteSpace) {\n                    if (c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\t\u0027 || c \u003d\u003d \u0027\\f\u0027) {\n                        continue;\n                    }\n                    if (!appendedLineBegin \u0026\u0026 (c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\n\u0027)) {\n                        continue;\n                    }\n                    skipWhiteSpace \u003d false;\n                    appendedLineBegin \u003d false;\n\n                }\n                if (len \u003d\u003d 0) { // Still on a new logical line\n                    if (c \u003d\u003d \u0027#\u0027 || c \u003d\u003d \u0027!\u0027) {\n                        // Comment, quickly consume the rest of the line\n\n                        // When checking for new line characters a range check,\n                        // starting with the higher bound (\u0027\\r\u0027) means one less\n                        // branch in the common case.\n                        commentLoop: while (true) {\n                            if (fromStream) {\n                                byte b;\n                                while (off \u003c limit) {\n                                    b \u003d byteBuf[off++];\n                                    if (b \u003c\u003d \u0027\\r\u0027 \u0026\u0026 (b \u003d\u003d \u0027\\r\u0027 || b \u003d\u003d \u0027\\n\u0027))\n                                        break commentLoop;\n                                }\n                                if (off \u003d\u003d limit) {\n                                    inLimit \u003d limit \u003d inStream.read(byteBuf);\n                                    if (limit \u003c\u003d 0) { // EOF\n                                        return -1;\n                                    }\n                                    off \u003d 0;\n                                }\n                            } else {\n                                while (off \u003c limit) {\n                                    c \u003d charBuf[off++];\n                                    if (c \u003c\u003d \u0027\\r\u0027 \u0026\u0026 (c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\n\u0027))\n                                        break commentLoop;\n                                }\n                                if (off \u003d\u003d limit) {\n                                    inLimit \u003d limit \u003d reader.read(charBuf);\n                                    if (limit \u003c\u003d 0) { // EOF\n                                        return -1;\n                                    }\n                                    off \u003d 0;\n                                }\n                            }\n                        }\n                        skipWhiteSpace \u003d true;\n                        continue;\n                    }\n                }\n\n                if (c !\u003d \u0027\\n\u0027 \u0026\u0026 c !\u003d \u0027\\r\u0027) {\n                    lineBuf[len++] \u003d c;\n                    if (len \u003d\u003d lineBuf.length) {\n                        lineBuf \u003d new char[ArraysSupport.newLength(len, 1, len)];\n                        System.arraycopy(this.lineBuf, 0, lineBuf, 0, len);\n                        this.lineBuf \u003d lineBuf;\n                    }\n                    // flip the preceding backslash flag\n                    precedingBackslash \u003d (c \u003d\u003d \u0027\\\\\u0027) ? !precedingBackslash : false;\n                } else {\n                    // reached EOL\n                    if (len \u003d\u003d 0) {\n                        skipWhiteSpace \u003d true;\n                        continue;\n                    }\n                    if (off \u003e\u003d limit) {\n                        inLimit \u003d limit \u003d fromStream ? inStream.read(byteBuf)\n                                                     : reader.read(charBuf);\n                        off \u003d 0;\n                        if (limit \u003c\u003d 0) { // EOF\n                            return precedingBackslash ? len - 1 : len;\n                        }\n                    }\n                    if (precedingBackslash) {\n                        // backslash at EOL is not part of the line\n                        len -\u003d 1;\n                        // skip leading whitespace characters in the following line\n                        skipWhiteSpace \u003d true;\n                        appendedLineBegin \u003d true;\n                        precedingBackslash \u003d false;\n                        // take care not to include any subsequent \\n\n                        if (c \u003d\u003d \u0027\\r\u0027) {\n                            if (fromStream) {\n                                if (byteBuf[off] \u003d\u003d \u0027\\n\u0027) {\n                                    off++;\n                                }\n                            } else {\n                                if (charBuf[off] \u003d\u003d \u0027\\n\u0027) {\n                                    off++;\n                                }\n                            }\n                        }\n                    } else {\n                        inOff \u003d off;\n                        return len;\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n     * Converts encoded \u0026#92;uxxxx to unicode chars\n     * and changes special saved chars to their original forms\n     */\n    private String loadConvert(char[] in, int off, int len, StringBuilder out) {\n        char aChar;\n        int end \u003d off + len;\n        int start \u003d off;\n        while (off \u003c end) {\n            aChar \u003d in[off++];\n            if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                break;\n            }\n        }\n        if (off \u003d\u003d end) { // No backslash\n            return new String(in, start, len);\n        }\n\n        // backslash found at off - 1, reset the shared buffer, rewind offset\n        out.setLength(0);\n        off--;\n        out.append(in, start, off - start);\n\n        while (off \u003c end) {\n            aChar \u003d in[off++];\n            if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                // No need to bounds check since LineReader::readLine excludes\n                // unescaped \\s at the end of the line\n                aChar \u003d in[off++];\n                if(aChar \u003d\u003d \u0027u\u0027) {\n                    // Read the xxxx\n                    if (off \u003e end - 4)\n                        throw new IllegalArgumentException(\n                                     \"Malformed \\\\uxxxx encoding.\");\n                    int value \u003d 0;\n                    for (int i \u003d 0; i \u003c 4; i++) {\n                        aChar \u003d in[off++];\n                        value \u003d switch (aChar) {\n                            case \u00270\u0027, \u00271\u0027, \u00272\u0027, \u00273\u0027, \u00274\u0027, \u00275\u0027, \u00276\u0027, \u00277\u0027, \u00278\u0027, \u00279\u0027 -\u003e (value \u003c\u003c 4) + aChar - \u00270\u0027;\n                            case \u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027, \u0027f\u0027                     -\u003e (value \u003c\u003c 4) + 10 + aChar - \u0027a\u0027;\n                            case \u0027A\u0027, \u0027B\u0027, \u0027C\u0027, \u0027D\u0027, \u0027E\u0027, \u0027F\u0027                     -\u003e (value \u003c\u003c 4) + 10 + aChar - \u0027A\u0027;\n                            default -\u003e throw new IllegalArgumentException(\"Malformed \\\\uxxxx encoding.\");\n                        };\n                    }\n                    out.append((char)value);\n                } else {\n                    if (aChar \u003d\u003d \u0027t\u0027) aChar \u003d \u0027\\t\u0027;\n                    else if (aChar \u003d\u003d \u0027r\u0027) aChar \u003d \u0027\\r\u0027;\n                    else if (aChar \u003d\u003d \u0027n\u0027) aChar \u003d \u0027\\n\u0027;\n                    else if (aChar \u003d\u003d \u0027f\u0027) aChar \u003d \u0027\\f\u0027;\n                    out.append(aChar);\n                }\n            } else {\n                out.append(aChar);\n            }\n        }\n        return out.toString();\n    }\n\n    /*\n     * Converts unicodes to encoded \u0026#92;uxxxx and escapes\n     * special characters with a preceding slash\n     */\n    private String saveConvert(String theString,\n                               boolean escapeSpace,\n                               boolean escapeUnicode) {\n        int len \u003d theString.length();\n        int bufLen \u003d len * 2;\n        if (bufLen \u003c 0) {\n            bufLen \u003d Integer.MAX_VALUE;\n        }\n        StringBuilder outBuffer \u003d new StringBuilder(bufLen);\n        HexFormat hex \u003d HexFormat.of().withUpperCase();\n        for(int x\u003d0; x\u003clen; x++) {\n            char aChar \u003d theString.charAt(x);\n            // Handle common case first, selecting largest block that\n            // avoids the specials below\n            if ((aChar \u003e 61) \u0026\u0026 (aChar \u003c 127)) {\n                if (aChar \u003d\u003d \u0027\\\\\u0027) {\n                    outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027\\\\\u0027);\n                    continue;\n                }\n                outBuffer.append(aChar);\n                continue;\n            }\n            switch(aChar) {\n                case \u0027 \u0027:\n                    if (x \u003d\u003d 0 || escapeSpace)\n                        outBuffer.append(\u0027\\\\\u0027);\n                    outBuffer.append(\u0027 \u0027);\n                    break;\n                case \u0027\\t\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027t\u0027);\n                          break;\n                case \u0027\\n\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027n\u0027);\n                          break;\n                case \u0027\\r\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027r\u0027);\n                          break;\n                case \u0027\\f\u0027:outBuffer.append(\u0027\\\\\u0027); outBuffer.append(\u0027f\u0027);\n                          break;\n                case \u0027\u003d\u0027: // Fall through\n                case \u0027:\u0027: // Fall through\n                case \u0027#\u0027: // Fall through\n                case \u0027!\u0027:\n                    outBuffer.append(\u0027\\\\\u0027); outBuffer.append(aChar);\n                    break;\n                default:\n                    if (((aChar \u003c 0x0020) || (aChar \u003e 0x007e)) \u0026 escapeUnicode ) {\n                        outBuffer.append(\"\\\\u\");\n                        outBuffer.append(hex.toHexDigits(aChar));\n                    } else {\n                        outBuffer.append(aChar);\n                    }\n            }\n        }\n        return outBuffer.toString();\n    }\n\n    private static void writeComments(BufferedWriter bw, String comments)\n        throws IOException {\n        HexFormat hex \u003d HexFormat.of().withUpperCase();\n        bw.write(\"#\");\n        int len \u003d comments.length();\n        int current \u003d 0;\n        int last \u003d 0;\n        while (current \u003c len) {\n            char c \u003d comments.charAt(current);\n            if (c \u003e \u0027\\u00ff\u0027 || c \u003d\u003d \u0027\\n\u0027 || c \u003d\u003d \u0027\\r\u0027) {\n                if (last !\u003d current)\n                    bw.write(comments.substring(last, current));\n                if (c \u003e \u0027\\u00ff\u0027) {\n                    bw.write(\"\\\\u\");\n                    bw.write(hex.toHexDigits(c));\n                } else {\n                    bw.newLine();\n                    if (c \u003d\u003d \u0027\\r\u0027 \u0026\u0026\n                        current !\u003d len - 1 \u0026\u0026\n                        comments.charAt(current + 1) \u003d\u003d \u0027\\n\u0027) {\n                        current++;\n                    }\n                    if (current \u003d\u003d len - 1 ||\n                        (comments.charAt(current + 1) !\u003d \u0027#\u0027 \u0026\u0026\n                        comments.charAt(current + 1) !\u003d \u0027!\u0027))\n                        bw.write(\"#\");\n                }\n                last \u003d current + 1;\n            }\n            current++;\n        }\n        if (last !\u003d current)\n            bw.write(comments.substring(last, current));\n        bw.newLine();\n    }\n\n    /**\n     * Calls the {@code store(OutputStream out, String comments)} method\n     * and suppresses IOExceptions that were thrown.\n     *\n     * @deprecated This method does not throw an IOException if an I/O error\n     * occurs while saving the property list.  The preferred way to save a\n     * properties list is via the {@code store(OutputStream out,\n     * String comments)} method or the\n     * {@code storeToXML(OutputStream os, String comment)} method.\n     *\n     * @param   out      an output stream.\n     * @param   comments   a description of the property list.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not\n     *             {@code Strings}.\n     */\n    @Deprecated\n    public void save(OutputStream out, String comments)  {\n        try {\n            store(out, comments);\n        } catch (IOException e) {\n        }\n    }\n\n    /**\n     * Writes this property list (key and element pairs) in this\n     * {@code Properties} table to the output character stream in a\n     * format suitable for using the {@link #load(java.io.Reader) load(Reader)}\n     * method.\n     * \u003cp\u003e\n     * Properties from the defaults table of this {@code Properties}\n     * table (if any) are \u003ci\u003enot\u003c/i\u003e written out by this method.\n     * \u003cp\u003e\n     * If the comments argument is not null, then an ASCII {@code #}\n     * character, the comments string, and a line separator are first written\n     * to the output stream. Thus, the {@code comments} can serve as an\n     * identifying comment. Any one of a line feed ({@code \\n}), a carriage\n     * return ({@code \\r}), or a carriage return followed immediately by a line feed\n     * ({@code \\r\\n}) in comments is replaced by a\n     * {@link System#lineSeparator() line separator} and if the next\n     * character in comments is not character {@code #} or character {@code !} then\n     * an ASCII {@code #} is written out after that line separator.\n     * \u003cp\u003e\n     * If the {@systemProperty java.properties.date} is set on the command line\n     * and is non-empty (as determined by {@link String#isEmpty()  String.isEmpty}),\n     * a comment line is written as follows.\n     * First, a {@code #} character is written, followed by the contents\n     * of the property, followed by a line separator. Any line terminator characters\n     * in the value of the system property are treated the same way as noted above\n     * for the comments argument.\n     * If the system property is not set or is empty, a comment line is written\n     * as follows.\n     * First, a {@code #} character is written, followed by the current date and time\n     * formatted as if by the {@link Date#toString() Date.toString} method,\n     * followed by a line separator.\n     * \u003cp\u003e\n     * Then every entry in this {@code Properties} table is\n     * written out, one per line. For each entry the key string is\n     * written, then an ASCII {@code \u003d}, then the associated\n     * element string. For the key, all space characters are\n     * written with a preceding {@code \\} character.  For the\n     * element, leading space characters, but not embedded or trailing\n     * space characters, are written with a preceding {@code \\}\n     * character. The key and element characters {@code #},\n     * {@code !}, {@code \u003d}, and {@code :} are written\n     * with a preceding backslash to ensure that they are properly loaded.\n     * \u003cp\u003e\n     * After the entries have been written, the output stream is flushed.\n     * The output stream remains open after this method returns.\n     *\n     * @implSpec The keys and elements are written in the natural sort order\n     * of the keys in the {@code entrySet()} unless {@code entrySet()} is\n     * overridden by a subclass to return a different value than {@code super.entrySet()}.\n     *\n     * @param   writer      an output character stream writer.\n     * @param   comments   a description of the property list.\n     * @throws     IOException if writing this property list to the specified\n     *             output stream throws an {@code IOException}.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not {@code Strings}.\n     * @throws     NullPointerException  if {@code writer} is null.\n     * @since 1.6\n     */\n    public void store(Writer writer, String comments)\n        throws IOException\n    {\n        store0((writer instanceof BufferedWriter)?(BufferedWriter)writer\n                                                 : new BufferedWriter(writer),\n               comments,\n               false);\n    }\n\n    /**\n     * Writes this property list (key and element pairs) in this\n     * {@code Properties} table to the output stream in a format suitable\n     * for loading into a {@code Properties} table using the\n     * {@link #load(InputStream) load(InputStream)} method.\n     * \u003cp\u003e\n     * Properties from the defaults table of this {@code Properties}\n     * table (if any) are \u003ci\u003enot\u003c/i\u003e written out by this method.\n     * \u003cp\u003e\n     * This method outputs the comments, properties keys and values in\n     * the same format as specified in\n     * {@link #store(java.io.Writer, java.lang.String) store(Writer)},\n     * with the following differences:\n     * \u003cul\u003e\n     * \u003cli\u003eThe stream is written using the ISO 8859-1 character encoding.\n     *\n     * \u003cli\u003eCharacters not in Latin-1 in the comments are written as\n     * {@code \\u005Cu}\u003ci\u003exxxx\u003c/i\u003e for their appropriate unicode\n     * hexadecimal value \u003ci\u003exxxx\u003c/i\u003e.\n     *\n     * \u003cli\u003eCharacters less than {@code \\u005Cu0020} and characters greater\n     * than {@code \\u005Cu007E} in property keys or values are written\n     * as {@code \\u005Cu}\u003ci\u003exxxx\u003c/i\u003e for the appropriate hexadecimal\n     * value \u003ci\u003exxxx\u003c/i\u003e.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * After the entries have been written, the output stream is flushed.\n     * The output stream remains open after this method returns.\n     *\n     * @param   out      an output stream.\n     * @param   comments   a description of the property list.\n     * @throws     IOException if writing this property list to the specified\n     *             output stream throws an {@code IOException}.\n     * @throws     ClassCastException  if this {@code Properties} object\n     *             contains any keys or values that are not {@code Strings}.\n     * @throws     NullPointerException  if {@code out} is null.\n     * @since 1.2\n     */\n    public void store(OutputStream out, String comments)\n        throws IOException\n    {\n        store0(new BufferedWriter(new OutputStreamWriter(out, ISO_8859_1.INSTANCE)),\n               comments,\n               true);\n    }\n\n    private void store0(BufferedWriter bw, String comments, boolean escUnicode)\n        throws IOException\n    {\n        if (comments !\u003d null) {\n            writeComments(bw, comments);\n        }\n        writeDateComment(bw);\n\n        synchronized (this) {\n            @SuppressWarnings(\"unchecked\")\n            Collection\u003cMap.Entry\u003cString, String\u003e\u003e entries \u003d (Set\u003cMap.Entry\u003cString, String\u003e\u003e) (Set) entrySet();\n            // entrySet() can be overridden by subclasses. Here we check to see if\n            // the returned instance type is the one returned by the Properties.entrySet()\n            // implementation. If yes, then we sort those entries in the natural order\n            // of their key. Else, we consider that the subclassed implementation may\n            // potentially have returned a differently ordered entries and so we just\n            // use the iteration order of the returned instance.\n            if (entries instanceof Collections.SynchronizedSet\u003c?\u003e ss\n                    \u0026\u0026 ss.c instanceof EntrySet) {\n                entries \u003d new ArrayList\u003c\u003e(entries);\n                ((List\u003cMap.Entry\u003cString, String\u003e\u003e) entries).sort(Map.Entry.comparingByKey());\n            }\n            for (Map.Entry\u003cString, String\u003e e : entries) {\n                String key \u003d e.getKey();\n                String val \u003d e.getValue();\n                key \u003d saveConvert(key, true, escUnicode);\n                /* No need to escape embedded and trailing spaces for value, hence\n                 * pass false to flag.\n                 */\n                val \u003d saveConvert(val, false, escUnicode);\n                bw.write(key + \"\u003d\" + val);\n                bw.newLine();\n            }\n        }\n        bw.flush();\n    }\n\n    private static void writeDateComment(BufferedWriter bw) throws IOException {\n        // value of java.properties.date system property isn\u0027t sensitive\n        // and so doesn\u0027t need any security manager checks to make the value accessible\n        // to the callers\n        String sysPropVal \u003d StaticProperty.javaPropertiesDate();\n        if (sysPropVal !\u003d null \u0026\u0026 !sysPropVal.isEmpty()) {\n            writeComments(bw, sysPropVal);\n        } else {\n            bw.write(\"#\" + new Date());\n            bw.newLine();\n        }\n    }\n\n    /**\n     * Loads all of the properties represented by the XML document on the\n     * specified input stream into this properties table.\n     *\n     * \u003cp\u003eThe XML document must have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     * Furthermore, the document must satisfy the properties DTD described\n     * above.\n     *\n     * \u003cp\u003e An implementation is required to read XML documents that use the\n     * \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An implementation may\n     * support additional encodings.\n     *\n     * \u003cp\u003eThe specified stream is closed after this method returns.\n     *\n     * @param in the input stream from which to read the XML document.\n     * @throws IOException if reading from the specified input stream\n     *         results in an {@code IOException}.\n     * @throws java.io.UnsupportedEncodingException if the document\u0027s encoding\n     *         declaration can be read and it specifies an encoding that is not\n     *         supported\n     * @throws InvalidPropertiesFormatException Data on input stream does not\n     *         constitute a valid XML document with the mandated document type.\n     * @throws NullPointerException if {@code in} is null.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #storeToXML(OutputStream, String, String)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 1.5\n     */\n    public synchronized void loadFromXML(InputStream in)\n        throws IOException, InvalidPropertiesFormatException\n    {\n        Objects.requireNonNull(in);\n        PropertiesDefaultHandler handler \u003d new PropertiesDefaultHandler();\n        handler.load(this, in);\n        in.close();\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table.\n     *\n     * \u003cp\u003e An invocation of this method of the form {@code props.storeToXML(os,\n     * comment)} behaves in exactly the same way as the invocation\n     * {@code props.storeToXML(os, comment, \"UTF-8\");}.\n     *\n     * @param os the output stream on which to emit the XML document.\n     * @param comment a description of the property list, or {@code null}\n     *        if no comment is desired.\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws NullPointerException if {@code os} is null.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not\n     *         {@code Strings}.\n     * @see    #loadFromXML(InputStream)\n     * @since 1.5\n     */\n    public void storeToXML(OutputStream os, String comment)\n        throws IOException\n    {\n        storeToXML(os, comment, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table, using the specified encoding.\n     *\n     * \u003cp\u003eThe XML document will have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003eIf the specified comment is {@code null} then no comment\n     * will be stored in the document.\n     *\n     * \u003cp\u003e An implementation is required to support writing of XML documents\n     * that use the \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An\n     * implementation may support additional encodings.\n     *\n     * \u003cp\u003eThe specified stream remains open after this method returns.\n     *\n     * \u003cp\u003eThis method behaves the same as\n     * {@linkplain #storeToXML(OutputStream os, String comment, Charset charset)}\n     * except that it will {@linkplain java.nio.charset.Charset#forName look up the charset}\n     * using the given encoding name.\n     *\n     * @param os        the output stream on which to emit the XML document.\n     * @param comment   a description of the property list, or {@code null}\n     *                  if no comment is desired.\n     * @param  encoding the name of a supported\n     *                  \u003ca href\u003d\"../lang/package-summary.html#charenc\"\u003e\n     *                  character encoding\u003c/a\u003e\n     *\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws java.io.UnsupportedEncodingException if the encoding is not\n     *         supported by the implementation.\n     * @throws NullPointerException if {@code os} is {@code null},\n     *         or if {@code encoding} is {@code null}.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not {@code Strings}.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #loadFromXML(InputStream)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 1.5\n     */\n    public void storeToXML(OutputStream os, String comment, String encoding)\n        throws IOException {\n        Objects.requireNonNull(os);\n        Objects.requireNonNull(encoding);\n\n        try {\n            Charset charset \u003d Charset.forName(encoding);\n            storeToXML(os, comment, charset);\n        } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {\n            throw new UnsupportedEncodingException(encoding);\n        }\n    }\n\n    /**\n     * Emits an XML document representing all of the properties contained\n     * in this table, using the specified encoding.\n     *\n     * \u003cp\u003eThe XML document will have the following DOCTYPE declaration:\n     * \u003cpre\u003e\n     * \u0026lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"\u0026gt;\n     * \u003c/pre\u003e\n     *\n     * \u003cp\u003eIf the specified comment is {@code null} then no comment\n     * will be stored in the document.\n     *\n     * \u003cp\u003e An implementation is required to support writing of XML documents\n     * that use the \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An\n     * implementation may support additional encodings.\n     *\n     * \u003cp\u003e Unmappable characters for the specified charset will be encoded as\n     * numeric character references.\n     *\n     * \u003cp\u003eThe specified stream remains open after this method returns.\n     *\n     * @param os        the output stream on which to emit the XML document.\n     * @param comment   a description of the property list, or {@code null}\n     *                  if no comment is desired.\n     * @param charset   the charset\n     *\n     * @throws IOException if writing to the specified output stream\n     *         results in an {@code IOException}.\n     * @throws NullPointerException if {@code os} or {@code charset} is {@code null}.\n     * @throws ClassCastException  if this {@code Properties} object\n     *         contains any keys or values that are not {@code Strings}.\n     *\n     * @spec https://www.w3.org/TR/xml Extensible Markup Language (XML) 1.0 (Fifth Edition)\n     * @see    #loadFromXML(InputStream)\n     * @see    \u003ca href\u003d\"http://www.w3.org/TR/REC-xml/#charencoding\"\u003eCharacter\n     *         Encoding in Entities\u003c/a\u003e\n     * @since 10\n     */\n    public void storeToXML(OutputStream os, String comment, Charset charset)\n        throws IOException {\n        Objects.requireNonNull(os, \"OutputStream\");\n        Objects.requireNonNull(charset, \"Charset\");\n        PropertiesDefaultHandler handler \u003d new PropertiesDefaultHandler();\n        handler.store(this, os, comment, charset);\n    }\n\n    /**\n     * Searches for the property with the specified key in this property list.\n     * If the key is not found in this property list, the default property list,\n     * and its defaults, recursively, are then checked. The method returns\n     * {@code null} if the property is not found.\n     *\n     * @param   key   the property key.\n     * @return  the value in this property list with the specified key value.\n     * @see     #setProperty\n     * @see     #defaults\n     */\n    public String getProperty(String key) {\n        Object oval \u003d map.get(key);\n        String sval \u003d (oval instanceof String) ? (String)oval : null;\n        Properties defaults;\n        return ((sval \u003d\u003d null) \u0026\u0026 ((defaults \u003d this.defaults) !\u003d null)) ? defaults.getProperty(key) : sval;\n    }\n\n    /**\n     * Searches for the property with the specified key in this property list.\n     * If the key is not found in this property list, the default property list,\n     * and its defaults, recursively, are then checked. The method returns the\n     * default value argument if the property is not found.\n     *\n     * @param   key            the hashtable key.\n     * @param   defaultValue   a default value.\n     *\n     * @return  the value in this property list with the specified key value.\n     * @see     #setProperty\n     * @see     #defaults\n     */\n    public String getProperty(String key, String defaultValue) {\n        String val \u003d getProperty(key);\n        return (val \u003d\u003d null) ? defaultValue : val;\n    }\n\n    /**\n     * Returns an enumeration of all the keys in this property list,\n     * including distinct keys in the default property list if a key\n     * of the same name has not already been found from the main\n     * properties list.\n     *\n     * @return  an enumeration of all the keys in this property list, including\n     *          the keys in the default property list.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     * @see     java.util.Enumeration\n     * @see     java.util.Properties#defaults\n     * @see     #stringPropertyNames\n     */\n    public Enumeration\u003c?\u003e propertyNames() {\n        Hashtable\u003cString,Object\u003e h \u003d new Hashtable\u003c\u003e();\n        enumerate(h);\n        return h.keys();\n    }\n\n    /**\n     * Returns an unmodifiable set of keys from this property list\n     * where the key and its corresponding value are strings,\n     * including distinct keys in the default property list if a key\n     * of the same name has not already been found from the main\n     * properties list.  Properties whose key or value is not\n     * of type {@code String} are omitted.\n     * \u003cp\u003e\n     * The returned set is not backed by this {@code Properties} object.\n     * Changes to this {@code Properties} object are not reflected in the\n     * returned set.\n     *\n     * @return  an unmodifiable set of keys in this property list where\n     *          the key and its corresponding value are strings,\n     *          including the keys in the default property list.\n     * @see     java.util.Properties#defaults\n     * @since   1.6\n     */\n    public Set\u003cString\u003e stringPropertyNames() {\n        Map\u003cString, String\u003e h \u003d new HashMap\u003c\u003e();\n        enumerateStringProperties(h);\n        return Collections.unmodifiableSet(h.keySet());\n    }\n\n    /**\n     * Prints this property list out to the specified output stream.\n     * This method is useful for debugging.\n     *\n     * @param   out   an output stream.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     */\n    public void list(PrintStream out) {\n        out.println(\"-- listing properties --\");\n        Map\u003cString, Object\u003e h \u003d new HashMap\u003c\u003e();\n        enumerate(h);\n        for (Map.Entry\u003cString, Object\u003e e : h.entrySet()) {\n            String key \u003d e.getKey();\n            String val \u003d (String)e.getValue();\n            if (val.length() \u003e 40) {\n                val \u003d val.substring(0, 37) + \"...\";\n            }\n            out.println(key + \"\u003d\" + val);\n        }\n    }\n\n    /**\n     * Prints this property list out to the specified output stream.\n     * This method is useful for debugging.\n     *\n     * @param   out   an output stream.\n     * @throws  ClassCastException if any key in this property list\n     *          is not a string.\n     * @since   1.1\n     */\n    /*\n     * Rather than use an anonymous inner class to share common code, this\n     * method is duplicated in order to ensure that a non-1.1 compiler can\n     * compile this file.\n     */\n    public void list(PrintWriter out) {\n        out.println(\"-- listing properties --\");\n        Map\u003cString, Object\u003e h \u003d new HashMap\u003c\u003e();\n        enumerate(h);\n        for (Map.Entry\u003cString, Object\u003e e : h.entrySet()) {\n            String key \u003d e.getKey();\n            String val \u003d (String)e.getValue();\n            if (val.length() \u003e 40) {\n                val \u003d val.substring(0, 37) + \"...\";\n            }\n            out.println(key + \"\u003d\" + val);\n        }\n    }\n\n    /**\n     * Enumerates all key/value pairs into the specified Map.\n     * @param h the Map\n     * @throws ClassCastException if any of the property keys\n     *         is not of String type.\n     */\n    private void enumerate(Map\u003cString, Object\u003e h) {\n        if (defaults !\u003d null) {\n            defaults.enumerate(h);\n        }\n        for (Map.Entry\u003cObject, Object\u003e e : entrySet()) {\n            String key \u003d (String)e.getKey();\n            h.put(key, e.getValue());\n        }\n    }\n\n    /**\n     * Enumerates all key/value pairs into the specified Map\n     * and omits the property if the key or value is not a string.\n     * @param h the Map\n     */\n    private void enumerateStringProperties(Map\u003cString, String\u003e h) {\n        if (defaults !\u003d null) {\n            defaults.enumerateStringProperties(h);\n        }\n        for (Map.Entry\u003cObject, Object\u003e e : entrySet()) {\n            Object k \u003d e.getKey();\n            Object v \u003d e.getValue();\n            if (k instanceof String \u0026\u0026 v instanceof String) {\n                h.put((String) k, (String) v);\n            }\n        }\n    }\n\n    //\n    // Hashtable methods overridden and delegated to a ConcurrentHashMap instance\n\n    @Override\n    public int size() {\n        return map.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    @Override\n    public Enumeration\u003cObject\u003e keys() {\n        // CHM.keys() returns Iterator w/ remove() - instead wrap keySet()\n        return Collections.enumeration(map.keySet());\n    }\n\n    @Override\n    public Enumeration\u003cObject\u003e elements() {\n        // CHM.elements() returns Iterator w/ remove() - instead wrap values()\n        return Collections.enumeration(map.values());\n    }\n\n    @Override\n    public boolean contains(Object value) {\n        return map.contains(value);\n    }\n\n    @Override\n    public boolean containsValue(Object value) {\n        return map.containsValue(value);\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return map.containsKey(key);\n    }\n\n    @Override\n    public Object get(Object key) {\n        return map.get(key);\n    }\n\n    @Override\n    public synchronized Object put(Object key, Object value) {\n        return map.put(key, value);\n    }\n\n    @Override\n    public synchronized Object remove(Object key) {\n        return map.remove(key);\n    }\n\n    @Override\n    public synchronized void putAll(Map\u003c?, ?\u003e t) {\n        map.putAll(t);\n    }\n\n    @Override\n    public synchronized void clear() {\n        map.clear();\n    }\n\n    @Override\n    public synchronized String toString() {\n        return map.toString();\n    }\n\n    @Override\n    public Set\u003cObject\u003e keySet() {\n        return Collections.synchronizedSet(map.keySet(), this);\n    }\n\n    @Override\n    public Collection\u003cObject\u003e values() {\n        return Collections.synchronizedCollection(map.values(), this);\n    }\n\n    @Override\n    public Set\u003cMap.Entry\u003cObject, Object\u003e\u003e entrySet() {\n        return Collections.synchronizedSet(new EntrySet(map.entrySet()), this);\n    }\n\n    /*\n     * Properties.entrySet() should not support add/addAll, however\n     * ConcurrentHashMap.entrySet() provides add/addAll.  This class wraps the\n     * Set returned from CHM, changing add/addAll to throw UOE.\n     */\n    private static class EntrySet implements Set\u003cMap.Entry\u003cObject, Object\u003e\u003e {\n        private Set\u003cMap.Entry\u003cObject,Object\u003e\u003e entrySet;\n\n        private EntrySet(Set\u003cMap.Entry\u003cObject, Object\u003e\u003e entrySet) {\n            this.entrySet \u003d entrySet;\n        }\n\n        @Override public int size() { return entrySet.size(); }\n        @Override public boolean isEmpty() { return entrySet.isEmpty(); }\n        @Override public boolean contains(Object o) { return entrySet.contains(o); }\n        @Override public Object[] toArray() { return entrySet.toArray(); }\n        @Override public \u003cT\u003e T[] toArray(T[] a) { return entrySet.toArray(a); }\n        @Override public void clear() { entrySet.clear(); }\n        @Override public boolean remove(Object o) { return entrySet.remove(o); }\n\n        @Override\n        public boolean add(Map.Entry\u003cObject, Object\u003e e) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean addAll(Collection\u003c? extends Map.Entry\u003cObject, Object\u003e\u003e c) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean containsAll(Collection\u003c?\u003e c) {\n            return entrySet.containsAll(c);\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            return o \u003d\u003d this || entrySet.equals(o);\n        }\n\n        @Override\n        public int hashCode() {\n            return entrySet.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return entrySet.toString();\n        }\n\n        @Override\n        public boolean removeAll(Collection\u003c?\u003e c) {\n            return entrySet.removeAll(c);\n        }\n\n        @Override\n        public boolean retainAll(Collection\u003c?\u003e c) {\n            return entrySet.retainAll(c);\n        }\n\n        @Override\n        public Iterator\u003cMap.Entry\u003cObject, Object\u003e\u003e iterator() {\n            return entrySet.iterator();\n        }\n    }\n\n    @Override\n    public synchronized boolean equals(Object o) {\n        return map.equals(o);\n    }\n\n    @Override\n    public synchronized int hashCode() {\n        return map.hashCode();\n    }\n\n    @Override\n    public Object getOrDefault(Object key, Object defaultValue) {\n        return map.getOrDefault(key, defaultValue);\n    }\n\n    @Override\n    public synchronized void forEach(BiConsumer\u003c? super Object, ? super Object\u003e action) {\n        map.forEach(action);\n    }\n\n    @Override\n    public synchronized void replaceAll(BiFunction\u003c? super Object, ? super Object, ?\u003e function) {\n        map.replaceAll(function);\n    }\n\n    @Override\n    public synchronized Object putIfAbsent(Object key, Object value) {\n        return map.putIfAbsent(key, value);\n    }\n\n    @Override\n    public synchronized boolean remove(Object key, Object value) {\n        return map.remove(key, value);\n    }\n\n    @Override\n    public synchronized boolean replace(Object key, Object oldValue, Object newValue) {\n        return map.replace(key, oldValue, newValue);\n    }\n\n    @Override\n    public synchronized Object replace(Object key, Object value) {\n        return map.replace(key, value);\n    }\n\n    @Override\n    public synchronized Object computeIfAbsent(Object key,\n            Function\u003c? super Object, ?\u003e mappingFunction) {\n        return map.computeIfAbsent(key, mappingFunction);\n    }\n\n    @Override\n    public synchronized Object computeIfPresent(Object key,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.computeIfPresent(key, remappingFunction);\n    }\n\n    @Override\n    public synchronized Object compute(Object key,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.compute(key, remappingFunction);\n    }\n\n    @Override\n    public synchronized Object merge(Object key, Object value,\n            BiFunction\u003c? super Object, ? super Object, ?\u003e remappingFunction) {\n        return map.merge(key, value, remappingFunction);\n    }\n\n    //\n    // Special Hashtable methods\n\n    @Override\n    protected void rehash() { /* no-op */ }\n\n    @Override\n    public synchronized Object clone() {\n        Properties clone \u003d (Properties) cloneHashtable();\n        clone.map \u003d new ConcurrentHashMap\u003c\u003e(map);\n        return clone;\n    }\n\n    //\n    // Hashtable serialization overrides\n    // (these should emit and consume Hashtable-compatible stream)\n\n    @Override\n    void writeHashtable(ObjectOutputStream s) throws IOException {\n        var map \u003d this.map;\n        List\u003cObject\u003e entryStack \u003d new ArrayList\u003c\u003e(map.size() * 2); // an estimate\n\n        for (Map.Entry\u003cObject, Object\u003e entry : map.entrySet()) {\n            entryStack.add(entry.getValue());\n            entryStack.add(entry.getKey());\n        }\n\n        // Write out the simulated threshold, loadfactor\n        float loadFactor \u003d 0.75f;\n        int count \u003d entryStack.size() / 2;\n        int length \u003d (int)(count / loadFactor) + (count / 20) + 3;\n        if (length \u003e count \u0026\u0026 (length \u0026 1) \u003d\u003d 0) {\n            length--;\n        }\n        synchronized (map) { // in case of multiple concurrent serializations\n            defaultWriteHashtable(s, length, loadFactor);\n        }\n\n        // Write out simulated length and real count of elements\n        s.writeInt(length);\n        s.writeInt(count);\n\n        // Write out the key/value objects from the stacked entries\n        for (int i \u003d entryStack.size() - 1; i \u003e\u003d 0; i--) {\n            s.writeObject(entryStack.get(i));\n        }\n    }\n\n    @Override\n    void readHashtable(ObjectInputStream s) throws IOException,\n            ClassNotFoundException {\n        // Read in the threshold and loadfactor\n        s.defaultReadObject();\n\n        // Read the original length of the array and number of elements\n        int origlength \u003d s.readInt();\n        int elements \u003d s.readInt();\n\n        // Validate # of elements\n        if (elements \u003c 0) {\n            throw new StreamCorruptedException(\"Illegal # of Elements: \" + elements);\n        }\n\n        // Constructing the backing map will lazily create an array when the first element is\n        // added, so check it before construction. Note that CHM\u0027s constructor takes a size\n        // that is the number of elements to be stored -- not the table size -- so it must be\n        // inflated by the default load factor of 0.75, then inflated to the next power of two.\n        // (CHM uses the same power-of-two computation as HashMap, and HashMap.tableSizeFor is\n        // accessible here.) Check Map.Entry[].class since it\u0027s the nearest public type to\n        // what is actually created.\n        SharedSecrets.getJavaObjectInputStreamAccess()\n                     .checkArray(s, Map.Entry[].class, HashMap.tableSizeFor((int)(elements / 0.75)));\n\n        // create CHM of appropriate capacity\n        var map \u003d new ConcurrentHashMap\u003c\u003e(elements);\n\n        // Read all the key/value objects\n        for (; elements \u003e 0; elements--) {\n            Object key \u003d s.readObject();\n            Object value \u003d s.readObject();\n            map.put(key, value);\n        }\n        this.map \u003d map;\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

Π°ΠΏΡ€. 25, 2024 2:59:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/util/Properties.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/util/Properties.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.04.25 14:59:08 INFO  compiling bestgame (1 scala source)
2024.04.25 14:59:08 INFO  time: compiled bestgame in 0.14s
Π°ΠΏΡ€. 25, 2024 3:03:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7305
2024.04.25 15:03:53 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\DataBaseManager.scala
2024.04.25 15:03:54 INFO  compiling bestgame (1 scala source)
2024.04.25 15:03:57 INFO  time: compiled bestgame in 2.81s
Π°ΠΏΡ€. 25, 2024 3:07:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7342
2024.04.25 15:19:08 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\ENVars.scala
scala.meta.tokenizers.TokenizeException: <input>:5: error: unclosed string literal
	val debug = readResult.getString("deg);
                                  ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:560)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:379)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 15:19:08 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\ENVars.scala
scala.meta.tokenizers.TokenizeException: <input>:5: error: unclosed string literal
	val debug = readResult.getString("debu);
                                  ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:560)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:379)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 15:19:09 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\ENVars.scala
scala.meta.tokenizers.TokenizeException: <input>:5: error: unclosed string literal
	val debug = readResult.getString("debu);
                                  ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:560)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:379)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 15:19:10 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\ENVars.scala
scala.meta.tokenizers.TokenizeException: <input>:5: error: unclosed string literal
	val debug = readResult.getString("de);
                                  ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:560)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:379)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 15:19:16 INFO  compiling bestgame (1 scala source)
2024.04.25 15:19:16 INFO  time: compiled bestgame in 0.31s
2024.04.25 15:22:43 INFO  compiling bestgame (1 scala source)
2024.04.25 15:22:43 INFO  time: compiled bestgame in 0.78s
2024.04.25 15:22:48 INFO  compiling bestgame (1 scala source)
2024.04.25 15:22:48 INFO  time: compiled bestgame in 0.23s
2024.04.25 15:23:02 INFO  compiling bestgame (1 scala source)
2024.04.25 15:23:02 INFO  time: compiled bestgame in 0.13s
Π°ΠΏΡ€. 25, 2024 3:25:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7577
2024.04.25 15:33:48 INFO  compiling bestgame (1 scala source)
2024.04.25 15:33:48 INFO  time: compiled bestgame in 0.16s
2024.04.25 15:33:49 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:08 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:08 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:10 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:11 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:12 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:13 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:14 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:14 INFO  compiling bestgame (1 scala source)
2024.04.25 15:34:14 INFO  time: compiled bestgame in 0.33s
2024.04.25 15:34:15 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:17 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:17 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:17 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:17 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:17 INFO  compiling bestgame (1 scala source)
2024.04.25 15:34:17 INFO  time: compiled bestgame in 0.12s
2024.04.25 15:34:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:35 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:36 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:37 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:39 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:42 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:43 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:44 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:45 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:45 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:34:46 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
Π°ΠΏΡ€. 25, 2024 3:34:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8040
2024.04.25 15:35:01 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:35:04 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:35:05 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:35:06 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:35:06 INFO  compiling bestgame (1 scala source)
2024.04.25 15:35:06 INFO  time: compiled bestgame in 93ms
2024.04.25 15:35:07 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:35:19 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:35:20 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:35:20 INFO  compiling bestgame (1 scala source)
2024.04.25 15:35:20 INFO  time: compiled bestgame in 0.19s
2024.04.25 15:35:20 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
Π°ΠΏΡ€. 25, 2024 3:35:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8135
Π°ΠΏΡ€. 25, 2024 3:35:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8144
2024.04.25 15:35:36 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:35:39 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:35:44 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\ENVars.scala
2024.04.25 15:35:44 INFO  compiling bestgame (1 scala source)
2024.04.25 15:35:44 INFO  time: compiled bestgame in 0.45s
2024.04.25 15:37:25 INFO  compiling bestgame (1 scala source)
2024.04.25 15:37:25 INFO  time: compiled bestgame in 0.3s
Π°ΠΏΡ€. 25, 2024 3:38:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.StringIndexOutOfBoundsException: Range [610, 651) out of bounds for length 642
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: Range [610, 651) out of bounds for length 642
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.StringIndexOutOfBoundsException: Range [610, 651) out of bounds for length 642
	at java.base/jdk.internal.util.Preconditions$1.apply(Preconditions.java:55)
	at java.base/jdk.internal.util.Preconditions$1.apply(Preconditions.java:52)
	at java.base/jdk.internal.util.Preconditions$4.apply(Preconditions.java:213)
	at java.base/jdk.internal.util.Preconditions$4.apply(Preconditions.java:210)
	at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:98)
	at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckFromToIndex(Preconditions.java:112)
	at java.base/jdk.internal.util.Preconditions.checkFromToIndex(Preconditions.java:349)
	at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4914)
	at java.base/java.lang.String.substring(String.java:2876)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.getIndentForPos(FlatMapToForComprehensionCodeAction.scala:677)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$4(FlatMapToForComprehensionCodeAction.scala:57)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$3(FlatMapToForComprehensionCodeAction.scala:53)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$2(FlatMapToForComprehensionCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$1(FlatMapToForComprehensionCodeAction.scala:51)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

Π°ΠΏΡ€. 25, 2024 3:38:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.StringIndexOutOfBoundsException: Range [610, 651) out of bounds for length 642
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: Range [610, 651) out of bounds for length 642
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.StringIndexOutOfBoundsException: Range [610, 651) out of bounds for length 642
	at java.base/jdk.internal.util.Preconditions$1.apply(Preconditions.java:55)
	at java.base/jdk.internal.util.Preconditions$1.apply(Preconditions.java:52)
	at java.base/jdk.internal.util.Preconditions$4.apply(Preconditions.java:213)
	at java.base/jdk.internal.util.Preconditions$4.apply(Preconditions.java:210)
	at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:98)
	at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckFromToIndex(Preconditions.java:112)
	at java.base/jdk.internal.util.Preconditions.checkFromToIndex(Preconditions.java:349)
	at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4914)
	at java.base/java.lang.String.substring(String.java:2876)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.getIndentForPos(FlatMapToForComprehensionCodeAction.scala:677)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$4(FlatMapToForComprehensionCodeAction.scala:57)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$3(FlatMapToForComprehensionCodeAction.scala:53)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$2(FlatMapToForComprehensionCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$1(FlatMapToForComprehensionCodeAction.scala:51)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

Π°ΠΏΡ€. 25, 2024 3:38:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.StringIndexOutOfBoundsException: Range [610, 651) out of bounds for length 642
java.util.concurrent.CompletionException: java.lang.StringIndexOutOfBoundsException: Range [610, 651) out of bounds for length 642
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.StringIndexOutOfBoundsException: Range [610, 651) out of bounds for length 642
	at java.base/jdk.internal.util.Preconditions$1.apply(Preconditions.java:55)
	at java.base/jdk.internal.util.Preconditions$1.apply(Preconditions.java:52)
	at java.base/jdk.internal.util.Preconditions$4.apply(Preconditions.java:213)
	at java.base/jdk.internal.util.Preconditions$4.apply(Preconditions.java:210)
	at java.base/jdk.internal.util.Preconditions.outOfBounds(Preconditions.java:98)
	at java.base/jdk.internal.util.Preconditions.outOfBoundsCheckFromToIndex(Preconditions.java:112)
	at java.base/jdk.internal.util.Preconditions.checkFromToIndex(Preconditions.java:349)
	at java.base/java.lang.String.checkBoundsBeginEnd(String.java:4914)
	at java.base/java.lang.String.substring(String.java:2876)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.getIndentForPos(FlatMapToForComprehensionCodeAction.scala:677)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$4(FlatMapToForComprehensionCodeAction.scala:57)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$3(FlatMapToForComprehensionCodeAction.scala:53)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$2(FlatMapToForComprehensionCodeAction.scala:52)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.metals.codeactions.FlatMapToForComprehensionCodeAction.$anonfun$contribute$1(FlatMapToForComprehensionCodeAction.scala:51)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2024.04.25 15:38:27 INFO  compiling bestgame (1 scala source)
2024.04.25 15:38:27 INFO  time: compiled bestgame in 0.13s
2024.04.25 15:38:31 INFO  compiling bestgame (1 scala source)
2024.04.25 15:38:31 INFO  time: compiled bestgame in 0.11s
2024.04.25 15:38:40 INFO  compiling bestgame (1 scala source)
2024.04.25 15:38:40 INFO  time: compiled bestgame in 0.16s
Π°ΠΏΡ€. 25, 2024 3:38:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8677
Π°ΠΏΡ€. 25, 2024 3:38:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8688
2024.04.25 15:43:37 INFO  compiling bestgame (1 scala source)
2024.04.25 15:43:37 INFO  time: compiled bestgame in 0.26s
2024.04.25 15:54:59 INFO  compiling bestgame (1 scala source)
2024.04.25 15:54:59 INFO  time: compiled bestgame in 1s
Π°ΠΏΡ€. 25, 2024 3:55:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 509,
      "uri": "file:///d%3A/bestgame/src/main/scala/gameClasses/Seeds.scala"
    },
    "contentChanges": [
      {
        "text": "package gameClasses\n\nsealed trait Seed(val name: String) extends Item\n{\n  val price \u003d 1;\n  //READ VALUES FROM JSON FILE\n}\ncase class Wheat() extends Seed(\"wheat\")\n\n\ndef stringToItem(name: String): Seed \u003d\n  name match {\n    case (\"Wheat\") \u003d\u003e Wheat()\n    case _ \u003d\u003e null;\n}\n\nobject Seeds\n{\n  def getPrice(seed: Seed): Int \u003d\n  {\n    1\n  }\n}"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..336]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:54)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:48)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine$lzycompute(Position.scala:39)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:39)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionMetaPosition.toLsp(ScalametaCommonEnrichments.scala:77)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.$anonfun$toRevised$8(TokenEditDistance.scala:310)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:241)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:283)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$2(Diagnostics.scala:239)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$2$adapted(Diagnostics.scala:238)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:619)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:617)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:935)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:238)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:203)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:138)
	at scala.meta.internal.metals.MetalsLspService.didChange(MetalsLspService.scala:1223)
	at scala.meta.internal.metals.WorkspaceLspService.didChange(WorkspaceLspService.scala:355)
	at scala.meta.metals.lsp.DelegatingScalaService.didChange(DelegatingScalaService.scala:50)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more

Π°ΠΏΡ€. 25, 2024 3:55:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 510,
      "uri": "file:///d%3A/bestgame/src/main/scala/gameClasses/Seeds.scala"
    },
    "contentChanges": [
      {
        "text": "package gameClasses\n\n\nsealed trait Seed(val name: String) extends Item\n{\n  val price \u003d 1;\n  //READ VALUES FROM JSON FILE\n}\ncase class Wheat() extends Seed(\"wheat\")\n\n\ndef stringToItem(name: String): Seed \u003d\n  name match {\n    case (\"Wheat\") \u003d\u003e Wheat()\n    case _ \u003d\u003e null;\n}\n\nobject Seeds\n{\n  def getPrice(seed: Seed): Int \u003d\n  {\n    1\n  }\n}"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..337]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:54)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:48)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine$lzycompute(Position.scala:39)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:39)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionMetaPosition.toLsp(ScalametaCommonEnrichments.scala:77)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.$anonfun$toRevised$8(TokenEditDistance.scala:310)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:241)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:283)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$2(Diagnostics.scala:239)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$2$adapted(Diagnostics.scala:238)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:619)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:617)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:935)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:238)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:203)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:138)
	at scala.meta.internal.metals.MetalsLspService.didChange(MetalsLspService.scala:1223)
	at scala.meta.internal.metals.WorkspaceLspService.didChange(WorkspaceLspService.scala:355)
	at scala.meta.metals.lsp.DelegatingScalaService.didChange(DelegatingScalaService.scala:50)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more

Π°ΠΏΡ€. 25, 2024 3:55:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 511,
      "uri": "file:///d%3A/bestgame/src/main/scala/gameClasses/Seeds.scala"
    },
    "contentChanges": [
      {
        "text": "package gameClasses\n\n\n\nsealed trait Seed(val name: String) extends Item\n{\n  val price \u003d 1;\n  //READ VALUES FROM JSON FILE\n}\ncase class Wheat() extends Seed(\"wheat\")\n\n\ndef stringToItem(name: String): Seed \u003d\n  name match {\n    case (\"Wheat\") \u003d\u003e Wheat()\n    case _ \u003d\u003e null;\n}\n\nobject Seeds\n{\n  def getPrice(seed: Seed): Int \u003d\n  {\n    1\n  }\n}"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: -1 is not a valid offset, allowed [0..338]
	at scala.meta.internal.inputs.InternalInput.offsetToLine(InternalInput.scala:54)
	at scala.meta.internal.inputs.InternalInput.offsetToLine$(InternalInput.scala:48)
	at scala.meta.inputs.Input$VirtualFile.offsetToLine(Input.scala:80)
	at scala.meta.inputs.Position$Range.startLine$lzycompute(Position.scala:39)
	at scala.meta.inputs.Position$Range.startLine(Position.scala:39)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionMetaPosition.toLsp(ScalametaCommonEnrichments.scala:77)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.$anonfun$toRevised$8(TokenEditDistance.scala:310)
	at scala.Option.flatMap(Option.scala:283)
	at scala.meta.internal.parsing.TokenEditDistance$Diff.toRevised(TokenEditDistance.scala:241)
	at scala.meta.internal.metals.Diagnostics.toFreshDiagnostic(Diagnostics.scala:283)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$2(Diagnostics.scala:239)
	at scala.meta.internal.metals.Diagnostics.$anonfun$publishDiagnostics$2$adapted(Diagnostics.scala:238)
	at scala.collection.IterableOnceOps.foreach(IterableOnce.scala:619)
	at scala.collection.IterableOnceOps.foreach$(IterableOnce.scala:617)
	at scala.collection.AbstractIterable.foreach(Iterable.scala:935)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:238)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:203)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:138)
	at scala.meta.internal.metals.MetalsLspService.didChange(MetalsLspService.scala:1223)
	at scala.meta.internal.metals.WorkspaceLspService.didChange(WorkspaceLspService.scala:355)
	at scala.meta.metals.lsp.DelegatingScalaService.didChange(DelegatingScalaService.scala:50)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more

2024.04.25 15:55:05 INFO  compiling bestgame (1 scala source)
2024.04.25 15:55:05 INFO  time: compiled bestgame in 0.39s
2024.04.25 15:55:10 INFO  compiling bestgame (1 scala source)
2024.04.25 15:55:10 INFO  time: compiled bestgame in 0.17s
2024.04.25 15:55:42 INFO  compiling bestgame (1 scala source)
2024.04.25 15:55:42 INFO  time: compiled bestgame in 0.52s
2024.04.25 15:55:43 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:55:49 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:55:52 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:55:52 INFO  compiling bestgame (1 scala source)
2024.04.25 15:55:52 INFO  time: compiled bestgame in 0.28s
2024.04.25 15:55:55 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:55:57 INFO  compiling bestgame (1 scala source)
2024.04.25 15:55:57 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:55:57 INFO  time: compiled bestgame in 0.31s
2024.04.25 15:55:57 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:56:00 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:56:02 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:56:04 INFO  compiling bestgame (1 scala source)
2024.04.25 15:56:04 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:56:04 INFO  time: compiled bestgame in 0.29s
2024.04.25 15:56:07 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:56:08 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:56:13 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:56:15 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:56:17 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:56:17 INFO  compiling bestgame (1 scala source)
2024.04.25 15:56:17 INFO  time: compiled bestgame in 0.36s
2024.04.25 15:56:18 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:56:34 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:56:36 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:56:36 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:56:36 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:56:37 INFO  compiling bestgame (1 scala source)
2024.04.25 15:56:37 INFO  time: compiled bestgame in 0.2s
2024.04.25 15:56:37 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:56:57 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:57:00 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:57:11 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:57:12 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:57:13 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:57:14 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:57:16 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:57:17 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:57:17 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:57:19 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:57:19 INFO  compiling bestgame (1 scala source)
2024.04.25 15:57:19 INFO  time: compiled bestgame in 99ms
2024.04.25 15:57:19 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:57:22 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:57:22 INFO  compiling bestgame (1 scala source)
2024.04.25 15:57:22 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:57:22 INFO  time: compiled bestgame in 0.27s
2024.04.25 15:57:23 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:57:28 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:57:39 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:57:40 INFO  compiling bestgame (1 scala source)
2024.04.25 15:57:40 INFO  time: compiled bestgame in 0.12s
2024.04.25 15:57:41 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:57:42 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:57:43 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:57:43 INFO  compiling bestgame (1 scala source)
2024.04.25 15:57:43 INFO  time: compiled bestgame in 0.1s
2024.04.25 15:57:44 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:57:57 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:58:02 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:58:05 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:58:06 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:58:06 INFO  compiling bestgame (1 scala source)
2024.04.25 15:58:06 INFO  time: compiled bestgame in 90ms
2024.04.25 15:58:06 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:58:08 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:58:11 INFO  compiling bestgame (1 scala source)
2024.04.25 15:58:11 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:58:11 INFO  time: compiled bestgame in 60ms
2024.04.25 15:58:12 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:58:15 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:58:20 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:58:23 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:58:23 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:58:23 INFO  compiling bestgame (1 scala source)
2024.04.25 15:58:23 INFO  time: compiled bestgame in 67ms
2024.04.25 15:58:24 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:58:31 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:58:33 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:58:33 INFO  compiling bestgame (1 scala source)
2024.04.25 15:58:33 INFO  time: compiled bestgame in 0.11s
2024.04.25 15:58:34 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:58:41 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:58:42 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:58:53 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:59:01 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:59:02 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:59:02 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:59:04 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:59:04 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:59:04 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:59:04 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:59:04 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:59:05 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:59:06 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:59:06 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:59:07 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:59:08 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:59:10 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:59:10 INFO  compiling bestgame (1 scala source)
2024.04.25 15:59:10 INFO  time: compiled bestgame in 0.24s
2024.04.25 15:59:11 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:59:13 INFO  compiling bestgame (1 scala source)
2024.04.25 15:59:13 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:59:13 INFO  time: compiled bestgame in 91ms
2024.04.25 15:59:13 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 15:59:21 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 16:00:25 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 16:01:15 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 16:02:32 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 16:04:05 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 16:05:16 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 16:05:24 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 16:05:29 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 16:05:29 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 16:05:31 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 16:05:32 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 16:05:32 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 16:05:34 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 16:05:35 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 16:05:36 WARN  Could not load snapshot text for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
2024.04.25 16:11:27 INFO  compiling bestgame (1 scala source)
2024.04.25 16:11:27 INFO  time: compiled bestgame in 0.62s
2024.04.25 16:11:33 INFO  compiling bestgame (1 scala source)
2024.04.25 16:11:33 INFO  time: compiled bestgame in 0.17s
Π°ΠΏΡ€. 25, 2024 4:11:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9880
2024.04.25 16:11:37 INFO  compiling bestgame (1 scala source)
2024.04.25 16:11:37 INFO  time: compiled bestgame in 0.28s
2024.04.25 16:12:18 INFO  compiling bestgame (1 scala source)
2024.04.25 16:12:18 INFO  time: compiled bestgame in 95ms
2024.04.25 16:12:24 INFO  compiling bestgame (1 scala source)
2024.04.25 16:12:24 INFO  time: compiled bestgame in 0.39s
2024.04.25 16:12:31 INFO  compiling bestgame (1 scala source)
2024.04.25 16:12:31 INFO  time: compiled bestgame in 0.28s
2024.04.25 16:12:34 INFO  compiling bestgame (1 scala source)
2024.04.25 16:12:34 INFO  time: compiled bestgame in 0.29s
2024.04.25 16:13:07 INFO  compiling bestgame (1 scala source)
2024.04.25 16:13:07 INFO  time: compiled bestgame in 0.47s
2024.04.25 16:13:09 INFO  compiling bestgame (1 scala source)
2024.04.25 16:13:09 INFO  time: compiled bestgame in 0.57s
2024.04.25 16:13:20 INFO  compiling bestgame (1 scala source)
2024.04.25 16:13:20 INFO  time: compiled bestgame in 0.25s
2024.04.25 16:14:13 INFO  compiling bestgame (1 scala source)
2024.04.25 16:14:13 INFO  time: compiled bestgame in 0.24s
Π°ΠΏΡ€. 25, 2024 4:16:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10252
2024.04.25 16:16:22 INFO  compiling bestgame (1 scala source)
2024.04.25 16:16:22 INFO  time: compiled bestgame in 0.12s
2024.04.25 16:16:26 INFO  compiling bestgame (1 scala source)
2024.04.25 16:16:26 INFO  time: compiled bestgame in 0.36s
2024.04.25 16:16:30 INFO  compiling bestgame (1 scala source)
2024.04.25 16:16:30 INFO  time: compiled bestgame in 88ms
2024.04.25 16:20:21 INFO  compiling bestgame (1 scala source)
2024.04.25 16:20:21 INFO  time: compiled bestgame in 0.21s
2024.04.25 16:20:39 INFO  compiling bestgame (1 scala source)
2024.04.25 16:20:39 INFO  time: compiled bestgame in 0.2s
2024.04.25 16:20:51 INFO  compiling bestgame (1 scala source)
2024.04.25 16:20:51 INFO  time: compiled bestgame in 0.64s
2024.04.25 16:20:56 INFO  compiling bestgame (1 scala source)
2024.04.25 16:20:56 INFO  time: compiled bestgame in 0.37s
2024.04.25 16:20:56 WARN  Using indexes to guess the definition of Task
2024.04.25 16:20:59 INFO  compiling bestgame (1 scala source)
2024.04.25 16:20:59 INFO  time: compiled bestgame in 90ms
2024.04.25 16:21:01 INFO  compiling bestgame (1 scala source)
2024.04.25 16:21:01 INFO  time: compiled bestgame in 81ms
2024.04.25 16:21:04 INFO  compiling bestgame (1 scala source)
2024.04.25 16:21:04 INFO  time: compiled bestgame in 96ms
2024.04.25 16:21:09 INFO  compiling bestgame (1 scala source)
2024.04.25 16:21:09 INFO  time: compiled bestgame in 0.26s
2024.04.25 16:21:13 INFO  compiling bestgame (1 scala source)
2024.04.25 16:21:13 INFO  time: compiled bestgame in 89ms
2024.04.25 16:21:33 INFO  compiling bestgame (1 scala source)
2024.04.25 16:21:33 INFO  time: compiled bestgame in 0.15s
2024.04.25 16:21:51 INFO  compiling bestgame (1 scala source)
2024.04.25 16:21:51 INFO  time: compiled bestgame in 0.32s
2024.04.25 16:22:43 INFO  compiling bestgame (1 scala source)
2024.04.25 16:22:43 INFO  time: compiled bestgame in 0.36s
2024.04.25 16:23:03 INFO  compiling bestgame (1 scala source)
2024.04.25 16:23:03 INFO  time: compiled bestgame in 0.32s
2024.04.25 16:23:08 INFO  compiling bestgame (1 scala source)
2024.04.25 16:23:08 INFO  time: compiled bestgame in 0.14s
2024.04.25 16:23:13 INFO  compiling bestgame (1 scala source)
2024.04.25 16:23:13 INFO  time: compiled bestgame in 0.1s
2024.04.25 16:23:34 INFO  compiling bestgame (1 scala source)
2024.04.25 16:23:34 INFO  time: compiled bestgame in 0.33s
2024.04.25 16:23:37 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
scala.meta.tokenizers.TokenizeException: <input>:16: error: unclosed string literal
    plant <- String(bytes, "UTF-8.flatMap(_.fromJson[Plant])
                           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:560)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:379)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 16:23:37 INFO  compiling bestgame (1 scala source)
2024.04.25 16:23:37 INFO  time: compiled bestgame in 0.39s
2024.04.25 16:23:38 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
scala.meta.tokenizers.TokenizeException: <input>:16: error: unclosed string literal
    plant <- String(bytes, "UTF-8.flatMap(_.fromJson[Plant])
                           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:560)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:379)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 16:23:38 INFO  compiling bestgame (1 scala source)
2024.04.25 16:23:38 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
scala.meta.tokenizers.TokenizeException: <input>:16: error: unclosed string literal
    plant <- String(bytes, "UTF-8).flatMap(_.fromJson[Plant])
                           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:560)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:379)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 16:23:38 INFO  time: compiled bestgame in 0.42s
2024.04.25 16:23:39 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
scala.meta.tokenizers.TokenizeException: <input>:16: error: unclosed string literal
    plant <- String(bytes, "UTF-8).flatMap(_.fromJson[Plant])
                           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:560)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:379)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 16:23:39 ERROR Failed to tokenize input for semantic tokens for D:\bestgame\src\main\scala\gameClasses\Seeds.scala
scala.meta.tokenizers.TokenizeException: <input>:16: error: unclosed string literal
    plant <- String(bytes, "UTF-8.flatMap(_.fromJson[Plant])
                           ^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.getStringLit(LegacyScanner.scala:560)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchDoubleQuote$1(LegacyScanner.scala:379)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:383)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:214)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:982)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:23)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:16)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:960)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:16)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:331)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.metals.SemanticTokensProvider$.getTokens(SemanticTokensProvider.scala:28)
	at scala.meta.internal.metals.SemanticTokensProvider$.provide(SemanticTokensProvider.scala:89)
	at scala.meta.internal.metals.Compilers.$anonfun$semanticTokens$3(Compilers.scala:597)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(Thread.java:1570)

2024.04.25 16:23:40 INFO  compiling bestgame (1 scala source)
2024.04.25 16:23:40 INFO  time: compiled bestgame in 0.37s
2024.04.25 16:23:45 INFO  compiling bestgame (1 scala source)
2024.04.25 16:23:45 INFO  time: compiled bestgame in 0.15s
2024.04.25 16:26:10 INFO  compiling bestgame (1 scala source)
2024.04.25 16:26:10 INFO  time: compiled bestgame in 0.15s
2024.04.25 16:26:36 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1570)
```

Π°ΠΏΡ€. 25, 2024 4:26:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/nio/file/Files.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2007, 2023, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.nio.file;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.UncheckedIOException;\nimport java.io.Writer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.attribute.BasicFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.attribute.DosFileAttributes;   // javadoc\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.FileAttributeView;\nimport java.nio.file.attribute.FileOwnerAttributeView;\nimport java.nio.file.attribute.FileStoreAttributeView;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributeView;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.UserPrincipal;\nimport java.nio.file.spi.FileSystemProvider;\nimport java.nio.file.spi.FileTypeDetector;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.ServiceLoader;\nimport java.util.Set;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.function.BiPredicate;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.util.ArraysSupport;\nimport sun.nio.ch.FileChannelImpl;\nimport sun.nio.cs.UTF_8;\n\n/**\n * This class consists exclusively of static methods that operate on files,\n * directories, or other types of files.\n *\n * \u003cp\u003e In most cases, the methods defined here will delegate to the associated\n * file system provider to perform the file operations.\n *\n * @since 1.7\n */\n\npublic final class Files {\n    // buffer size used for reading and writing\n    private static final int BUFFER_SIZE \u003d 8192;\n\n    private Files() { }\n\n    /**\n     * Returns the {@code FileSystemProvider} to delegate to.\n     */\n    private static FileSystemProvider provider(Path path) {\n        return path.getFileSystem().provider();\n    }\n\n    /**\n     * Convert a Closeable to a Runnable by converting checked IOException\n     * to UncheckedIOException\n     */\n    private static Runnable asUncheckedRunnable(Closeable c) {\n        return () -\u003e {\n            try {\n                c.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n    }\n\n    // -- File contents --\n\n    /**\n     * Opens a file, returning an input stream to read from the file. The stream\n     * will not be buffered, and is not required to support the {@link\n     * InputStream#mark mark} or {@link InputStream#reset reset} methods. The\n     * stream will be safe for access by multiple concurrent threads. Reading\n     * commences at the beginning of the file. Whether the returned stream is\n     * \u003ci\u003easynchronously closeable\u003c/i\u003e and/or \u003ci\u003einterruptible\u003c/i\u003e is highly\n     * file system provider specific and therefore not specified.\n     *\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\n     * If no options are present then it is equivalent to opening the file with\n     * the {@link StandardOpenOption#READ READ} option. In addition to the {@code\n     * READ} option, an implementation may also support additional implementation\n     * specific options.\n     *\n     * @param   path\n     *          the path to the file to open\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new input stream\n     *\n     * @throws  IllegalArgumentException\n     *          if an invalid combination of options is specified\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static InputStream newInputStream(Path path, OpenOption... options)\n        throws IOException\n    {\n        return provider(path).newInputStream(path, options);\n    }\n\n    /**\n     * Opens or creates a file, returning an output stream that may be used to\n     * write bytes to the file. The resulting stream will not be buffered. The\n     * stream will be safe for access by multiple concurrent threads. Whether\n     * the returned stream is \u003ci\u003easynchronously closeable\u003c/i\u003e and/or\n     * \u003ci\u003einterruptible\u003c/i\u003e is highly file system provider specific and\n     * therefore not specified.\n     *\n     * \u003cp\u003e This method opens or creates a file in exactly the manner specified\n     * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\n     * method with the exception that the {@link StandardOpenOption#READ READ}\n     * option may not be present in the array of options. If no options are\n     * present then this method works as if the {@link StandardOpenOption#CREATE\n     * CREATE}, {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING},\n     * and {@link StandardOpenOption#WRITE WRITE} options are present. In other\n     * words, it opens the file for writing, creating the file if it doesn\u0027t\n     * exist, or initially truncating an existing {@link #isRegularFile\n     * regular-file} to a size of {@code 0} if it exists.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *\n     *     // truncate and overwrite an existing file, or create the file if\n     *     // it doesn\u0027t initially exist\n     *     OutputStream out \u003d Files.newOutputStream(path);\n     *\n     *     // append to an existing file, fail if the file does not exist\n     *     out \u003d Files.newOutputStream(path, APPEND);\n     *\n     *     // append to an existing file, create file if it doesn\u0027t initially exist\n     *     out \u003d Files.newOutputStream(path, CREATE, APPEND);\n     *\n     *     // always create new file, failing if it already exists\n     *     out \u003d Files.newOutputStream(path, CREATE_NEW);\n     * }\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new output stream\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static OutputStream newOutputStream(Path path, OpenOption... options)\n        throws IOException\n    {\n        return provider(path).newOutputStream(path, options);\n    }\n\n    /**\n     * Opens or creates a file, returning a seekable byte channel to access the\n     * file.\n     *\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\n     * The {@link StandardOpenOption#READ READ} and {@link\n     * StandardOpenOption#WRITE WRITE} options determine if the file should be\n     * opened for reading and/or writing. If neither option (or the {@link\n     * StandardOpenOption#APPEND APPEND} option) is present then the file is\n     * opened for reading. By default reading or writing commence at the\n     * beginning of the file.\n     *\n     * \u003cp\u003e In the addition to {@code READ} and {@code WRITE}, the following\n     * options may be present:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#APPEND APPEND} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then the file is opened for writing and\n     *     each invocation of the channel\u0027s {@code write} method first advances\n     *     the position to the end of the file and then writes the requested\n     *     data. Whether the advancement of the position and the writing of the\n     *     data are done in a single atomic operation is system-dependent and\n     *     therefore unspecified. This option may not be used in conjunction\n     *     with the {@code READ} or {@code TRUNCATE_EXISTING} options. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then the existing file is truncated to\n     *   a size of 0 bytes. This option is ignored when the file is opened only\n     *   for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#CREATE_NEW CREATE_NEW} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then a new file is created, failing if\n     *   the file already exists or is a symbolic link. When creating a file the\n     *   check for the existence of the file and the creation of the file if it\n     *   does not exist is atomic with respect to other file system operations.\n     *   This option is ignored when the file is opened only for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\" \u003e {@link StandardOpenOption#CREATE CREATE} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then an existing file is opened if it\n     *   exists, otherwise a new file is created. This option is ignored if the\n     *   {@code CREATE_NEW} option is also present or the file is opened only\n     *   for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\" \u003e {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} \u003c/th\u003e\n     *   \u003ctd\u003e When this option is present then the implementation makes a\n     *   \u003cem\u003ebest effort\u003c/em\u003e attempt to delete the file when closed by the\n     *   {@link SeekableByteChannel#close close} method. If the {@code close}\n     *   method is not invoked then a \u003cem\u003ebest effort\u003c/em\u003e attempt is made to\n     *   delete the file when the Java virtual machine terminates. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e{@link StandardOpenOption#SPARSE SPARSE} \u003c/th\u003e\n     *   \u003ctd\u003e When creating a new file this option is a \u003cem\u003ehint\u003c/em\u003e that the\n     *   new file will be sparse. This option is ignored when not creating\n     *   a new file. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#SYNC SYNC} \u003c/th\u003e\n     *   \u003ctd\u003e Requires that every update to the file\u0027s content or metadata be\n     *   written synchronously to the underlying storage device. (see \u003ca\n     *   href\u003d\"package-summary.html#integrity\"\u003e Synchronized I/O file\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#DSYNC DSYNC} \u003c/th\u003e\n     *   \u003ctd\u003e Requires that every update to the file\u0027s content be written\n     *   synchronously to the underlying storage device. (see \u003ca\n     *   href\u003d\"package-summary.html#integrity\"\u003e Synchronized I/O file\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation may also support additional implementation specific\n     * options.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when a new file is created.\n     *\n     * \u003cp\u003e In the case of the default provider, the returned seekable byte channel\n     * is a {@link java.nio.channels.FileChannel}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *\n     *     // open file for reading\n     *     ReadableByteChannel rbc \u003d Files.newByteChannel(path, EnumSet.of(READ)));\n     *\n     *     // open file for writing to the end of an existing file, creating\n     *     // the file if it doesn\u0027t already exist\n     *     WritableByteChannel wbc \u003d Files.newByteChannel(path, EnumSet.of(CREATE,APPEND));\n     *\n     *     // create file with initial permissions, opening it for both reading and writing\n     *     FileAttribute\u003cSet\u003cPosixFilePermission\u003e\u003e perms \u003d ...\n     *     SeekableByteChannel sbc \u003d\n     *         Files.newByteChannel(path, EnumSet.of(CREATE_NEW,READ,WRITE), perms);\n     * }\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  a new seekable byte channel\n     *\n     * @throws  IllegalArgumentException\n     *          if the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported open option is specified or the array contains\n     *          attributes that cannot be set atomically when creating the file\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          and the file is being opened for writing \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the path if the file is\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method is invoked to check write access to the path\n     *          if the file is opened for writing. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see java.nio.channels.FileChannel#open(Path,Set,FileAttribute[])\n     */\n    public static SeekableByteChannel newByteChannel(Path path,\n                                                     Set\u003c? extends OpenOption\u003e options,\n                                                     FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return provider(path).newByteChannel(path, options, attrs);\n    }\n\n    /**\n     * Opens or creates a file, returning a seekable byte channel to access the\n     * file.\n     *\n     * \u003cp\u003e This method opens or creates a file in exactly the manner specified\n     * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\n     * method.\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new seekable byte channel\n     *\n     * @throws  IllegalArgumentException\n     *          if the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported open option is specified\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          and the file is being opened for writing \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the path if the file is\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method is invoked to check write access to the path\n     *          if the file is opened for writing. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see java.nio.channels.FileChannel#open(Path,OpenOption[])\n     */\n    public static SeekableByteChannel newByteChannel(Path path, OpenOption... options)\n        throws IOException\n    {\n        Set\u003cOpenOption\u003e set;\n        if (options.length \u003d\u003d 0) {\n            set \u003d Collections.emptySet();\n        } else {\n            set \u003d new HashSet\u003c\u003e();\n            Collections.addAll(set, options);\n        }\n        return newByteChannel(path, set);\n    }\n\n    // -- Directories --\n\n    private static class AcceptAllFilter\n        implements DirectoryStream.Filter\u003cPath\u003e\n    {\n        private AcceptAllFilter() { }\n\n        @Override\n        public boolean accept(Path entry) { return true; }\n\n        static final AcceptAllFilter FILTER \u003d new AcceptAllFilter();\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * all entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * @param   dir\n     *          the path to the directory\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir)\n        throws IOException\n    {\n        return provider(dir).newDirectoryStream(dir, AcceptAllFilter.FILTER);\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * the entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}. The entries returned by\n     * the iterator are filtered by matching the {@code String} representation\n     * of their file names against the given \u003cem\u003eglobbing\u003c/em\u003e pattern.\n     *\n     * \u003cp\u003e For example, suppose we want to iterate over the files ending with\n     * \".java\" in a directory:\n     * {@snippet lang\u003djava :\n     *     Path dir \u003d ...\n     *     try (DirectoryStream\u003cPath\u003e stream \u003d Files.newDirectoryStream(dir, \"*.java\")) {\n     *         :\n     *     }\n     * }\n     *\n     * \u003cp\u003e The globbing pattern is specified by the {@link\n     * FileSystem#getPathMatcher getPathMatcher} method.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * @param   dir\n     *          the path to the directory\n     * @param   glob\n     *          the glob pattern\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  java.util.regex.PatternSyntaxException\n     *          if the pattern is invalid\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, String glob)\n        throws IOException\n    {\n        // avoid creating a matcher if all entries are required.\n        if (glob.equals(\"*\"))\n            return newDirectoryStream(dir);\n\n        // create a matcher and return a filter that uses it.\n        FileSystem fs \u003d dir.getFileSystem();\n        final PathMatcher matcher \u003d fs.getPathMatcher(\"glob:\" + glob);\n        DirectoryStream.Filter\u003cPath\u003e filter \u003d new DirectoryStream.Filter\u003c\u003e() {\n            @Override\n            public boolean accept(Path entry)  {\n                return matcher.matches(entry.getFileName());\n            }\n        };\n        return fs.provider().newDirectoryStream(dir, filter);\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * the entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}. The entries returned by\n     * the iterator are filtered by the given {@link DirectoryStream.Filter\n     * filter}.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e Where the filter terminates due to an uncaught error or runtime\n     * exception then it is propagated to the {@link Iterator#hasNext()\n     * hasNext} or {@link Iterator#next() next} method. Where an {@code\n     * IOException} is thrown, it results in the {@code hasNext} or {@code\n     * next} method throwing a {@link DirectoryIteratorException} with the\n     * {@code IOException} as the cause.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to iterate over the files in a directory that are\n     * larger than 8K.\n     * {@snippet lang\u003djava :\n     *     DirectoryStream.Filter\u003cPath\u003e filter \u003d new DirectoryStream.Filter\u003cPath\u003e() {\n     *         public boolean accept(Path file) throws IOException {\n     *             return (Files.size(file) \u003e 8192L);\n     *         }\n     *     };\n     *     Path dir \u003d ...\n     *     try (DirectoryStream\u003cPath\u003e stream \u003d Files.newDirectoryStream(dir, filter)) {\n     *         :\n     *     }\n     * }\n     *\n     * @param   dir\n     *          the path to the directory\n     * @param   filter\n     *          the directory stream filter\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir,\n                                                           DirectoryStream.Filter\u003c? super Path\u003e filter)\n        throws IOException\n    {\n        return provider(dir).newDirectoryStream(dir, filter);\n    }\n\n    // -- Creation and deletion --\n\n    private static final Set\u003cOpenOption\u003e DEFAULT_CREATE_OPTIONS \u003d\n        Set.of(StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE);\n\n    /**\n     * Creates a new and empty file, failing if the file already exists. The\n     * check for the existence of the file and the creation of the new file if\n     * it does not exist are a single operation that is atomic with respect to\n     * all other filesystem activities that might affect the directory.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the file. Each attribute\n     * is identified by its {@link FileAttribute#name name}. If more than one\n     * attribute of the same name is included in the array then all but the last\n     * occurrence is ignored.\n     *\n     * @param   path\n     *          the path to the file to create\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the file\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs or the parent directory does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the new file.\n     */\n    public static Path createFile(Path path, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        newByteChannel(path, DEFAULT_CREATE_OPTIONS, attrs).close();\n        return path;\n    }\n\n    /**\n     * Creates a new directory. The check for the existence of the file and the\n     * creation of the directory if it does not exist are a single operation\n     * that is atomic with respect to all other filesystem activities that might\n     * affect the directory. The {@link #createDirectories createDirectories}\n     * method should be used where it is required to create all nonexistent\n     * parent directories first.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the directory. Each\n     * attribute is identified by its {@link FileAttribute#name name}. If more\n     * than one attribute of the same name is included in the array then all but\n     * the last occurrence is ignored.\n     *\n     * @param   dir\n     *          the directory to create\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the directory\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  FileAlreadyExistsException\n     *          if a directory could not otherwise be created because a file of\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs or the parent directory does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the new directory.\n     */\n    public static Path createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        provider(dir).createDirectory(dir, attrs);\n        return dir;\n    }\n\n    /**\n     * Creates a directory by creating all nonexistent parent directories first.\n     * Unlike the {@link #createDirectory createDirectory} method, an exception\n     * is not thrown if the directory could not be created because it already\n     * exists.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the nonexistent\n     * directories. Each file attribute is identified by its {@link\n     * FileAttribute#name name}. If more than one attribute of the same name is\n     * included in the array then all but the last occurrence is ignored.\n     *\n     * \u003cp\u003e If this method fails, then it may do so after creating some, but not\n     * all, of the parent directories.\n     *\n     * @param   dir\n     *          the directory to create\n     *\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the directory\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  FileAlreadyExistsException\n     *          if {@code dir} exists but is not a directory \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          in the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked prior to attempting to create a directory and\n     *          its {@link SecurityManager#checkRead(String) checkRead} is\n     *          invoked for each parent directory that is checked. If {@code\n     *          dir} is not an absolute path then its {@link Path#toAbsolutePath\n     *          toAbsolutePath} may need to be invoked to get its absolute path.\n     *          This may invoke the security manager\u0027s {@link\n     *          SecurityManager#checkPropertyAccess(String) checkPropertyAccess}\n     *          method to check access to the system property {@code user.dir}\n     */\n    public static Path createDirectories(Path dir, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        // attempt to create the directory\n        try {\n            createAndCheckIsDirectory(dir, attrs);\n            return dir;\n        } catch (FileAlreadyExistsException x) {\n            // file exists and is not a directory\n            throw x;\n        } catch (IOException x) {\n            // parent may not exist or other reason\n        }\n        SecurityException se \u003d null;\n        Path absDir \u003d dir;\n        try {\n            absDir \u003d dir.toAbsolutePath();\n        } catch (SecurityException x) {\n            // don\u0027t have permission to get absolute path\n            se \u003d x;\n        }\n        // find a descendant that exists\n        Path parent \u003d absDir.getParent();\n        while (parent !\u003d null) {\n            try {\n                provider(parent).checkAccess(parent);\n                break;\n            } catch (NoSuchFileException x) {\n                // does not exist\n            }\n            parent \u003d parent.getParent();\n        }\n        if (parent \u003d\u003d null) {\n            // unable to find existing parent\n            if (se \u003d\u003d null) {\n                throw new FileSystemException(absDir.toString(), null,\n                    \"Unable to determine if root directory exists\");\n            } else {\n                throw se;\n            }\n        }\n\n        // create directories\n        Path child \u003d parent;\n        for (Path name: parent.relativize(absDir)) {\n            child \u003d child.resolve(name);\n            createAndCheckIsDirectory(child, attrs);\n        }\n        return dir;\n    }\n\n    /**\n     * Used by createDirectories to attempt to create a directory. A no-op\n     * if the directory already exists.\n     */\n    private static void createAndCheckIsDirectory(Path dir,\n                                                  FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        try {\n            createDirectory(dir, attrs);\n        } catch (FileAlreadyExistsException x) {\n            if (!isDirectory(dir))\n                throw x;\n        }\n    }\n\n    /**\n     * Creates a new empty file in the specified directory, using the given\n     * prefix and suffix strings to generate its name. The resulting\n     * {@code Path} is associated with the same {@code FileSystem} as the given\n     * directory.\n     *\n     * \u003cp\u003e The details as to how the name of the file is constructed is\n     * implementation dependent and therefore not specified. Where possible\n     * the {@code prefix} and {@code suffix} are used to construct candidate\n     * names in the same manner as the {@link\n     * java.io.File#createTempFile(String,String,File)} method.\n     *\n     * \u003cp\u003e As with the {@code File.createTempFile} methods, this method is only\n     * part of a temporary-file facility. Where used as a \u003cem\u003ework file\u003c/em\u003e,\n     * the resulting file may be opened using the {@link\n     * StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} option so that the\n     * file is deleted when the appropriate {@code close} method is invoked.\n     * Alternatively, a {@link Runtime#addShutdownHook shutdown-hook}, or the\n     * {@link java.io.File#deleteOnExit} mechanism may be used to delete the\n     * file automatically.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the file. Each attribute\n     * is identified by its {@link FileAttribute#name name}. If more than one\n     * attribute of the same name is included in the array then all but the last\n     * occurrence is ignored. When no file attributes are specified, then the\n     * resulting file may have more restrictive access permissions to files\n     * created by the {@link java.io.File#createTempFile(String,String,File)}\n     * method.\n     *\n     * @param   dir\n     *          the path to directory in which to create the file\n     * @param   prefix\n     *          the prefix string to be used in generating the file\u0027s name;\n     *          may be {@code null}\n     * @param   suffix\n     *          the suffix string to be used in generating the file\u0027s name;\n     *          may be {@code null}, in which case \"{@code .tmp}\" is used\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the path to the newly created file that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix or suffix parameters cannot be used to generate\n     *          a candidate file name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or {@code dir} does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file.\n     */\n    public static Path createTempFile(Path dir,\n                                      String prefix,\n                                      String suffix,\n                                      FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempFile(Objects.requireNonNull(dir),\n                                             prefix, suffix, attrs);\n    }\n\n    /**\n     * Creates an empty file in the default temporary-file directory, using\n     * the given prefix and suffix to generate its name. The resulting {@code\n     * Path} is associated with the default {@code FileSystem}.\n     *\n     * \u003cp\u003e This method works in exactly the manner specified by the\n     * {@link #createTempFile(Path,String,String,FileAttribute[])} method for\n     * the case that the {@code dir} parameter is the temporary-file directory.\n     *\n     * @param   prefix\n     *          the prefix string to be used in generating the file\u0027s name;\n     *          may be {@code null}\n     * @param   suffix\n     *          the suffix string to be used in generating the file\u0027s name;\n     *          may be {@code null}, in which case \"{@code .tmp}\" is used\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the path to the newly created file that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix or suffix parameters cannot be used to generate\n     *          a candidate file name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or the temporary-file directory does not\n     *          exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file.\n     */\n    public static Path createTempFile(String prefix,\n                                      String suffix,\n                                      FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempFile(null, prefix, suffix, attrs);\n    }\n\n    /**\n     * Creates a new directory in the specified directory, using the given\n     * prefix to generate its name.  The resulting {@code Path} is associated\n     * with the same {@code FileSystem} as the given directory.\n     *\n     * \u003cp\u003e The details as to how the name of the directory is constructed is\n     * implementation dependent and therefore not specified. Where possible\n     * the {@code prefix} is used to construct candidate names.\n     *\n     * \u003cp\u003e As with the {@code createTempFile} methods, this method is only\n     * part of a temporary-file facility. A {@link Runtime#addShutdownHook\n     * shutdown-hook}, or the {@link java.io.File#deleteOnExit} mechanism may be\n     * used to delete the directory automatically.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the directory. Each\n     * attribute is identified by its {@link FileAttribute#name name}. If more\n     * than one attribute of the same name is included in the array then all but\n     * the last occurrence is ignored.\n     *\n     * @param   dir\n     *          the path to directory in which to create the directory\n     * @param   prefix\n     *          the prefix string to be used in generating the directory\u0027s name;\n     *          may be {@code null}\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the path to the newly created directory that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix cannot be used to generate a candidate directory name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or {@code dir} does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access when creating the\n     *          directory.\n     */\n    public static Path createTempDirectory(Path dir,\n                                           String prefix,\n                                           FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempDirectory(Objects.requireNonNull(dir),\n                                                  prefix, attrs);\n    }\n\n    /**\n     * Creates a new directory in the default temporary-file directory, using\n     * the given prefix to generate its name. The resulting {@code Path} is\n     * associated with the default {@code FileSystem}.\n     *\n     * \u003cp\u003e This method works in exactly the manner specified by {@link\n     * #createTempDirectory(Path,String,FileAttribute[])} method for the case\n     * that the {@code dir} parameter is the temporary-file directory.\n     *\n     * @param   prefix\n     *          the prefix string to be used in generating the directory\u0027s name;\n     *          may be {@code null}\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the path to the newly created directory that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix cannot be used to generate a candidate directory name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or the temporary-file directory does not\n     *          exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access when creating the\n     *          directory.\n     */\n    public static Path createTempDirectory(String prefix,\n                                           FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempDirectory(null, prefix, attrs);\n    }\n\n    /**\n     * Creates a symbolic link to a target \u003ci\u003e(optional operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e The {@code target} parameter is the target of the link. It may be an\n     * {@link Path#isAbsolute absolute} or relative path and may not exist. When\n     * the target is a relative path then file system operations on the resulting\n     * link are relative to the path of the link.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * attributes} to set atomically when creating the link. Each attribute is\n     * identified by its {@link FileAttribute#name name}. If more than one attribute\n     * of the same name is included in the array then all but the last occurrence\n     * is ignored.\n     *\n     * \u003cp\u003e Where symbolic links are supported, but the underlying {@link FileStore}\n     * does not support symbolic links, then this may fail with an {@link\n     * IOException}. Additionally, some operating systems may require that the\n     * Java virtual machine be started with implementation specific privileges to\n     * create symbolic links, in which case this method may throw {@code IOException}.\n     *\n     * @param   link\n     *          the path of the symbolic link to create\n     * @param   target\n     *          the target of the symbolic link\n     * @param   attrs\n     *          the array of attributes to set atomically when creating the\n     *          symbolic link\n     *\n     * @return  the path to the symbolic link\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support symbolic links or the\n     *          array contains an attribute that cannot be set atomically when\n     *          creating the symbolic link\n     * @throws  FileAlreadyExistsException\n     *          if a file with the name already exists \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it denies {@link LinkPermission}{@code (\"symbolic\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the path of the symbolic link.\n     */\n    public static Path createSymbolicLink(Path link, Path target,\n                                          FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        provider(link).createSymbolicLink(link, target, attrs);\n        return link;\n    }\n\n    /**\n     * Creates a new link (directory entry) for an existing file \u003ci\u003e(optional\n     * operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e The {@code link} parameter locates the directory entry to create.\n     * The {@code existing} parameter is the path to an existing file. This\n     * method creates a new directory entry for the file so that it can be\n     * accessed using {@code link} as the path. On some file systems this is\n     * known as creating a \"hard link\". Whether the file attributes are\n     * maintained for the file or for each directory entry is file system\n     * specific and therefore not specified. Typically, a file system requires\n     * that all links (directory entries) for a file be on the same file system.\n     * Furthermore, on some platforms, the Java virtual machine may require to\n     * be started with implementation specific privileges to create hard links\n     * or to create links to directories.\n     *\n     * @param   link\n     *          the link (directory entry) to create\n     * @param   existing\n     *          a path to an existing file\n     *\n     * @return  the path to the link (directory entry)\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support adding an existing file\n     *          to a directory\n     * @throws  FileAlreadyExistsException\n     *          if the entry could not otherwise be created because a file of\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it denies {@link LinkPermission}{@code (\"hard\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to either the link or the\n     *          existing file.\n     */\n    public static Path createLink(Path link, Path existing) throws IOException {\n        provider(link).createLink(link, existing);\n        return link;\n    }\n\n    /**\n     * Deletes a file.\n     *\n     * \u003cp\u003e An implementation may require to examine the file to determine if the\n     * file is a directory. Consequently this method may not be atomic with respect\n     * to other file system operations.  If the file is a symbolic link then the\n     * symbolic link itself, not the final target of the link, is deleted.\n     *\n     * \u003cp\u003e If the file is a directory then the directory must be empty. In some\n     * implementations a directory has entries for special files or links that\n     * are created when the directory is created. In such implementations a\n     * directory is considered empty when only the special entries exist.\n     * This method can be used with the {@link #walkFileTree walkFileTree}\n     * method to delete a directory and all entries in the directory, or an\n     * entire \u003ci\u003efile-tree\u003c/i\u003e where required.\n     *\n     * \u003cp\u003e On some operating systems it may not be possible to remove a file when\n     * it is open and in use by this Java virtual machine or other programs.\n     *\n     * @param   path\n     *          the path to the file to delete\n     *\n     * @throws  NoSuchFileException\n     *          if the file does not exist \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          if the file is a directory and could not otherwise be deleted\n     *          because the directory is not empty \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\n     *          is invoked to check delete access to the file\n     */\n    public static void delete(Path path) throws IOException {\n        provider(path).delete(path);\n    }\n\n    /**\n     * Deletes a file if it exists.\n     *\n     * \u003cp\u003e As with the {@link #delete(Path) delete(Path)} method, an\n     * implementation may need to examine the file to determine if the file is a\n     * directory. Consequently this method may not be atomic with respect to\n     * other file system operations.  If the file is a symbolic link, then the\n     * symbolic link itself, not the final target of the link, is deleted.\n     *\n     * \u003cp\u003e If the file is a directory then the directory must be empty. In some\n     * implementations a directory has entries for special files or links that\n     * are created when the directory is created. In such implementations a\n     * directory is considered empty when only the special entries exist.\n     *\n     * \u003cp\u003e On some operating systems it may not be possible to remove a file when\n     * it is open and in use by this Java virtual machine or other programs.\n     *\n     * @param   path\n     *          the path to the file to delete\n     *\n     * @return  {@code true} if the file was deleted by this method; {@code\n     *          false} if the file could not be deleted because it did not\n     *          exist\n     *\n     * @throws  DirectoryNotEmptyException\n     *          if the file is a directory and could not otherwise be deleted\n     *          because the directory is not empty \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\n     *          is invoked to check delete access to the file.\n     */\n    public static boolean deleteIfExists(Path path) throws IOException {\n        return provider(path).deleteIfExists(path);\n    }\n\n    // -- Copying and moving files --\n\n    /**\n     * Copy a file to a target file.\n     *\n     * \u003cp\u003e This method copies a file to the target file with the {@code\n     * options} parameter specifying how the copy is performed. By default, the\n     * copy fails if the target file already exists or is a symbolic link,\n     * except if the source and target are the {@link #isSameFile same} file, in\n     * which case the method completes without copying the file. File attributes\n     * are not required to be copied to the target file. If symbolic links are\n     * supported, and the file is a symbolic link, then the final target of the\n     * link is copied. If the file is a directory then an empty directory is\n     * created in the target location (entries in the directory are not\n     * copied). This method can be used with the {@link #walkFileTree\n     * walkFileTree} method to copy a directory and all entries in the directory,\n     * or an entire \u003ci\u003efile-tree\u003c/i\u003e where required.\n     *\n     * \u003cp\u003e The {@code options} parameter may include any of the following:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e Replace an existing file. A non-empty directory cannot be\n     *     replaced. If the target file exists and is a symbolic link, then the\n     *     symbolic link itself, not the target of the link, is replaced. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#COPY_ATTRIBUTES COPY_ATTRIBUTES} \u003c/th\u003e\n     *   \u003ctd\u003e Attempts to copy the file attributes associated with this file to\n     *     the target file. The exact file attributes that are copied is platform\n     *     and file system dependent and therefore unspecified. Minimally, the\n     *     {@link BasicFileAttributes#lastModifiedTime last-modified-time} is\n     *     copied to the target file if supported by both the source and target\n     *     file stores. Copying of file timestamps may result in precision\n     *     loss. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} \u003c/th\u003e\n     *   \u003ctd\u003e Symbolic links are not followed. If the file is a symbolic link,\n     *     then the symbolic link itself, not the target of the link, is copied.\n     *     It is implementation specific if file attributes can be copied to the\n     *     new link. In other words, the {@code COPY_ATTRIBUTES} option may be\n     *     ignored when copying a symbolic link. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation of this interface may support additional\n     * implementation specific options.\n     *\n     * \u003cp\u003e Copying a file is not an atomic operation. If an {@link IOException}\n     * is thrown, then it is possible that the target file is incomplete or some\n     * of its file attributes have not been copied from the source file. When\n     * the {@code REPLACE_EXISTING} option is specified and the target file\n     * exists, then the target file is replaced. The check for the existence of\n     * the file and the creation of the new file may not be atomic with respect\n     * to other file system activities.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to copy a file into a directory, giving it the same file\n     * name as the source file:\n     * {@snippet lang\u003djava :\n     *     Path source \u003d ...\n     *     Path newdir \u003d ...\n     *     Files.copy(source, newdir.resolve(source.getFileName());\n     * }\n     *\n     * @param   source\n     *          the path to the file to copy\n     * @param   target\n     *          the path to the target file (may be associated with a different\n     *          provider to the source path)\n     * @param   options\n     *          options specifying how the copy should be done\n     *\n     * @return  the path to the target file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains a copy option that is not supported\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the source file, the\n     *          {@link SecurityManager#checkWrite(String) checkWrite} is invoked\n     *          to check write access to the target file. If a symbolic link is\n     *          copied the security manager is invoked to check {@link\n     *          LinkPermission}{@code (\"symbolic\")}.\n     */\n    public static Path copy(Path source, Path target, CopyOption... options)\n        throws IOException\n    {\n        FileSystemProvider provider \u003d provider(source);\n        if (provider(target) \u003d\u003d provider) {\n            // same provider\n            provider.copy(source, target, options);\n        } else {\n            // different providers\n            CopyMoveHelper.copyToForeignTarget(source, target, options);\n        }\n        return target;\n    }\n\n    /**\n     * Move or rename a file to a target file.\n     *\n     * \u003cp\u003e By default, this method attempts to move the file to the target\n     * file, failing if the target file exists except if the source and\n     * target are the {@link #isSameFile same} file, in which case this method\n     * has no effect. If the file is a symbolic link then the symbolic link\n     * itself, not the target of the link, is moved. This method may be\n     * invoked to move an empty directory. In some implementations a directory\n     * has entries for special files or links that are created when the\n     * directory is created. In such implementations a directory is considered\n     * empty when only the special entries exist. When invoked to move a\n     * directory that is not empty then the directory is moved if it does not\n     * require moving the entries in the directory.  For example, renaming a\n     * directory on the same {@link FileStore} will usually not require moving\n     * the entries in the directory. When moving a directory requires that its\n     * entries be moved then this method fails (by throwing an {@code\n     * IOException}). To move a \u003ci\u003efile tree\u003c/i\u003e may involve copying rather\n     * than moving directories and this can be done using the {@link\n     * #copy copy} method in conjunction with the {@link\n     * #walkFileTree Files.walkFileTree} utility method.\n     *\n     * \u003cp\u003e The {@code options} parameter may include any of the following:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e Replace an existing file. A non-empty directory cannot be\n     *     replaced. If the target file exists and is a symbolic link, then the\n     *     symbolic link itself, not the target of the link, is replaced. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#ATOMIC_MOVE ATOMIC_MOVE} \u003c/th\u003e\n     *   \u003ctd\u003e The move is performed as an atomic file system operation and all\n     *     other options are ignored. If the target file exists then it is\n     *     implementation specific if the existing file is replaced or this method\n     *     fails by throwing an {@link IOException}. If the move cannot be\n     *     performed as an atomic file system operation then {@link\n     *     AtomicMoveNotSupportedException} is thrown. This can arise, for\n     *     example, when the target location is on a different {@code FileStore}\n     *     and would require that the file be copied, or target location is\n     *     associated with a different provider to this object. \u003c/td\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation of this interface may support additional\n     * implementation specific options.\n     *\n     * \u003cp\u003e Moving a file will copy the {@link\n     * BasicFileAttributes#lastModifiedTime last-modified-time} to the target\n     * file if supported by both source and target file stores. Copying of file\n     * timestamps may result in precision loss. An implementation may also\n     * attempt to copy other file attributes but is not required to fail if the\n     * file attributes cannot be copied. When the move is performed as\n     * a non-atomic operation, and an {@code IOException} is thrown, then the\n     * state of the files is not defined. The original file and the target file\n     * may both exist, the target file may be incomplete or some of its file\n     * attributes may not been copied from the original file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * Suppose we want to rename a file to \"newname\", keeping the file in the\n     * same directory:\n     * {@snippet lang\u003djava :\n     *     Path source \u003d ...\n     *     Files.move(source, source.resolveSibling(\"newname\"));\n     * }\n     * Alternatively, suppose we want to move a file to new directory, keeping\n     * the same file name, and replacing any existing file of that name in the\n     * directory:\n     * {@snippet lang\u003djava :\n     *     Path source \u003d ...\n     *     Path newdir \u003d ...\n     *     Files.move(source, newdir.resolve(source.getFileName()), REPLACE_EXISTING);\n     * }\n     *\n     * @param   source\n     *          the path to the file to move\n     * @param   target\n     *          the path to the target file (may be associated with a different\n     *          provider to the source path)\n     * @param   options\n     *          options specifying how the move should be done\n     *\n     * @return  the path to the target file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains a copy option that is not supported\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory, or the\n     *          source is a non-empty directory containing entries that would\n     *          be required to be moved \u003ci\u003e(optional specific exceptions)\u003c/i\u003e\n     * @throws  AtomicMoveNotSupportedException\n     *          if the options array contains the {@code ATOMIC_MOVE} option but\n     *          the file cannot be moved as an atomic file system operation.\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to both the source and\n     *          target file.\n     */\n    public static Path move(Path source, Path target, CopyOption... options)\n        throws IOException\n    {\n        FileSystemProvider provider \u003d provider(source);\n        if (provider(target) \u003d\u003d provider) {\n            // same provider\n            provider.move(source, target, options);\n        } else {\n            // different providers\n            CopyMoveHelper.moveToForeignTarget(source, target, options);\n        }\n        return target;\n    }\n\n    // -- Miscellaneous --\n\n    /**\n     * Reads the target of a symbolic link \u003ci\u003e(optional operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e If the file system supports \u003ca href\u003d\"package-summary.html#links\"\u003esymbolic\n     * links\u003c/a\u003e then this method is used to read the target of the link, failing\n     * if the file is not a symbolic link. The target of the link need not exist.\n     * The returned {@code Path} object will be associated with the same file\n     * system as {@code link}.\n     *\n     * @param   link\n     *          the path to the symbolic link\n     *\n     * @return  a {@code Path} object representing the target of the link\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support symbolic links\n     * @throws  NotLinkException\n     *          if the target could otherwise not be read because the file\n     *          is not a symbolic link \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it checks that {@code FilePermission} has been\n     *          granted with the \"{@code readlink}\" action to read the link.\n     */\n    public static Path readSymbolicLink(Path link) throws IOException {\n        return provider(link).readSymbolicLink(link);\n    }\n\n    /**\n     * Returns the {@link FileStore} representing the file store where a file\n     * is located.\n     *\n     * \u003cp\u003e Once a reference to the {@code FileStore} is obtained it is\n     * implementation specific if operations on the returned {@code FileStore},\n     * or {@link FileStoreAttributeView} objects obtained from it, continue\n     * to depend on the existence of the file. In particular the behavior is not\n     * defined for the case that the file is deleted or moved to a different\n     * file store.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the file store where the file is stored\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file, and in\n     *          addition it checks\n     *          {@link RuntimePermission}{@code (\"getFileStoreAttributes\")}\n     */\n    public static FileStore getFileStore(Path path) throws IOException {\n        return provider(path).getFileStore(path);\n    }\n\n    /**\n     * Tests if two paths locate the same file.\n     *\n     * \u003cp\u003e If both {@code Path} objects are {@link Path#equals(Object) equal}\n     * then this method returns {@code true} without checking if the file exists.\n     * If the two {@code Path} objects are associated with different providers\n     * then this method returns {@code false}. Otherwise, this method checks if\n     * both {@code Path} objects locate the same file, and depending on the\n     * implementation, may require to open or access both files.\n     *\n     * \u003cp\u003e If the file system and files remain static, then this method implements\n     * an equivalence relation for non-null {@code Paths}.\n     * \u003cul\u003e\n     * \u003cli\u003eIt is \u003ci\u003ereflexive\u003c/i\u003e: for {@code Path} {@code f},\n     *     {@code isSameFile(f,f)} should return {@code true}.\n     * \u003cli\u003eIt is \u003ci\u003esymmetric\u003c/i\u003e: for two {@code Paths} {@code f} and {@code g},\n     *     {@code isSameFile(f,g)} will equal {@code isSameFile(g,f)}.\n     * \u003cli\u003eIt is \u003ci\u003etransitive\u003c/i\u003e: for three {@code Paths}\n     *     {@code f}, {@code g}, and {@code h}, if {@code isSameFile(f,g)} returns\n     *     {@code true} and {@code isSameFile(g,h)} returns {@code true}, then\n     *     {@code isSameFile(f,h)} will return {@code true}.\n     * \u003c/ul\u003e\n     *\n     * @param   path\n     *          one path to the file\n     * @param   path2\n     *          the other path\n     *\n     * @return  {@code true} if, and only if, the two paths locate the same file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to both files when the\n     *          two paths are not equal\n     *\n     * @see java.nio.file.attribute.BasicFileAttributes#fileKey\n     */\n    public static boolean isSameFile(Path path, Path path2) throws IOException {\n        return provider(path).isSameFile(path, path2);\n    }\n\n    /**\n     * Finds and returns the position of the first mismatched byte in the content\n     * of two files, or {@code -1L} if there is no mismatch. The position will be\n     * in the inclusive range of {@code 0L} up to the size (in bytes) of the\n     * smaller file.\n     *\n     * \u003cp\u003e Two files are considered to match if they satisfy one of the following\n     * conditions:\n     * \u003cul\u003e\n     * \u003cli\u003e The two paths locate the {@linkplain #isSameFile(Path, Path) same file},\n     *      even if two {@linkplain Path#equals(Object) equal} paths locate a file\n     *      that does not exist, or \u003c/li\u003e\n     * \u003cli\u003e The two files are the same size, and every byte in the first file\n     *      is identical to the corresponding byte in the second file. \u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e Otherwise there is a mismatch between the two files and the value\n     * returned by this method is:\n     * \u003cul\u003e\n     * \u003cli\u003e The position of the first mismatched byte, or \u003c/li\u003e\n     * \u003cli\u003e The size of the smaller file (in bytes) when the files are of different\n     *      sizes and every byte of the smaller file is identical to the\n     *      corresponding byte of the larger file. \u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e This method may not be atomic with respect to other file system\n     * operations. This method is always \u003ci\u003ereflexive\u003c/i\u003e (for {@code Path f},\n     * {@code mismatch(f,f)} returns {@code -1L}). If the file system and files\n     * remain static, then this method is \u003ci\u003esymmetric\u003c/i\u003e (for two {@code Paths f}\n     * and {@code g}, {@code mismatch(f,g)} will return the same value as\n     * {@code mismatch(g,f)}).\n     *\n     * \u003cp\u003e If both {@code Path} objects are equal, then this method returns\n     * {@code true} without checking if the file exists.\n     *\n     * @param   path\n     *          the path to the first file\n     * @param   path2\n     *          the path to the second file\n     *\n     * @return  the position of the first mismatch or {@code -1L} if no mismatch\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to both files when the\n     *          two paths are not equal\n     *\n     * @since 12\n     */\n    public static long mismatch(Path path, Path path2) throws IOException {\n        if (isSameFile(path, path2)) {\n            return -1;\n        }\n        byte[] buffer1 \u003d new byte[BUFFER_SIZE];\n        byte[] buffer2 \u003d new byte[BUFFER_SIZE];\n        try (InputStream in1 \u003d Files.newInputStream(path);\n             InputStream in2 \u003d Files.newInputStream(path2)) {\n            long totalRead \u003d 0;\n            while (true) {\n                int nRead1 \u003d in1.readNBytes(buffer1, 0, BUFFER_SIZE);\n                int nRead2 \u003d in2.readNBytes(buffer2, 0, BUFFER_SIZE);\n\n                int i \u003d Arrays.mismatch(buffer1, 0, nRead1, buffer2, 0, nRead2);\n                if (i \u003e -1) {\n                    return totalRead + i;\n                }\n                if (nRead1 \u003c BUFFER_SIZE) {\n                    // we\u0027ve reached the end of the files, but found no mismatch\n                    return -1;\n                }\n                totalRead +\u003d nRead1;\n            }\n        }\n    }\n\n    /**\n     * Tells whether or not a file is considered \u003cem\u003ehidden\u003c/em\u003e.\n     *\n     * @apiNote\n     * The exact definition of hidden is platform or provider dependent. On UNIX\n     * for example a file is considered to be hidden if its name begins with a\n     * period character (\u0027.\u0027). On Windows a file is considered hidden if the DOS\n     * {@link DosFileAttributes#isHidden hidden} attribute is set.\n     *\n     * \u003cp\u003e Depending on the implementation this method may require to access\n     * the file system to determine if the file is considered hidden.\n     *\n     * @param   path\n     *          the path to the file to test\n     *\n     * @return  {@code true} if the file is considered hidden\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static boolean isHidden(Path path) throws IOException {\n        return provider(path).isHidden(path);\n    }\n\n    // lazy loading of default and installed file type detectors\n    private static class FileTypeDetectors{\n        static final FileTypeDetector defaultFileTypeDetector \u003d\n            createDefaultFileTypeDetector();\n        static final List\u003cFileTypeDetector\u003e installedDetectors \u003d\n            loadInstalledDetectors();\n\n        // creates the default file type detector\n        @SuppressWarnings(\"removal\")\n        private static FileTypeDetector createDefaultFileTypeDetector() {\n            return AccessController\n                .doPrivileged(new PrivilegedAction\u003c\u003e() {\n                    @Override public FileTypeDetector run() {\n                        return sun.nio.fs.DefaultFileTypeDetector.create();\n                }});\n        }\n\n        // loads all installed file type detectors\n        @SuppressWarnings(\"removal\")\n        private static List\u003cFileTypeDetector\u003e loadInstalledDetectors() {\n            return AccessController\n                .doPrivileged(new PrivilegedAction\u003c\u003e() {\n                    @Override public List\u003cFileTypeDetector\u003e run() {\n                        List\u003cFileTypeDetector\u003e list \u003d new ArrayList\u003c\u003e();\n                        ServiceLoader\u003cFileTypeDetector\u003e loader \u003d ServiceLoader\n                            .load(FileTypeDetector.class, ClassLoader.getSystemClassLoader());\n                        for (FileTypeDetector detector: loader) {\n                            list.add(detector);\n                        }\n                        return list;\n                }});\n        }\n    }\n\n    /**\n     * Probes the content type of a file.\n     *\n     * \u003cp\u003e This method uses the installed {@link FileTypeDetector} implementations\n     * to probe the given file to determine its content type. Each file type\n     * detector\u0027s {@link FileTypeDetector#probeContentType probeContentType} is\n     * invoked, in turn, to probe the file type. If the file is recognized then\n     * the content type is returned. If the file is not recognized by any of the\n     * installed file type detectors then a system-default file type detector is\n     * invoked to guess the content type.\n     *\n     * \u003cp\u003e A given invocation of the Java virtual machine maintains a system-wide\n     * list of file type detectors. Installed file type detectors are loaded\n     * using the service-provider loading facility defined by the {@link ServiceLoader}\n     * class. Installed file type detectors are loaded using the system class\n     * loader. If the system class loader cannot be found then the platform class\n     * loader is used. File type detectors are typically installed\n     * by placing them in a JAR file on the application class path,\n     * the JAR file contains a provider-configuration file\n     * named {@code java.nio.file.spi.FileTypeDetector} in the resource directory\n     * {@code META-INF/services}, and the file lists one or more fully-qualified\n     * names of concrete subclass of {@code FileTypeDetector } that have a zero\n     * argument constructor. If the process of locating or instantiating the\n     * installed file type detectors fails then an unspecified error is thrown.\n     * The ordering that installed providers are located is implementation\n     * specific.\n     *\n     * \u003cp\u003e The return value of this method is the string form of the value of a\n     * Multipurpose Internet Mail Extension (MIME) content type as\n     * defined by \u003ca href\u003d\"http://www.ietf.org/rfc/rfc2045.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2045:\n     * Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet\n     * Message Bodies\u003c/i\u003e\u003c/a\u003e. The string is guaranteed to be parsable according\n     * to the grammar in the RFC.\n     *\n     * @param   path\n     *          the path to the file to probe\n     *\n     * @return  The content type of the file, or {@code null} if the content\n     *          type cannot be determined\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          If a security manager is installed and it denies an unspecified\n     *          permission required by a file type detector implementation.\n     *\n     * @spec https://www.rfc-editor.org/info/rfc2045\n     *      RFC 2045: Multipurpose Internet Mail Extensions (MIME) Part One:\n     *              Format of Internet Message Bodies\n     */\n    public static String probeContentType(Path path)\n        throws IOException\n    {\n        // try installed file type detectors\n        for (FileTypeDetector detector: FileTypeDetectors.installedDetectors) {\n            String result \u003d detector.probeContentType(path);\n            if (result !\u003d null)\n                return result;\n        }\n\n        // fallback to default\n        return FileTypeDetectors.defaultFileTypeDetector.probeContentType(path);\n    }\n\n    // -- File Attributes --\n\n    /**\n     * Returns a file attribute view of a given type.\n     *\n     * \u003cp\u003e A file attribute view provides a read-only or updatable view of a\n     * set of file attributes. This method is intended to be used where the file\n     * attribute view defines type-safe methods to read or update the file\n     * attributes. The {@code type} parameter is the type of the attribute view\n     * required and the method returns an instance of that type if supported.\n     * The {@link BasicFileAttributeView} type supports access to the basic\n     * attributes of a file. Invoking this method to select a file attribute\n     * view of that type will always return an instance of that class.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled by the resulting file attribute view for the case that the\n     * file is a symbolic link. By default, symbolic links are followed. If the\n     * option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} is present then\n     * symbolic links are not followed. This option is ignored by implementations\n     * that do not support symbolic links.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want read or set a file\u0027s ACL, if supported:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     AclFileAttributeView view \u003d Files.getFileAttributeView(path, AclFileAttributeView.class);\n     *     if (view !\u003d null) {\n     *         List\u003cAclEntry\u003e acl \u003d view.getAcl();\n     *         :\n     *     }\n     * }\n     *\n     * @param   \u003cV\u003e\n     *          The {@code FileAttributeView} type\n     * @param   path\n     *          the path to the file\n     * @param   type\n     *          the {@code Class} object corresponding to the file attribute view\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a file attribute view of the specified type, or {@code null} if\n     *          the attribute view type is not available\n     */\n    public static \u003cV extends FileAttributeView\u003e V getFileAttributeView(Path path,\n                                                                       Class\u003cV\u003e type,\n                                                                       LinkOption... options)\n    {\n        return provider(path).getFileAttributeView(path, type, options);\n    }\n\n    /**\n     * Reads a file\u0027s attributes as a bulk operation.\n     *\n     * \u003cp\u003e The {@code type} parameter is the type of the attributes required\n     * and this method returns an instance of that type if supported. All\n     * implementations support a basic set of file attributes and so invoking\n     * this method with a  {@code type} parameter of {@code\n     * BasicFileAttributes.class} will not throw {@code\n     * UnsupportedOperationException}.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e It is implementation specific if all file attributes are read as an\n     * atomic operation with respect to other file system operations.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to read a file\u0027s attributes in bulk:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     BasicFileAttributes attrs \u003d Files.readAttributes(path, BasicFileAttributes.class);\n     * }\n     * Alternatively, suppose we want to read file\u0027s POSIX attributes without\n     * following symbolic links:\n     * {@snippet lang\u003djava :\n     *     PosixFileAttributes attrs \u003d\n     *         Files.readAttributes(path, PosixFileAttributes.class, NOFOLLOW_LINKS);\n     * }\n     *\n     * @param   \u003cA\u003e\n     *          The {@code BasicFileAttributes} type\n     * @param   path\n     *          the path to the file\n     * @param   type\n     *          the {@code Class} of the file attributes required\n     *          to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the file attributes\n     *\n     * @throws  UnsupportedOperationException\n     *          if an attributes of the given type are not supported\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file. If this\n     *          method is invoked to read security sensitive attributes then the\n     *          security manager may be invoked to check for additional permissions.\n     */\n    public static \u003cA extends BasicFileAttributes\u003e A readAttributes(Path path,\n                                                                   Class\u003cA\u003e type,\n                                                                   LinkOption... options)\n        throws IOException\n    {\n        return provider(path).readAttributes(path, type, options);\n    }\n\n    /**\n     * Sets the value of a file attribute.\n     *\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be set\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute\n     * within the set.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is set. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to set the DOS \"hidden\" attribute:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     Files.setAttribute(path, \"dos:hidden\", true);\n     * }\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attribute\n     *          the attribute to set\n     * @param   value\n     *          the attribute value\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if the attribute name is not specified, or is not recognized, or\n     *          the attribute value is of the correct type but has an\n     *          inappropriate value\n     * @throws  ClassCastException\n     *          if the attribute value is not of the expected type or is a\n     *          collection containing elements that are not of the expected\n     *          type\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file. If this method is invoked\n     *          to set security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Path setAttribute(Path path, String attribute, Object value,\n                                    LinkOption... options)\n        throws IOException\n    {\n        provider(path).setAttribute(path, attribute, value, options);\n        return path;\n    }\n\n    /**\n     * Reads the value of a file attribute.\n     *\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be read\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we require the user ID of the file owner on a system that\n     * supports a \"{@code unix}\" view:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     int uid \u003d (Integer)Files.getAttribute(path, \"unix:uid\");\n     * }\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attribute\n     *          the attribute to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the attribute value\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if the attribute name is not specified or is not recognized\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file. If this method is invoked\n     *          to read security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Object getAttribute(Path path, String attribute,\n                                      LinkOption... options)\n        throws IOException\n    {\n        // only one attribute should be read\n        if (attribute.indexOf(\u0027*\u0027) \u003e\u003d 0 || attribute.indexOf(\u0027,\u0027) \u003e\u003d 0)\n            throw new IllegalArgumentException(attribute);\n        Map\u003cString,Object\u003e map \u003d readAttributes(path, attribute, options);\n        assert map.size() \u003d\u003d 1;\n        String name;\n        int pos \u003d attribute.indexOf(\u0027:\u0027);\n        if (pos \u003d\u003d -1) {\n            name \u003d attribute;\n        } else {\n            name \u003d (pos \u003d\u003d attribute.length()) ? \"\" : attribute.substring(pos+1);\n        }\n        return map.get(name);\n    }\n\n    /**\n     * Reads a set of file attributes as a bulk operation.\n     *\n     * \u003cp\u003e The {@code attributes} parameter identifies the attributes to be read\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-list\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems.\n     *\n     * \u003cp\u003e The \u003ci\u003eattribute-list\u003c/i\u003e component is a comma separated list of\n     * one or more names of attributes to read. If the list contains the value\n     * {@code \"*\"} then all attributes are read. Attributes that are not supported\n     * are ignored and will not be present in the returned map. It is\n     * implementation specific if all attributes are read as an atomic operation\n     * with respect to other file system operations.\n     *\n     * \u003cp\u003e The following examples demonstrate possible values for the {@code\n     * attributes} parameter:\n     *\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align: left; margin-left:2em\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003ePossible values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eExample\n     *  \u003cth scope\u003d\"col\"\u003eDescription\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"*\"} \u003c/th\u003e\n     *   \u003ctd\u003e Read all {@link BasicFileAttributes basic-file-attributes}. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"size,lastModifiedTime,lastAccessTime\"} \u003c/th\u003e\n     *   \u003ctd\u003e Reads the file size, last modified time, and last access time\n     *     attributes. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"posix:*\"} \u003c/th\u003e\n     *   \u003ctd\u003e Read all {@link PosixFileAttributes POSIX-file-attributes}. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"posix:permissions,owner,size\"} \u003c/th\u003e\n     *   \u003ctd\u003e Reads the POSIX file permissions, owner, and file size. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attributes\n     *          the attributes to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a map of the attributes returned; The map\u0027s keys are the\n     *          attribute names, its values are the attribute values\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if no attributes are specified or an unrecognized attribute is\n     *          specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file. If this method is invoked\n     *          to read security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Map\u003cString,Object\u003e readAttributes(Path path, String attributes,\n                                                    LinkOption... options)\n        throws IOException\n    {\n        return provider(path).readAttributes(path, attributes, options);\n    }\n\n    /**\n     * Returns a file\u0027s POSIX file permissions.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\n     * that supports the {@link PosixFileAttributeView}. This attribute view\n     * provides access to file attributes commonly associated with files on file\n     * systems used by operating systems that implement the Portable Operating\n     * System Interface (POSIX) family of standards.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the file permissions\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          PosixFileAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, a security manager is\n     *          installed, and it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\n     *          denies read access to the file.\n     */\n    public static Set\u003cPosixFilePermission\u003e getPosixFilePermissions(Path path,\n                                                                   LinkOption... options)\n        throws IOException\n    {\n        return readAttributes(path, PosixFileAttributes.class, options).permissions();\n    }\n\n    /**\n     * Sets a file\u0027s POSIX permissions.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\n     * that supports the {@link PosixFileAttributeView}. This attribute view\n     * provides access to file attributes commonly associated with files on file\n     * systems used by operating systems that implement the Portable Operating\n     * System Interface (POSIX) family of standards.\n     *\n     * @param   path\n     *          The path to the file\n     * @param   perms\n     *          The new set of permissions\n     *\n     * @return  The given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          PosixFileAttributeView}\n     * @throws  ClassCastException\n     *          if the sets contains elements that are not of type {@code\n     *          PosixFilePermission}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file.\n     */\n    public static Path setPosixFilePermissions(Path path,\n                                               Set\u003cPosixFilePermission\u003e perms)\n        throws IOException\n    {\n        PosixFileAttributeView view \u003d\n            getFileAttributeView(path, PosixFileAttributeView.class);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        view.setPermissions(perms);\n        return path;\n    }\n\n    /**\n     * Returns the owner of a file.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a file system that\n     * supports {@link FileOwnerAttributeView}. This file attribute view provides\n     * access to a file attribute that is the owner of the file.\n     *\n     * @param   path\n     *          The path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  A user principal representing the owner of the file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          FileOwnerAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\n     *          denies read access to the file.\n     */\n    public static UserPrincipal getOwner(Path path, LinkOption... options) throws IOException {\n        FileOwnerAttributeView view \u003d\n            getFileAttributeView(path, FileOwnerAttributeView.class, options);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        return view.getOwner();\n    }\n\n    /**\n     * Updates the file owner.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a file system that\n     * supports {@link FileOwnerAttributeView}. This file attribute view provides\n     * access to a file attribute that is the owner of the file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to make \"joe\" the owner of a file:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     UserPrincipalLookupService lookupService \u003d\n     *         provider(path).getUserPrincipalLookupService();\n     *     UserPrincipal joe \u003d lookupService.lookupPrincipalByName(\"joe\");\n     *     Files.setOwner(path, joe);\n     * }\n     *\n     * @param   path\n     *          The path to the file\n     * @param   owner\n     *          The new file owner\n     *\n     * @return  The given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          FileOwnerAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file.\n     *\n     * @see FileSystem#getUserPrincipalLookupService\n     * @see java.nio.file.attribute.UserPrincipalLookupService\n     */\n    public static Path setOwner(Path path, UserPrincipal owner)\n        throws IOException\n    {\n        FileOwnerAttributeView view \u003d\n            getFileAttributeView(path, FileOwnerAttributeView.class);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        view.setOwner(owner);\n        return path;\n    }\n\n    /**\n     * Tests whether a file is a symbolic link.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a symbolic link then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isSymbolicLink} method.\n     *\n     * @param   path  The path to the file\n     *\n     * @return  {@code true} if the file is a symbolic link; {@code false} if\n     *          the file does not exist, is not a symbolic link, or it cannot\n     *          be determined if the file is a symbolic link or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isSymbolicLink(Path path) {\n        try {\n            return readAttributes(path,\n                                  BasicFileAttributes.class,\n                                  LinkOption.NOFOLLOW_LINKS).isSymbolicLink();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is a directory.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a directory then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isDirectory} method.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file is a directory; {@code false} if\n     *          the file does not exist, is not a directory, or it cannot\n     *          be determined if the file is a directory or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isDirectory(Path path, LinkOption... options) {\n        try {\n            var attrs \u003d provider(path)\n                    .readAttributesIfExists(path, BasicFileAttributes.class, options);\n            return (attrs !\u003d null) \u0026\u0026 attrs.isDirectory();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is a regular file with opaque content.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a regular file then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isRegularFile} method.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file is a regular file; {@code false} if\n     *          the file does not exist, is not a regular file, or it\n     *          cannot be determined if the file is a regular file or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isRegularFile(Path path, LinkOption... options) {\n        try {\n            var attrs \u003d provider(path)\n                    .readAttributesIfExists(path, BasicFileAttributes.class, options);\n            return (attrs !\u003d null) \u0026\u0026 attrs.isRegularFile();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Returns a file\u0027s last modified time.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a {@code FileTime} representing the time the file was last\n     *          modified, or an implementation specific default when a time\n     *          stamp to indicate the time of last modification is not supported\n     *          by the file system\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     *\n     * @see BasicFileAttributes#lastModifiedTime\n     */\n    public static FileTime getLastModifiedTime(Path path, LinkOption... options)\n        throws IOException\n    {\n        return readAttributes(path, BasicFileAttributes.class, options).lastModifiedTime();\n    }\n\n    /**\n     * Updates a file\u0027s last modified time attribute. The file time is converted\n     * to the epoch and precision supported by the file system. Converting from\n     * finer to coarser granularities result in precision loss. The behavior of\n     * this method when attempting to set the last modified time when it is not\n     * supported by the file system or is outside the range supported by the\n     * underlying file store is not defined. It may or not fail by throwing an\n     * {@code IOException}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to set the last modified time to the current time:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     FileTime now \u003d FileTime.fromMillis(System.currentTimeMillis());\n     *     Files.setLastModifiedTime(path, now);\n     * }\n     *\n     * @param   path\n     *          the path to the file\n     * @param   time\n     *          the new last modified time\n     *\n     * @return  the given path\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method denies write access to the file.\n     *\n     * @see BasicFileAttributeView#setTimes\n     */\n    public static Path setLastModifiedTime(Path path, FileTime time)\n        throws IOException\n    {\n        getFileAttributeView(path, BasicFileAttributeView.class)\n            .setTimes(Objects.requireNonNull(time), null, null);\n        return path;\n    }\n\n    /**\n     * Returns the size of a file (in bytes). The size may differ from the\n     * actual size on the file system due to compression, support for sparse\n     * files, or other reasons. The size of files that are not {@link\n     * #isRegularFile regular} files is implementation specific and\n     * therefore unspecified.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the file size, in bytes\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     *\n     * @see BasicFileAttributes#size\n     */\n    public static long size(Path path) throws IOException {\n        return readAttributes(path, BasicFileAttributes.class).size();\n    }\n\n    // -- Accessibility --\n\n    /**\n     * Returns {@code false} if NOFOLLOW_LINKS is present.\n     */\n    private static boolean followLinks(LinkOption... options) {\n        boolean followLinks \u003d true;\n        for (LinkOption opt: options) {\n            if (opt \u003d\u003d LinkOption.NOFOLLOW_LINKS) {\n                followLinks \u003d false;\n                continue;\n            }\n            if (opt \u003d\u003d null)\n                throw new NullPointerException();\n            throw new AssertionError(\"Should not get here\");\n        }\n        return followLinks;\n    }\n\n    /**\n     * Tests whether a file exists.\n     *\n     * \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated. If this\n     * method indicates the file exists then there is no guarantee that a\n     * subsequent access will succeed. Care should be taken when using this\n     * method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file exists; {@code false} if the file does\n     *          not exist or its existence cannot be determined.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String)} is invoked to check\n     *          read access to the file.\n     *\n     * @see #notExists\n     * @see FileSystemProvider#checkAccess\n     */\n    public static boolean exists(Path path, LinkOption... options) {\n        return provider(path).exists(path, options);\n    }\n\n    /**\n     * Tests whether the file located by this path does not exist. This method\n     * is intended for cases where it is required to take action when it can be\n     * confirmed that a file does not exist.\n     *\n     * \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Note that this method is not the complement of the {@link #exists\n     * exists} method. Where it is not possible to determine if a file exists\n     * or not then both methods return {@code false}. As with the {@code exists}\n     * method, the result of this method is immediately outdated. If this\n     * method indicates the file does exist then there is no guarantee that a\n     * subsequent attempt to create the file will succeed. Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file does not exist; {@code false} if the\n     *          file exists or its existence cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String)} is invoked to check\n     *          read access to the file.\n     */\n    public static boolean notExists(Path path, LinkOption... options) {\n        try {\n            if (followLinks(options)) {\n                provider(path).checkAccess(path);\n            } else {\n                // attempt to read attributes without following links\n                readAttributes(path, BasicFileAttributes.class,\n                               LinkOption.NOFOLLOW_LINKS);\n            }\n            // file exists\n            return false;\n        } catch (NoSuchFileException x) {\n            // file confirmed not to exist\n            return true;\n        } catch (IOException x) {\n            return false;\n        }\n    }\n\n    /**\n     * Used by isReadable, isWritable, isExecutable to test access to a file.\n     */\n    private static boolean isAccessible(Path path, AccessMode... modes) {\n        try {\n            provider(path).checkAccess(path, modes);\n            return true;\n        } catch (IOException x) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is readable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges that would\n     * allow it open the file for reading. Depending on the implementation, this\n     * method may require to read file permissions, access control lists, or\n     * other file attributes in order to check the effective access to the file.\n     * Consequently, this method may not be atomic with respect to other file\n     * system operations.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated, there is\n     * no guarantee that a subsequent attempt to open the file for reading will\n     * succeed (or even that it will access the same file). Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is readable; {@code false}\n     *          if the file does not exist, read access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          is invoked to check read access to the file.\n     */\n    public static boolean isReadable(Path path) {\n        return isAccessible(path, AccessMode.READ);\n    }\n\n    /**\n     * Tests whether a file is writable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges that would\n     * allow it open the file for writing. Depending on the implementation, this\n     * method may require to read file permissions, access control lists, or\n     * other file attributes in order to check the effective access to the file.\n     * Consequently, this method may not be atomic with respect to other file\n     * system operations.\n     *\n     * \u003cp\u003e Note that result of this method is immediately outdated, there is no\n     * guarantee that a subsequent attempt to open the file for writing will\n     * succeed (or even that it will access the same file). Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is writable; {@code false}\n     *          if the file does not exist, write access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          is invoked to check write access to the file.\n     */\n    public static boolean isWritable(Path path) {\n        return isAccessible(path, AccessMode.WRITE);\n    }\n\n    /**\n     * Tests whether a file is executable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges to {@link\n     * Runtime#exec execute} the file. The semantics may differ when checking\n     * access to a directory. For example, on UNIX systems, checking for\n     * execute access checks that the Java virtual machine has permission to\n     * search the directory in order to access file or subdirectories.\n     *\n     * \u003cp\u003e Depending on the implementation, this method may require to read file\n     * permissions, access control lists, or other file attributes in order to\n     * check the effective access to the file. Consequently, this method may not\n     * be atomic with respect to other file system operations.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated, there is\n     * no guarantee that a subsequent attempt to execute the file will succeed\n     * (or even that it will access the same file). Care should be taken when\n     * using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is executable; {@code false}\n     *          if the file does not exist, execute access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkExec(String)\n     *          checkExec} is invoked to check execute access to the file.\n     */\n    public static boolean isExecutable(Path path) {\n        return isAccessible(path, AccessMode.EXECUTE);\n    }\n\n    // -- Recursive operations --\n\n    /**\n     * Walks a file tree.\n     *\n     * \u003cp\u003e This method walks a file tree rooted at a given starting file. The\n     * file tree traversal is \u003cem\u003edepth-first\u003c/em\u003e with the given {@link\n     * FileVisitor} invoked for each file encountered. File tree traversal\n     * completes when all accessible files in the tree have been visited, or a\n     * visit method returns a result of {@link FileVisitResult#TERMINATE\n     * TERMINATE}. Where a visit method terminates due an {@code IOException},\n     * an uncaught error, or runtime exception, then the traversal is terminated\n     * and the error or exception is propagated to the caller of this method.\n     *\n     * \u003cp\u003e For each file encountered this method attempts to read its {@link\n     * java.nio.file.attribute.BasicFileAttributes}. If the file is not a\n     * directory then the {@link FileVisitor#visitFile visitFile} method is\n     * invoked with the file attributes. If the file attributes cannot be read,\n     * due to an I/O exception, then the {@link FileVisitor#visitFileFailed\n     * visitFileFailed} method is invoked with the I/O exception.\n     *\n     * \u003cp\u003e Where the file is a directory, and the directory could not be opened,\n     * then the {@code visitFileFailed} method is invoked with the I/O exception,\n     * after which, the file tree walk continues, by default, at the next\n     * \u003cem\u003esibling\u003c/em\u003e of the directory.\n     *\n     * \u003cp\u003e Where the directory is opened successfully, then the entries in the\n     * directory, and their \u003cem\u003edescendants\u003c/em\u003e are visited. When all entries\n     * have been visited, or an I/O error occurs during iteration of the\n     * directory, then the directory is closed and the visitor\u0027s {@link\n     * FileVisitor#postVisitDirectory postVisitDirectory} method is invoked.\n     * The file tree walk then continues, by default, at the next \u003cem\u003esibling\u003c/em\u003e\n     * of the directory.\n     *\n     * \u003cp\u003e By default, symbolic links are not automatically followed by this\n     * method. If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\n     * followed. When following links, and the attributes of the target cannot\n     * be read, then this method attempts to get the {@code BasicFileAttributes}\n     * of the link. If they can be read then the {@code visitFile} method is\n     * invoked with the attributes of the link (otherwise the {@code visitFileFailed}\n     * method is invoked as specified above).\n     *\n     * \u003cp\u003e If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then this method keeps\n     * track of directories visited so that cycles can be detected. A cycle\n     * arises when there is an entry in a directory that is an ancestor of the\n     * directory. Cycle detection is done by recording the {@link\n     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\n     * or if file keys are not available, by invoking the {@link #isSameFile\n     * isSameFile} method to test if a directory is the same file as an\n     * ancestor. When a cycle is detected it is treated as an I/O error, and the\n     * {@link FileVisitor#visitFileFailed visitFileFailed} method is invoked with\n     * an instance of {@link FileSystemLoopException}.\n     *\n     * \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\n     * directories to visit. A value of {@code 0} means that only the starting\n     * file is visited, unless denied by the security manager. A value of\n     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\n     * levels should be visited. The {@code visitFile} method is invoked for all\n     * files, including directories, encountered at {@code maxDepth}, unless the\n     * basic file attributes cannot be read, in which case the {@code\n     * visitFileFailed} method is invoked.\n     *\n     * \u003cp\u003e If a visitor returns a result of {@code null} then {@code\n     * NullPointerException} is thrown.\n     *\n     * \u003cp\u003e When a security manager is installed and it denies access to a file\n     * (or directory), then it is ignored and the visitor is not invoked for\n     * that file (or directory).\n     *\n     * @param   start\n     *          the starting file\n     * @param   options\n     *          options to configure the traversal\n     * @param   maxDepth\n     *          the maximum number of directory levels to visit\n     * @param   visitor\n     *          the file visitor to invoke for each file\n     *\n     * @return  the starting file\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown by a visitor method\n     */\n    public static Path walkFileTree(Path start,\n                                    Set\u003cFileVisitOption\u003e options,\n                                    int maxDepth,\n                                    FileVisitor\u003c? super Path\u003e visitor)\n        throws IOException\n    {\n        /**\n         * Create a FileTreeWalker to walk the file tree, invoking the visitor\n         * for each event.\n         */\n        try (FileTreeWalker walker \u003d new FileTreeWalker(options, maxDepth)) {\n            FileTreeWalker.Event ev \u003d walker.walk(start);\n            do {\n                FileVisitResult result \u003d switch (ev.type()) {\n                    case ENTRY -\u003e {\n                        IOException ioe \u003d ev.ioeException();\n                        if (ioe \u003d\u003d null) {\n                            assert ev.attributes() !\u003d null;\n                            yield visitor.visitFile(ev.file(), ev.attributes());\n                        } else {\n                            yield visitor.visitFileFailed(ev.file(), ioe);\n                        }\n                    }\n                    case START_DIRECTORY -\u003e {\n                        var res \u003d visitor.preVisitDirectory(ev.file(), ev.attributes());\n\n                        // if SKIP_SIBLINGS and SKIP_SUBTREE is returned then\n                        // there shouldn\u0027t be any more events for the current\n                        // directory.\n                        if (res \u003d\u003d FileVisitResult.SKIP_SUBTREE ||\n                            res \u003d\u003d FileVisitResult.SKIP_SIBLINGS)\n                            walker.pop();\n                        yield res;\n                    }\n                    case END_DIRECTORY -\u003e {\n                        var res \u003d visitor.postVisitDirectory(ev.file(), ev.ioeException());\n\n                        // SKIP_SIBLINGS is a no-op for postVisitDirectory\n                        if (res \u003d\u003d FileVisitResult.SKIP_SIBLINGS)\n                            res \u003d FileVisitResult.CONTINUE;\n                        yield res;\n                    }\n                    default -\u003e throw new AssertionError(\"Should not get here\");\n                };\n\n                if (Objects.requireNonNull(result) !\u003d FileVisitResult.CONTINUE) {\n                    if (result \u003d\u003d FileVisitResult.TERMINATE) {\n                        break;\n                    } else if (result \u003d\u003d FileVisitResult.SKIP_SIBLINGS) {\n                        walker.skipRemainingSiblings();\n                    }\n                }\n                ev \u003d walker.next();\n            } while (ev !\u003d null);\n        }\n\n        return start;\n    }\n\n    /**\n     * Walks a file tree.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * walkFileTree(Path, Set\u003cFileVisitOption\u003e, int, FileVisitor\u003c? super Path\u003e)\n     * Files.walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\n     * }\u003c/blockquote\u003e\n     * In other words, it does not follow symbolic links, and visits all levels\n     * of the file tree.\n     *\n     * @param   start\n     *          the starting file\n     * @param   visitor\n     *          the file visitor to invoke for each file\n     *\n     * @return  the starting file\n     *\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown by a visitor method\n     */\n    public static Path walkFileTree(Path start, FileVisitor\u003c? super Path\u003e visitor)\n        throws IOException\n    {\n        return walkFileTree(start,\n                            EnumSet.noneOf(FileVisitOption.class),\n                            Integer.MAX_VALUE,\n                            visitor);\n    }\n\n\n    // -- Utility methods for simple usages --\n\n\n    /**\n     * Opens a file for reading, returning a {@code BufferedReader} that may be\n     * used to read text from the file in an efficient manner. Bytes from the\n     * file are decoded into characters using the specified charset. Reading\n     * commences at the beginning of the file.\n     *\n     * \u003cp\u003e The {@code Reader} methods that read from the file throw {@code\n     * IOException} if a malformed or unmappable byte sequence is read.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  a new buffered reader, with default buffer size, to read text\n     *          from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see #readAllLines\n     */\n    public static BufferedReader newBufferedReader(Path path, Charset cs)\n        throws IOException\n    {\n        CharsetDecoder decoder \u003d cs.newDecoder();\n        Reader reader \u003d new InputStreamReader(newInputStream(path), decoder);\n        return new BufferedReader(reader);\n    }\n\n    /**\n     * Opens a file for reading, returning a {@code BufferedReader} to read text\n     * from the file in an efficient manner. Bytes from the file are decoded into\n     * characters using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset\n     * charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * newBufferedReader(Path, Charset)\n     * Files.newBufferedReader(path, StandardCharsets.UTF_8)\n     * }\u003c/blockquote\u003e\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  a new buffered reader, with default buffer size, to read text\n     *          from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static BufferedReader newBufferedReader(Path path) throws IOException {\n        return newBufferedReader(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Opens or creates a file for writing, returning a {@code BufferedWriter}\n     * that may be used to write text to the file in an efficient manner.\n     * The {@code options} parameter specifies how the file is created or\n     * opened. If no options are present then this method works as if the {@link\n     * StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0} if it exists.\n     *\n     * \u003cp\u003e The {@code Writer} methods to write text throw {@code IOException}\n     * if the text cannot be encoded using the specified charset. Due to\n     * buffering, an {@code IOException} caused by an encoding error\n     * (unmappable-character or malformed-input) may be thrown when {@linkplain\n     * BufferedWriter#write(char[],int,int) writing}, {@linkplain\n     * BufferedWriter#flush flushing}, or {@linkplain BufferedWriter#close\n     * closing} the buffered writer.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new buffered writer, with default buffer size, to write text\n     *          to the file\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs opening or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see #write(Path,Iterable,Charset,OpenOption[])\n     */\n    public static BufferedWriter newBufferedWriter(Path path, Charset cs,\n                                                   OpenOption... options)\n        throws IOException\n    {\n        CharsetEncoder encoder \u003d cs.newEncoder();\n        Writer writer \u003d new OutputStreamWriter(newOutputStream(path, options), encoder);\n        return new BufferedWriter(writer);\n    }\n\n    /**\n     * Opens or creates a file for writing, returning a {@code BufferedWriter}\n     * to write text to the file in an efficient manner. The text is encoded\n     * into bytes for writing using the {@link StandardCharsets#UTF_8 UTF-8}\n     * {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * newBufferedWriter(Path, Charset, OpenOption...)\n     * Files.newBufferedWriter(path, StandardCharsets.UTF_8, options)\n     * }\u003c/blockquote\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new buffered writer, with default buffer size, to write text\n     *          to the file\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs opening or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 1.8\n     */\n    public static BufferedWriter newBufferedWriter(Path path, OpenOption... options)\n        throws IOException\n    {\n        return newBufferedWriter(path, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Copies all bytes from an input stream to a file. On return, the input\n     * stream will be at end of stream.\n     *\n     * \u003cp\u003e By default, the copy fails if the target file already exists or is a\n     * symbolic link. If the {@link StandardCopyOption#REPLACE_EXISTING\n     * REPLACE_EXISTING} option is specified, and the target file already exists,\n     * then it is replaced if it is not a non-empty directory. If the target\n     * file exists and is a symbolic link, then the symbolic link is replaced.\n     * In this release, the {@code REPLACE_EXISTING} option is the only option\n     * required to be supported by this method. Additional options may be\n     * supported in future releases.\n     *\n     * \u003cp\u003e  If an I/O error occurs reading from the input stream or writing to\n     * the file, then it may do so after the target file has been created and\n     * after some bytes have been read or written. Consequently the input\n     * stream may not be at end of stream and may be in an inconsistent state.\n     * It is strongly recommended that the input stream be promptly closed if an\n     * I/O error occurs.\n     *\n     * \u003cp\u003e This method may block indefinitely reading from the input stream (or\n     * writing to the file). The behavior for the case that the input stream is\n     * \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy is\n     * highly input stream and file system provider specific and therefore not\n     * specified.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: Suppose we want to capture a web page and save\n     * it to a file:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     URI u \u003d URI.create(\"http://www.example.com/\");\n     *     try (InputStream in \u003d u.toURL().openStream()) {\n     *         Files.copy(in, path);\n     *     }\n     * }\n     *\n     * @param   in\n     *          the input stream to read from\n     * @param   target\n     *          the path to the file\n     * @param   options\n     *          options specifying how the copy should be done\n     *\n     * @return  the number of bytes read or written\n     *\n     * @throws  IOException\n     *          if an I/O error occurs when reading or writing\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  UnsupportedOperationException\n     *          if {@code options} contains a copy option that is not supported\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. Where the\n     *          {@code REPLACE_EXISTING} option is specified, the security\n     *          manager\u0027s {@link SecurityManager#checkDelete(String) checkDelete}\n     *          method is invoked to check that an existing file can be deleted.\n     */\n    public static long copy(InputStream in, Path target, CopyOption... options)\n        throws IOException\n    {\n        // ensure not null before opening file\n        Objects.requireNonNull(in);\n\n        // check for REPLACE_EXISTING\n        boolean replaceExisting \u003d false;\n        for (CopyOption opt: options) {\n            if (opt \u003d\u003d StandardCopyOption.REPLACE_EXISTING) {\n                replaceExisting \u003d true;\n            } else {\n                if (opt \u003d\u003d null) {\n                    throw new NullPointerException(\"options contains \u0027null\u0027\");\n                }  else {\n                    throw new UnsupportedOperationException(opt + \" not supported\");\n                }\n            }\n        }\n\n        // attempt to delete an existing file\n        SecurityException se \u003d null;\n        if (replaceExisting) {\n            try {\n                deleteIfExists(target);\n            } catch (SecurityException x) {\n                se \u003d x;\n            }\n        }\n\n        // attempt to create target file. If it fails with\n        // FileAlreadyExistsException then it may be because the security\n        // manager prevented us from deleting the file, in which case we just\n        // throw the SecurityException.\n        OutputStream ostream;\n        try {\n            ostream \u003d newOutputStream(target, StandardOpenOption.CREATE_NEW,\n                                              StandardOpenOption.WRITE);\n        } catch (FileAlreadyExistsException x) {\n            if (se !\u003d null)\n                throw se;\n            // someone else won the race and created the file\n            throw x;\n        }\n\n        // do the copy\n        try (OutputStream out \u003d ostream) {\n            return in.transferTo(out);\n        }\n    }\n\n    /**\n     * Copies all bytes from a file to an output stream.\n     *\n     * \u003cp\u003e If an I/O error occurs reading from the file or writing to the output\n     * stream, then it may do so after some bytes have been read or written.\n     * Consequently the output stream may be in an inconsistent state. It is\n     * strongly recommended that the output stream be promptly closed if an I/O\n     * error occurs.\n     *\n     * \u003cp\u003e This method may block indefinitely writing to the output stream (or\n     * reading from the file). The behavior for the case that the output stream\n     * is \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy\n     * is highly output stream and file system provider specific and therefore\n     * not specified.\n     *\n     * \u003cp\u003e Note that if the given output stream is {@link java.io.Flushable}\n     * then its {@link java.io.Flushable#flush flush} method may need to invoked\n     * after this method completes so as to flush any buffered output.\n     *\n     * @param   source\n     *          the  path to the file\n     * @param   out\n     *          the output stream to write to\n     *\n     * @return  the number of bytes read or written\n     *\n     * @throws  IOException\n     *          if an I/O error occurs when reading or writing\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static long copy(Path source, OutputStream out) throws IOException {\n        // ensure not null before opening file\n        Objects.requireNonNull(out);\n\n        try (InputStream in \u003d newInputStream(source)) {\n            return in.transferTo(out);\n        }\n    }\n\n    private static final jdk.internal.access.JavaLangAccess JLA \u003d\n            jdk.internal.access.SharedSecrets.getJavaLangAccess();\n\n    /**\n     * Reads all the bytes from an input stream. Uses {@code initialSize} as a hint\n     * about how many bytes the stream will have.\n     *\n     * @param   source\n     *          the input stream to read from\n     * @param   initialSize\n     *          the initial size of the byte array to allocate\n     *\n     * @return  a byte array containing the bytes read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the stream\n     * @throws  OutOfMemoryError\n     *          if an array of the required size cannot be allocated\n     */\n    private static byte[] read(InputStream source, int initialSize) throws IOException {\n        int capacity \u003d initialSize;\n        byte[] buf \u003d new byte[capacity];\n        int nread \u003d 0;\n        int n;\n        for (;;) {\n            // read to EOF which may read more or less than initialSize (eg: file\n            // is truncated while we are reading)\n            while ((n \u003d source.read(buf, nread, capacity - nread)) \u003e 0)\n                nread +\u003d n;\n\n            // if last call to source.read() returned -1, we are done\n            // otherwise, try to read one more byte; if that failed we\u0027re done too\n            if (n \u003c 0 || (n \u003d source.read()) \u003c 0)\n                break;\n\n            // one more byte was read; need to allocate a larger buffer\n            capacity \u003d Math.max(ArraysSupport.newLength(capacity,\n                                                        1,       /* minimum growth */\n                                                        capacity /* preferred growth */),\n                                BUFFER_SIZE);\n            buf \u003d Arrays.copyOf(buf, capacity);\n            buf[nread++] \u003d (byte)n;\n        }\n        return (capacity \u003d\u003d nread) ? buf : Arrays.copyOf(buf, nread);\n    }\n\n    /**\n     * Reads all the bytes from a file. The method ensures that the file is\n     * closed when all bytes have been read or an I/O error, or other runtime\n     * exception, is thrown.\n     *\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\n     * convenient to read all bytes into a byte array. It is not intended for\n     * reading in large files.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  a byte array containing the bytes read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the stream\n     * @throws  OutOfMemoryError\n     *          if an array of the required size cannot be allocated, for\n     *          example the file is larger that {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static byte[] readAllBytes(Path path) throws IOException {\n        try (SeekableByteChannel sbc \u003d Files.newByteChannel(path);\n             InputStream in \u003d Channels.newInputStream(sbc)) {\n            if (sbc instanceof FileChannelImpl)\n                ((FileChannelImpl) sbc).setUninterruptible();\n            long size \u003d sbc.size();\n            if (size \u003e (long) Integer.MAX_VALUE)\n                throw new OutOfMemoryError(\"Required array size too large\");\n            return read(in, (int)size);\n        }\n    }\n\n    /**\n     * Reads all content from a file into a string, decoding from bytes to characters\n     * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     * The method ensures that the file is closed when all content have been read\n     * or an I/O error, or other runtime exception, is thrown.\n     *\n     * \u003cp\u003e This method is equivalent to: {@link readString(Path, Charset)\n     * readString(path, StandardCharsets.UTF_8)}.\n     *\n     * @param   path the path to the file\n     *\n     * @return  a String containing the content read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  OutOfMemoryError\n     *          if the file is extremely large, for example larger than {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 11\n     */\n    public static String readString(Path path) throws IOException {\n        return readString(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Reads all characters from a file into a string, decoding from bytes to characters\n     * using the specified {@linkplain Charset charset}.\n     * The method ensures that the file is closed when all content have been read\n     * or an I/O error, or other runtime exception, is thrown.\n     *\n     * \u003cp\u003e This method reads all content including the line separators in the middle\n     * and/or at the end. The resulting string will contain line separators as they\n     * appear in the file.\n     *\n     * @apiNote\n     * This method is intended for simple cases where it is appropriate and convenient\n     * to read the content of a file into a String. It is not intended for reading\n     * very large files.\n     *\n     *\n     *\n     * @param   path the path to the file\n     * @param   cs the charset to use for decoding\n     *\n     * @return  a String containing the content read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  OutOfMemoryError\n     *          if the file is extremely large, for example larger than {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 11\n     */\n    public static String readString(Path path, Charset cs) throws IOException {\n        Objects.requireNonNull(path);\n        Objects.requireNonNull(cs);\n\n        byte[] ba \u003d readAllBytes(path);\n        if (path.getClass().getModule() !\u003d Object.class.getModule())\n            ba \u003d ba.clone();\n        return JLA.newStringNoRepl(ba, cs);\n    }\n\n    /**\n     * Read all lines from a file. This method ensures that the file is\n     * closed when all bytes have been read or an I/O error, or other runtime\n     * exception, is thrown. Bytes from the file are decoded into characters\n     * using the specified charset.\n     *\n     * \u003cp\u003e This method recognizes the following as line terminators:\n     * \u003cul\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e followed by \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e,\n     *     CARRIAGE RETURN followed by LINE FEED \u003c/li\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e, LINE FEED \u003c/li\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e, CARRIAGE RETURN \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e Additional Unicode line terminators may be recognized in future\n     * releases.\n     *\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\n     * convenient to read all lines in a single operation. It is not intended\n     * for reading in large files.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  the lines from the file as a {@code List}; whether the {@code\n     *          List} is modifiable or not is implementation dependent and\n     *          therefore not specified\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see #newBufferedReader\n     */\n    public static List\u003cString\u003e readAllLines(Path path, Charset cs) throws IOException {\n        try (BufferedReader reader \u003d newBufferedReader(path, cs)) {\n            List\u003cString\u003e result \u003d new ArrayList\u003c\u003e();\n            for (;;) {\n                String line \u003d reader.readLine();\n                if (line \u003d\u003d null)\n                    break;\n                result.add(line);\n            }\n            return result;\n        }\n    }\n\n    /**\n     * Read all lines from a file. Bytes from the file are decoded into characters\n     * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * readAllLines(Path, Charset)\n     * Files.readAllLines(path, StandardCharsets.UTF_8)\n     * }\u003c/blockquote\u003e\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the lines from the file as a {@code List}; whether the {@code\n     *          List} is modifiable or not is implementation dependent and\n     *          therefore not specified\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static List\u003cString\u003e readAllLines(Path path) throws IOException {\n        return readAllLines(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Writes bytes to a file. The {@code options} parameter specifies how\n     * the file is created or opened. If no options are present then this method\n     * works as if the {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}. All bytes in the byte array are written to the file.\n     * The method ensures that the file is closed when all bytes have been\n     * written (or an I/O error or other runtime exception is thrown). If an I/O\n     * error occurs then it may do so after the file has been created or\n     * truncated, or after some bytes have been written to the file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: By default the method creates a new file or\n     * overwrites an existing file. Suppose you instead want to append bytes\n     * to an existing file:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     byte[] bytes \u003d ...\n     *     Files.write(path, bytes, StandardOpenOption.APPEND);\n     * }\n     *\n     * @param   path\n     *          the path to the file\n     * @param   bytes\n     *          the byte array with the bytes to write\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static Path write(Path path, byte[] bytes, OpenOption... options)\n        throws IOException\n    {\n        // ensure bytes is not null before opening file\n        Objects.requireNonNull(bytes);\n\n        try (OutputStream out \u003d Files.newOutputStream(path, options)) {\n            int len \u003d bytes.length;\n            int rem \u003d len;\n            while (rem \u003e 0) {\n                int n \u003d Math.min(rem, BUFFER_SIZE);\n                out.write(bytes, (len-rem), n);\n                rem -\u003d n;\n            }\n        }\n        return path;\n    }\n\n    /**\n     * Write lines of text to a file. Each line is a char sequence and is\n     * written to the file in sequence with each line terminated by the\n     * platform\u0027s line separator, as defined by the system property {@code\n     * line.separator}. Characters are encoded into bytes using the specified\n     * charset.\n     *\n     * \u003cp\u003e The {@code options} parameter specifies how the file is created\n     * or opened. If no options are present then this method works as if the\n     * {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}. The method ensures that the file is closed when all\n     * lines have been written (or an I/O error or other runtime exception is\n     * thrown). If an I/O error occurs then it may do so after the file has\n     * been created or truncated, or after some bytes have been written to the\n     * file.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   lines\n     *          an object to iterate over the char sequences\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines,\n                             Charset cs, OpenOption... options)\n        throws IOException\n    {\n        // ensure lines is not null before opening file\n        Objects.requireNonNull(lines);\n        CharsetEncoder encoder \u003d cs.newEncoder();\n        try (OutputStream out \u003d newOutputStream(path, options);\n             BufferedWriter writer \u003d new BufferedWriter(new OutputStreamWriter(out, encoder))) {\n            for (CharSequence line: lines) {\n                writer.append(line);\n                writer.newLine();\n            }\n        }\n        return path;\n    }\n\n    /**\n     * Write lines of text to a file. Characters are encoded into bytes using\n     * the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * write(Path, Iterable\u003c? extends CharSequence\u003e, Charset, OpenOption...)\n     * Files.write(path, lines, StandardCharsets.UTF_8, options)\n     * }\u003c/blockquote\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   lines\n     *          an object to iterate over the char sequences\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded as {@code UTF-8}\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 1.8\n     */\n    public static Path write(Path path,\n                             Iterable\u003c? extends CharSequence\u003e lines,\n                             OpenOption... options)\n        throws IOException\n    {\n        return write(path, lines, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.\n     * Characters are encoded into bytes using the\n     * {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method is equivalent to: {@link\n     * writeString(Path, CharSequence, Charset, OpenOption...)\n     * writeString(path, csq, StandardCharsets.UTF_8, options)}.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   csq\n     *          the CharSequence to be written\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using UTF-8\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 11\n     */\n    public static Path writeString(Path path, CharSequence csq, OpenOption... options)\n            throws IOException\n    {\n        return writeString(path, csq, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.\n     * Characters are encoded into bytes using the specified\n     * {@linkplain java.nio.charset.Charset charset}.\n     *\n     * \u003cp\u003e All characters are written as they are, including the line separators in\n     * the char sequence. No extra characters are added.\n     *\n     * \u003cp\u003e The {@code options} parameter specifies how the file is created\n     * or opened. If no options are present then this method works as if the\n     * {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}.\n     *\n     *\n     * @param   path\n     *          the path to the file\n     * @param   csq\n     *          the CharSequence to be written\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 11\n     */\n    public static Path writeString(Path path, CharSequence csq, Charset cs, OpenOption... options)\n            throws IOException\n    {\n        // ensure the text is not null before opening file\n        Objects.requireNonNull(path);\n        Objects.requireNonNull(csq);\n        Objects.requireNonNull(cs);\n\n        byte[] bytes \u003d JLA.getBytesNoRepl(String.valueOf(csq), cs);\n        if (path.getClass().getModule() !\u003d Object.class.getModule())\n            bytes \u003d bytes.clone();\n        write(path, bytes, options);\n\n        return path;\n    }\n\n    // -- Stream APIs --\n\n    /**\n     * Return a lazily populated {@code Stream}, the elements of\n     * which are the entries in the directory.  The listing is not recursive.\n     *\n     * \u003cp\u003e The elements of the stream are {@link Path} objects that are\n     * obtained as if by {@link Path#resolve(Path) resolving} the name of the\n     * directory entry against {@code dir}. Some file systems maintain special\n     * links to the directory itself and the directory\u0027s parent directory.\n     * Entries representing these links are not included.\n     *\n     * \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It is thread safe but does\n     * not freeze the directory while iterating, so it may (or may not)\n     * reflect updates to the directory that occur after returning from this\n     * method.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open directory.\n     * The directory is closed by closing the stream.\n     *\n     * \u003cp\u003e Operating on a closed stream behaves as if the end of stream\n     * has been reached. Due to read-ahead, one or more elements may be\n     * returned after the stream has been closed.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after this method has returned, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directory is closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   dir  The path to the directory\n     *\n     * @return  The {@code Stream} describing the content of the\n     *          directory\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs when opening the directory\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     *\n     * @see     #newDirectoryStream(Path)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e list(Path dir) throws IOException {\n        DirectoryStream\u003cPath\u003e ds \u003d Files.newDirectoryStream(dir);\n        try {\n            final Iterator\u003cPath\u003e delegate \u003d ds.iterator();\n\n            // Re-wrap DirectoryIteratorException to UncheckedIOException\n            Iterator\u003cPath\u003e iterator \u003d new Iterator\u003c\u003e() {\n                @Override\n                public boolean hasNext() {\n                    try {\n                        return delegate.hasNext();\n                    } catch (DirectoryIteratorException e) {\n                        throw new UncheckedIOException(e.getCause());\n                    }\n                }\n                @Override\n                public Path next() {\n                    try {\n                        return delegate.next();\n                    } catch (DirectoryIteratorException e) {\n                        throw new UncheckedIOException(e.getCause());\n                    }\n                }\n            };\n\n            Spliterator\u003cPath\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(asUncheckedRunnable(ds));\n        } catch (Error|RuntimeException e) {\n            try {\n                ds.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {}\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by walking the file tree rooted at a given starting file.  The\n     * file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\n     * are {@link Path} objects that are obtained as if by {@link\n     * Path#resolve(Path) resolving} the relative path against {@code start}.\n     *\n     * \u003cp\u003e The {@code stream} walks the file tree as elements are consumed.\n     * The {@code Stream} returned is guaranteed to have at least one\n     * element, the starting file itself. For each file visited, the stream\n     * attempts to read its {@link BasicFileAttributes}. If the file is a\n     * directory and can be opened successfully, entries in the directory, and\n     * their \u003cem\u003edescendants\u003c/em\u003e will follow the directory in the stream as\n     * they are encountered. When all entries have been visited, then the\n     * directory is closed. The file tree walk then continues at the next\n     * \u003cem\u003esibling\u003c/em\u003e of the directory.\n     *\n     * \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It does not freeze the\n     * file tree while iterating, so it may (or may not) reflect updates to\n     * the file tree that occur after returned from this method.\n     *\n     * \u003cp\u003e By default, symbolic links are not automatically followed by this\n     * method. If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\n     * followed. When following links, and the attributes of the target cannot\n     * be read, then this method attempts to get the {@code BasicFileAttributes}\n     * of the link.\n     *\n     * \u003cp\u003e If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then the stream keeps\n     * track of directories visited so that cycles can be detected. A cycle\n     * arises when there is an entry in a directory that is an ancestor of the\n     * directory. Cycle detection is done by recording the {@link\n     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\n     * or if file keys are not available, by invoking the {@link #isSameFile\n     * isSameFile} method to test if a directory is the same file as an\n     * ancestor. When a cycle is detected it is treated as an I/O error with\n     * an instance of {@link FileSystemLoopException}.\n     *\n     * \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\n     * directories to visit. A value of {@code 0} means that only the starting\n     * file is visited, unless denied by the security manager. A value of\n     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\n     * levels should be visited.\n     *\n     * \u003cp\u003e When a security manager is installed and it denies access to a file\n     * (or directory), then it is ignored and not included in the stream.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after this method has returned, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   maxDepth\n     *          the maximum number of directory levels to visit\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e walk(Path start,\n                                    int maxDepth,\n                                    FileVisitOption... options)\n        throws IOException\n    {\n        FileTreeIterator iterator \u003d new FileTreeIterator(start, maxDepth, options);\n        try {\n            Spliterator\u003cFileTreeWalker.Event\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(iterator::close)\n                                .map(entry -\u003e entry.file());\n        } catch (Error|RuntimeException e) {\n            iterator.close();\n            throw e;\n        }\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by walking the file tree rooted at a given starting file.  The\n     * file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\n     * are {@link Path} objects that are obtained as if by {@link\n     * Path#resolve(Path) resolving} the relative path against {@code start}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * walk(Path, int, FileVisitOption...)\n     * Files.walk(start, Integer.MAX_VALUE, options)\n     * }\u003c/blockquote\u003e\n     * In other words, it visits all levels of the file tree.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     *\n     * @see     #walk(Path, int, FileVisitOption...)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e walk(Path start, FileVisitOption... options) throws IOException {\n        return walk(start, Integer.MAX_VALUE, options);\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by searching for files in a file tree rooted at a given starting\n     * file.\n     *\n     * \u003cp\u003e This method walks the file tree in exactly the manner specified by\n     * the {@link #walk walk} method. For each file encountered, the given\n     * {@link BiPredicate} is invoked with its {@link Path} and {@link\n     * BasicFileAttributes}. The {@code Path} object is obtained as if by\n     * {@link Path#resolve(Path) resolving} the relative path against {@code\n     * start} and is only included in the returned {@link Stream} if\n     * the {@code BiPredicate} returns true. Compare to calling {@link\n     * java.util.stream.Stream#filter filter} on the {@code Stream}\n     * returned by {@code walk} method, this method may be more efficient by\n     * avoiding redundant retrieval of the {@code BasicFileAttributes}.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after returned from this method, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   maxDepth\n     *          the maximum number of directory levels to search\n     * @param   matcher\n     *          the function used to decide whether a file should be included\n     *          in the returned stream\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     *\n     * @see     #walk(Path, int, FileVisitOption...)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e find(Path start,\n                                    int maxDepth,\n                                    BiPredicate\u003cPath, BasicFileAttributes\u003e matcher,\n                                    FileVisitOption... options)\n        throws IOException\n    {\n        FileTreeIterator iterator \u003d new FileTreeIterator(start, maxDepth, options);\n        try {\n            Spliterator\u003cFileTreeWalker.Event\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(iterator::close)\n                                .filter(entry -\u003e matcher.test(entry.file(), entry.attributes()))\n                                .map(entry -\u003e entry.file());\n        } catch (Error|RuntimeException e) {\n            iterator.close();\n            throw e;\n        }\n    }\n\n\n    /**\n     * Read all lines from a file as a {@code Stream}. Unlike {@link\n     * #readAllLines(Path, Charset) readAllLines}, this method does not read\n     * all lines into a {@code List}, but instead populates lazily as the stream\n     * is consumed.\n     *\n     * \u003cp\u003e Bytes from the file are decoded into characters using the specified\n     * charset and the same line terminators as specified by {@code\n     * readAllLines} are supported.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open file. The file\n     * is closed by closing the stream.\n     *\n     * \u003cp\u003e The file contents should not be modified during the execution of the\n     * terminal stream operation. Otherwise, the result of the terminal stream\n     * operation is undefined.\n     *\n     * \u003cp\u003e After this method returns, then any subsequent I/O exception that\n     * occurs while reading from the file or when a malformed or unmappable byte\n     * sequence is read, is wrapped in an {@link UncheckedIOException} that will\n     * be thrown from the\n     * {@link java.util.stream.Stream} method that caused the read to take\n     * place. In case an {@code IOException} is thrown when closing the file,\n     * it is also wrapped as an {@code UncheckedIOException}.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open file is closed promptly\n     * after the stream\u0027s operations have completed.\n     *\n     * @implNote\n     * This implementation supports good parallel stream performance for the\n     * standard charsets {@link StandardCharsets#UTF_8 UTF-8},\n     * {@link StandardCharsets#US_ASCII US-ASCII} and\n     * {@link StandardCharsets#ISO_8859_1 ISO-8859-1}.  Such\n     * \u003cem\u003eline-optimal\u003c/em\u003e charsets have the property that the encoded bytes\n     * of a line feed (\u0027\\n\u0027) or a carriage return (\u0027\\r\u0027) are efficiently\n     * identifiable from other encoded characters when randomly accessing the\n     * bytes of the file.\n     *\n     * \u003cp\u003e For non-\u003cem\u003eline-optimal\u003c/em\u003e charsets the stream source\u0027s\n     * spliterator has poor splitting properties, similar to that of a\n     * spliterator associated with an iterator or that associated with a stream\n     * returned from {@link BufferedReader#lines()}.  Poor splitting properties\n     * can result in poor parallel stream performance.\n     *\n     * \u003cp\u003e For \u003cem\u003eline-optimal\u003c/em\u003e charsets the stream source\u0027s spliterator\n     * has good splitting properties, assuming the file contains a regular\n     * sequence of lines.  Good splitting properties can result in good parallel\n     * stream performance.  The spliterator for a \u003cem\u003eline-optimal\u003c/em\u003e charset\n     * takes advantage of the charset properties (a line feed or a carriage\n     * return being efficient identifiable) such that when splitting it can\n     * approximately divide the number of covered lines in half.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  the lines from the file as a {@code Stream}\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see     #readAllLines(Path, Charset)\n     * @see     #newBufferedReader(Path, Charset)\n     * @see     java.io.BufferedReader#lines()\n     * @since   1.8\n     */\n    public static Stream\u003cString\u003e lines(Path path, Charset cs) throws IOException {\n        // Use the good splitting spliterator if:\n        // 1) the path is associated with the default file system;\n        // 2) the character set is supported; and\n        // 3) the file size is such that all bytes can be indexed by int values\n        //    (this limitation is imposed by ByteBuffer)\n        if (path.getFileSystem() \u003d\u003d FileSystems.getDefault() \u0026\u0026\n            FileChannelLinesSpliterator.SUPPORTED_CHARSETS.contains(cs)) {\n            FileChannel fc \u003d FileChannel.open(path, StandardOpenOption.READ);\n\n            Stream\u003cString\u003e fcls \u003d createFileChannelLinesStream(fc, cs);\n            if (fcls !\u003d null) {\n                return fcls;\n            }\n            fc.close();\n        }\n\n        return createBufferedReaderLinesStream(Files.newBufferedReader(path, cs));\n    }\n\n    private static Stream\u003cString\u003e createFileChannelLinesStream(FileChannel fc, Charset cs) throws IOException {\n        try {\n            // Obtaining the size from the FileChannel is much faster\n            // than obtaining using path.toFile().length()\n            long length \u003d fc.size();\n            // FileChannel.size() may in certain circumstances return zero\n            // for a non-zero length file so disallow this case.\n            if (length \u003e 0 \u0026\u0026 length \u003c\u003d Integer.MAX_VALUE) {\n                FileChannelLinesSpliterator fcls \u003d\n                    new FileChannelLinesSpliterator(fc, cs, 0, (int) length);\n                return StreamSupport.stream(fcls, false)\n                        .onClose(Files.asUncheckedRunnable(fc))\n                        .onClose(() -\u003e fcls.close());\n            }\n        } catch (Error|RuntimeException|IOException e) {\n            try {\n                fc.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {\n                }\n            }\n            throw e;\n        }\n        return null;\n    }\n\n    private static Stream\u003cString\u003e createBufferedReaderLinesStream(BufferedReader br) {\n        try {\n            return br.lines().onClose(asUncheckedRunnable(br));\n        } catch (Error|RuntimeException e) {\n            try {\n                br.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {\n                }\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Read all lines from a file as a {@code Stream}. Bytes from the file are\n     * decoded into characters using the {@link StandardCharsets#UTF_8 UTF-8}\n     * {@link Charset charset}.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open file. The file\n     * is closed by closing the stream.\n     *\n     * \u003cp\u003e The file contents should not be modified during the execution of the\n     * terminal stream operation. Otherwise, the result of the terminal stream\n     * operation is undefined.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * lines(Path, Charset)\n     * Files.lines(path, StandardCharsets.UTF_8)\n     * }\u003c/blockquote\u003e\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open file is closed promptly\n     * after the stream\u0027s operations have completed.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the lines from the file as a {@code Stream}\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static Stream\u003cString\u003e lines(Path path) throws IOException {\n        return lines(path, UTF_8.INSTANCE);\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

Π°ΠΏΡ€. 25, 2024 4:26:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/nio/file/Files.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.04.25 16:26:37 INFO  compiling bestgame (1 scala source)
2024.04.25 16:26:37 INFO  time: compiled bestgame in 97ms
2024.04.25 16:26:38 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1570)
```

Π°ΠΏΡ€. 25, 2024 4:26:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/nio/file/Files.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2007, 2023, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.nio.file;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.UncheckedIOException;\nimport java.io.Writer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.attribute.BasicFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.attribute.DosFileAttributes;   // javadoc\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.FileAttributeView;\nimport java.nio.file.attribute.FileOwnerAttributeView;\nimport java.nio.file.attribute.FileStoreAttributeView;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributeView;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.UserPrincipal;\nimport java.nio.file.spi.FileSystemProvider;\nimport java.nio.file.spi.FileTypeDetector;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.ServiceLoader;\nimport java.util.Set;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.function.BiPredicate;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.util.ArraysSupport;\nimport sun.nio.ch.FileChannelImpl;\nimport sun.nio.cs.UTF_8;\n\n/**\n * This class consists exclusively of static methods that operate on files,\n * directories, or other types of files.\n *\n * \u003cp\u003e In most cases, the methods defined here will delegate to the associated\n * file system provider to perform the file operations.\n *\n * @since 1.7\n */\n\npublic final class Files {\n    // buffer size used for reading and writing\n    private static final int BUFFER_SIZE \u003d 8192;\n\n    private Files() { }\n\n    /**\n     * Returns the {@code FileSystemProvider} to delegate to.\n     */\n    private static FileSystemProvider provider(Path path) {\n        return path.getFileSystem().provider();\n    }\n\n    /**\n     * Convert a Closeable to a Runnable by converting checked IOException\n     * to UncheckedIOException\n     */\n    private static Runnable asUncheckedRunnable(Closeable c) {\n        return () -\u003e {\n            try {\n                c.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n    }\n\n    // -- File contents --\n\n    /**\n     * Opens a file, returning an input stream to read from the file. The stream\n     * will not be buffered, and is not required to support the {@link\n     * InputStream#mark mark} or {@link InputStream#reset reset} methods. The\n     * stream will be safe for access by multiple concurrent threads. Reading\n     * commences at the beginning of the file. Whether the returned stream is\n     * \u003ci\u003easynchronously closeable\u003c/i\u003e and/or \u003ci\u003einterruptible\u003c/i\u003e is highly\n     * file system provider specific and therefore not specified.\n     *\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\n     * If no options are present then it is equivalent to opening the file with\n     * the {@link StandardOpenOption#READ READ} option. In addition to the {@code\n     * READ} option, an implementation may also support additional implementation\n     * specific options.\n     *\n     * @param   path\n     *          the path to the file to open\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new input stream\n     *\n     * @throws  IllegalArgumentException\n     *          if an invalid combination of options is specified\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static InputStream newInputStream(Path path, OpenOption... options)\n        throws IOException\n    {\n        return provider(path).newInputStream(path, options);\n    }\n\n    /**\n     * Opens or creates a file, returning an output stream that may be used to\n     * write bytes to the file. The resulting stream will not be buffered. The\n     * stream will be safe for access by multiple concurrent threads. Whether\n     * the returned stream is \u003ci\u003easynchronously closeable\u003c/i\u003e and/or\n     * \u003ci\u003einterruptible\u003c/i\u003e is highly file system provider specific and\n     * therefore not specified.\n     *\n     * \u003cp\u003e This method opens or creates a file in exactly the manner specified\n     * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\n     * method with the exception that the {@link StandardOpenOption#READ READ}\n     * option may not be present in the array of options. If no options are\n     * present then this method works as if the {@link StandardOpenOption#CREATE\n     * CREATE}, {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING},\n     * and {@link StandardOpenOption#WRITE WRITE} options are present. In other\n     * words, it opens the file for writing, creating the file if it doesn\u0027t\n     * exist, or initially truncating an existing {@link #isRegularFile\n     * regular-file} to a size of {@code 0} if it exists.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *\n     *     // truncate and overwrite an existing file, or create the file if\n     *     // it doesn\u0027t initially exist\n     *     OutputStream out \u003d Files.newOutputStream(path);\n     *\n     *     // append to an existing file, fail if the file does not exist\n     *     out \u003d Files.newOutputStream(path, APPEND);\n     *\n     *     // append to an existing file, create file if it doesn\u0027t initially exist\n     *     out \u003d Files.newOutputStream(path, CREATE, APPEND);\n     *\n     *     // always create new file, failing if it already exists\n     *     out \u003d Files.newOutputStream(path, CREATE_NEW);\n     * }\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new output stream\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static OutputStream newOutputStream(Path path, OpenOption... options)\n        throws IOException\n    {\n        return provider(path).newOutputStream(path, options);\n    }\n\n    /**\n     * Opens or creates a file, returning a seekable byte channel to access the\n     * file.\n     *\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\n     * The {@link StandardOpenOption#READ READ} and {@link\n     * StandardOpenOption#WRITE WRITE} options determine if the file should be\n     * opened for reading and/or writing. If neither option (or the {@link\n     * StandardOpenOption#APPEND APPEND} option) is present then the file is\n     * opened for reading. By default reading or writing commence at the\n     * beginning of the file.\n     *\n     * \u003cp\u003e In the addition to {@code READ} and {@code WRITE}, the following\n     * options may be present:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#APPEND APPEND} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then the file is opened for writing and\n     *     each invocation of the channel\u0027s {@code write} method first advances\n     *     the position to the end of the file and then writes the requested\n     *     data. Whether the advancement of the position and the writing of the\n     *     data are done in a single atomic operation is system-dependent and\n     *     therefore unspecified. This option may not be used in conjunction\n     *     with the {@code READ} or {@code TRUNCATE_EXISTING} options. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then the existing file is truncated to\n     *   a size of 0 bytes. This option is ignored when the file is opened only\n     *   for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#CREATE_NEW CREATE_NEW} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then a new file is created, failing if\n     *   the file already exists or is a symbolic link. When creating a file the\n     *   check for the existence of the file and the creation of the file if it\n     *   does not exist is atomic with respect to other file system operations.\n     *   This option is ignored when the file is opened only for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\" \u003e {@link StandardOpenOption#CREATE CREATE} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then an existing file is opened if it\n     *   exists, otherwise a new file is created. This option is ignored if the\n     *   {@code CREATE_NEW} option is also present or the file is opened only\n     *   for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\" \u003e {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} \u003c/th\u003e\n     *   \u003ctd\u003e When this option is present then the implementation makes a\n     *   \u003cem\u003ebest effort\u003c/em\u003e attempt to delete the file when closed by the\n     *   {@link SeekableByteChannel#close close} method. If the {@code close}\n     *   method is not invoked then a \u003cem\u003ebest effort\u003c/em\u003e attempt is made to\n     *   delete the file when the Java virtual machine terminates. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e{@link StandardOpenOption#SPARSE SPARSE} \u003c/th\u003e\n     *   \u003ctd\u003e When creating a new file this option is a \u003cem\u003ehint\u003c/em\u003e that the\n     *   new file will be sparse. This option is ignored when not creating\n     *   a new file. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#SYNC SYNC} \u003c/th\u003e\n     *   \u003ctd\u003e Requires that every update to the file\u0027s content or metadata be\n     *   written synchronously to the underlying storage device. (see \u003ca\n     *   href\u003d\"package-summary.html#integrity\"\u003e Synchronized I/O file\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#DSYNC DSYNC} \u003c/th\u003e\n     *   \u003ctd\u003e Requires that every update to the file\u0027s content be written\n     *   synchronously to the underlying storage device. (see \u003ca\n     *   href\u003d\"package-summary.html#integrity\"\u003e Synchronized I/O file\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation may also support additional implementation specific\n     * options.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when a new file is created.\n     *\n     * \u003cp\u003e In the case of the default provider, the returned seekable byte channel\n     * is a {@link java.nio.channels.FileChannel}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *\n     *     // open file for reading\n     *     ReadableByteChannel rbc \u003d Files.newByteChannel(path, EnumSet.of(READ)));\n     *\n     *     // open file for writing to the end of an existing file, creating\n     *     // the file if it doesn\u0027t already exist\n     *     WritableByteChannel wbc \u003d Files.newByteChannel(path, EnumSet.of(CREATE,APPEND));\n     *\n     *     // create file with initial permissions, opening it for both reading and writing\n     *     FileAttribute\u003cSet\u003cPosixFilePermission\u003e\u003e perms \u003d ...\n     *     SeekableByteChannel sbc \u003d\n     *         Files.newByteChannel(path, EnumSet.of(CREATE_NEW,READ,WRITE), perms);\n     * }\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  a new seekable byte channel\n     *\n     * @throws  IllegalArgumentException\n     *          if the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported open option is specified or the array contains\n     *          attributes that cannot be set atomically when creating the file\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          and the file is being opened for writing \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the path if the file is\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method is invoked to check write access to the path\n     *          if the file is opened for writing. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see java.nio.channels.FileChannel#open(Path,Set,FileAttribute[])\n     */\n    public static SeekableByteChannel newByteChannel(Path path,\n                                                     Set\u003c? extends OpenOption\u003e options,\n                                                     FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return provider(path).newByteChannel(path, options, attrs);\n    }\n\n    /**\n     * Opens or creates a file, returning a seekable byte channel to access the\n     * file.\n     *\n     * \u003cp\u003e This method opens or creates a file in exactly the manner specified\n     * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\n     * method.\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new seekable byte channel\n     *\n     * @throws  IllegalArgumentException\n     *          if the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported open option is specified\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          and the file is being opened for writing \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the path if the file is\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method is invoked to check write access to the path\n     *          if the file is opened for writing. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see java.nio.channels.FileChannel#open(Path,OpenOption[])\n     */\n    public static SeekableByteChannel newByteChannel(Path path, OpenOption... options)\n        throws IOException\n    {\n        Set\u003cOpenOption\u003e set;\n        if (options.length \u003d\u003d 0) {\n            set \u003d Collections.emptySet();\n        } else {\n            set \u003d new HashSet\u003c\u003e();\n            Collections.addAll(set, options);\n        }\n        return newByteChannel(path, set);\n    }\n\n    // -- Directories --\n\n    private static class AcceptAllFilter\n        implements DirectoryStream.Filter\u003cPath\u003e\n    {\n        private AcceptAllFilter() { }\n\n        @Override\n        public boolean accept(Path entry) { return true; }\n\n        static final AcceptAllFilter FILTER \u003d new AcceptAllFilter();\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * all entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * @param   dir\n     *          the path to the directory\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir)\n        throws IOException\n    {\n        return provider(dir).newDirectoryStream(dir, AcceptAllFilter.FILTER);\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * the entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}. The entries returned by\n     * the iterator are filtered by matching the {@code String} representation\n     * of their file names against the given \u003cem\u003eglobbing\u003c/em\u003e pattern.\n     *\n     * \u003cp\u003e For example, suppose we want to iterate over the files ending with\n     * \".java\" in a directory:\n     * {@snippet lang\u003djava :\n     *     Path dir \u003d ...\n     *     try (DirectoryStream\u003cPath\u003e stream \u003d Files.newDirectoryStream(dir, \"*.java\")) {\n     *         :\n     *     }\n     * }\n     *\n     * \u003cp\u003e The globbing pattern is specified by the {@link\n     * FileSystem#getPathMatcher getPathMatcher} method.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * @param   dir\n     *          the path to the directory\n     * @param   glob\n     *          the glob pattern\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  java.util.regex.PatternSyntaxException\n     *          if the pattern is invalid\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, String glob)\n        throws IOException\n    {\n        // avoid creating a matcher if all entries are required.\n        if (glob.equals(\"*\"))\n            return newDirectoryStream(dir);\n\n        // create a matcher and return a filter that uses it.\n        FileSystem fs \u003d dir.getFileSystem();\n        final PathMatcher matcher \u003d fs.getPathMatcher(\"glob:\" + glob);\n        DirectoryStream.Filter\u003cPath\u003e filter \u003d new DirectoryStream.Filter\u003c\u003e() {\n            @Override\n            public boolean accept(Path entry)  {\n                return matcher.matches(entry.getFileName());\n            }\n        };\n        return fs.provider().newDirectoryStream(dir, filter);\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * the entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}. The entries returned by\n     * the iterator are filtered by the given {@link DirectoryStream.Filter\n     * filter}.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e Where the filter terminates due to an uncaught error or runtime\n     * exception then it is propagated to the {@link Iterator#hasNext()\n     * hasNext} or {@link Iterator#next() next} method. Where an {@code\n     * IOException} is thrown, it results in the {@code hasNext} or {@code\n     * next} method throwing a {@link DirectoryIteratorException} with the\n     * {@code IOException} as the cause.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to iterate over the files in a directory that are\n     * larger than 8K.\n     * {@snippet lang\u003djava :\n     *     DirectoryStream.Filter\u003cPath\u003e filter \u003d new DirectoryStream.Filter\u003cPath\u003e() {\n     *         public boolean accept(Path file) throws IOException {\n     *             return (Files.size(file) \u003e 8192L);\n     *         }\n     *     };\n     *     Path dir \u003d ...\n     *     try (DirectoryStream\u003cPath\u003e stream \u003d Files.newDirectoryStream(dir, filter)) {\n     *         :\n     *     }\n     * }\n     *\n     * @param   dir\n     *          the path to the directory\n     * @param   filter\n     *          the directory stream filter\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir,\n                                                           DirectoryStream.Filter\u003c? super Path\u003e filter)\n        throws IOException\n    {\n        return provider(dir).newDirectoryStream(dir, filter);\n    }\n\n    // -- Creation and deletion --\n\n    private static final Set\u003cOpenOption\u003e DEFAULT_CREATE_OPTIONS \u003d\n        Set.of(StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE);\n\n    /**\n     * Creates a new and empty file, failing if the file already exists. The\n     * check for the existence of the file and the creation of the new file if\n     * it does not exist are a single operation that is atomic with respect to\n     * all other filesystem activities that might affect the directory.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the file. Each attribute\n     * is identified by its {@link FileAttribute#name name}. If more than one\n     * attribute of the same name is included in the array then all but the last\n     * occurrence is ignored.\n     *\n     * @param   path\n     *          the path to the file to create\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the file\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs or the parent directory does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the new file.\n     */\n    public static Path createFile(Path path, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        newByteChannel(path, DEFAULT_CREATE_OPTIONS, attrs).close();\n        return path;\n    }\n\n    /**\n     * Creates a new directory. The check for the existence of the file and the\n     * creation of the directory if it does not exist are a single operation\n     * that is atomic with respect to all other filesystem activities that might\n     * affect the directory. The {@link #createDirectories createDirectories}\n     * method should be used where it is required to create all nonexistent\n     * parent directories first.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the directory. Each\n     * attribute is identified by its {@link FileAttribute#name name}. If more\n     * than one attribute of the same name is included in the array then all but\n     * the last occurrence is ignored.\n     *\n     * @param   dir\n     *          the directory to create\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the directory\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  FileAlreadyExistsException\n     *          if a directory could not otherwise be created because a file of\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs or the parent directory does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the new directory.\n     */\n    public static Path createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        provider(dir).createDirectory(dir, attrs);\n        return dir;\n    }\n\n    /**\n     * Creates a directory by creating all nonexistent parent directories first.\n     * Unlike the {@link #createDirectory createDirectory} method, an exception\n     * is not thrown if the directory could not be created because it already\n     * exists.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the nonexistent\n     * directories. Each file attribute is identified by its {@link\n     * FileAttribute#name name}. If more than one attribute of the same name is\n     * included in the array then all but the last occurrence is ignored.\n     *\n     * \u003cp\u003e If this method fails, then it may do so after creating some, but not\n     * all, of the parent directories.\n     *\n     * @param   dir\n     *          the directory to create\n     *\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the directory\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  FileAlreadyExistsException\n     *          if {@code dir} exists but is not a directory \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          in the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked prior to attempting to create a directory and\n     *          its {@link SecurityManager#checkRead(String) checkRead} is\n     *          invoked for each parent directory that is checked. If {@code\n     *          dir} is not an absolute path then its {@link Path#toAbsolutePath\n     *          toAbsolutePath} may need to be invoked to get its absolute path.\n     *          This may invoke the security manager\u0027s {@link\n     *          SecurityManager#checkPropertyAccess(String) checkPropertyAccess}\n     *          method to check access to the system property {@code user.dir}\n     */\n    public static Path createDirectories(Path dir, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        // attempt to create the directory\n        try {\n            createAndCheckIsDirectory(dir, attrs);\n            return dir;\n        } catch (FileAlreadyExistsException x) {\n            // file exists and is not a directory\n            throw x;\n        } catch (IOException x) {\n            // parent may not exist or other reason\n        }\n        SecurityException se \u003d null;\n        Path absDir \u003d dir;\n        try {\n            absDir \u003d dir.toAbsolutePath();\n        } catch (SecurityException x) {\n            // don\u0027t have permission to get absolute path\n            se \u003d x;\n        }\n        // find a descendant that exists\n        Path parent \u003d absDir.getParent();\n        while (parent !\u003d null) {\n            try {\n                provider(parent).checkAccess(parent);\n                break;\n            } catch (NoSuchFileException x) {\n                // does not exist\n            }\n            parent \u003d parent.getParent();\n        }\n        if (parent \u003d\u003d null) {\n            // unable to find existing parent\n            if (se \u003d\u003d null) {\n                throw new FileSystemException(absDir.toString(), null,\n                    \"Unable to determine if root directory exists\");\n            } else {\n                throw se;\n            }\n        }\n\n        // create directories\n        Path child \u003d parent;\n        for (Path name: parent.relativize(absDir)) {\n            child \u003d child.resolve(name);\n            createAndCheckIsDirectory(child, attrs);\n        }\n        return dir;\n    }\n\n    /**\n     * Used by createDirectories to attempt to create a directory. A no-op\n     * if the directory already exists.\n     */\n    private static void createAndCheckIsDirectory(Path dir,\n                                                  FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        try {\n            createDirectory(dir, attrs);\n        } catch (FileAlreadyExistsException x) {\n            if (!isDirectory(dir))\n                throw x;\n        }\n    }\n\n    /**\n     * Creates a new empty file in the specified directory, using the given\n     * prefix and suffix strings to generate its name. The resulting\n     * {@code Path} is associated with the same {@code FileSystem} as the given\n     * directory.\n     *\n     * \u003cp\u003e The details as to how the name of the file is constructed is\n     * implementation dependent and therefore not specified. Where possible\n     * the {@code prefix} and {@code suffix} are used to construct candidate\n     * names in the same manner as the {@link\n     * java.io.File#createTempFile(String,String,File)} method.\n     *\n     * \u003cp\u003e As with the {@code File.createTempFile} methods, this method is only\n     * part of a temporary-file facility. Where used as a \u003cem\u003ework file\u003c/em\u003e,\n     * the resulting file may be opened using the {@link\n     * StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} option so that the\n     * file is deleted when the appropriate {@code close} method is invoked.\n     * Alternatively, a {@link Runtime#addShutdownHook shutdown-hook}, or the\n     * {@link java.io.File#deleteOnExit} mechanism may be used to delete the\n     * file automatically.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the file. Each attribute\n     * is identified by its {@link FileAttribute#name name}. If more than one\n     * attribute of the same name is included in the array then all but the last\n     * occurrence is ignored. When no file attributes are specified, then the\n     * resulting file may have more restrictive access permissions to files\n     * created by the {@link java.io.File#createTempFile(String,String,File)}\n     * method.\n     *\n     * @param   dir\n     *          the path to directory in which to create the file\n     * @param   prefix\n     *          the prefix string to be used in generating the file\u0027s name;\n     *          may be {@code null}\n     * @param   suffix\n     *          the suffix string to be used in generating the file\u0027s name;\n     *          may be {@code null}, in which case \"{@code .tmp}\" is used\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the path to the newly created file that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix or suffix parameters cannot be used to generate\n     *          a candidate file name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or {@code dir} does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file.\n     */\n    public static Path createTempFile(Path dir,\n                                      String prefix,\n                                      String suffix,\n                                      FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempFile(Objects.requireNonNull(dir),\n                                             prefix, suffix, attrs);\n    }\n\n    /**\n     * Creates an empty file in the default temporary-file directory, using\n     * the given prefix and suffix to generate its name. The resulting {@code\n     * Path} is associated with the default {@code FileSystem}.\n     *\n     * \u003cp\u003e This method works in exactly the manner specified by the\n     * {@link #createTempFile(Path,String,String,FileAttribute[])} method for\n     * the case that the {@code dir} parameter is the temporary-file directory.\n     *\n     * @param   prefix\n     *          the prefix string to be used in generating the file\u0027s name;\n     *          may be {@code null}\n     * @param   suffix\n     *          the suffix string to be used in generating the file\u0027s name;\n     *          may be {@code null}, in which case \"{@code .tmp}\" is used\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the path to the newly created file that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix or suffix parameters cannot be used to generate\n     *          a candidate file name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or the temporary-file directory does not\n     *          exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file.\n     */\n    public static Path createTempFile(String prefix,\n                                      String suffix,\n                                      FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempFile(null, prefix, suffix, attrs);\n    }\n\n    /**\n     * Creates a new directory in the specified directory, using the given\n     * prefix to generate its name.  The resulting {@code Path} is associated\n     * with the same {@code FileSystem} as the given directory.\n     *\n     * \u003cp\u003e The details as to how the name of the directory is constructed is\n     * implementation dependent and therefore not specified. Where possible\n     * the {@code prefix} is used to construct candidate names.\n     *\n     * \u003cp\u003e As with the {@code createTempFile} methods, this method is only\n     * part of a temporary-file facility. A {@link Runtime#addShutdownHook\n     * shutdown-hook}, or the {@link java.io.File#deleteOnExit} mechanism may be\n     * used to delete the directory automatically.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the directory. Each\n     * attribute is identified by its {@link FileAttribute#name name}. If more\n     * than one attribute of the same name is included in the array then all but\n     * the last occurrence is ignored.\n     *\n     * @param   dir\n     *          the path to directory in which to create the directory\n     * @param   prefix\n     *          the prefix string to be used in generating the directory\u0027s name;\n     *          may be {@code null}\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the path to the newly created directory that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix cannot be used to generate a candidate directory name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or {@code dir} does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access when creating the\n     *          directory.\n     */\n    public static Path createTempDirectory(Path dir,\n                                           String prefix,\n                                           FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempDirectory(Objects.requireNonNull(dir),\n                                                  prefix, attrs);\n    }\n\n    /**\n     * Creates a new directory in the default temporary-file directory, using\n     * the given prefix to generate its name. The resulting {@code Path} is\n     * associated with the default {@code FileSystem}.\n     *\n     * \u003cp\u003e This method works in exactly the manner specified by {@link\n     * #createTempDirectory(Path,String,FileAttribute[])} method for the case\n     * that the {@code dir} parameter is the temporary-file directory.\n     *\n     * @param   prefix\n     *          the prefix string to be used in generating the directory\u0027s name;\n     *          may be {@code null}\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the path to the newly created directory that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix cannot be used to generate a candidate directory name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or the temporary-file directory does not\n     *          exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access when creating the\n     *          directory.\n     */\n    public static Path createTempDirectory(String prefix,\n                                           FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempDirectory(null, prefix, attrs);\n    }\n\n    /**\n     * Creates a symbolic link to a target \u003ci\u003e(optional operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e The {@code target} parameter is the target of the link. It may be an\n     * {@link Path#isAbsolute absolute} or relative path and may not exist. When\n     * the target is a relative path then file system operations on the resulting\n     * link are relative to the path of the link.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * attributes} to set atomically when creating the link. Each attribute is\n     * identified by its {@link FileAttribute#name name}. If more than one attribute\n     * of the same name is included in the array then all but the last occurrence\n     * is ignored.\n     *\n     * \u003cp\u003e Where symbolic links are supported, but the underlying {@link FileStore}\n     * does not support symbolic links, then this may fail with an {@link\n     * IOException}. Additionally, some operating systems may require that the\n     * Java virtual machine be started with implementation specific privileges to\n     * create symbolic links, in which case this method may throw {@code IOException}.\n     *\n     * @param   link\n     *          the path of the symbolic link to create\n     * @param   target\n     *          the target of the symbolic link\n     * @param   attrs\n     *          the array of attributes to set atomically when creating the\n     *          symbolic link\n     *\n     * @return  the path to the symbolic link\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support symbolic links or the\n     *          array contains an attribute that cannot be set atomically when\n     *          creating the symbolic link\n     * @throws  FileAlreadyExistsException\n     *          if a file with the name already exists \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it denies {@link LinkPermission}{@code (\"symbolic\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the path of the symbolic link.\n     */\n    public static Path createSymbolicLink(Path link, Path target,\n                                          FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        provider(link).createSymbolicLink(link, target, attrs);\n        return link;\n    }\n\n    /**\n     * Creates a new link (directory entry) for an existing file \u003ci\u003e(optional\n     * operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e The {@code link} parameter locates the directory entry to create.\n     * The {@code existing} parameter is the path to an existing file. This\n     * method creates a new directory entry for the file so that it can be\n     * accessed using {@code link} as the path. On some file systems this is\n     * known as creating a \"hard link\". Whether the file attributes are\n     * maintained for the file or for each directory entry is file system\n     * specific and therefore not specified. Typically, a file system requires\n     * that all links (directory entries) for a file be on the same file system.\n     * Furthermore, on some platforms, the Java virtual machine may require to\n     * be started with implementation specific privileges to create hard links\n     * or to create links to directories.\n     *\n     * @param   link\n     *          the link (directory entry) to create\n     * @param   existing\n     *          a path to an existing file\n     *\n     * @return  the path to the link (directory entry)\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support adding an existing file\n     *          to a directory\n     * @throws  FileAlreadyExistsException\n     *          if the entry could not otherwise be created because a file of\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it denies {@link LinkPermission}{@code (\"hard\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to either the link or the\n     *          existing file.\n     */\n    public static Path createLink(Path link, Path existing) throws IOException {\n        provider(link).createLink(link, existing);\n        return link;\n    }\n\n    /**\n     * Deletes a file.\n     *\n     * \u003cp\u003e An implementation may require to examine the file to determine if the\n     * file is a directory. Consequently this method may not be atomic with respect\n     * to other file system operations.  If the file is a symbolic link then the\n     * symbolic link itself, not the final target of the link, is deleted.\n     *\n     * \u003cp\u003e If the file is a directory then the directory must be empty. In some\n     * implementations a directory has entries for special files or links that\n     * are created when the directory is created. In such implementations a\n     * directory is considered empty when only the special entries exist.\n     * This method can be used with the {@link #walkFileTree walkFileTree}\n     * method to delete a directory and all entries in the directory, or an\n     * entire \u003ci\u003efile-tree\u003c/i\u003e where required.\n     *\n     * \u003cp\u003e On some operating systems it may not be possible to remove a file when\n     * it is open and in use by this Java virtual machine or other programs.\n     *\n     * @param   path\n     *          the path to the file to delete\n     *\n     * @throws  NoSuchFileException\n     *          if the file does not exist \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          if the file is a directory and could not otherwise be deleted\n     *          because the directory is not empty \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\n     *          is invoked to check delete access to the file\n     */\n    public static void delete(Path path) throws IOException {\n        provider(path).delete(path);\n    }\n\n    /**\n     * Deletes a file if it exists.\n     *\n     * \u003cp\u003e As with the {@link #delete(Path) delete(Path)} method, an\n     * implementation may need to examine the file to determine if the file is a\n     * directory. Consequently this method may not be atomic with respect to\n     * other file system operations.  If the file is a symbolic link, then the\n     * symbolic link itself, not the final target of the link, is deleted.\n     *\n     * \u003cp\u003e If the file is a directory then the directory must be empty. In some\n     * implementations a directory has entries for special files or links that\n     * are created when the directory is created. In such implementations a\n     * directory is considered empty when only the special entries exist.\n     *\n     * \u003cp\u003e On some operating systems it may not be possible to remove a file when\n     * it is open and in use by this Java virtual machine or other programs.\n     *\n     * @param   path\n     *          the path to the file to delete\n     *\n     * @return  {@code true} if the file was deleted by this method; {@code\n     *          false} if the file could not be deleted because it did not\n     *          exist\n     *\n     * @throws  DirectoryNotEmptyException\n     *          if the file is a directory and could not otherwise be deleted\n     *          because the directory is not empty \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\n     *          is invoked to check delete access to the file.\n     */\n    public static boolean deleteIfExists(Path path) throws IOException {\n        return provider(path).deleteIfExists(path);\n    }\n\n    // -- Copying and moving files --\n\n    /**\n     * Copy a file to a target file.\n     *\n     * \u003cp\u003e This method copies a file to the target file with the {@code\n     * options} parameter specifying how the copy is performed. By default, the\n     * copy fails if the target file already exists or is a symbolic link,\n     * except if the source and target are the {@link #isSameFile same} file, in\n     * which case the method completes without copying the file. File attributes\n     * are not required to be copied to the target file. If symbolic links are\n     * supported, and the file is a symbolic link, then the final target of the\n     * link is copied. If the file is a directory then an empty directory is\n     * created in the target location (entries in the directory are not\n     * copied). This method can be used with the {@link #walkFileTree\n     * walkFileTree} method to copy a directory and all entries in the directory,\n     * or an entire \u003ci\u003efile-tree\u003c/i\u003e where required.\n     *\n     * \u003cp\u003e The {@code options} parameter may include any of the following:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e Replace an existing file. A non-empty directory cannot be\n     *     replaced. If the target file exists and is a symbolic link, then the\n     *     symbolic link itself, not the target of the link, is replaced. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#COPY_ATTRIBUTES COPY_ATTRIBUTES} \u003c/th\u003e\n     *   \u003ctd\u003e Attempts to copy the file attributes associated with this file to\n     *     the target file. The exact file attributes that are copied is platform\n     *     and file system dependent and therefore unspecified. Minimally, the\n     *     {@link BasicFileAttributes#lastModifiedTime last-modified-time} is\n     *     copied to the target file if supported by both the source and target\n     *     file stores. Copying of file timestamps may result in precision\n     *     loss. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} \u003c/th\u003e\n     *   \u003ctd\u003e Symbolic links are not followed. If the file is a symbolic link,\n     *     then the symbolic link itself, not the target of the link, is copied.\n     *     It is implementation specific if file attributes can be copied to the\n     *     new link. In other words, the {@code COPY_ATTRIBUTES} option may be\n     *     ignored when copying a symbolic link. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation of this interface may support additional\n     * implementation specific options.\n     *\n     * \u003cp\u003e Copying a file is not an atomic operation. If an {@link IOException}\n     * is thrown, then it is possible that the target file is incomplete or some\n     * of its file attributes have not been copied from the source file. When\n     * the {@code REPLACE_EXISTING} option is specified and the target file\n     * exists, then the target file is replaced. The check for the existence of\n     * the file and the creation of the new file may not be atomic with respect\n     * to other file system activities.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to copy a file into a directory, giving it the same file\n     * name as the source file:\n     * {@snippet lang\u003djava :\n     *     Path source \u003d ...\n     *     Path newdir \u003d ...\n     *     Files.copy(source, newdir.resolve(source.getFileName());\n     * }\n     *\n     * @param   source\n     *          the path to the file to copy\n     * @param   target\n     *          the path to the target file (may be associated with a different\n     *          provider to the source path)\n     * @param   options\n     *          options specifying how the copy should be done\n     *\n     * @return  the path to the target file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains a copy option that is not supported\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the source file, the\n     *          {@link SecurityManager#checkWrite(String) checkWrite} is invoked\n     *          to check write access to the target file. If a symbolic link is\n     *          copied the security manager is invoked to check {@link\n     *          LinkPermission}{@code (\"symbolic\")}.\n     */\n    public static Path copy(Path source, Path target, CopyOption... options)\n        throws IOException\n    {\n        FileSystemProvider provider \u003d provider(source);\n        if (provider(target) \u003d\u003d provider) {\n            // same provider\n            provider.copy(source, target, options);\n        } else {\n            // different providers\n            CopyMoveHelper.copyToForeignTarget(source, target, options);\n        }\n        return target;\n    }\n\n    /**\n     * Move or rename a file to a target file.\n     *\n     * \u003cp\u003e By default, this method attempts to move the file to the target\n     * file, failing if the target file exists except if the source and\n     * target are the {@link #isSameFile same} file, in which case this method\n     * has no effect. If the file is a symbolic link then the symbolic link\n     * itself, not the target of the link, is moved. This method may be\n     * invoked to move an empty directory. In some implementations a directory\n     * has entries for special files or links that are created when the\n     * directory is created. In such implementations a directory is considered\n     * empty when only the special entries exist. When invoked to move a\n     * directory that is not empty then the directory is moved if it does not\n     * require moving the entries in the directory.  For example, renaming a\n     * directory on the same {@link FileStore} will usually not require moving\n     * the entries in the directory. When moving a directory requires that its\n     * entries be moved then this method fails (by throwing an {@code\n     * IOException}). To move a \u003ci\u003efile tree\u003c/i\u003e may involve copying rather\n     * than moving directories and this can be done using the {@link\n     * #copy copy} method in conjunction with the {@link\n     * #walkFileTree Files.walkFileTree} utility method.\n     *\n     * \u003cp\u003e The {@code options} parameter may include any of the following:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e Replace an existing file. A non-empty directory cannot be\n     *     replaced. If the target file exists and is a symbolic link, then the\n     *     symbolic link itself, not the target of the link, is replaced. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#ATOMIC_MOVE ATOMIC_MOVE} \u003c/th\u003e\n     *   \u003ctd\u003e The move is performed as an atomic file system operation and all\n     *     other options are ignored. If the target file exists then it is\n     *     implementation specific if the existing file is replaced or this method\n     *     fails by throwing an {@link IOException}. If the move cannot be\n     *     performed as an atomic file system operation then {@link\n     *     AtomicMoveNotSupportedException} is thrown. This can arise, for\n     *     example, when the target location is on a different {@code FileStore}\n     *     and would require that the file be copied, or target location is\n     *     associated with a different provider to this object. \u003c/td\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation of this interface may support additional\n     * implementation specific options.\n     *\n     * \u003cp\u003e Moving a file will copy the {@link\n     * BasicFileAttributes#lastModifiedTime last-modified-time} to the target\n     * file if supported by both source and target file stores. Copying of file\n     * timestamps may result in precision loss. An implementation may also\n     * attempt to copy other file attributes but is not required to fail if the\n     * file attributes cannot be copied. When the move is performed as\n     * a non-atomic operation, and an {@code IOException} is thrown, then the\n     * state of the files is not defined. The original file and the target file\n     * may both exist, the target file may be incomplete or some of its file\n     * attributes may not been copied from the original file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * Suppose we want to rename a file to \"newname\", keeping the file in the\n     * same directory:\n     * {@snippet lang\u003djava :\n     *     Path source \u003d ...\n     *     Files.move(source, source.resolveSibling(\"newname\"));\n     * }\n     * Alternatively, suppose we want to move a file to new directory, keeping\n     * the same file name, and replacing any existing file of that name in the\n     * directory:\n     * {@snippet lang\u003djava :\n     *     Path source \u003d ...\n     *     Path newdir \u003d ...\n     *     Files.move(source, newdir.resolve(source.getFileName()), REPLACE_EXISTING);\n     * }\n     *\n     * @param   source\n     *          the path to the file to move\n     * @param   target\n     *          the path to the target file (may be associated with a different\n     *          provider to the source path)\n     * @param   options\n     *          options specifying how the move should be done\n     *\n     * @return  the path to the target file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains a copy option that is not supported\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory, or the\n     *          source is a non-empty directory containing entries that would\n     *          be required to be moved \u003ci\u003e(optional specific exceptions)\u003c/i\u003e\n     * @throws  AtomicMoveNotSupportedException\n     *          if the options array contains the {@code ATOMIC_MOVE} option but\n     *          the file cannot be moved as an atomic file system operation.\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to both the source and\n     *          target file.\n     */\n    public static Path move(Path source, Path target, CopyOption... options)\n        throws IOException\n    {\n        FileSystemProvider provider \u003d provider(source);\n        if (provider(target) \u003d\u003d provider) {\n            // same provider\n            provider.move(source, target, options);\n        } else {\n            // different providers\n            CopyMoveHelper.moveToForeignTarget(source, target, options);\n        }\n        return target;\n    }\n\n    // -- Miscellaneous --\n\n    /**\n     * Reads the target of a symbolic link \u003ci\u003e(optional operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e If the file system supports \u003ca href\u003d\"package-summary.html#links\"\u003esymbolic\n     * links\u003c/a\u003e then this method is used to read the target of the link, failing\n     * if the file is not a symbolic link. The target of the link need not exist.\n     * The returned {@code Path} object will be associated with the same file\n     * system as {@code link}.\n     *\n     * @param   link\n     *          the path to the symbolic link\n     *\n     * @return  a {@code Path} object representing the target of the link\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support symbolic links\n     * @throws  NotLinkException\n     *          if the target could otherwise not be read because the file\n     *          is not a symbolic link \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it checks that {@code FilePermission} has been\n     *          granted with the \"{@code readlink}\" action to read the link.\n     */\n    public static Path readSymbolicLink(Path link) throws IOException {\n        return provider(link).readSymbolicLink(link);\n    }\n\n    /**\n     * Returns the {@link FileStore} representing the file store where a file\n     * is located.\n     *\n     * \u003cp\u003e Once a reference to the {@code FileStore} is obtained it is\n     * implementation specific if operations on the returned {@code FileStore},\n     * or {@link FileStoreAttributeView} objects obtained from it, continue\n     * to depend on the existence of the file. In particular the behavior is not\n     * defined for the case that the file is deleted or moved to a different\n     * file store.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the file store where the file is stored\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file, and in\n     *          addition it checks\n     *          {@link RuntimePermission}{@code (\"getFileStoreAttributes\")}\n     */\n    public static FileStore getFileStore(Path path) throws IOException {\n        return provider(path).getFileStore(path);\n    }\n\n    /**\n     * Tests if two paths locate the same file.\n     *\n     * \u003cp\u003e If both {@code Path} objects are {@link Path#equals(Object) equal}\n     * then this method returns {@code true} without checking if the file exists.\n     * If the two {@code Path} objects are associated with different providers\n     * then this method returns {@code false}. Otherwise, this method checks if\n     * both {@code Path} objects locate the same file, and depending on the\n     * implementation, may require to open or access both files.\n     *\n     * \u003cp\u003e If the file system and files remain static, then this method implements\n     * an equivalence relation for non-null {@code Paths}.\n     * \u003cul\u003e\n     * \u003cli\u003eIt is \u003ci\u003ereflexive\u003c/i\u003e: for {@code Path} {@code f},\n     *     {@code isSameFile(f,f)} should return {@code true}.\n     * \u003cli\u003eIt is \u003ci\u003esymmetric\u003c/i\u003e: for two {@code Paths} {@code f} and {@code g},\n     *     {@code isSameFile(f,g)} will equal {@code isSameFile(g,f)}.\n     * \u003cli\u003eIt is \u003ci\u003etransitive\u003c/i\u003e: for three {@code Paths}\n     *     {@code f}, {@code g}, and {@code h}, if {@code isSameFile(f,g)} returns\n     *     {@code true} and {@code isSameFile(g,h)} returns {@code true}, then\n     *     {@code isSameFile(f,h)} will return {@code true}.\n     * \u003c/ul\u003e\n     *\n     * @param   path\n     *          one path to the file\n     * @param   path2\n     *          the other path\n     *\n     * @return  {@code true} if, and only if, the two paths locate the same file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to both files when the\n     *          two paths are not equal\n     *\n     * @see java.nio.file.attribute.BasicFileAttributes#fileKey\n     */\n    public static boolean isSameFile(Path path, Path path2) throws IOException {\n        return provider(path).isSameFile(path, path2);\n    }\n\n    /**\n     * Finds and returns the position of the first mismatched byte in the content\n     * of two files, or {@code -1L} if there is no mismatch. The position will be\n     * in the inclusive range of {@code 0L} up to the size (in bytes) of the\n     * smaller file.\n     *\n     * \u003cp\u003e Two files are considered to match if they satisfy one of the following\n     * conditions:\n     * \u003cul\u003e\n     * \u003cli\u003e The two paths locate the {@linkplain #isSameFile(Path, Path) same file},\n     *      even if two {@linkplain Path#equals(Object) equal} paths locate a file\n     *      that does not exist, or \u003c/li\u003e\n     * \u003cli\u003e The two files are the same size, and every byte in the first file\n     *      is identical to the corresponding byte in the second file. \u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e Otherwise there is a mismatch between the two files and the value\n     * returned by this method is:\n     * \u003cul\u003e\n     * \u003cli\u003e The position of the first mismatched byte, or \u003c/li\u003e\n     * \u003cli\u003e The size of the smaller file (in bytes) when the files are of different\n     *      sizes and every byte of the smaller file is identical to the\n     *      corresponding byte of the larger file. \u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e This method may not be atomic with respect to other file system\n     * operations. This method is always \u003ci\u003ereflexive\u003c/i\u003e (for {@code Path f},\n     * {@code mismatch(f,f)} returns {@code -1L}). If the file system and files\n     * remain static, then this method is \u003ci\u003esymmetric\u003c/i\u003e (for two {@code Paths f}\n     * and {@code g}, {@code mismatch(f,g)} will return the same value as\n     * {@code mismatch(g,f)}).\n     *\n     * \u003cp\u003e If both {@code Path} objects are equal, then this method returns\n     * {@code true} without checking if the file exists.\n     *\n     * @param   path\n     *          the path to the first file\n     * @param   path2\n     *          the path to the second file\n     *\n     * @return  the position of the first mismatch or {@code -1L} if no mismatch\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to both files when the\n     *          two paths are not equal\n     *\n     * @since 12\n     */\n    public static long mismatch(Path path, Path path2) throws IOException {\n        if (isSameFile(path, path2)) {\n            return -1;\n        }\n        byte[] buffer1 \u003d new byte[BUFFER_SIZE];\n        byte[] buffer2 \u003d new byte[BUFFER_SIZE];\n        try (InputStream in1 \u003d Files.newInputStream(path);\n             InputStream in2 \u003d Files.newInputStream(path2)) {\n            long totalRead \u003d 0;\n            while (true) {\n                int nRead1 \u003d in1.readNBytes(buffer1, 0, BUFFER_SIZE);\n                int nRead2 \u003d in2.readNBytes(buffer2, 0, BUFFER_SIZE);\n\n                int i \u003d Arrays.mismatch(buffer1, 0, nRead1, buffer2, 0, nRead2);\n                if (i \u003e -1) {\n                    return totalRead + i;\n                }\n                if (nRead1 \u003c BUFFER_SIZE) {\n                    // we\u0027ve reached the end of the files, but found no mismatch\n                    return -1;\n                }\n                totalRead +\u003d nRead1;\n            }\n        }\n    }\n\n    /**\n     * Tells whether or not a file is considered \u003cem\u003ehidden\u003c/em\u003e.\n     *\n     * @apiNote\n     * The exact definition of hidden is platform or provider dependent. On UNIX\n     * for example a file is considered to be hidden if its name begins with a\n     * period character (\u0027.\u0027). On Windows a file is considered hidden if the DOS\n     * {@link DosFileAttributes#isHidden hidden} attribute is set.\n     *\n     * \u003cp\u003e Depending on the implementation this method may require to access\n     * the file system to determine if the file is considered hidden.\n     *\n     * @param   path\n     *          the path to the file to test\n     *\n     * @return  {@code true} if the file is considered hidden\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static boolean isHidden(Path path) throws IOException {\n        return provider(path).isHidden(path);\n    }\n\n    // lazy loading of default and installed file type detectors\n    private static class FileTypeDetectors{\n        static final FileTypeDetector defaultFileTypeDetector \u003d\n            createDefaultFileTypeDetector();\n        static final List\u003cFileTypeDetector\u003e installedDetectors \u003d\n            loadInstalledDetectors();\n\n        // creates the default file type detector\n        @SuppressWarnings(\"removal\")\n        private static FileTypeDetector createDefaultFileTypeDetector() {\n            return AccessController\n                .doPrivileged(new PrivilegedAction\u003c\u003e() {\n                    @Override public FileTypeDetector run() {\n                        return sun.nio.fs.DefaultFileTypeDetector.create();\n                }});\n        }\n\n        // loads all installed file type detectors\n        @SuppressWarnings(\"removal\")\n        private static List\u003cFileTypeDetector\u003e loadInstalledDetectors() {\n            return AccessController\n                .doPrivileged(new PrivilegedAction\u003c\u003e() {\n                    @Override public List\u003cFileTypeDetector\u003e run() {\n                        List\u003cFileTypeDetector\u003e list \u003d new ArrayList\u003c\u003e();\n                        ServiceLoader\u003cFileTypeDetector\u003e loader \u003d ServiceLoader\n                            .load(FileTypeDetector.class, ClassLoader.getSystemClassLoader());\n                        for (FileTypeDetector detector: loader) {\n                            list.add(detector);\n                        }\n                        return list;\n                }});\n        }\n    }\n\n    /**\n     * Probes the content type of a file.\n     *\n     * \u003cp\u003e This method uses the installed {@link FileTypeDetector} implementations\n     * to probe the given file to determine its content type. Each file type\n     * detector\u0027s {@link FileTypeDetector#probeContentType probeContentType} is\n     * invoked, in turn, to probe the file type. If the file is recognized then\n     * the content type is returned. If the file is not recognized by any of the\n     * installed file type detectors then a system-default file type detector is\n     * invoked to guess the content type.\n     *\n     * \u003cp\u003e A given invocation of the Java virtual machine maintains a system-wide\n     * list of file type detectors. Installed file type detectors are loaded\n     * using the service-provider loading facility defined by the {@link ServiceLoader}\n     * class. Installed file type detectors are loaded using the system class\n     * loader. If the system class loader cannot be found then the platform class\n     * loader is used. File type detectors are typically installed\n     * by placing them in a JAR file on the application class path,\n     * the JAR file contains a provider-configuration file\n     * named {@code java.nio.file.spi.FileTypeDetector} in the resource directory\n     * {@code META-INF/services}, and the file lists one or more fully-qualified\n     * names of concrete subclass of {@code FileTypeDetector } that have a zero\n     * argument constructor. If the process of locating or instantiating the\n     * installed file type detectors fails then an unspecified error is thrown.\n     * The ordering that installed providers are located is implementation\n     * specific.\n     *\n     * \u003cp\u003e The return value of this method is the string form of the value of a\n     * Multipurpose Internet Mail Extension (MIME) content type as\n     * defined by \u003ca href\u003d\"http://www.ietf.org/rfc/rfc2045.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2045:\n     * Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet\n     * Message Bodies\u003c/i\u003e\u003c/a\u003e. The string is guaranteed to be parsable according\n     * to the grammar in the RFC.\n     *\n     * @param   path\n     *          the path to the file to probe\n     *\n     * @return  The content type of the file, or {@code null} if the content\n     *          type cannot be determined\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          If a security manager is installed and it denies an unspecified\n     *          permission required by a file type detector implementation.\n     *\n     * @spec https://www.rfc-editor.org/info/rfc2045\n     *      RFC 2045: Multipurpose Internet Mail Extensions (MIME) Part One:\n     *              Format of Internet Message Bodies\n     */\n    public static String probeContentType(Path path)\n        throws IOException\n    {\n        // try installed file type detectors\n        for (FileTypeDetector detector: FileTypeDetectors.installedDetectors) {\n            String result \u003d detector.probeContentType(path);\n            if (result !\u003d null)\n                return result;\n        }\n\n        // fallback to default\n        return FileTypeDetectors.defaultFileTypeDetector.probeContentType(path);\n    }\n\n    // -- File Attributes --\n\n    /**\n     * Returns a file attribute view of a given type.\n     *\n     * \u003cp\u003e A file attribute view provides a read-only or updatable view of a\n     * set of file attributes. This method is intended to be used where the file\n     * attribute view defines type-safe methods to read or update the file\n     * attributes. The {@code type} parameter is the type of the attribute view\n     * required and the method returns an instance of that type if supported.\n     * The {@link BasicFileAttributeView} type supports access to the basic\n     * attributes of a file. Invoking this method to select a file attribute\n     * view of that type will always return an instance of that class.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled by the resulting file attribute view for the case that the\n     * file is a symbolic link. By default, symbolic links are followed. If the\n     * option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} is present then\n     * symbolic links are not followed. This option is ignored by implementations\n     * that do not support symbolic links.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want read or set a file\u0027s ACL, if supported:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     AclFileAttributeView view \u003d Files.getFileAttributeView(path, AclFileAttributeView.class);\n     *     if (view !\u003d null) {\n     *         List\u003cAclEntry\u003e acl \u003d view.getAcl();\n     *         :\n     *     }\n     * }\n     *\n     * @param   \u003cV\u003e\n     *          The {@code FileAttributeView} type\n     * @param   path\n     *          the path to the file\n     * @param   type\n     *          the {@code Class} object corresponding to the file attribute view\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a file attribute view of the specified type, or {@code null} if\n     *          the attribute view type is not available\n     */\n    public static \u003cV extends FileAttributeView\u003e V getFileAttributeView(Path path,\n                                                                       Class\u003cV\u003e type,\n                                                                       LinkOption... options)\n    {\n        return provider(path).getFileAttributeView(path, type, options);\n    }\n\n    /**\n     * Reads a file\u0027s attributes as a bulk operation.\n     *\n     * \u003cp\u003e The {@code type} parameter is the type of the attributes required\n     * and this method returns an instance of that type if supported. All\n     * implementations support a basic set of file attributes and so invoking\n     * this method with a  {@code type} parameter of {@code\n     * BasicFileAttributes.class} will not throw {@code\n     * UnsupportedOperationException}.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e It is implementation specific if all file attributes are read as an\n     * atomic operation with respect to other file system operations.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to read a file\u0027s attributes in bulk:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     BasicFileAttributes attrs \u003d Files.readAttributes(path, BasicFileAttributes.class);\n     * }\n     * Alternatively, suppose we want to read file\u0027s POSIX attributes without\n     * following symbolic links:\n     * {@snippet lang\u003djava :\n     *     PosixFileAttributes attrs \u003d\n     *         Files.readAttributes(path, PosixFileAttributes.class, NOFOLLOW_LINKS);\n     * }\n     *\n     * @param   \u003cA\u003e\n     *          The {@code BasicFileAttributes} type\n     * @param   path\n     *          the path to the file\n     * @param   type\n     *          the {@code Class} of the file attributes required\n     *          to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the file attributes\n     *\n     * @throws  UnsupportedOperationException\n     *          if an attributes of the given type are not supported\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file. If this\n     *          method is invoked to read security sensitive attributes then the\n     *          security manager may be invoked to check for additional permissions.\n     */\n    public static \u003cA extends BasicFileAttributes\u003e A readAttributes(Path path,\n                                                                   Class\u003cA\u003e type,\n                                                                   LinkOption... options)\n        throws IOException\n    {\n        return provider(path).readAttributes(path, type, options);\n    }\n\n    /**\n     * Sets the value of a file attribute.\n     *\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be set\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute\n     * within the set.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is set. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to set the DOS \"hidden\" attribute:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     Files.setAttribute(path, \"dos:hidden\", true);\n     * }\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attribute\n     *          the attribute to set\n     * @param   value\n     *          the attribute value\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if the attribute name is not specified, or is not recognized, or\n     *          the attribute value is of the correct type but has an\n     *          inappropriate value\n     * @throws  ClassCastException\n     *          if the attribute value is not of the expected type or is a\n     *          collection containing elements that are not of the expected\n     *          type\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file. If this method is invoked\n     *          to set security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Path setAttribute(Path path, String attribute, Object value,\n                                    LinkOption... options)\n        throws IOException\n    {\n        provider(path).setAttribute(path, attribute, value, options);\n        return path;\n    }\n\n    /**\n     * Reads the value of a file attribute.\n     *\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be read\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we require the user ID of the file owner on a system that\n     * supports a \"{@code unix}\" view:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     int uid \u003d (Integer)Files.getAttribute(path, \"unix:uid\");\n     * }\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attribute\n     *          the attribute to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the attribute value\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if the attribute name is not specified or is not recognized\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file. If this method is invoked\n     *          to read security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Object getAttribute(Path path, String attribute,\n                                      LinkOption... options)\n        throws IOException\n    {\n        // only one attribute should be read\n        if (attribute.indexOf(\u0027*\u0027) \u003e\u003d 0 || attribute.indexOf(\u0027,\u0027) \u003e\u003d 0)\n            throw new IllegalArgumentException(attribute);\n        Map\u003cString,Object\u003e map \u003d readAttributes(path, attribute, options);\n        assert map.size() \u003d\u003d 1;\n        String name;\n        int pos \u003d attribute.indexOf(\u0027:\u0027);\n        if (pos \u003d\u003d -1) {\n            name \u003d attribute;\n        } else {\n            name \u003d (pos \u003d\u003d attribute.length()) ? \"\" : attribute.substring(pos+1);\n        }\n        return map.get(name);\n    }\n\n    /**\n     * Reads a set of file attributes as a bulk operation.\n     *\n     * \u003cp\u003e The {@code attributes} parameter identifies the attributes to be read\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-list\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems.\n     *\n     * \u003cp\u003e The \u003ci\u003eattribute-list\u003c/i\u003e component is a comma separated list of\n     * one or more names of attributes to read. If the list contains the value\n     * {@code \"*\"} then all attributes are read. Attributes that are not supported\n     * are ignored and will not be present in the returned map. It is\n     * implementation specific if all attributes are read as an atomic operation\n     * with respect to other file system operations.\n     *\n     * \u003cp\u003e The following examples demonstrate possible values for the {@code\n     * attributes} parameter:\n     *\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align: left; margin-left:2em\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003ePossible values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eExample\n     *  \u003cth scope\u003d\"col\"\u003eDescription\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"*\"} \u003c/th\u003e\n     *   \u003ctd\u003e Read all {@link BasicFileAttributes basic-file-attributes}. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"size,lastModifiedTime,lastAccessTime\"} \u003c/th\u003e\n     *   \u003ctd\u003e Reads the file size, last modified time, and last access time\n     *     attributes. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"posix:*\"} \u003c/th\u003e\n     *   \u003ctd\u003e Read all {@link PosixFileAttributes POSIX-file-attributes}. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"posix:permissions,owner,size\"} \u003c/th\u003e\n     *   \u003ctd\u003e Reads the POSIX file permissions, owner, and file size. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attributes\n     *          the attributes to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a map of the attributes returned; The map\u0027s keys are the\n     *          attribute names, its values are the attribute values\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if no attributes are specified or an unrecognized attribute is\n     *          specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file. If this method is invoked\n     *          to read security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Map\u003cString,Object\u003e readAttributes(Path path, String attributes,\n                                                    LinkOption... options)\n        throws IOException\n    {\n        return provider(path).readAttributes(path, attributes, options);\n    }\n\n    /**\n     * Returns a file\u0027s POSIX file permissions.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\n     * that supports the {@link PosixFileAttributeView}. This attribute view\n     * provides access to file attributes commonly associated with files on file\n     * systems used by operating systems that implement the Portable Operating\n     * System Interface (POSIX) family of standards.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the file permissions\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          PosixFileAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, a security manager is\n     *          installed, and it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\n     *          denies read access to the file.\n     */\n    public static Set\u003cPosixFilePermission\u003e getPosixFilePermissions(Path path,\n                                                                   LinkOption... options)\n        throws IOException\n    {\n        return readAttributes(path, PosixFileAttributes.class, options).permissions();\n    }\n\n    /**\n     * Sets a file\u0027s POSIX permissions.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\n     * that supports the {@link PosixFileAttributeView}. This attribute view\n     * provides access to file attributes commonly associated with files on file\n     * systems used by operating systems that implement the Portable Operating\n     * System Interface (POSIX) family of standards.\n     *\n     * @param   path\n     *          The path to the file\n     * @param   perms\n     *          The new set of permissions\n     *\n     * @return  The given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          PosixFileAttributeView}\n     * @throws  ClassCastException\n     *          if the sets contains elements that are not of type {@code\n     *          PosixFilePermission}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file.\n     */\n    public static Path setPosixFilePermissions(Path path,\n                                               Set\u003cPosixFilePermission\u003e perms)\n        throws IOException\n    {\n        PosixFileAttributeView view \u003d\n            getFileAttributeView(path, PosixFileAttributeView.class);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        view.setPermissions(perms);\n        return path;\n    }\n\n    /**\n     * Returns the owner of a file.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a file system that\n     * supports {@link FileOwnerAttributeView}. This file attribute view provides\n     * access to a file attribute that is the owner of the file.\n     *\n     * @param   path\n     *          The path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  A user principal representing the owner of the file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          FileOwnerAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\n     *          denies read access to the file.\n     */\n    public static UserPrincipal getOwner(Path path, LinkOption... options) throws IOException {\n        FileOwnerAttributeView view \u003d\n            getFileAttributeView(path, FileOwnerAttributeView.class, options);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        return view.getOwner();\n    }\n\n    /**\n     * Updates the file owner.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a file system that\n     * supports {@link FileOwnerAttributeView}. This file attribute view provides\n     * access to a file attribute that is the owner of the file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to make \"joe\" the owner of a file:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     UserPrincipalLookupService lookupService \u003d\n     *         provider(path).getUserPrincipalLookupService();\n     *     UserPrincipal joe \u003d lookupService.lookupPrincipalByName(\"joe\");\n     *     Files.setOwner(path, joe);\n     * }\n     *\n     * @param   path\n     *          The path to the file\n     * @param   owner\n     *          The new file owner\n     *\n     * @return  The given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          FileOwnerAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file.\n     *\n     * @see FileSystem#getUserPrincipalLookupService\n     * @see java.nio.file.attribute.UserPrincipalLookupService\n     */\n    public static Path setOwner(Path path, UserPrincipal owner)\n        throws IOException\n    {\n        FileOwnerAttributeView view \u003d\n            getFileAttributeView(path, FileOwnerAttributeView.class);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        view.setOwner(owner);\n        return path;\n    }\n\n    /**\n     * Tests whether a file is a symbolic link.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a symbolic link then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isSymbolicLink} method.\n     *\n     * @param   path  The path to the file\n     *\n     * @return  {@code true} if the file is a symbolic link; {@code false} if\n     *          the file does not exist, is not a symbolic link, or it cannot\n     *          be determined if the file is a symbolic link or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isSymbolicLink(Path path) {\n        try {\n            return readAttributes(path,\n                                  BasicFileAttributes.class,\n                                  LinkOption.NOFOLLOW_LINKS).isSymbolicLink();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is a directory.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a directory then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isDirectory} method.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file is a directory; {@code false} if\n     *          the file does not exist, is not a directory, or it cannot\n     *          be determined if the file is a directory or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isDirectory(Path path, LinkOption... options) {\n        try {\n            var attrs \u003d provider(path)\n                    .readAttributesIfExists(path, BasicFileAttributes.class, options);\n            return (attrs !\u003d null) \u0026\u0026 attrs.isDirectory();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is a regular file with opaque content.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a regular file then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isRegularFile} method.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file is a regular file; {@code false} if\n     *          the file does not exist, is not a regular file, or it\n     *          cannot be determined if the file is a regular file or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isRegularFile(Path path, LinkOption... options) {\n        try {\n            var attrs \u003d provider(path)\n                    .readAttributesIfExists(path, BasicFileAttributes.class, options);\n            return (attrs !\u003d null) \u0026\u0026 attrs.isRegularFile();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Returns a file\u0027s last modified time.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a {@code FileTime} representing the time the file was last\n     *          modified, or an implementation specific default when a time\n     *          stamp to indicate the time of last modification is not supported\n     *          by the file system\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     *\n     * @see BasicFileAttributes#lastModifiedTime\n     */\n    public static FileTime getLastModifiedTime(Path path, LinkOption... options)\n        throws IOException\n    {\n        return readAttributes(path, BasicFileAttributes.class, options).lastModifiedTime();\n    }\n\n    /**\n     * Updates a file\u0027s last modified time attribute. The file time is converted\n     * to the epoch and precision supported by the file system. Converting from\n     * finer to coarser granularities result in precision loss. The behavior of\n     * this method when attempting to set the last modified time when it is not\n     * supported by the file system or is outside the range supported by the\n     * underlying file store is not defined. It may or not fail by throwing an\n     * {@code IOException}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to set the last modified time to the current time:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     FileTime now \u003d FileTime.fromMillis(System.currentTimeMillis());\n     *     Files.setLastModifiedTime(path, now);\n     * }\n     *\n     * @param   path\n     *          the path to the file\n     * @param   time\n     *          the new last modified time\n     *\n     * @return  the given path\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method denies write access to the file.\n     *\n     * @see BasicFileAttributeView#setTimes\n     */\n    public static Path setLastModifiedTime(Path path, FileTime time)\n        throws IOException\n    {\n        getFileAttributeView(path, BasicFileAttributeView.class)\n            .setTimes(Objects.requireNonNull(time), null, null);\n        return path;\n    }\n\n    /**\n     * Returns the size of a file (in bytes). The size may differ from the\n     * actual size on the file system due to compression, support for sparse\n     * files, or other reasons. The size of files that are not {@link\n     * #isRegularFile regular} files is implementation specific and\n     * therefore unspecified.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the file size, in bytes\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     *\n     * @see BasicFileAttributes#size\n     */\n    public static long size(Path path) throws IOException {\n        return readAttributes(path, BasicFileAttributes.class).size();\n    }\n\n    // -- Accessibility --\n\n    /**\n     * Returns {@code false} if NOFOLLOW_LINKS is present.\n     */\n    private static boolean followLinks(LinkOption... options) {\n        boolean followLinks \u003d true;\n        for (LinkOption opt: options) {\n            if (opt \u003d\u003d LinkOption.NOFOLLOW_LINKS) {\n                followLinks \u003d false;\n                continue;\n            }\n            if (opt \u003d\u003d null)\n                throw new NullPointerException();\n            throw new AssertionError(\"Should not get here\");\n        }\n        return followLinks;\n    }\n\n    /**\n     * Tests whether a file exists.\n     *\n     * \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated. If this\n     * method indicates the file exists then there is no guarantee that a\n     * subsequent access will succeed. Care should be taken when using this\n     * method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file exists; {@code false} if the file does\n     *          not exist or its existence cannot be determined.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String)} is invoked to check\n     *          read access to the file.\n     *\n     * @see #notExists\n     * @see FileSystemProvider#checkAccess\n     */\n    public static boolean exists(Path path, LinkOption... options) {\n        return provider(path).exists(path, options);\n    }\n\n    /**\n     * Tests whether the file located by this path does not exist. This method\n     * is intended for cases where it is required to take action when it can be\n     * confirmed that a file does not exist.\n     *\n     * \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Note that this method is not the complement of the {@link #exists\n     * exists} method. Where it is not possible to determine if a file exists\n     * or not then both methods return {@code false}. As with the {@code exists}\n     * method, the result of this method is immediately outdated. If this\n     * method indicates the file does exist then there is no guarantee that a\n     * subsequent attempt to create the file will succeed. Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file does not exist; {@code false} if the\n     *          file exists or its existence cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String)} is invoked to check\n     *          read access to the file.\n     */\n    public static boolean notExists(Path path, LinkOption... options) {\n        try {\n            if (followLinks(options)) {\n                provider(path).checkAccess(path);\n            } else {\n                // attempt to read attributes without following links\n                readAttributes(path, BasicFileAttributes.class,\n                               LinkOption.NOFOLLOW_LINKS);\n            }\n            // file exists\n            return false;\n        } catch (NoSuchFileException x) {\n            // file confirmed not to exist\n            return true;\n        } catch (IOException x) {\n            return false;\n        }\n    }\n\n    /**\n     * Used by isReadable, isWritable, isExecutable to test access to a file.\n     */\n    private static boolean isAccessible(Path path, AccessMode... modes) {\n        try {\n            provider(path).checkAccess(path, modes);\n            return true;\n        } catch (IOException x) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is readable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges that would\n     * allow it open the file for reading. Depending on the implementation, this\n     * method may require to read file permissions, access control lists, or\n     * other file attributes in order to check the effective access to the file.\n     * Consequently, this method may not be atomic with respect to other file\n     * system operations.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated, there is\n     * no guarantee that a subsequent attempt to open the file for reading will\n     * succeed (or even that it will access the same file). Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is readable; {@code false}\n     *          if the file does not exist, read access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          is invoked to check read access to the file.\n     */\n    public static boolean isReadable(Path path) {\n        return isAccessible(path, AccessMode.READ);\n    }\n\n    /**\n     * Tests whether a file is writable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges that would\n     * allow it open the file for writing. Depending on the implementation, this\n     * method may require to read file permissions, access control lists, or\n     * other file attributes in order to check the effective access to the file.\n     * Consequently, this method may not be atomic with respect to other file\n     * system operations.\n     *\n     * \u003cp\u003e Note that result of this method is immediately outdated, there is no\n     * guarantee that a subsequent attempt to open the file for writing will\n     * succeed (or even that it will access the same file). Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is writable; {@code false}\n     *          if the file does not exist, write access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          is invoked to check write access to the file.\n     */\n    public static boolean isWritable(Path path) {\n        return isAccessible(path, AccessMode.WRITE);\n    }\n\n    /**\n     * Tests whether a file is executable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges to {@link\n     * Runtime#exec execute} the file. The semantics may differ when checking\n     * access to a directory. For example, on UNIX systems, checking for\n     * execute access checks that the Java virtual machine has permission to\n     * search the directory in order to access file or subdirectories.\n     *\n     * \u003cp\u003e Depending on the implementation, this method may require to read file\n     * permissions, access control lists, or other file attributes in order to\n     * check the effective access to the file. Consequently, this method may not\n     * be atomic with respect to other file system operations.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated, there is\n     * no guarantee that a subsequent attempt to execute the file will succeed\n     * (or even that it will access the same file). Care should be taken when\n     * using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is executable; {@code false}\n     *          if the file does not exist, execute access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkExec(String)\n     *          checkExec} is invoked to check execute access to the file.\n     */\n    public static boolean isExecutable(Path path) {\n        return isAccessible(path, AccessMode.EXECUTE);\n    }\n\n    // -- Recursive operations --\n\n    /**\n     * Walks a file tree.\n     *\n     * \u003cp\u003e This method walks a file tree rooted at a given starting file. The\n     * file tree traversal is \u003cem\u003edepth-first\u003c/em\u003e with the given {@link\n     * FileVisitor} invoked for each file encountered. File tree traversal\n     * completes when all accessible files in the tree have been visited, or a\n     * visit method returns a result of {@link FileVisitResult#TERMINATE\n     * TERMINATE}. Where a visit method terminates due an {@code IOException},\n     * an uncaught error, or runtime exception, then the traversal is terminated\n     * and the error or exception is propagated to the caller of this method.\n     *\n     * \u003cp\u003e For each file encountered this method attempts to read its {@link\n     * java.nio.file.attribute.BasicFileAttributes}. If the file is not a\n     * directory then the {@link FileVisitor#visitFile visitFile} method is\n     * invoked with the file attributes. If the file attributes cannot be read,\n     * due to an I/O exception, then the {@link FileVisitor#visitFileFailed\n     * visitFileFailed} method is invoked with the I/O exception.\n     *\n     * \u003cp\u003e Where the file is a directory, and the directory could not be opened,\n     * then the {@code visitFileFailed} method is invoked with the I/O exception,\n     * after which, the file tree walk continues, by default, at the next\n     * \u003cem\u003esibling\u003c/em\u003e of the directory.\n     *\n     * \u003cp\u003e Where the directory is opened successfully, then the entries in the\n     * directory, and their \u003cem\u003edescendants\u003c/em\u003e are visited. When all entries\n     * have been visited, or an I/O error occurs during iteration of the\n     * directory, then the directory is closed and the visitor\u0027s {@link\n     * FileVisitor#postVisitDirectory postVisitDirectory} method is invoked.\n     * The file tree walk then continues, by default, at the next \u003cem\u003esibling\u003c/em\u003e\n     * of the directory.\n     *\n     * \u003cp\u003e By default, symbolic links are not automatically followed by this\n     * method. If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\n     * followed. When following links, and the attributes of the target cannot\n     * be read, then this method attempts to get the {@code BasicFileAttributes}\n     * of the link. If they can be read then the {@code visitFile} method is\n     * invoked with the attributes of the link (otherwise the {@code visitFileFailed}\n     * method is invoked as specified above).\n     *\n     * \u003cp\u003e If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then this method keeps\n     * track of directories visited so that cycles can be detected. A cycle\n     * arises when there is an entry in a directory that is an ancestor of the\n     * directory. Cycle detection is done by recording the {@link\n     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\n     * or if file keys are not available, by invoking the {@link #isSameFile\n     * isSameFile} method to test if a directory is the same file as an\n     * ancestor. When a cycle is detected it is treated as an I/O error, and the\n     * {@link FileVisitor#visitFileFailed visitFileFailed} method is invoked with\n     * an instance of {@link FileSystemLoopException}.\n     *\n     * \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\n     * directories to visit. A value of {@code 0} means that only the starting\n     * file is visited, unless denied by the security manager. A value of\n     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\n     * levels should be visited. The {@code visitFile} method is invoked for all\n     * files, including directories, encountered at {@code maxDepth}, unless the\n     * basic file attributes cannot be read, in which case the {@code\n     * visitFileFailed} method is invoked.\n     *\n     * \u003cp\u003e If a visitor returns a result of {@code null} then {@code\n     * NullPointerException} is thrown.\n     *\n     * \u003cp\u003e When a security manager is installed and it denies access to a file\n     * (or directory), then it is ignored and the visitor is not invoked for\n     * that file (or directory).\n     *\n     * @param   start\n     *          the starting file\n     * @param   options\n     *          options to configure the traversal\n     * @param   maxDepth\n     *          the maximum number of directory levels to visit\n     * @param   visitor\n     *          the file visitor to invoke for each file\n     *\n     * @return  the starting file\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown by a visitor method\n     */\n    public static Path walkFileTree(Path start,\n                                    Set\u003cFileVisitOption\u003e options,\n                                    int maxDepth,\n                                    FileVisitor\u003c? super Path\u003e visitor)\n        throws IOException\n    {\n        /**\n         * Create a FileTreeWalker to walk the file tree, invoking the visitor\n         * for each event.\n         */\n        try (FileTreeWalker walker \u003d new FileTreeWalker(options, maxDepth)) {\n            FileTreeWalker.Event ev \u003d walker.walk(start);\n            do {\n                FileVisitResult result \u003d switch (ev.type()) {\n                    case ENTRY -\u003e {\n                        IOException ioe \u003d ev.ioeException();\n                        if (ioe \u003d\u003d null) {\n                            assert ev.attributes() !\u003d null;\n                            yield visitor.visitFile(ev.file(), ev.attributes());\n                        } else {\n                            yield visitor.visitFileFailed(ev.file(), ioe);\n                        }\n                    }\n                    case START_DIRECTORY -\u003e {\n                        var res \u003d visitor.preVisitDirectory(ev.file(), ev.attributes());\n\n                        // if SKIP_SIBLINGS and SKIP_SUBTREE is returned then\n                        // there shouldn\u0027t be any more events for the current\n                        // directory.\n                        if (res \u003d\u003d FileVisitResult.SKIP_SUBTREE ||\n                            res \u003d\u003d FileVisitResult.SKIP_SIBLINGS)\n                            walker.pop();\n                        yield res;\n                    }\n                    case END_DIRECTORY -\u003e {\n                        var res \u003d visitor.postVisitDirectory(ev.file(), ev.ioeException());\n\n                        // SKIP_SIBLINGS is a no-op for postVisitDirectory\n                        if (res \u003d\u003d FileVisitResult.SKIP_SIBLINGS)\n                            res \u003d FileVisitResult.CONTINUE;\n                        yield res;\n                    }\n                    default -\u003e throw new AssertionError(\"Should not get here\");\n                };\n\n                if (Objects.requireNonNull(result) !\u003d FileVisitResult.CONTINUE) {\n                    if (result \u003d\u003d FileVisitResult.TERMINATE) {\n                        break;\n                    } else if (result \u003d\u003d FileVisitResult.SKIP_SIBLINGS) {\n                        walker.skipRemainingSiblings();\n                    }\n                }\n                ev \u003d walker.next();\n            } while (ev !\u003d null);\n        }\n\n        return start;\n    }\n\n    /**\n     * Walks a file tree.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * walkFileTree(Path, Set\u003cFileVisitOption\u003e, int, FileVisitor\u003c? super Path\u003e)\n     * Files.walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\n     * }\u003c/blockquote\u003e\n     * In other words, it does not follow symbolic links, and visits all levels\n     * of the file tree.\n     *\n     * @param   start\n     *          the starting file\n     * @param   visitor\n     *          the file visitor to invoke for each file\n     *\n     * @return  the starting file\n     *\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown by a visitor method\n     */\n    public static Path walkFileTree(Path start, FileVisitor\u003c? super Path\u003e visitor)\n        throws IOException\n    {\n        return walkFileTree(start,\n                            EnumSet.noneOf(FileVisitOption.class),\n                            Integer.MAX_VALUE,\n                            visitor);\n    }\n\n\n    // -- Utility methods for simple usages --\n\n\n    /**\n     * Opens a file for reading, returning a {@code BufferedReader} that may be\n     * used to read text from the file in an efficient manner. Bytes from the\n     * file are decoded into characters using the specified charset. Reading\n     * commences at the beginning of the file.\n     *\n     * \u003cp\u003e The {@code Reader} methods that read from the file throw {@code\n     * IOException} if a malformed or unmappable byte sequence is read.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  a new buffered reader, with default buffer size, to read text\n     *          from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see #readAllLines\n     */\n    public static BufferedReader newBufferedReader(Path path, Charset cs)\n        throws IOException\n    {\n        CharsetDecoder decoder \u003d cs.newDecoder();\n        Reader reader \u003d new InputStreamReader(newInputStream(path), decoder);\n        return new BufferedReader(reader);\n    }\n\n    /**\n     * Opens a file for reading, returning a {@code BufferedReader} to read text\n     * from the file in an efficient manner. Bytes from the file are decoded into\n     * characters using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset\n     * charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * newBufferedReader(Path, Charset)\n     * Files.newBufferedReader(path, StandardCharsets.UTF_8)\n     * }\u003c/blockquote\u003e\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  a new buffered reader, with default buffer size, to read text\n     *          from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static BufferedReader newBufferedReader(Path path) throws IOException {\n        return newBufferedReader(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Opens or creates a file for writing, returning a {@code BufferedWriter}\n     * that may be used to write text to the file in an efficient manner.\n     * The {@code options} parameter specifies how the file is created or\n     * opened. If no options are present then this method works as if the {@link\n     * StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0} if it exists.\n     *\n     * \u003cp\u003e The {@code Writer} methods to write text throw {@code IOException}\n     * if the text cannot be encoded using the specified charset. Due to\n     * buffering, an {@code IOException} caused by an encoding error\n     * (unmappable-character or malformed-input) may be thrown when {@linkplain\n     * BufferedWriter#write(char[],int,int) writing}, {@linkplain\n     * BufferedWriter#flush flushing}, or {@linkplain BufferedWriter#close\n     * closing} the buffered writer.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new buffered writer, with default buffer size, to write text\n     *          to the file\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs opening or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see #write(Path,Iterable,Charset,OpenOption[])\n     */\n    public static BufferedWriter newBufferedWriter(Path path, Charset cs,\n                                                   OpenOption... options)\n        throws IOException\n    {\n        CharsetEncoder encoder \u003d cs.newEncoder();\n        Writer writer \u003d new OutputStreamWriter(newOutputStream(path, options), encoder);\n        return new BufferedWriter(writer);\n    }\n\n    /**\n     * Opens or creates a file for writing, returning a {@code BufferedWriter}\n     * to write text to the file in an efficient manner. The text is encoded\n     * into bytes for writing using the {@link StandardCharsets#UTF_8 UTF-8}\n     * {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * newBufferedWriter(Path, Charset, OpenOption...)\n     * Files.newBufferedWriter(path, StandardCharsets.UTF_8, options)\n     * }\u003c/blockquote\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new buffered writer, with default buffer size, to write text\n     *          to the file\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs opening or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 1.8\n     */\n    public static BufferedWriter newBufferedWriter(Path path, OpenOption... options)\n        throws IOException\n    {\n        return newBufferedWriter(path, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Copies all bytes from an input stream to a file. On return, the input\n     * stream will be at end of stream.\n     *\n     * \u003cp\u003e By default, the copy fails if the target file already exists or is a\n     * symbolic link. If the {@link StandardCopyOption#REPLACE_EXISTING\n     * REPLACE_EXISTING} option is specified, and the target file already exists,\n     * then it is replaced if it is not a non-empty directory. If the target\n     * file exists and is a symbolic link, then the symbolic link is replaced.\n     * In this release, the {@code REPLACE_EXISTING} option is the only option\n     * required to be supported by this method. Additional options may be\n     * supported in future releases.\n     *\n     * \u003cp\u003e  If an I/O error occurs reading from the input stream or writing to\n     * the file, then it may do so after the target file has been created and\n     * after some bytes have been read or written. Consequently the input\n     * stream may not be at end of stream and may be in an inconsistent state.\n     * It is strongly recommended that the input stream be promptly closed if an\n     * I/O error occurs.\n     *\n     * \u003cp\u003e This method may block indefinitely reading from the input stream (or\n     * writing to the file). The behavior for the case that the input stream is\n     * \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy is\n     * highly input stream and file system provider specific and therefore not\n     * specified.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: Suppose we want to capture a web page and save\n     * it to a file:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     URI u \u003d URI.create(\"http://www.example.com/\");\n     *     try (InputStream in \u003d u.toURL().openStream()) {\n     *         Files.copy(in, path);\n     *     }\n     * }\n     *\n     * @param   in\n     *          the input stream to read from\n     * @param   target\n     *          the path to the file\n     * @param   options\n     *          options specifying how the copy should be done\n     *\n     * @return  the number of bytes read or written\n     *\n     * @throws  IOException\n     *          if an I/O error occurs when reading or writing\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  UnsupportedOperationException\n     *          if {@code options} contains a copy option that is not supported\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. Where the\n     *          {@code REPLACE_EXISTING} option is specified, the security\n     *          manager\u0027s {@link SecurityManager#checkDelete(String) checkDelete}\n     *          method is invoked to check that an existing file can be deleted.\n     */\n    public static long copy(InputStream in, Path target, CopyOption... options)\n        throws IOException\n    {\n        // ensure not null before opening file\n        Objects.requireNonNull(in);\n\n        // check for REPLACE_EXISTING\n        boolean replaceExisting \u003d false;\n        for (CopyOption opt: options) {\n            if (opt \u003d\u003d StandardCopyOption.REPLACE_EXISTING) {\n                replaceExisting \u003d true;\n            } else {\n                if (opt \u003d\u003d null) {\n                    throw new NullPointerException(\"options contains \u0027null\u0027\");\n                }  else {\n                    throw new UnsupportedOperationException(opt + \" not supported\");\n                }\n            }\n        }\n\n        // attempt to delete an existing file\n        SecurityException se \u003d null;\n        if (replaceExisting) {\n            try {\n                deleteIfExists(target);\n            } catch (SecurityException x) {\n                se \u003d x;\n            }\n        }\n\n        // attempt to create target file. If it fails with\n        // FileAlreadyExistsException then it may be because the security\n        // manager prevented us from deleting the file, in which case we just\n        // throw the SecurityException.\n        OutputStream ostream;\n        try {\n            ostream \u003d newOutputStream(target, StandardOpenOption.CREATE_NEW,\n                                              StandardOpenOption.WRITE);\n        } catch (FileAlreadyExistsException x) {\n            if (se !\u003d null)\n                throw se;\n            // someone else won the race and created the file\n            throw x;\n        }\n\n        // do the copy\n        try (OutputStream out \u003d ostream) {\n            return in.transferTo(out);\n        }\n    }\n\n    /**\n     * Copies all bytes from a file to an output stream.\n     *\n     * \u003cp\u003e If an I/O error occurs reading from the file or writing to the output\n     * stream, then it may do so after some bytes have been read or written.\n     * Consequently the output stream may be in an inconsistent state. It is\n     * strongly recommended that the output stream be promptly closed if an I/O\n     * error occurs.\n     *\n     * \u003cp\u003e This method may block indefinitely writing to the output stream (or\n     * reading from the file). The behavior for the case that the output stream\n     * is \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy\n     * is highly output stream and file system provider specific and therefore\n     * not specified.\n     *\n     * \u003cp\u003e Note that if the given output stream is {@link java.io.Flushable}\n     * then its {@link java.io.Flushable#flush flush} method may need to invoked\n     * after this method completes so as to flush any buffered output.\n     *\n     * @param   source\n     *          the  path to the file\n     * @param   out\n     *          the output stream to write to\n     *\n     * @return  the number of bytes read or written\n     *\n     * @throws  IOException\n     *          if an I/O error occurs when reading or writing\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static long copy(Path source, OutputStream out) throws IOException {\n        // ensure not null before opening file\n        Objects.requireNonNull(out);\n\n        try (InputStream in \u003d newInputStream(source)) {\n            return in.transferTo(out);\n        }\n    }\n\n    private static final jdk.internal.access.JavaLangAccess JLA \u003d\n            jdk.internal.access.SharedSecrets.getJavaLangAccess();\n\n    /**\n     * Reads all the bytes from an input stream. Uses {@code initialSize} as a hint\n     * about how many bytes the stream will have.\n     *\n     * @param   source\n     *          the input stream to read from\n     * @param   initialSize\n     *          the initial size of the byte array to allocate\n     *\n     * @return  a byte array containing the bytes read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the stream\n     * @throws  OutOfMemoryError\n     *          if an array of the required size cannot be allocated\n     */\n    private static byte[] read(InputStream source, int initialSize) throws IOException {\n        int capacity \u003d initialSize;\n        byte[] buf \u003d new byte[capacity];\n        int nread \u003d 0;\n        int n;\n        for (;;) {\n            // read to EOF which may read more or less than initialSize (eg: file\n            // is truncated while we are reading)\n            while ((n \u003d source.read(buf, nread, capacity - nread)) \u003e 0)\n                nread +\u003d n;\n\n            // if last call to source.read() returned -1, we are done\n            // otherwise, try to read one more byte; if that failed we\u0027re done too\n            if (n \u003c 0 || (n \u003d source.read()) \u003c 0)\n                break;\n\n            // one more byte was read; need to allocate a larger buffer\n            capacity \u003d Math.max(ArraysSupport.newLength(capacity,\n                                                        1,       /* minimum growth */\n                                                        capacity /* preferred growth */),\n                                BUFFER_SIZE);\n            buf \u003d Arrays.copyOf(buf, capacity);\n            buf[nread++] \u003d (byte)n;\n        }\n        return (capacity \u003d\u003d nread) ? buf : Arrays.copyOf(buf, nread);\n    }\n\n    /**\n     * Reads all the bytes from a file. The method ensures that the file is\n     * closed when all bytes have been read or an I/O error, or other runtime\n     * exception, is thrown.\n     *\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\n     * convenient to read all bytes into a byte array. It is not intended for\n     * reading in large files.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  a byte array containing the bytes read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the stream\n     * @throws  OutOfMemoryError\n     *          if an array of the required size cannot be allocated, for\n     *          example the file is larger that {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static byte[] readAllBytes(Path path) throws IOException {\n        try (SeekableByteChannel sbc \u003d Files.newByteChannel(path);\n             InputStream in \u003d Channels.newInputStream(sbc)) {\n            if (sbc instanceof FileChannelImpl)\n                ((FileChannelImpl) sbc).setUninterruptible();\n            long size \u003d sbc.size();\n            if (size \u003e (long) Integer.MAX_VALUE)\n                throw new OutOfMemoryError(\"Required array size too large\");\n            return read(in, (int)size);\n        }\n    }\n\n    /**\n     * Reads all content from a file into a string, decoding from bytes to characters\n     * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     * The method ensures that the file is closed when all content have been read\n     * or an I/O error, or other runtime exception, is thrown.\n     *\n     * \u003cp\u003e This method is equivalent to: {@link readString(Path, Charset)\n     * readString(path, StandardCharsets.UTF_8)}.\n     *\n     * @param   path the path to the file\n     *\n     * @return  a String containing the content read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  OutOfMemoryError\n     *          if the file is extremely large, for example larger than {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 11\n     */\n    public static String readString(Path path) throws IOException {\n        return readString(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Reads all characters from a file into a string, decoding from bytes to characters\n     * using the specified {@linkplain Charset charset}.\n     * The method ensures that the file is closed when all content have been read\n     * or an I/O error, or other runtime exception, is thrown.\n     *\n     * \u003cp\u003e This method reads all content including the line separators in the middle\n     * and/or at the end. The resulting string will contain line separators as they\n     * appear in the file.\n     *\n     * @apiNote\n     * This method is intended for simple cases where it is appropriate and convenient\n     * to read the content of a file into a String. It is not intended for reading\n     * very large files.\n     *\n     *\n     *\n     * @param   path the path to the file\n     * @param   cs the charset to use for decoding\n     *\n     * @return  a String containing the content read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  OutOfMemoryError\n     *          if the file is extremely large, for example larger than {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 11\n     */\n    public static String readString(Path path, Charset cs) throws IOException {\n        Objects.requireNonNull(path);\n        Objects.requireNonNull(cs);\n\n        byte[] ba \u003d readAllBytes(path);\n        if (path.getClass().getModule() !\u003d Object.class.getModule())\n            ba \u003d ba.clone();\n        return JLA.newStringNoRepl(ba, cs);\n    }\n\n    /**\n     * Read all lines from a file. This method ensures that the file is\n     * closed when all bytes have been read or an I/O error, or other runtime\n     * exception, is thrown. Bytes from the file are decoded into characters\n     * using the specified charset.\n     *\n     * \u003cp\u003e This method recognizes the following as line terminators:\n     * \u003cul\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e followed by \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e,\n     *     CARRIAGE RETURN followed by LINE FEED \u003c/li\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e, LINE FEED \u003c/li\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e, CARRIAGE RETURN \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e Additional Unicode line terminators may be recognized in future\n     * releases.\n     *\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\n     * convenient to read all lines in a single operation. It is not intended\n     * for reading in large files.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  the lines from the file as a {@code List}; whether the {@code\n     *          List} is modifiable or not is implementation dependent and\n     *          therefore not specified\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see #newBufferedReader\n     */\n    public static List\u003cString\u003e readAllLines(Path path, Charset cs) throws IOException {\n        try (BufferedReader reader \u003d newBufferedReader(path, cs)) {\n            List\u003cString\u003e result \u003d new ArrayList\u003c\u003e();\n            for (;;) {\n                String line \u003d reader.readLine();\n                if (line \u003d\u003d null)\n                    break;\n                result.add(line);\n            }\n            return result;\n        }\n    }\n\n    /**\n     * Read all lines from a file. Bytes from the file are decoded into characters\n     * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * readAllLines(Path, Charset)\n     * Files.readAllLines(path, StandardCharsets.UTF_8)\n     * }\u003c/blockquote\u003e\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the lines from the file as a {@code List}; whether the {@code\n     *          List} is modifiable or not is implementation dependent and\n     *          therefore not specified\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static List\u003cString\u003e readAllLines(Path path) throws IOException {\n        return readAllLines(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Writes bytes to a file. The {@code options} parameter specifies how\n     * the file is created or opened. If no options are present then this method\n     * works as if the {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}. All bytes in the byte array are written to the file.\n     * The method ensures that the file is closed when all bytes have been\n     * written (or an I/O error or other runtime exception is thrown). If an I/O\n     * error occurs then it may do so after the file has been created or\n     * truncated, or after some bytes have been written to the file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: By default the method creates a new file or\n     * overwrites an existing file. Suppose you instead want to append bytes\n     * to an existing file:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     byte[] bytes \u003d ...\n     *     Files.write(path, bytes, StandardOpenOption.APPEND);\n     * }\n     *\n     * @param   path\n     *          the path to the file\n     * @param   bytes\n     *          the byte array with the bytes to write\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static Path write(Path path, byte[] bytes, OpenOption... options)\n        throws IOException\n    {\n        // ensure bytes is not null before opening file\n        Objects.requireNonNull(bytes);\n\n        try (OutputStream out \u003d Files.newOutputStream(path, options)) {\n            int len \u003d bytes.length;\n            int rem \u003d len;\n            while (rem \u003e 0) {\n                int n \u003d Math.min(rem, BUFFER_SIZE);\n                out.write(bytes, (len-rem), n);\n                rem -\u003d n;\n            }\n        }\n        return path;\n    }\n\n    /**\n     * Write lines of text to a file. Each line is a char sequence and is\n     * written to the file in sequence with each line terminated by the\n     * platform\u0027s line separator, as defined by the system property {@code\n     * line.separator}. Characters are encoded into bytes using the specified\n     * charset.\n     *\n     * \u003cp\u003e The {@code options} parameter specifies how the file is created\n     * or opened. If no options are present then this method works as if the\n     * {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}. The method ensures that the file is closed when all\n     * lines have been written (or an I/O error or other runtime exception is\n     * thrown). If an I/O error occurs then it may do so after the file has\n     * been created or truncated, or after some bytes have been written to the\n     * file.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   lines\n     *          an object to iterate over the char sequences\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines,\n                             Charset cs, OpenOption... options)\n        throws IOException\n    {\n        // ensure lines is not null before opening file\n        Objects.requireNonNull(lines);\n        CharsetEncoder encoder \u003d cs.newEncoder();\n        try (OutputStream out \u003d newOutputStream(path, options);\n             BufferedWriter writer \u003d new BufferedWriter(new OutputStreamWriter(out, encoder))) {\n            for (CharSequence line: lines) {\n                writer.append(line);\n                writer.newLine();\n            }\n        }\n        return path;\n    }\n\n    /**\n     * Write lines of text to a file. Characters are encoded into bytes using\n     * the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * write(Path, Iterable\u003c? extends CharSequence\u003e, Charset, OpenOption...)\n     * Files.write(path, lines, StandardCharsets.UTF_8, options)\n     * }\u003c/blockquote\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   lines\n     *          an object to iterate over the char sequences\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded as {@code UTF-8}\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 1.8\n     */\n    public static Path write(Path path,\n                             Iterable\u003c? extends CharSequence\u003e lines,\n                             OpenOption... options)\n        throws IOException\n    {\n        return write(path, lines, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.\n     * Characters are encoded into bytes using the\n     * {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method is equivalent to: {@link\n     * writeString(Path, CharSequence, Charset, OpenOption...)\n     * writeString(path, csq, StandardCharsets.UTF_8, options)}.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   csq\n     *          the CharSequence to be written\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using UTF-8\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 11\n     */\n    public static Path writeString(Path path, CharSequence csq, OpenOption... options)\n            throws IOException\n    {\n        return writeString(path, csq, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.\n     * Characters are encoded into bytes using the specified\n     * {@linkplain java.nio.charset.Charset charset}.\n     *\n     * \u003cp\u003e All characters are written as they are, including the line separators in\n     * the char sequence. No extra characters are added.\n     *\n     * \u003cp\u003e The {@code options} parameter specifies how the file is created\n     * or opened. If no options are present then this method works as if the\n     * {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}.\n     *\n     *\n     * @param   path\n     *          the path to the file\n     * @param   csq\n     *          the CharSequence to be written\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 11\n     */\n    public static Path writeString(Path path, CharSequence csq, Charset cs, OpenOption... options)\n            throws IOException\n    {\n        // ensure the text is not null before opening file\n        Objects.requireNonNull(path);\n        Objects.requireNonNull(csq);\n        Objects.requireNonNull(cs);\n\n        byte[] bytes \u003d JLA.getBytesNoRepl(String.valueOf(csq), cs);\n        if (path.getClass().getModule() !\u003d Object.class.getModule())\n            bytes \u003d bytes.clone();\n        write(path, bytes, options);\n\n        return path;\n    }\n\n    // -- Stream APIs --\n\n    /**\n     * Return a lazily populated {@code Stream}, the elements of\n     * which are the entries in the directory.  The listing is not recursive.\n     *\n     * \u003cp\u003e The elements of the stream are {@link Path} objects that are\n     * obtained as if by {@link Path#resolve(Path) resolving} the name of the\n     * directory entry against {@code dir}. Some file systems maintain special\n     * links to the directory itself and the directory\u0027s parent directory.\n     * Entries representing these links are not included.\n     *\n     * \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It is thread safe but does\n     * not freeze the directory while iterating, so it may (or may not)\n     * reflect updates to the directory that occur after returning from this\n     * method.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open directory.\n     * The directory is closed by closing the stream.\n     *\n     * \u003cp\u003e Operating on a closed stream behaves as if the end of stream\n     * has been reached. Due to read-ahead, one or more elements may be\n     * returned after the stream has been closed.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after this method has returned, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directory is closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   dir  The path to the directory\n     *\n     * @return  The {@code Stream} describing the content of the\n     *          directory\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs when opening the directory\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     *\n     * @see     #newDirectoryStream(Path)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e list(Path dir) throws IOException {\n        DirectoryStream\u003cPath\u003e ds \u003d Files.newDirectoryStream(dir);\n        try {\n            final Iterator\u003cPath\u003e delegate \u003d ds.iterator();\n\n            // Re-wrap DirectoryIteratorException to UncheckedIOException\n            Iterator\u003cPath\u003e iterator \u003d new Iterator\u003c\u003e() {\n                @Override\n                public boolean hasNext() {\n                    try {\n                        return delegate.hasNext();\n                    } catch (DirectoryIteratorException e) {\n                        throw new UncheckedIOException(e.getCause());\n                    }\n                }\n                @Override\n                public Path next() {\n                    try {\n                        return delegate.next();\n                    } catch (DirectoryIteratorException e) {\n                        throw new UncheckedIOException(e.getCause());\n                    }\n                }\n            };\n\n            Spliterator\u003cPath\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(asUncheckedRunnable(ds));\n        } catch (Error|RuntimeException e) {\n            try {\n                ds.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {}\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by walking the file tree rooted at a given starting file.  The\n     * file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\n     * are {@link Path} objects that are obtained as if by {@link\n     * Path#resolve(Path) resolving} the relative path against {@code start}.\n     *\n     * \u003cp\u003e The {@code stream} walks the file tree as elements are consumed.\n     * The {@code Stream} returned is guaranteed to have at least one\n     * element, the starting file itself. For each file visited, the stream\n     * attempts to read its {@link BasicFileAttributes}. If the file is a\n     * directory and can be opened successfully, entries in the directory, and\n     * their \u003cem\u003edescendants\u003c/em\u003e will follow the directory in the stream as\n     * they are encountered. When all entries have been visited, then the\n     * directory is closed. The file tree walk then continues at the next\n     * \u003cem\u003esibling\u003c/em\u003e of the directory.\n     *\n     * \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It does not freeze the\n     * file tree while iterating, so it may (or may not) reflect updates to\n     * the file tree that occur after returned from this method.\n     *\n     * \u003cp\u003e By default, symbolic links are not automatically followed by this\n     * method. If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\n     * followed. When following links, and the attributes of the target cannot\n     * be read, then this method attempts to get the {@code BasicFileAttributes}\n     * of the link.\n     *\n     * \u003cp\u003e If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then the stream keeps\n     * track of directories visited so that cycles can be detected. A cycle\n     * arises when there is an entry in a directory that is an ancestor of the\n     * directory. Cycle detection is done by recording the {@link\n     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\n     * or if file keys are not available, by invoking the {@link #isSameFile\n     * isSameFile} method to test if a directory is the same file as an\n     * ancestor. When a cycle is detected it is treated as an I/O error with\n     * an instance of {@link FileSystemLoopException}.\n     *\n     * \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\n     * directories to visit. A value of {@code 0} means that only the starting\n     * file is visited, unless denied by the security manager. A value of\n     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\n     * levels should be visited.\n     *\n     * \u003cp\u003e When a security manager is installed and it denies access to a file\n     * (or directory), then it is ignored and not included in the stream.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after this method has returned, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   maxDepth\n     *          the maximum number of directory levels to visit\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e walk(Path start,\n                                    int maxDepth,\n                                    FileVisitOption... options)\n        throws IOException\n    {\n        FileTreeIterator iterator \u003d new FileTreeIterator(start, maxDepth, options);\n        try {\n            Spliterator\u003cFileTreeWalker.Event\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(iterator::close)\n                                .map(entry -\u003e entry.file());\n        } catch (Error|RuntimeException e) {\n            iterator.close();\n            throw e;\n        }\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by walking the file tree rooted at a given starting file.  The\n     * file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\n     * are {@link Path} objects that are obtained as if by {@link\n     * Path#resolve(Path) resolving} the relative path against {@code start}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * walk(Path, int, FileVisitOption...)\n     * Files.walk(start, Integer.MAX_VALUE, options)\n     * }\u003c/blockquote\u003e\n     * In other words, it visits all levels of the file tree.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     *\n     * @see     #walk(Path, int, FileVisitOption...)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e walk(Path start, FileVisitOption... options) throws IOException {\n        return walk(start, Integer.MAX_VALUE, options);\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by searching for files in a file tree rooted at a given starting\n     * file.\n     *\n     * \u003cp\u003e This method walks the file tree in exactly the manner specified by\n     * the {@link #walk walk} method. For each file encountered, the given\n     * {@link BiPredicate} is invoked with its {@link Path} and {@link\n     * BasicFileAttributes}. The {@code Path} object is obtained as if by\n     * {@link Path#resolve(Path) resolving} the relative path against {@code\n     * start} and is only included in the returned {@link Stream} if\n     * the {@code BiPredicate} returns true. Compare to calling {@link\n     * java.util.stream.Stream#filter filter} on the {@code Stream}\n     * returned by {@code walk} method, this method may be more efficient by\n     * avoiding redundant retrieval of the {@code BasicFileAttributes}.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after returned from this method, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   maxDepth\n     *          the maximum number of directory levels to search\n     * @param   matcher\n     *          the function used to decide whether a file should be included\n     *          in the returned stream\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     *\n     * @see     #walk(Path, int, FileVisitOption...)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e find(Path start,\n                                    int maxDepth,\n                                    BiPredicate\u003cPath, BasicFileAttributes\u003e matcher,\n                                    FileVisitOption... options)\n        throws IOException\n    {\n        FileTreeIterator iterator \u003d new FileTreeIterator(start, maxDepth, options);\n        try {\n            Spliterator\u003cFileTreeWalker.Event\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(iterator::close)\n                                .filter(entry -\u003e matcher.test(entry.file(), entry.attributes()))\n                                .map(entry -\u003e entry.file());\n        } catch (Error|RuntimeException e) {\n            iterator.close();\n            throw e;\n        }\n    }\n\n\n    /**\n     * Read all lines from a file as a {@code Stream}. Unlike {@link\n     * #readAllLines(Path, Charset) readAllLines}, this method does not read\n     * all lines into a {@code List}, but instead populates lazily as the stream\n     * is consumed.\n     *\n     * \u003cp\u003e Bytes from the file are decoded into characters using the specified\n     * charset and the same line terminators as specified by {@code\n     * readAllLines} are supported.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open file. The file\n     * is closed by closing the stream.\n     *\n     * \u003cp\u003e The file contents should not be modified during the execution of the\n     * terminal stream operation. Otherwise, the result of the terminal stream\n     * operation is undefined.\n     *\n     * \u003cp\u003e After this method returns, then any subsequent I/O exception that\n     * occurs while reading from the file or when a malformed or unmappable byte\n     * sequence is read, is wrapped in an {@link UncheckedIOException} that will\n     * be thrown from the\n     * {@link java.util.stream.Stream} method that caused the read to take\n     * place. In case an {@code IOException} is thrown when closing the file,\n     * it is also wrapped as an {@code UncheckedIOException}.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open file is closed promptly\n     * after the stream\u0027s operations have completed.\n     *\n     * @implNote\n     * This implementation supports good parallel stream performance for the\n     * standard charsets {@link StandardCharsets#UTF_8 UTF-8},\n     * {@link StandardCharsets#US_ASCII US-ASCII} and\n     * {@link StandardCharsets#ISO_8859_1 ISO-8859-1}.  Such\n     * \u003cem\u003eline-optimal\u003c/em\u003e charsets have the property that the encoded bytes\n     * of a line feed (\u0027\\n\u0027) or a carriage return (\u0027\\r\u0027) are efficiently\n     * identifiable from other encoded characters when randomly accessing the\n     * bytes of the file.\n     *\n     * \u003cp\u003e For non-\u003cem\u003eline-optimal\u003c/em\u003e charsets the stream source\u0027s\n     * spliterator has poor splitting properties, similar to that of a\n     * spliterator associated with an iterator or that associated with a stream\n     * returned from {@link BufferedReader#lines()}.  Poor splitting properties\n     * can result in poor parallel stream performance.\n     *\n     * \u003cp\u003e For \u003cem\u003eline-optimal\u003c/em\u003e charsets the stream source\u0027s spliterator\n     * has good splitting properties, assuming the file contains a regular\n     * sequence of lines.  Good splitting properties can result in good parallel\n     * stream performance.  The spliterator for a \u003cem\u003eline-optimal\u003c/em\u003e charset\n     * takes advantage of the charset properties (a line feed or a carriage\n     * return being efficient identifiable) such that when splitting it can\n     * approximately divide the number of covered lines in half.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  the lines from the file as a {@code Stream}\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see     #readAllLines(Path, Charset)\n     * @see     #newBufferedReader(Path, Charset)\n     * @see     java.io.BufferedReader#lines()\n     * @since   1.8\n     */\n    public static Stream\u003cString\u003e lines(Path path, Charset cs) throws IOException {\n        // Use the good splitting spliterator if:\n        // 1) the path is associated with the default file system;\n        // 2) the character set is supported; and\n        // 3) the file size is such that all bytes can be indexed by int values\n        //    (this limitation is imposed by ByteBuffer)\n        if (path.getFileSystem() \u003d\u003d FileSystems.getDefault() \u0026\u0026\n            FileChannelLinesSpliterator.SUPPORTED_CHARSETS.contains(cs)) {\n            FileChannel fc \u003d FileChannel.open(path, StandardOpenOption.READ);\n\n            Stream\u003cString\u003e fcls \u003d createFileChannelLinesStream(fc, cs);\n            if (fcls !\u003d null) {\n                return fcls;\n            }\n            fc.close();\n        }\n\n        return createBufferedReaderLinesStream(Files.newBufferedReader(path, cs));\n    }\n\n    private static Stream\u003cString\u003e createFileChannelLinesStream(FileChannel fc, Charset cs) throws IOException {\n        try {\n            // Obtaining the size from the FileChannel is much faster\n            // than obtaining using path.toFile().length()\n            long length \u003d fc.size();\n            // FileChannel.size() may in certain circumstances return zero\n            // for a non-zero length file so disallow this case.\n            if (length \u003e 0 \u0026\u0026 length \u003c\u003d Integer.MAX_VALUE) {\n                FileChannelLinesSpliterator fcls \u003d\n                    new FileChannelLinesSpliterator(fc, cs, 0, (int) length);\n                return StreamSupport.stream(fcls, false)\n                        .onClose(Files.asUncheckedRunnable(fc))\n                        .onClose(() -\u003e fcls.close());\n            }\n        } catch (Error|RuntimeException|IOException e) {\n            try {\n                fc.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {\n                }\n            }\n            throw e;\n        }\n        return null;\n    }\n\n    private static Stream\u003cString\u003e createBufferedReaderLinesStream(BufferedReader br) {\n        try {\n            return br.lines().onClose(asUncheckedRunnable(br));\n        } catch (Error|RuntimeException e) {\n            try {\n                br.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {\n                }\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Read all lines from a file as a {@code Stream}. Bytes from the file are\n     * decoded into characters using the {@link StandardCharsets#UTF_8 UTF-8}\n     * {@link Charset charset}.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open file. The file\n     * is closed by closing the stream.\n     *\n     * \u003cp\u003e The file contents should not be modified during the execution of the\n     * terminal stream operation. Otherwise, the result of the terminal stream\n     * operation is undefined.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * lines(Path, Charset)\n     * Files.lines(path, StandardCharsets.UTF_8)\n     * }\u003c/blockquote\u003e\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open file is closed promptly\n     * after the stream\u0027s operations have completed.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the lines from the file as a {@code Stream}\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static Stream\u003cString\u003e lines(Path path) throws IOException {\n        return lines(path, UTF_8.INSTANCE);\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

Π°ΠΏΡ€. 25, 2024 4:26:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/nio/file/Files.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.04.25 16:26:40 INFO  compiling bestgame (1 scala source)
2024.04.25 16:26:42 INFO  time: compiled bestgame in 2.18s
2024.04.25 16:26:55 INFO  compiling bestgame (1 scala source)
2024.04.25 16:26:55 INFO  time: compiled bestgame in 0.11s
2024.04.25 16:30:52 INFO  compiling bestgame (1 scala source)
2024.04.25 16:30:52 INFO  time: compiled bestgame in 0.16s
2024.04.25 16:32:10 INFO  compiling bestgame (1 scala source)
2024.04.25 16:32:10 INFO  time: compiled bestgame in 0.13s
Π°ΠΏΡ€. 25, 2024 4:32:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12167
2024.04.25 16:32:35 INFO  compiling bestgame (1 scala source)
2024.04.25 16:32:35 INFO  time: compiled bestgame in 0.48s
Π°ΠΏΡ€. 25, 2024 4:32:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12249
2024.04.25 16:32:43 INFO  compiling bestgame (1 scala source)
2024.04.25 16:32:43 INFO  time: compiled bestgame in 0.11s
2024.04.25 16:32:44 INFO  Report absolute-path: ### java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/nio/file/Files.java

Uri: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/nio/file/Files.java


#### Error stacktrace:

```
java.base/java.net.URI.create(URI.java:932)
	scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePathSafe(MetalsEnrichments.scala:715)
	scala.meta.internal.metals.WorkspaceLspService.getServiceFor(WorkspaceLspService.scala:262)
	scala.meta.internal.metals.WorkspaceLspService.executeCommand(WorkspaceLspService.scala:715)
	scala.meta.metals.lsp.DelegatingScalaService.executeCommand(DelegatingScalaService.scala:169)
	java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	java.base/java.lang.reflect.Method.invoke(Method.java:580)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	java.base/java.lang.Thread.run(Thread.java:1570)
```

Π°ΠΏΡ€. 25, 2024 4:32:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/nio/file/Files.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 2007, 2023, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\n\npackage java.nio.file;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.UncheckedIOException;\nimport java.io.Writer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.attribute.BasicFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.attribute.DosFileAttributes;   // javadoc\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.FileAttributeView;\nimport java.nio.file.attribute.FileOwnerAttributeView;\nimport java.nio.file.attribute.FileStoreAttributeView;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributeView;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.nio.file.attribute.UserPrincipal;\nimport java.nio.file.spi.FileSystemProvider;\nimport java.nio.file.spi.FileTypeDetector;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.ServiceLoader;\nimport java.util.Set;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.function.BiPredicate;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport jdk.internal.util.ArraysSupport;\nimport sun.nio.ch.FileChannelImpl;\nimport sun.nio.cs.UTF_8;\n\n/**\n * This class consists exclusively of static methods that operate on files,\n * directories, or other types of files.\n *\n * \u003cp\u003e In most cases, the methods defined here will delegate to the associated\n * file system provider to perform the file operations.\n *\n * @since 1.7\n */\n\npublic final class Files {\n    // buffer size used for reading and writing\n    private static final int BUFFER_SIZE \u003d 8192;\n\n    private Files() { }\n\n    /**\n     * Returns the {@code FileSystemProvider} to delegate to.\n     */\n    private static FileSystemProvider provider(Path path) {\n        return path.getFileSystem().provider();\n    }\n\n    /**\n     * Convert a Closeable to a Runnable by converting checked IOException\n     * to UncheckedIOException\n     */\n    private static Runnable asUncheckedRunnable(Closeable c) {\n        return () -\u003e {\n            try {\n                c.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        };\n    }\n\n    // -- File contents --\n\n    /**\n     * Opens a file, returning an input stream to read from the file. The stream\n     * will not be buffered, and is not required to support the {@link\n     * InputStream#mark mark} or {@link InputStream#reset reset} methods. The\n     * stream will be safe for access by multiple concurrent threads. Reading\n     * commences at the beginning of the file. Whether the returned stream is\n     * \u003ci\u003easynchronously closeable\u003c/i\u003e and/or \u003ci\u003einterruptible\u003c/i\u003e is highly\n     * file system provider specific and therefore not specified.\n     *\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\n     * If no options are present then it is equivalent to opening the file with\n     * the {@link StandardOpenOption#READ READ} option. In addition to the {@code\n     * READ} option, an implementation may also support additional implementation\n     * specific options.\n     *\n     * @param   path\n     *          the path to the file to open\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new input stream\n     *\n     * @throws  IllegalArgumentException\n     *          if an invalid combination of options is specified\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static InputStream newInputStream(Path path, OpenOption... options)\n        throws IOException\n    {\n        return provider(path).newInputStream(path, options);\n    }\n\n    /**\n     * Opens or creates a file, returning an output stream that may be used to\n     * write bytes to the file. The resulting stream will not be buffered. The\n     * stream will be safe for access by multiple concurrent threads. Whether\n     * the returned stream is \u003ci\u003easynchronously closeable\u003c/i\u003e and/or\n     * \u003ci\u003einterruptible\u003c/i\u003e is highly file system provider specific and\n     * therefore not specified.\n     *\n     * \u003cp\u003e This method opens or creates a file in exactly the manner specified\n     * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\n     * method with the exception that the {@link StandardOpenOption#READ READ}\n     * option may not be present in the array of options. If no options are\n     * present then this method works as if the {@link StandardOpenOption#CREATE\n     * CREATE}, {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING},\n     * and {@link StandardOpenOption#WRITE WRITE} options are present. In other\n     * words, it opens the file for writing, creating the file if it doesn\u0027t\n     * exist, or initially truncating an existing {@link #isRegularFile\n     * regular-file} to a size of {@code 0} if it exists.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *\n     *     // truncate and overwrite an existing file, or create the file if\n     *     // it doesn\u0027t initially exist\n     *     OutputStream out \u003d Files.newOutputStream(path);\n     *\n     *     // append to an existing file, fail if the file does not exist\n     *     out \u003d Files.newOutputStream(path, APPEND);\n     *\n     *     // append to an existing file, create file if it doesn\u0027t initially exist\n     *     out \u003d Files.newOutputStream(path, CREATE, APPEND);\n     *\n     *     // always create new file, failing if it already exists\n     *     out \u003d Files.newOutputStream(path, CREATE_NEW);\n     * }\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new output stream\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static OutputStream newOutputStream(Path path, OpenOption... options)\n        throws IOException\n    {\n        return provider(path).newOutputStream(path, options);\n    }\n\n    /**\n     * Opens or creates a file, returning a seekable byte channel to access the\n     * file.\n     *\n     * \u003cp\u003e The {@code options} parameter determines how the file is opened.\n     * The {@link StandardOpenOption#READ READ} and {@link\n     * StandardOpenOption#WRITE WRITE} options determine if the file should be\n     * opened for reading and/or writing. If neither option (or the {@link\n     * StandardOpenOption#APPEND APPEND} option) is present then the file is\n     * opened for reading. By default reading or writing commence at the\n     * beginning of the file.\n     *\n     * \u003cp\u003e In the addition to {@code READ} and {@code WRITE}, the following\n     * options may be present:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#APPEND APPEND} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then the file is opened for writing and\n     *     each invocation of the channel\u0027s {@code write} method first advances\n     *     the position to the end of the file and then writes the requested\n     *     data. Whether the advancement of the position and the writing of the\n     *     data are done in a single atomic operation is system-dependent and\n     *     therefore unspecified. This option may not be used in conjunction\n     *     with the {@code READ} or {@code TRUNCATE_EXISTING} options. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then the existing file is truncated to\n     *   a size of 0 bytes. This option is ignored when the file is opened only\n     *   for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#CREATE_NEW CREATE_NEW} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then a new file is created, failing if\n     *   the file already exists or is a symbolic link. When creating a file the\n     *   check for the existence of the file and the creation of the file if it\n     *   does not exist is atomic with respect to other file system operations.\n     *   This option is ignored when the file is opened only for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\" \u003e {@link StandardOpenOption#CREATE CREATE} \u003c/th\u003e\n     *   \u003ctd\u003e If this option is present then an existing file is opened if it\n     *   exists, otherwise a new file is created. This option is ignored if the\n     *   {@code CREATE_NEW} option is also present or the file is opened only\n     *   for reading. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\" \u003e {@link StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} \u003c/th\u003e\n     *   \u003ctd\u003e When this option is present then the implementation makes a\n     *   \u003cem\u003ebest effort\u003c/em\u003e attempt to delete the file when closed by the\n     *   {@link SeekableByteChannel#close close} method. If the {@code close}\n     *   method is not invoked then a \u003cem\u003ebest effort\u003c/em\u003e attempt is made to\n     *   delete the file when the Java virtual machine terminates. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e{@link StandardOpenOption#SPARSE SPARSE} \u003c/th\u003e\n     *   \u003ctd\u003e When creating a new file this option is a \u003cem\u003ehint\u003c/em\u003e that the\n     *   new file will be sparse. This option is ignored when not creating\n     *   a new file. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#SYNC SYNC} \u003c/th\u003e\n     *   \u003ctd\u003e Requires that every update to the file\u0027s content or metadata be\n     *   written synchronously to the underlying storage device. (see \u003ca\n     *   href\u003d\"package-summary.html#integrity\"\u003e Synchronized I/O file\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardOpenOption#DSYNC DSYNC} \u003c/th\u003e\n     *   \u003ctd\u003e Requires that every update to the file\u0027s content be written\n     *   synchronously to the underlying storage device. (see \u003ca\n     *   href\u003d\"package-summary.html#integrity\"\u003e Synchronized I/O file\n     *   integrity\u003c/a\u003e). \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation may also support additional implementation specific\n     * options.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when a new file is created.\n     *\n     * \u003cp\u003e In the case of the default provider, the returned seekable byte channel\n     * is a {@link java.nio.channels.FileChannel}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *\n     *     // open file for reading\n     *     ReadableByteChannel rbc \u003d Files.newByteChannel(path, EnumSet.of(READ)));\n     *\n     *     // open file for writing to the end of an existing file, creating\n     *     // the file if it doesn\u0027t already exist\n     *     WritableByteChannel wbc \u003d Files.newByteChannel(path, EnumSet.of(CREATE,APPEND));\n     *\n     *     // create file with initial permissions, opening it for both reading and writing\n     *     FileAttribute\u003cSet\u003cPosixFilePermission\u003e\u003e perms \u003d ...\n     *     SeekableByteChannel sbc \u003d\n     *         Files.newByteChannel(path, EnumSet.of(CREATE_NEW,READ,WRITE), perms);\n     * }\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  a new seekable byte channel\n     *\n     * @throws  IllegalArgumentException\n     *          if the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported open option is specified or the array contains\n     *          attributes that cannot be set atomically when creating the file\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          and the file is being opened for writing \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the path if the file is\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method is invoked to check write access to the path\n     *          if the file is opened for writing. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see java.nio.channels.FileChannel#open(Path,Set,FileAttribute[])\n     */\n    public static SeekableByteChannel newByteChannel(Path path,\n                                                     Set\u003c? extends OpenOption\u003e options,\n                                                     FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return provider(path).newByteChannel(path, options, attrs);\n    }\n\n    /**\n     * Opens or creates a file, returning a seekable byte channel to access the\n     * file.\n     *\n     * \u003cp\u003e This method opens or creates a file in exactly the manner specified\n     * by the {@link #newByteChannel(Path,Set,FileAttribute[]) newByteChannel}\n     * method.\n     *\n     * @param   path\n     *          the path to the file to open or create\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new seekable byte channel\n     *\n     * @throws  IllegalArgumentException\n     *          if the set contains an invalid combination of options\n     * @throws  UnsupportedOperationException\n     *          if an unsupported open option is specified\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          and the file is being opened for writing \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the path if the file is\n     *          opened for reading. The {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method is invoked to check write access to the path\n     *          if the file is opened for writing. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see java.nio.channels.FileChannel#open(Path,OpenOption[])\n     */\n    public static SeekableByteChannel newByteChannel(Path path, OpenOption... options)\n        throws IOException\n    {\n        Set\u003cOpenOption\u003e set;\n        if (options.length \u003d\u003d 0) {\n            set \u003d Collections.emptySet();\n        } else {\n            set \u003d new HashSet\u003c\u003e();\n            Collections.addAll(set, options);\n        }\n        return newByteChannel(path, set);\n    }\n\n    // -- Directories --\n\n    private static class AcceptAllFilter\n        implements DirectoryStream.Filter\u003cPath\u003e\n    {\n        private AcceptAllFilter() { }\n\n        @Override\n        public boolean accept(Path entry) { return true; }\n\n        static final AcceptAllFilter FILTER \u003d new AcceptAllFilter();\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * all entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * @param   dir\n     *          the path to the directory\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir)\n        throws IOException\n    {\n        return provider(dir).newDirectoryStream(dir, AcceptAllFilter.FILTER);\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * the entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}. The entries returned by\n     * the iterator are filtered by matching the {@code String} representation\n     * of their file names against the given \u003cem\u003eglobbing\u003c/em\u003e pattern.\n     *\n     * \u003cp\u003e For example, suppose we want to iterate over the files ending with\n     * \".java\" in a directory:\n     * {@snippet lang\u003djava :\n     *     Path dir \u003d ...\n     *     try (DirectoryStream\u003cPath\u003e stream \u003d Files.newDirectoryStream(dir, \"*.java\")) {\n     *         :\n     *     }\n     * }\n     *\n     * \u003cp\u003e The globbing pattern is specified by the {@link\n     * FileSystem#getPathMatcher getPathMatcher} method.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * @param   dir\n     *          the path to the directory\n     * @param   glob\n     *          the glob pattern\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  java.util.regex.PatternSyntaxException\n     *          if the pattern is invalid\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir, String glob)\n        throws IOException\n    {\n        // avoid creating a matcher if all entries are required.\n        if (glob.equals(\"*\"))\n            return newDirectoryStream(dir);\n\n        // create a matcher and return a filter that uses it.\n        FileSystem fs \u003d dir.getFileSystem();\n        final PathMatcher matcher \u003d fs.getPathMatcher(\"glob:\" + glob);\n        DirectoryStream.Filter\u003cPath\u003e filter \u003d new DirectoryStream.Filter\u003c\u003e() {\n            @Override\n            public boolean accept(Path entry)  {\n                return matcher.matches(entry.getFileName());\n            }\n        };\n        return fs.provider().newDirectoryStream(dir, filter);\n    }\n\n    /**\n     * Opens a directory, returning a {@link DirectoryStream} to iterate over\n     * the entries in the directory. The elements returned by the directory\n     * stream\u0027s {@link DirectoryStream#iterator iterator} are of type {@code\n     * Path}, each one representing an entry in the directory. The {@code Path}\n     * objects are obtained as if by {@link Path#resolve(Path) resolving} the\n     * name of the directory entry against {@code dir}. The entries returned by\n     * the iterator are filtered by the given {@link DirectoryStream.Filter\n     * filter}.\n     *\n     * \u003cp\u003e When not using the try-with-resources construct, then directory\n     * stream\u0027s {@code close} method should be invoked after iteration is\n     * completed so as to free any resources held for the open directory.\n     *\n     * \u003cp\u003e Where the filter terminates due to an uncaught error or runtime\n     * exception then it is propagated to the {@link Iterator#hasNext()\n     * hasNext} or {@link Iterator#next() next} method. Where an {@code\n     * IOException} is thrown, it results in the {@code hasNext} or {@code\n     * next} method throwing a {@link DirectoryIteratorException} with the\n     * {@code IOException} as the cause.\n     *\n     * \u003cp\u003e When an implementation supports operations on entries in the\n     * directory that execute in a race-free manner then the returned directory\n     * stream is a {@link SecureDirectoryStream}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to iterate over the files in a directory that are\n     * larger than 8K.\n     * {@snippet lang\u003djava :\n     *     DirectoryStream.Filter\u003cPath\u003e filter \u003d new DirectoryStream.Filter\u003cPath\u003e() {\n     *         public boolean accept(Path file) throws IOException {\n     *             return (Files.size(file) \u003e 8192L);\n     *         }\n     *     };\n     *     Path dir \u003d ...\n     *     try (DirectoryStream\u003cPath\u003e stream \u003d Files.newDirectoryStream(dir, filter)) {\n     *         :\n     *     }\n     * }\n     *\n     * @param   dir\n     *          the path to the directory\n     * @param   filter\n     *          the directory stream filter\n     *\n     * @return  a new and open {@code DirectoryStream} object\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     */\n    public static DirectoryStream\u003cPath\u003e newDirectoryStream(Path dir,\n                                                           DirectoryStream.Filter\u003c? super Path\u003e filter)\n        throws IOException\n    {\n        return provider(dir).newDirectoryStream(dir, filter);\n    }\n\n    // -- Creation and deletion --\n\n    private static final Set\u003cOpenOption\u003e DEFAULT_CREATE_OPTIONS \u003d\n        Set.of(StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE);\n\n    /**\n     * Creates a new and empty file, failing if the file already exists. The\n     * check for the existence of the file and the creation of the new file if\n     * it does not exist are a single operation that is atomic with respect to\n     * all other filesystem activities that might affect the directory.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the file. Each attribute\n     * is identified by its {@link FileAttribute#name name}. If more than one\n     * attribute of the same name is included in the array then all but the last\n     * occurrence is ignored.\n     *\n     * @param   path\n     *          the path to the file to create\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the file\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs or the parent directory does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the new file.\n     */\n    public static Path createFile(Path path, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        newByteChannel(path, DEFAULT_CREATE_OPTIONS, attrs).close();\n        return path;\n    }\n\n    /**\n     * Creates a new directory. The check for the existence of the file and the\n     * creation of the directory if it does not exist are a single operation\n     * that is atomic with respect to all other filesystem activities that might\n     * affect the directory. The {@link #createDirectories createDirectories}\n     * method should be used where it is required to create all nonexistent\n     * parent directories first.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the directory. Each\n     * attribute is identified by its {@link FileAttribute#name name}. If more\n     * than one attribute of the same name is included in the array then all but\n     * the last occurrence is ignored.\n     *\n     * @param   dir\n     *          the directory to create\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the directory\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  FileAlreadyExistsException\n     *          if a directory could not otherwise be created because a file of\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs or the parent directory does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the new directory.\n     */\n    public static Path createDirectory(Path dir, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        provider(dir).createDirectory(dir, attrs);\n        return dir;\n    }\n\n    /**\n     * Creates a directory by creating all nonexistent parent directories first.\n     * Unlike the {@link #createDirectory createDirectory} method, an exception\n     * is not thrown if the directory could not be created because it already\n     * exists.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the nonexistent\n     * directories. Each file attribute is identified by its {@link\n     * FileAttribute#name name}. If more than one attribute of the same name is\n     * included in the array then all but the last occurrence is ignored.\n     *\n     * \u003cp\u003e If this method fails, then it may do so after creating some, but not\n     * all, of the parent directories.\n     *\n     * @param   dir\n     *          the directory to create\n     *\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the directory\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  FileAlreadyExistsException\n     *          if {@code dir} exists but is not a directory \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          in the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked prior to attempting to create a directory and\n     *          its {@link SecurityManager#checkRead(String) checkRead} is\n     *          invoked for each parent directory that is checked. If {@code\n     *          dir} is not an absolute path then its {@link Path#toAbsolutePath\n     *          toAbsolutePath} may need to be invoked to get its absolute path.\n     *          This may invoke the security manager\u0027s {@link\n     *          SecurityManager#checkPropertyAccess(String) checkPropertyAccess}\n     *          method to check access to the system property {@code user.dir}\n     */\n    public static Path createDirectories(Path dir, FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        // attempt to create the directory\n        try {\n            createAndCheckIsDirectory(dir, attrs);\n            return dir;\n        } catch (FileAlreadyExistsException x) {\n            // file exists and is not a directory\n            throw x;\n        } catch (IOException x) {\n            // parent may not exist or other reason\n        }\n        SecurityException se \u003d null;\n        Path absDir \u003d dir;\n        try {\n            absDir \u003d dir.toAbsolutePath();\n        } catch (SecurityException x) {\n            // don\u0027t have permission to get absolute path\n            se \u003d x;\n        }\n        // find a descendant that exists\n        Path parent \u003d absDir.getParent();\n        while (parent !\u003d null) {\n            try {\n                provider(parent).checkAccess(parent);\n                break;\n            } catch (NoSuchFileException x) {\n                // does not exist\n            }\n            parent \u003d parent.getParent();\n        }\n        if (parent \u003d\u003d null) {\n            // unable to find existing parent\n            if (se \u003d\u003d null) {\n                throw new FileSystemException(absDir.toString(), null,\n                    \"Unable to determine if root directory exists\");\n            } else {\n                throw se;\n            }\n        }\n\n        // create directories\n        Path child \u003d parent;\n        for (Path name: parent.relativize(absDir)) {\n            child \u003d child.resolve(name);\n            createAndCheckIsDirectory(child, attrs);\n        }\n        return dir;\n    }\n\n    /**\n     * Used by createDirectories to attempt to create a directory. A no-op\n     * if the directory already exists.\n     */\n    private static void createAndCheckIsDirectory(Path dir,\n                                                  FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        try {\n            createDirectory(dir, attrs);\n        } catch (FileAlreadyExistsException x) {\n            if (!isDirectory(dir))\n                throw x;\n        }\n    }\n\n    /**\n     * Creates a new empty file in the specified directory, using the given\n     * prefix and suffix strings to generate its name. The resulting\n     * {@code Path} is associated with the same {@code FileSystem} as the given\n     * directory.\n     *\n     * \u003cp\u003e The details as to how the name of the file is constructed is\n     * implementation dependent and therefore not specified. Where possible\n     * the {@code prefix} and {@code suffix} are used to construct candidate\n     * names in the same manner as the {@link\n     * java.io.File#createTempFile(String,String,File)} method.\n     *\n     * \u003cp\u003e As with the {@code File.createTempFile} methods, this method is only\n     * part of a temporary-file facility. Where used as a \u003cem\u003ework file\u003c/em\u003e,\n     * the resulting file may be opened using the {@link\n     * StandardOpenOption#DELETE_ON_CLOSE DELETE_ON_CLOSE} option so that the\n     * file is deleted when the appropriate {@code close} method is invoked.\n     * Alternatively, a {@link Runtime#addShutdownHook shutdown-hook}, or the\n     * {@link java.io.File#deleteOnExit} mechanism may be used to delete the\n     * file automatically.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the file. Each attribute\n     * is identified by its {@link FileAttribute#name name}. If more than one\n     * attribute of the same name is included in the array then all but the last\n     * occurrence is ignored. When no file attributes are specified, then the\n     * resulting file may have more restrictive access permissions to files\n     * created by the {@link java.io.File#createTempFile(String,String,File)}\n     * method.\n     *\n     * @param   dir\n     *          the path to directory in which to create the file\n     * @param   prefix\n     *          the prefix string to be used in generating the file\u0027s name;\n     *          may be {@code null}\n     * @param   suffix\n     *          the suffix string to be used in generating the file\u0027s name;\n     *          may be {@code null}, in which case \"{@code .tmp}\" is used\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the path to the newly created file that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix or suffix parameters cannot be used to generate\n     *          a candidate file name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or {@code dir} does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file.\n     */\n    public static Path createTempFile(Path dir,\n                                      String prefix,\n                                      String suffix,\n                                      FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempFile(Objects.requireNonNull(dir),\n                                             prefix, suffix, attrs);\n    }\n\n    /**\n     * Creates an empty file in the default temporary-file directory, using\n     * the given prefix and suffix to generate its name. The resulting {@code\n     * Path} is associated with the default {@code FileSystem}.\n     *\n     * \u003cp\u003e This method works in exactly the manner specified by the\n     * {@link #createTempFile(Path,String,String,FileAttribute[])} method for\n     * the case that the {@code dir} parameter is the temporary-file directory.\n     *\n     * @param   prefix\n     *          the prefix string to be used in generating the file\u0027s name;\n     *          may be {@code null}\n     * @param   suffix\n     *          the suffix string to be used in generating the file\u0027s name;\n     *          may be {@code null}, in which case \"{@code .tmp}\" is used\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the file\n     *\n     * @return  the path to the newly created file that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix or suffix parameters cannot be used to generate\n     *          a candidate file name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or the temporary-file directory does not\n     *          exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file.\n     */\n    public static Path createTempFile(String prefix,\n                                      String suffix,\n                                      FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempFile(null, prefix, suffix, attrs);\n    }\n\n    /**\n     * Creates a new directory in the specified directory, using the given\n     * prefix to generate its name.  The resulting {@code Path} is associated\n     * with the same {@code FileSystem} as the given directory.\n     *\n     * \u003cp\u003e The details as to how the name of the directory is constructed is\n     * implementation dependent and therefore not specified. Where possible\n     * the {@code prefix} is used to construct candidate names.\n     *\n     * \u003cp\u003e As with the {@code createTempFile} methods, this method is only\n     * part of a temporary-file facility. A {@link Runtime#addShutdownHook\n     * shutdown-hook}, or the {@link java.io.File#deleteOnExit} mechanism may be\n     * used to delete the directory automatically.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * file-attributes} to set atomically when creating the directory. Each\n     * attribute is identified by its {@link FileAttribute#name name}. If more\n     * than one attribute of the same name is included in the array then all but\n     * the last occurrence is ignored.\n     *\n     * @param   dir\n     *          the path to directory in which to create the directory\n     * @param   prefix\n     *          the prefix string to be used in generating the directory\u0027s name;\n     *          may be {@code null}\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the path to the newly created directory that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix cannot be used to generate a candidate directory name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or {@code dir} does not exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access when creating the\n     *          directory.\n     */\n    public static Path createTempDirectory(Path dir,\n                                           String prefix,\n                                           FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempDirectory(Objects.requireNonNull(dir),\n                                                  prefix, attrs);\n    }\n\n    /**\n     * Creates a new directory in the default temporary-file directory, using\n     * the given prefix to generate its name. The resulting {@code Path} is\n     * associated with the default {@code FileSystem}.\n     *\n     * \u003cp\u003e This method works in exactly the manner specified by {@link\n     * #createTempDirectory(Path,String,FileAttribute[])} method for the case\n     * that the {@code dir} parameter is the temporary-file directory.\n     *\n     * @param   prefix\n     *          the prefix string to be used in generating the directory\u0027s name;\n     *          may be {@code null}\n     * @param   attrs\n     *          an optional list of file attributes to set atomically when\n     *          creating the directory\n     *\n     * @return  the path to the newly created directory that did not exist before\n     *          this method was invoked\n     *\n     * @throws  IllegalArgumentException\n     *          if the prefix cannot be used to generate a candidate directory name\n     * @throws  UnsupportedOperationException\n     *          if the array contains an attribute that cannot be set atomically\n     *          when creating the directory\n     * @throws  IOException\n     *          if an I/O error occurs or the temporary-file directory does not\n     *          exist\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access when creating the\n     *          directory.\n     */\n    public static Path createTempDirectory(String prefix,\n                                           FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        return TempFileHelper.createTempDirectory(null, prefix, attrs);\n    }\n\n    /**\n     * Creates a symbolic link to a target \u003ci\u003e(optional operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e The {@code target} parameter is the target of the link. It may be an\n     * {@link Path#isAbsolute absolute} or relative path and may not exist. When\n     * the target is a relative path then file system operations on the resulting\n     * link are relative to the path of the link.\n     *\n     * \u003cp\u003e The {@code attrs} parameter is optional {@link FileAttribute\n     * attributes} to set atomically when creating the link. Each attribute is\n     * identified by its {@link FileAttribute#name name}. If more than one attribute\n     * of the same name is included in the array then all but the last occurrence\n     * is ignored.\n     *\n     * \u003cp\u003e Where symbolic links are supported, but the underlying {@link FileStore}\n     * does not support symbolic links, then this may fail with an {@link\n     * IOException}. Additionally, some operating systems may require that the\n     * Java virtual machine be started with implementation specific privileges to\n     * create symbolic links, in which case this method may throw {@code IOException}.\n     *\n     * @param   link\n     *          the path of the symbolic link to create\n     * @param   target\n     *          the target of the symbolic link\n     * @param   attrs\n     *          the array of attributes to set atomically when creating the\n     *          symbolic link\n     *\n     * @return  the path to the symbolic link\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support symbolic links or the\n     *          array contains an attribute that cannot be set atomically when\n     *          creating the symbolic link\n     * @throws  FileAlreadyExistsException\n     *          if a file with the name already exists \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it denies {@link LinkPermission}{@code (\"symbolic\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the path of the symbolic link.\n     */\n    public static Path createSymbolicLink(Path link, Path target,\n                                          FileAttribute\u003c?\u003e... attrs)\n        throws IOException\n    {\n        provider(link).createSymbolicLink(link, target, attrs);\n        return link;\n    }\n\n    /**\n     * Creates a new link (directory entry) for an existing file \u003ci\u003e(optional\n     * operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e The {@code link} parameter locates the directory entry to create.\n     * The {@code existing} parameter is the path to an existing file. This\n     * method creates a new directory entry for the file so that it can be\n     * accessed using {@code link} as the path. On some file systems this is\n     * known as creating a \"hard link\". Whether the file attributes are\n     * maintained for the file or for each directory entry is file system\n     * specific and therefore not specified. Typically, a file system requires\n     * that all links (directory entries) for a file be on the same file system.\n     * Furthermore, on some platforms, the Java virtual machine may require to\n     * be started with implementation specific privileges to create hard links\n     * or to create links to directories.\n     *\n     * @param   link\n     *          the link (directory entry) to create\n     * @param   existing\n     *          a path to an existing file\n     *\n     * @return  the path to the link (directory entry)\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support adding an existing file\n     *          to a directory\n     * @throws  FileAlreadyExistsException\n     *          if the entry could not otherwise be created because a file of\n     *          that name already exists \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it denies {@link LinkPermission}{@code (\"hard\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to either the link or the\n     *          existing file.\n     */\n    public static Path createLink(Path link, Path existing) throws IOException {\n        provider(link).createLink(link, existing);\n        return link;\n    }\n\n    /**\n     * Deletes a file.\n     *\n     * \u003cp\u003e An implementation may require to examine the file to determine if the\n     * file is a directory. Consequently this method may not be atomic with respect\n     * to other file system operations.  If the file is a symbolic link then the\n     * symbolic link itself, not the final target of the link, is deleted.\n     *\n     * \u003cp\u003e If the file is a directory then the directory must be empty. In some\n     * implementations a directory has entries for special files or links that\n     * are created when the directory is created. In such implementations a\n     * directory is considered empty when only the special entries exist.\n     * This method can be used with the {@link #walkFileTree walkFileTree}\n     * method to delete a directory and all entries in the directory, or an\n     * entire \u003ci\u003efile-tree\u003c/i\u003e where required.\n     *\n     * \u003cp\u003e On some operating systems it may not be possible to remove a file when\n     * it is open and in use by this Java virtual machine or other programs.\n     *\n     * @param   path\n     *          the path to the file to delete\n     *\n     * @throws  NoSuchFileException\n     *          if the file does not exist \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          if the file is a directory and could not otherwise be deleted\n     *          because the directory is not empty \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\n     *          is invoked to check delete access to the file\n     */\n    public static void delete(Path path) throws IOException {\n        provider(path).delete(path);\n    }\n\n    /**\n     * Deletes a file if it exists.\n     *\n     * \u003cp\u003e As with the {@link #delete(Path) delete(Path)} method, an\n     * implementation may need to examine the file to determine if the file is a\n     * directory. Consequently this method may not be atomic with respect to\n     * other file system operations.  If the file is a symbolic link, then the\n     * symbolic link itself, not the final target of the link, is deleted.\n     *\n     * \u003cp\u003e If the file is a directory then the directory must be empty. In some\n     * implementations a directory has entries for special files or links that\n     * are created when the directory is created. In such implementations a\n     * directory is considered empty when only the special entries exist.\n     *\n     * \u003cp\u003e On some operating systems it may not be possible to remove a file when\n     * it is open and in use by this Java virtual machine or other programs.\n     *\n     * @param   path\n     *          the path to the file to delete\n     *\n     * @return  {@code true} if the file was deleted by this method; {@code\n     *          false} if the file could not be deleted because it did not\n     *          exist\n     *\n     * @throws  DirectoryNotEmptyException\n     *          if the file is a directory and could not otherwise be deleted\n     *          because the directory is not empty \u003ci\u003e(optional specific\n     *          exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkDelete(String)} method\n     *          is invoked to check delete access to the file.\n     */\n    public static boolean deleteIfExists(Path path) throws IOException {\n        return provider(path).deleteIfExists(path);\n    }\n\n    // -- Copying and moving files --\n\n    /**\n     * Copy a file to a target file.\n     *\n     * \u003cp\u003e This method copies a file to the target file with the {@code\n     * options} parameter specifying how the copy is performed. By default, the\n     * copy fails if the target file already exists or is a symbolic link,\n     * except if the source and target are the {@link #isSameFile same} file, in\n     * which case the method completes without copying the file. File attributes\n     * are not required to be copied to the target file. If symbolic links are\n     * supported, and the file is a symbolic link, then the final target of the\n     * link is copied. If the file is a directory then an empty directory is\n     * created in the target location (entries in the directory are not\n     * copied). This method can be used with the {@link #walkFileTree\n     * walkFileTree} method to copy a directory and all entries in the directory,\n     * or an entire \u003ci\u003efile-tree\u003c/i\u003e where required.\n     *\n     * \u003cp\u003e The {@code options} parameter may include any of the following:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e Replace an existing file. A non-empty directory cannot be\n     *     replaced. If the target file exists and is a symbolic link, then the\n     *     symbolic link itself, not the target of the link, is replaced. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#COPY_ATTRIBUTES COPY_ATTRIBUTES} \u003c/th\u003e\n     *   \u003ctd\u003e Attempts to copy the file attributes associated with this file to\n     *     the target file. The exact file attributes that are copied is platform\n     *     and file system dependent and therefore unspecified. Minimally, the\n     *     {@link BasicFileAttributes#lastModifiedTime last-modified-time} is\n     *     copied to the target file if supported by both the source and target\n     *     file stores. Copying of file timestamps may result in precision\n     *     loss. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} \u003c/th\u003e\n     *   \u003ctd\u003e Symbolic links are not followed. If the file is a symbolic link,\n     *     then the symbolic link itself, not the target of the link, is copied.\n     *     It is implementation specific if file attributes can be copied to the\n     *     new link. In other words, the {@code COPY_ATTRIBUTES} option may be\n     *     ignored when copying a symbolic link. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation of this interface may support additional\n     * implementation specific options.\n     *\n     * \u003cp\u003e Copying a file is not an atomic operation. If an {@link IOException}\n     * is thrown, then it is possible that the target file is incomplete or some\n     * of its file attributes have not been copied from the source file. When\n     * the {@code REPLACE_EXISTING} option is specified and the target file\n     * exists, then the target file is replaced. The check for the existence of\n     * the file and the creation of the new file may not be atomic with respect\n     * to other file system activities.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to copy a file into a directory, giving it the same file\n     * name as the source file:\n     * {@snippet lang\u003djava :\n     *     Path source \u003d ...\n     *     Path newdir \u003d ...\n     *     Files.copy(source, newdir.resolve(source.getFileName());\n     * }\n     *\n     * @param   source\n     *          the path to the file to copy\n     * @param   target\n     *          the path to the target file (may be associated with a different\n     *          provider to the source path)\n     * @param   options\n     *          options specifying how the copy should be done\n     *\n     * @return  the path to the target file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains a copy option that is not supported\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the source file, the\n     *          {@link SecurityManager#checkWrite(String) checkWrite} is invoked\n     *          to check write access to the target file. If a symbolic link is\n     *          copied the security manager is invoked to check {@link\n     *          LinkPermission}{@code (\"symbolic\")}.\n     */\n    public static Path copy(Path source, Path target, CopyOption... options)\n        throws IOException\n    {\n        FileSystemProvider provider \u003d provider(source);\n        if (provider(target) \u003d\u003d provider) {\n            // same provider\n            provider.copy(source, target, options);\n        } else {\n            // different providers\n            CopyMoveHelper.copyToForeignTarget(source, target, options);\n        }\n        return target;\n    }\n\n    /**\n     * Move or rename a file to a target file.\n     *\n     * \u003cp\u003e By default, this method attempts to move the file to the target\n     * file, failing if the target file exists except if the source and\n     * target are the {@link #isSameFile same} file, in which case this method\n     * has no effect. If the file is a symbolic link then the symbolic link\n     * itself, not the target of the link, is moved. This method may be\n     * invoked to move an empty directory. In some implementations a directory\n     * has entries for special files or links that are created when the\n     * directory is created. In such implementations a directory is considered\n     * empty when only the special entries exist. When invoked to move a\n     * directory that is not empty then the directory is moved if it does not\n     * require moving the entries in the directory.  For example, renaming a\n     * directory on the same {@link FileStore} will usually not require moving\n     * the entries in the directory. When moving a directory requires that its\n     * entries be moved then this method fails (by throwing an {@code\n     * IOException}). To move a \u003ci\u003efile tree\u003c/i\u003e may involve copying rather\n     * than moving directories and this can be done using the {@link\n     * #copy copy} method in conjunction with the {@link\n     * #walkFileTree Files.walkFileTree} utility method.\n     *\n     * \u003cp\u003e The {@code options} parameter may include any of the following:\n     *\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eOptions\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e \u003cth scope\u003d\"col\"\u003eOption\u003c/th\u003e \u003cth scope\u003d\"col\"\u003eDescription\u003c/th\u003e \u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#REPLACE_EXISTING REPLACE_EXISTING} \u003c/th\u003e\n     *   \u003ctd\u003e Replace an existing file. A non-empty directory cannot be\n     *     replaced. If the target file exists and is a symbolic link, then the\n     *     symbolic link itself, not the target of the link, is replaced. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@link StandardCopyOption#ATOMIC_MOVE ATOMIC_MOVE} \u003c/th\u003e\n     *   \u003ctd\u003e The move is performed as an atomic file system operation and all\n     *     other options are ignored. If the target file exists then it is\n     *     implementation specific if the existing file is replaced or this method\n     *     fails by throwing an {@link IOException}. If the move cannot be\n     *     performed as an atomic file system operation then {@link\n     *     AtomicMoveNotSupportedException} is thrown. This can arise, for\n     *     example, when the target location is on a different {@code FileStore}\n     *     and would require that the file be copied, or target location is\n     *     associated with a different provider to this object. \u003c/td\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e An implementation of this interface may support additional\n     * implementation specific options.\n     *\n     * \u003cp\u003e Moving a file will copy the {@link\n     * BasicFileAttributes#lastModifiedTime last-modified-time} to the target\n     * file if supported by both source and target file stores. Copying of file\n     * timestamps may result in precision loss. An implementation may also\n     * attempt to copy other file attributes but is not required to fail if the\n     * file attributes cannot be copied. When the move is performed as\n     * a non-atomic operation, and an {@code IOException} is thrown, then the\n     * state of the files is not defined. The original file and the target file\n     * may both exist, the target file may be incomplete or some of its file\n     * attributes may not been copied from the original file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Examples:\u003c/b\u003e\n     * Suppose we want to rename a file to \"newname\", keeping the file in the\n     * same directory:\n     * {@snippet lang\u003djava :\n     *     Path source \u003d ...\n     *     Files.move(source, source.resolveSibling(\"newname\"));\n     * }\n     * Alternatively, suppose we want to move a file to new directory, keeping\n     * the same file name, and replacing any existing file of that name in the\n     * directory:\n     * {@snippet lang\u003djava :\n     *     Path source \u003d ...\n     *     Path newdir \u003d ...\n     *     Files.move(source, newdir.resolve(source.getFileName()), REPLACE_EXISTING);\n     * }\n     *\n     * @param   source\n     *          the path to the file to move\n     * @param   target\n     *          the path to the target file (may be associated with a different\n     *          provider to the source path)\n     * @param   options\n     *          options specifying how the move should be done\n     *\n     * @return  the path to the target file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the array contains a copy option that is not supported\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory, or the\n     *          source is a non-empty directory containing entries that would\n     *          be required to be moved \u003ci\u003e(optional specific exceptions)\u003c/i\u003e\n     * @throws  AtomicMoveNotSupportedException\n     *          if the options array contains the {@code ATOMIC_MOVE} option but\n     *          the file cannot be moved as an atomic file system operation.\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to both the source and\n     *          target file.\n     */\n    public static Path move(Path source, Path target, CopyOption... options)\n        throws IOException\n    {\n        FileSystemProvider provider \u003d provider(source);\n        if (provider(target) \u003d\u003d provider) {\n            // same provider\n            provider.move(source, target, options);\n        } else {\n            // different providers\n            CopyMoveHelper.moveToForeignTarget(source, target, options);\n        }\n        return target;\n    }\n\n    // -- Miscellaneous --\n\n    /**\n     * Reads the target of a symbolic link \u003ci\u003e(optional operation)\u003c/i\u003e.\n     *\n     * \u003cp\u003e If the file system supports \u003ca href\u003d\"package-summary.html#links\"\u003esymbolic\n     * links\u003c/a\u003e then this method is used to read the target of the link, failing\n     * if the file is not a symbolic link. The target of the link need not exist.\n     * The returned {@code Path} object will be associated with the same file\n     * system as {@code link}.\n     *\n     * @param   link\n     *          the path to the symbolic link\n     *\n     * @return  a {@code Path} object representing the target of the link\n     *\n     * @throws  UnsupportedOperationException\n     *          if the implementation does not support symbolic links\n     * @throws  NotLinkException\n     *          if the target could otherwise not be read because the file\n     *          is not a symbolic link \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager\n     *          is installed, it checks that {@code FilePermission} has been\n     *          granted with the \"{@code readlink}\" action to read the link.\n     */\n    public static Path readSymbolicLink(Path link) throws IOException {\n        return provider(link).readSymbolicLink(link);\n    }\n\n    /**\n     * Returns the {@link FileStore} representing the file store where a file\n     * is located.\n     *\n     * \u003cp\u003e Once a reference to the {@code FileStore} is obtained it is\n     * implementation specific if operations on the returned {@code FileStore},\n     * or {@link FileStoreAttributeView} objects obtained from it, continue\n     * to depend on the existence of the file. In particular the behavior is not\n     * defined for the case that the file is deleted or moved to a different\n     * file store.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the file store where the file is stored\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file, and in\n     *          addition it checks\n     *          {@link RuntimePermission}{@code (\"getFileStoreAttributes\")}\n     */\n    public static FileStore getFileStore(Path path) throws IOException {\n        return provider(path).getFileStore(path);\n    }\n\n    /**\n     * Tests if two paths locate the same file.\n     *\n     * \u003cp\u003e If both {@code Path} objects are {@link Path#equals(Object) equal}\n     * then this method returns {@code true} without checking if the file exists.\n     * If the two {@code Path} objects are associated with different providers\n     * then this method returns {@code false}. Otherwise, this method checks if\n     * both {@code Path} objects locate the same file, and depending on the\n     * implementation, may require to open or access both files.\n     *\n     * \u003cp\u003e If the file system and files remain static, then this method implements\n     * an equivalence relation for non-null {@code Paths}.\n     * \u003cul\u003e\n     * \u003cli\u003eIt is \u003ci\u003ereflexive\u003c/i\u003e: for {@code Path} {@code f},\n     *     {@code isSameFile(f,f)} should return {@code true}.\n     * \u003cli\u003eIt is \u003ci\u003esymmetric\u003c/i\u003e: for two {@code Paths} {@code f} and {@code g},\n     *     {@code isSameFile(f,g)} will equal {@code isSameFile(g,f)}.\n     * \u003cli\u003eIt is \u003ci\u003etransitive\u003c/i\u003e: for three {@code Paths}\n     *     {@code f}, {@code g}, and {@code h}, if {@code isSameFile(f,g)} returns\n     *     {@code true} and {@code isSameFile(g,h)} returns {@code true}, then\n     *     {@code isSameFile(f,h)} will return {@code true}.\n     * \u003c/ul\u003e\n     *\n     * @param   path\n     *          one path to the file\n     * @param   path2\n     *          the other path\n     *\n     * @return  {@code true} if, and only if, the two paths locate the same file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to both files when the\n     *          two paths are not equal\n     *\n     * @see java.nio.file.attribute.BasicFileAttributes#fileKey\n     */\n    public static boolean isSameFile(Path path, Path path2) throws IOException {\n        return provider(path).isSameFile(path, path2);\n    }\n\n    /**\n     * Finds and returns the position of the first mismatched byte in the content\n     * of two files, or {@code -1L} if there is no mismatch. The position will be\n     * in the inclusive range of {@code 0L} up to the size (in bytes) of the\n     * smaller file.\n     *\n     * \u003cp\u003e Two files are considered to match if they satisfy one of the following\n     * conditions:\n     * \u003cul\u003e\n     * \u003cli\u003e The two paths locate the {@linkplain #isSameFile(Path, Path) same file},\n     *      even if two {@linkplain Path#equals(Object) equal} paths locate a file\n     *      that does not exist, or \u003c/li\u003e\n     * \u003cli\u003e The two files are the same size, and every byte in the first file\n     *      is identical to the corresponding byte in the second file. \u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e Otherwise there is a mismatch between the two files and the value\n     * returned by this method is:\n     * \u003cul\u003e\n     * \u003cli\u003e The position of the first mismatched byte, or \u003c/li\u003e\n     * \u003cli\u003e The size of the smaller file (in bytes) when the files are of different\n     *      sizes and every byte of the smaller file is identical to the\n     *      corresponding byte of the larger file. \u003c/li\u003e\n     * \u003c/ul\u003e\n     *\n     * \u003cp\u003e This method may not be atomic with respect to other file system\n     * operations. This method is always \u003ci\u003ereflexive\u003c/i\u003e (for {@code Path f},\n     * {@code mismatch(f,f)} returns {@code -1L}). If the file system and files\n     * remain static, then this method is \u003ci\u003esymmetric\u003c/i\u003e (for two {@code Paths f}\n     * and {@code g}, {@code mismatch(f,g)} will return the same value as\n     * {@code mismatch(g,f)}).\n     *\n     * \u003cp\u003e If both {@code Path} objects are equal, then this method returns\n     * {@code true} without checking if the file exists.\n     *\n     * @param   path\n     *          the path to the first file\n     * @param   path2\n     *          the path to the second file\n     *\n     * @return  the position of the first mismatch or {@code -1L} if no mismatch\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to both files when the\n     *          two paths are not equal\n     *\n     * @since 12\n     */\n    public static long mismatch(Path path, Path path2) throws IOException {\n        if (isSameFile(path, path2)) {\n            return -1;\n        }\n        byte[] buffer1 \u003d new byte[BUFFER_SIZE];\n        byte[] buffer2 \u003d new byte[BUFFER_SIZE];\n        try (InputStream in1 \u003d Files.newInputStream(path);\n             InputStream in2 \u003d Files.newInputStream(path2)) {\n            long totalRead \u003d 0;\n            while (true) {\n                int nRead1 \u003d in1.readNBytes(buffer1, 0, BUFFER_SIZE);\n                int nRead2 \u003d in2.readNBytes(buffer2, 0, BUFFER_SIZE);\n\n                int i \u003d Arrays.mismatch(buffer1, 0, nRead1, buffer2, 0, nRead2);\n                if (i \u003e -1) {\n                    return totalRead + i;\n                }\n                if (nRead1 \u003c BUFFER_SIZE) {\n                    // we\u0027ve reached the end of the files, but found no mismatch\n                    return -1;\n                }\n                totalRead +\u003d nRead1;\n            }\n        }\n    }\n\n    /**\n     * Tells whether or not a file is considered \u003cem\u003ehidden\u003c/em\u003e.\n     *\n     * @apiNote\n     * The exact definition of hidden is platform or provider dependent. On UNIX\n     * for example a file is considered to be hidden if its name begins with a\n     * period character (\u0027.\u0027). On Windows a file is considered hidden if the DOS\n     * {@link DosFileAttributes#isHidden hidden} attribute is set.\n     *\n     * \u003cp\u003e Depending on the implementation this method may require to access\n     * the file system to determine if the file is considered hidden.\n     *\n     * @param   path\n     *          the path to the file to test\n     *\n     * @return  {@code true} if the file is considered hidden\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static boolean isHidden(Path path) throws IOException {\n        return provider(path).isHidden(path);\n    }\n\n    // lazy loading of default and installed file type detectors\n    private static class FileTypeDetectors{\n        static final FileTypeDetector defaultFileTypeDetector \u003d\n            createDefaultFileTypeDetector();\n        static final List\u003cFileTypeDetector\u003e installedDetectors \u003d\n            loadInstalledDetectors();\n\n        // creates the default file type detector\n        @SuppressWarnings(\"removal\")\n        private static FileTypeDetector createDefaultFileTypeDetector() {\n            return AccessController\n                .doPrivileged(new PrivilegedAction\u003c\u003e() {\n                    @Override public FileTypeDetector run() {\n                        return sun.nio.fs.DefaultFileTypeDetector.create();\n                }});\n        }\n\n        // loads all installed file type detectors\n        @SuppressWarnings(\"removal\")\n        private static List\u003cFileTypeDetector\u003e loadInstalledDetectors() {\n            return AccessController\n                .doPrivileged(new PrivilegedAction\u003c\u003e() {\n                    @Override public List\u003cFileTypeDetector\u003e run() {\n                        List\u003cFileTypeDetector\u003e list \u003d new ArrayList\u003c\u003e();\n                        ServiceLoader\u003cFileTypeDetector\u003e loader \u003d ServiceLoader\n                            .load(FileTypeDetector.class, ClassLoader.getSystemClassLoader());\n                        for (FileTypeDetector detector: loader) {\n                            list.add(detector);\n                        }\n                        return list;\n                }});\n        }\n    }\n\n    /**\n     * Probes the content type of a file.\n     *\n     * \u003cp\u003e This method uses the installed {@link FileTypeDetector} implementations\n     * to probe the given file to determine its content type. Each file type\n     * detector\u0027s {@link FileTypeDetector#probeContentType probeContentType} is\n     * invoked, in turn, to probe the file type. If the file is recognized then\n     * the content type is returned. If the file is not recognized by any of the\n     * installed file type detectors then a system-default file type detector is\n     * invoked to guess the content type.\n     *\n     * \u003cp\u003e A given invocation of the Java virtual machine maintains a system-wide\n     * list of file type detectors. Installed file type detectors are loaded\n     * using the service-provider loading facility defined by the {@link ServiceLoader}\n     * class. Installed file type detectors are loaded using the system class\n     * loader. If the system class loader cannot be found then the platform class\n     * loader is used. File type detectors are typically installed\n     * by placing them in a JAR file on the application class path,\n     * the JAR file contains a provider-configuration file\n     * named {@code java.nio.file.spi.FileTypeDetector} in the resource directory\n     * {@code META-INF/services}, and the file lists one or more fully-qualified\n     * names of concrete subclass of {@code FileTypeDetector } that have a zero\n     * argument constructor. If the process of locating or instantiating the\n     * installed file type detectors fails then an unspecified error is thrown.\n     * The ordering that installed providers are located is implementation\n     * specific.\n     *\n     * \u003cp\u003e The return value of this method is the string form of the value of a\n     * Multipurpose Internet Mail Extension (MIME) content type as\n     * defined by \u003ca href\u003d\"http://www.ietf.org/rfc/rfc2045.txt\"\u003e\u003ci\u003eRFC\u0026nbsp;2045:\n     * Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet\n     * Message Bodies\u003c/i\u003e\u003c/a\u003e. The string is guaranteed to be parsable according\n     * to the grammar in the RFC.\n     *\n     * @param   path\n     *          the path to the file to probe\n     *\n     * @return  The content type of the file, or {@code null} if the content\n     *          type cannot be determined\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          If a security manager is installed and it denies an unspecified\n     *          permission required by a file type detector implementation.\n     *\n     * @spec https://www.rfc-editor.org/info/rfc2045\n     *      RFC 2045: Multipurpose Internet Mail Extensions (MIME) Part One:\n     *              Format of Internet Message Bodies\n     */\n    public static String probeContentType(Path path)\n        throws IOException\n    {\n        // try installed file type detectors\n        for (FileTypeDetector detector: FileTypeDetectors.installedDetectors) {\n            String result \u003d detector.probeContentType(path);\n            if (result !\u003d null)\n                return result;\n        }\n\n        // fallback to default\n        return FileTypeDetectors.defaultFileTypeDetector.probeContentType(path);\n    }\n\n    // -- File Attributes --\n\n    /**\n     * Returns a file attribute view of a given type.\n     *\n     * \u003cp\u003e A file attribute view provides a read-only or updatable view of a\n     * set of file attributes. This method is intended to be used where the file\n     * attribute view defines type-safe methods to read or update the file\n     * attributes. The {@code type} parameter is the type of the attribute view\n     * required and the method returns an instance of that type if supported.\n     * The {@link BasicFileAttributeView} type supports access to the basic\n     * attributes of a file. Invoking this method to select a file attribute\n     * view of that type will always return an instance of that class.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled by the resulting file attribute view for the case that the\n     * file is a symbolic link. By default, symbolic links are followed. If the\n     * option {@link LinkOption#NOFOLLOW_LINKS NOFOLLOW_LINKS} is present then\n     * symbolic links are not followed. This option is ignored by implementations\n     * that do not support symbolic links.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want read or set a file\u0027s ACL, if supported:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     AclFileAttributeView view \u003d Files.getFileAttributeView(path, AclFileAttributeView.class);\n     *     if (view !\u003d null) {\n     *         List\u003cAclEntry\u003e acl \u003d view.getAcl();\n     *         :\n     *     }\n     * }\n     *\n     * @param   \u003cV\u003e\n     *          The {@code FileAttributeView} type\n     * @param   path\n     *          the path to the file\n     * @param   type\n     *          the {@code Class} object corresponding to the file attribute view\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a file attribute view of the specified type, or {@code null} if\n     *          the attribute view type is not available\n     */\n    public static \u003cV extends FileAttributeView\u003e V getFileAttributeView(Path path,\n                                                                       Class\u003cV\u003e type,\n                                                                       LinkOption... options)\n    {\n        return provider(path).getFileAttributeView(path, type, options);\n    }\n\n    /**\n     * Reads a file\u0027s attributes as a bulk operation.\n     *\n     * \u003cp\u003e The {@code type} parameter is the type of the attributes required\n     * and this method returns an instance of that type if supported. All\n     * implementations support a basic set of file attributes and so invoking\n     * this method with a  {@code type} parameter of {@code\n     * BasicFileAttributes.class} will not throw {@code\n     * UnsupportedOperationException}.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e It is implementation specific if all file attributes are read as an\n     * atomic operation with respect to other file system operations.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to read a file\u0027s attributes in bulk:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     BasicFileAttributes attrs \u003d Files.readAttributes(path, BasicFileAttributes.class);\n     * }\n     * Alternatively, suppose we want to read file\u0027s POSIX attributes without\n     * following symbolic links:\n     * {@snippet lang\u003djava :\n     *     PosixFileAttributes attrs \u003d\n     *         Files.readAttributes(path, PosixFileAttributes.class, NOFOLLOW_LINKS);\n     * }\n     *\n     * @param   \u003cA\u003e\n     *          The {@code BasicFileAttributes} type\n     * @param   path\n     *          the path to the file\n     * @param   type\n     *          the {@code Class} of the file attributes required\n     *          to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the file attributes\n     *\n     * @throws  UnsupportedOperationException\n     *          if an attributes of the given type are not supported\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file. If this\n     *          method is invoked to read security sensitive attributes then the\n     *          security manager may be invoked to check for additional permissions.\n     */\n    public static \u003cA extends BasicFileAttributes\u003e A readAttributes(Path path,\n                                                                   Class\u003cA\u003e type,\n                                                                   LinkOption... options)\n        throws IOException\n    {\n        return provider(path).readAttributes(path, type, options);\n    }\n\n    /**\n     * Sets the value of a file attribute.\n     *\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be set\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute\n     * within the set.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is set. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to set the DOS \"hidden\" attribute:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     Files.setAttribute(path, \"dos:hidden\", true);\n     * }\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attribute\n     *          the attribute to set\n     * @param   value\n     *          the attribute value\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if the attribute name is not specified, or is not recognized, or\n     *          the attribute value is of the correct type but has an\n     *          inappropriate value\n     * @throws  ClassCastException\n     *          if the attribute value is not of the expected type or is a\n     *          collection containing elements that are not of the expected\n     *          type\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file. If this method is invoked\n     *          to set security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Path setAttribute(Path path, String attribute, Object value,\n                                    LinkOption... options)\n        throws IOException\n    {\n        provider(path).setAttribute(path, attribute, value, options);\n        return path;\n    }\n\n    /**\n     * Reads the value of a file attribute.\n     *\n     * \u003cp\u003e The {@code attribute} parameter identifies the attribute to be read\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-name\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems. \u003ci\u003eattribute-name\u003c/i\u003e is the name of the attribute.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we require the user ID of the file owner on a system that\n     * supports a \"{@code unix}\" view:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     int uid \u003d (Integer)Files.getAttribute(path, \"unix:uid\");\n     * }\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attribute\n     *          the attribute to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the attribute value\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if the attribute name is not specified or is not recognized\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file. If this method is invoked\n     *          to read security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Object getAttribute(Path path, String attribute,\n                                      LinkOption... options)\n        throws IOException\n    {\n        // only one attribute should be read\n        if (attribute.indexOf(\u0027*\u0027) \u003e\u003d 0 || attribute.indexOf(\u0027,\u0027) \u003e\u003d 0)\n            throw new IllegalArgumentException(attribute);\n        Map\u003cString,Object\u003e map \u003d readAttributes(path, attribute, options);\n        assert map.size() \u003d\u003d 1;\n        String name;\n        int pos \u003d attribute.indexOf(\u0027:\u0027);\n        if (pos \u003d\u003d -1) {\n            name \u003d attribute;\n        } else {\n            name \u003d (pos \u003d\u003d attribute.length()) ? \"\" : attribute.substring(pos+1);\n        }\n        return map.get(name);\n    }\n\n    /**\n     * Reads a set of file attributes as a bulk operation.\n     *\n     * \u003cp\u003e The {@code attributes} parameter identifies the attributes to be read\n     * and takes the form:\n     * \u003cblockquote\u003e\n     * [\u003ci\u003eview-name\u003c/i\u003e\u003cb\u003e:\u003c/b\u003e]\u003ci\u003eattribute-list\u003c/i\u003e\n     * \u003c/blockquote\u003e\n     * where square brackets [...] delineate an optional component and the\n     * character {@code \u0027:\u0027} stands for itself.\n     *\n     * \u003cp\u003e \u003ci\u003eview-name\u003c/i\u003e is the {@link FileAttributeView#name name} of a {@link\n     * FileAttributeView} that identifies a set of file attributes. If not\n     * specified then it defaults to {@code \"basic\"}, the name of the file\n     * attribute view that identifies the basic set of file attributes common to\n     * many file systems.\n     *\n     * \u003cp\u003e The \u003ci\u003eattribute-list\u003c/i\u003e component is a comma separated list of\n     * one or more names of attributes to read. If the list contains the value\n     * {@code \"*\"} then all attributes are read. Attributes that are not supported\n     * are ignored and will not be present in the returned map. It is\n     * implementation specific if all attributes are read as an atomic operation\n     * with respect to other file system operations.\n     *\n     * \u003cp\u003e The following examples demonstrate possible values for the {@code\n     * attributes} parameter:\n     *\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align: left; margin-left:2em\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003ePossible values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\n     *  \u003cth scope\u003d\"col\"\u003eExample\n     *  \u003cth scope\u003d\"col\"\u003eDescription\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"*\"} \u003c/th\u003e\n     *   \u003ctd\u003e Read all {@link BasicFileAttributes basic-file-attributes}. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"size,lastModifiedTime,lastAccessTime\"} \u003c/th\u003e\n     *   \u003ctd\u003e Reads the file size, last modified time, and last access time\n     *     attributes. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"posix:*\"} \u003c/th\u003e\n     *   \u003ctd\u003e Read all {@link PosixFileAttributes POSIX-file-attributes}. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003ctr\u003e\n     *   \u003cth scope\u003d\"row\"\u003e {@code \"posix:permissions,owner,size\"} \u003c/th\u003e\n     *   \u003ctd\u003e Reads the POSIX file permissions, owner, and file size. \u003c/td\u003e\n     * \u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   attributes\n     *          the attributes to read\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a map of the attributes returned; The map\u0027s keys are the\n     *          attribute names, its values are the attribute values\n     *\n     * @throws  UnsupportedOperationException\n     *          if the attribute view is not available\n     * @throws  IllegalArgumentException\n     *          if no attributes are specified or an unrecognized attribute is\n     *          specified\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file. If this method is invoked\n     *          to read security sensitive attributes then the security manager\n     *          may be invoked to check for additional permissions.\n     */\n    public static Map\u003cString,Object\u003e readAttributes(Path path, String attributes,\n                                                    LinkOption... options)\n        throws IOException\n    {\n        return provider(path).readAttributes(path, attributes, options);\n    }\n\n    /**\n     * Returns a file\u0027s POSIX file permissions.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\n     * that supports the {@link PosixFileAttributeView}. This attribute view\n     * provides access to file attributes commonly associated with files on file\n     * systems used by operating systems that implement the Portable Operating\n     * System Interface (POSIX) family of standards.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  the file permissions\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          PosixFileAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, a security manager is\n     *          installed, and it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\n     *          denies read access to the file.\n     */\n    public static Set\u003cPosixFilePermission\u003e getPosixFilePermissions(Path path,\n                                                                   LinkOption... options)\n        throws IOException\n    {\n        return readAttributes(path, PosixFileAttributes.class, options).permissions();\n    }\n\n    /**\n     * Sets a file\u0027s POSIX permissions.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a {@code FileSystem}\n     * that supports the {@link PosixFileAttributeView}. This attribute view\n     * provides access to file attributes commonly associated with files on file\n     * systems used by operating systems that implement the Portable Operating\n     * System Interface (POSIX) family of standards.\n     *\n     * @param   path\n     *          The path to the file\n     * @param   perms\n     *          The new set of permissions\n     *\n     * @return  The given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          PosixFileAttributeView}\n     * @throws  ClassCastException\n     *          if the sets contains elements that are not of type {@code\n     *          PosixFilePermission}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file.\n     */\n    public static Path setPosixFilePermissions(Path path,\n                                               Set\u003cPosixFilePermission\u003e perms)\n        throws IOException\n    {\n        PosixFileAttributeView view \u003d\n            getFileAttributeView(path, PosixFileAttributeView.class);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        view.setPermissions(perms);\n        return path;\n    }\n\n    /**\n     * Returns the owner of a file.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a file system that\n     * supports {@link FileOwnerAttributeView}. This file attribute view provides\n     * access to a file attribute that is the owner of the file.\n     *\n     * @param   path\n     *          The path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  A user principal representing the owner of the file\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          FileOwnerAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkRead(String) checkRead} method\n     *          denies read access to the file.\n     */\n    public static UserPrincipal getOwner(Path path, LinkOption... options) throws IOException {\n        FileOwnerAttributeView view \u003d\n            getFileAttributeView(path, FileOwnerAttributeView.class, options);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        return view.getOwner();\n    }\n\n    /**\n     * Updates the file owner.\n     *\n     * \u003cp\u003e The {@code path} parameter is associated with a file system that\n     * supports {@link FileOwnerAttributeView}. This file attribute view provides\n     * access to a file attribute that is the owner of the file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to make \"joe\" the owner of a file:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     UserPrincipalLookupService lookupService \u003d\n     *         provider(path).getUserPrincipalLookupService();\n     *     UserPrincipal joe \u003d lookupService.lookupPrincipalByName(\"joe\");\n     *     Files.setOwner(path, joe);\n     * }\n     *\n     * @param   path\n     *          The path to the file\n     * @param   owner\n     *          The new file owner\n     *\n     * @return  The given path\n     *\n     * @throws  UnsupportedOperationException\n     *          if the associated file system does not support the {@code\n     *          FileOwnerAttributeView}\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, it denies\n     *          {@link RuntimePermission}{@code (\"accessUserInformation\")}\n     *          or its {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method denies write access to the file.\n     *\n     * @see FileSystem#getUserPrincipalLookupService\n     * @see java.nio.file.attribute.UserPrincipalLookupService\n     */\n    public static Path setOwner(Path path, UserPrincipal owner)\n        throws IOException\n    {\n        FileOwnerAttributeView view \u003d\n            getFileAttributeView(path, FileOwnerAttributeView.class);\n        if (view \u003d\u003d null)\n            throw new UnsupportedOperationException();\n        view.setOwner(owner);\n        return path;\n    }\n\n    /**\n     * Tests whether a file is a symbolic link.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a symbolic link then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isSymbolicLink} method.\n     *\n     * @param   path  The path to the file\n     *\n     * @return  {@code true} if the file is a symbolic link; {@code false} if\n     *          the file does not exist, is not a symbolic link, or it cannot\n     *          be determined if the file is a symbolic link or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isSymbolicLink(Path path) {\n        try {\n            return readAttributes(path,\n                                  BasicFileAttributes.class,\n                                  LinkOption.NOFOLLOW_LINKS).isSymbolicLink();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is a directory.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a directory then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isDirectory} method.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file is a directory; {@code false} if\n     *          the file does not exist, is not a directory, or it cannot\n     *          be determined if the file is a directory or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isDirectory(Path path, LinkOption... options) {\n        try {\n            var attrs \u003d provider(path)\n                    .readAttributesIfExists(path, BasicFileAttributes.class, options);\n            return (attrs !\u003d null) \u0026\u0026 attrs.isDirectory();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is a regular file with opaque content.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Where it is required to distinguish an I/O exception from the case\n     * that the file is not a regular file then the file attributes can be\n     * read with the {@link #readAttributes(Path,Class,LinkOption[])\n     * readAttributes} method and the file type tested with the {@link\n     * BasicFileAttributes#isRegularFile} method.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file is a regular file; {@code false} if\n     *          the file does not exist, is not a regular file, or it\n     *          cannot be determined if the file is a regular file or not.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     */\n    public static boolean isRegularFile(Path path, LinkOption... options) {\n        try {\n            var attrs \u003d provider(path)\n                    .readAttributesIfExists(path, BasicFileAttributes.class, options);\n            return (attrs !\u003d null) \u0026\u0026 attrs.isRegularFile();\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n\n    /**\n     * Returns a file\u0027s last modified time.\n     *\n     * \u003cp\u003e The {@code options} array may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed and the file attribute of the final target\n     * of the link is read. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  a {@code FileTime} representing the time the file was last\n     *          modified, or an implementation specific default when a time\n     *          stamp to indicate the time of last modification is not supported\n     *          by the file system\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     *\n     * @see BasicFileAttributes#lastModifiedTime\n     */\n    public static FileTime getLastModifiedTime(Path path, LinkOption... options)\n        throws IOException\n    {\n        return readAttributes(path, BasicFileAttributes.class, options).lastModifiedTime();\n    }\n\n    /**\n     * Updates a file\u0027s last modified time attribute. The file time is converted\n     * to the epoch and precision supported by the file system. Converting from\n     * finer to coarser granularities result in precision loss. The behavior of\n     * this method when attempting to set the last modified time when it is not\n     * supported by the file system or is outside the range supported by the\n     * underlying file store is not defined. It may or not fail by throwing an\n     * {@code IOException}.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage Example:\u003c/b\u003e\n     * Suppose we want to set the last modified time to the current time:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     FileTime now \u003d FileTime.fromMillis(System.currentTimeMillis());\n     *     Files.setLastModifiedTime(path, now);\n     * }\n     *\n     * @param   path\n     *          the path to the file\n     * @param   time\n     *          the new last modified time\n     *\n     * @return  the given path\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkWrite(String)\n     *          checkWrite} method denies write access to the file.\n     *\n     * @see BasicFileAttributeView#setTimes\n     */\n    public static Path setLastModifiedTime(Path path, FileTime time)\n        throws IOException\n    {\n        getFileAttributeView(path, BasicFileAttributeView.class)\n            .setTimes(Objects.requireNonNull(time), null, null);\n        return path;\n    }\n\n    /**\n     * Returns the size of a file (in bytes). The size may differ from the\n     * actual size on the file system due to compression, support for sparse\n     * files, or other reasons. The size of files that are not {@link\n     * #isRegularFile regular} files is implementation specific and\n     * therefore unspecified.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the file size, in bytes\n     *\n     * @throws  IOException\n     *          if an I/O error occurs\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, its {@link SecurityManager#checkRead(String) checkRead}\n     *          method denies read access to the file.\n     *\n     * @see BasicFileAttributes#size\n     */\n    public static long size(Path path) throws IOException {\n        return readAttributes(path, BasicFileAttributes.class).size();\n    }\n\n    // -- Accessibility --\n\n    /**\n     * Returns {@code false} if NOFOLLOW_LINKS is present.\n     */\n    private static boolean followLinks(LinkOption... options) {\n        boolean followLinks \u003d true;\n        for (LinkOption opt: options) {\n            if (opt \u003d\u003d LinkOption.NOFOLLOW_LINKS) {\n                followLinks \u003d false;\n                continue;\n            }\n            if (opt \u003d\u003d null)\n                throw new NullPointerException();\n            throw new AssertionError(\"Should not get here\");\n        }\n        return followLinks;\n    }\n\n    /**\n     * Tests whether a file exists.\n     *\n     * \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated. If this\n     * method indicates the file exists then there is no guarantee that a\n     * subsequent access will succeed. Care should be taken when using this\n     * method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file exists; {@code false} if the file does\n     *          not exist or its existence cannot be determined.\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String)} is invoked to check\n     *          read access to the file.\n     *\n     * @see #notExists\n     * @see FileSystemProvider#checkAccess\n     */\n    public static boolean exists(Path path, LinkOption... options) {\n        return provider(path).exists(path, options);\n    }\n\n    /**\n     * Tests whether the file located by this path does not exist. This method\n     * is intended for cases where it is required to take action when it can be\n     * confirmed that a file does not exist.\n     *\n     * \u003cp\u003e The {@code options} parameter may be used to indicate how symbolic links\n     * are handled for the case that the file is a symbolic link. By default,\n     * symbolic links are followed. If the option {@link LinkOption#NOFOLLOW_LINKS\n     * NOFOLLOW_LINKS} is present then symbolic links are not followed.\n     *\n     * \u003cp\u003e Note that this method is not the complement of the {@link #exists\n     * exists} method. Where it is not possible to determine if a file exists\n     * or not then both methods return {@code false}. As with the {@code exists}\n     * method, the result of this method is immediately outdated. If this\n     * method indicates the file does exist then there is no guarantee that a\n     * subsequent attempt to create the file will succeed. Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to test\n     * @param   options\n     *          options indicating how symbolic links are handled\n     *\n     * @return  {@code true} if the file does not exist; {@code false} if the\n     *          file exists or its existence cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String)} is invoked to check\n     *          read access to the file.\n     */\n    public static boolean notExists(Path path, LinkOption... options) {\n        try {\n            if (followLinks(options)) {\n                provider(path).checkAccess(path);\n            } else {\n                // attempt to read attributes without following links\n                readAttributes(path, BasicFileAttributes.class,\n                               LinkOption.NOFOLLOW_LINKS);\n            }\n            // file exists\n            return false;\n        } catch (NoSuchFileException x) {\n            // file confirmed not to exist\n            return true;\n        } catch (IOException x) {\n            return false;\n        }\n    }\n\n    /**\n     * Used by isReadable, isWritable, isExecutable to test access to a file.\n     */\n    private static boolean isAccessible(Path path, AccessMode... modes) {\n        try {\n            provider(path).checkAccess(path, modes);\n            return true;\n        } catch (IOException x) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests whether a file is readable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges that would\n     * allow it open the file for reading. Depending on the implementation, this\n     * method may require to read file permissions, access control lists, or\n     * other file attributes in order to check the effective access to the file.\n     * Consequently, this method may not be atomic with respect to other file\n     * system operations.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated, there is\n     * no guarantee that a subsequent attempt to open the file for reading will\n     * succeed (or even that it will access the same file). Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is readable; {@code false}\n     *          if the file does not exist, read access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          is invoked to check read access to the file.\n     */\n    public static boolean isReadable(Path path) {\n        return isAccessible(path, AccessMode.READ);\n    }\n\n    /**\n     * Tests whether a file is writable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges that would\n     * allow it open the file for writing. Depending on the implementation, this\n     * method may require to read file permissions, access control lists, or\n     * other file attributes in order to check the effective access to the file.\n     * Consequently, this method may not be atomic with respect to other file\n     * system operations.\n     *\n     * \u003cp\u003e Note that result of this method is immediately outdated, there is no\n     * guarantee that a subsequent attempt to open the file for writing will\n     * succeed (or even that it will access the same file). Care should be taken\n     * when using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is writable; {@code false}\n     *          if the file does not exist, write access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          is invoked to check write access to the file.\n     */\n    public static boolean isWritable(Path path) {\n        return isAccessible(path, AccessMode.WRITE);\n    }\n\n    /**\n     * Tests whether a file is executable. This method checks that a file exists\n     * and that this Java virtual machine has appropriate privileges to {@link\n     * Runtime#exec execute} the file. The semantics may differ when checking\n     * access to a directory. For example, on UNIX systems, checking for\n     * execute access checks that the Java virtual machine has permission to\n     * search the directory in order to access file or subdirectories.\n     *\n     * \u003cp\u003e Depending on the implementation, this method may require to read file\n     * permissions, access control lists, or other file attributes in order to\n     * check the effective access to the file. Consequently, this method may not\n     * be atomic with respect to other file system operations.\n     *\n     * \u003cp\u003e Note that the result of this method is immediately outdated, there is\n     * no guarantee that a subsequent attempt to execute the file will succeed\n     * (or even that it will access the same file). Care should be taken when\n     * using this method in security sensitive applications.\n     *\n     * @param   path\n     *          the path to the file to check\n     *\n     * @return  {@code true} if the file exists and is executable; {@code false}\n     *          if the file does not exist, execute access would be denied because\n     *          the Java virtual machine has insufficient privileges, or access\n     *          cannot be determined\n     *\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkExec(String)\n     *          checkExec} is invoked to check execute access to the file.\n     */\n    public static boolean isExecutable(Path path) {\n        return isAccessible(path, AccessMode.EXECUTE);\n    }\n\n    // -- Recursive operations --\n\n    /**\n     * Walks a file tree.\n     *\n     * \u003cp\u003e This method walks a file tree rooted at a given starting file. The\n     * file tree traversal is \u003cem\u003edepth-first\u003c/em\u003e with the given {@link\n     * FileVisitor} invoked for each file encountered. File tree traversal\n     * completes when all accessible files in the tree have been visited, or a\n     * visit method returns a result of {@link FileVisitResult#TERMINATE\n     * TERMINATE}. Where a visit method terminates due an {@code IOException},\n     * an uncaught error, or runtime exception, then the traversal is terminated\n     * and the error or exception is propagated to the caller of this method.\n     *\n     * \u003cp\u003e For each file encountered this method attempts to read its {@link\n     * java.nio.file.attribute.BasicFileAttributes}. If the file is not a\n     * directory then the {@link FileVisitor#visitFile visitFile} method is\n     * invoked with the file attributes. If the file attributes cannot be read,\n     * due to an I/O exception, then the {@link FileVisitor#visitFileFailed\n     * visitFileFailed} method is invoked with the I/O exception.\n     *\n     * \u003cp\u003e Where the file is a directory, and the directory could not be opened,\n     * then the {@code visitFileFailed} method is invoked with the I/O exception,\n     * after which, the file tree walk continues, by default, at the next\n     * \u003cem\u003esibling\u003c/em\u003e of the directory.\n     *\n     * \u003cp\u003e Where the directory is opened successfully, then the entries in the\n     * directory, and their \u003cem\u003edescendants\u003c/em\u003e are visited. When all entries\n     * have been visited, or an I/O error occurs during iteration of the\n     * directory, then the directory is closed and the visitor\u0027s {@link\n     * FileVisitor#postVisitDirectory postVisitDirectory} method is invoked.\n     * The file tree walk then continues, by default, at the next \u003cem\u003esibling\u003c/em\u003e\n     * of the directory.\n     *\n     * \u003cp\u003e By default, symbolic links are not automatically followed by this\n     * method. If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\n     * followed. When following links, and the attributes of the target cannot\n     * be read, then this method attempts to get the {@code BasicFileAttributes}\n     * of the link. If they can be read then the {@code visitFile} method is\n     * invoked with the attributes of the link (otherwise the {@code visitFileFailed}\n     * method is invoked as specified above).\n     *\n     * \u003cp\u003e If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then this method keeps\n     * track of directories visited so that cycles can be detected. A cycle\n     * arises when there is an entry in a directory that is an ancestor of the\n     * directory. Cycle detection is done by recording the {@link\n     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\n     * or if file keys are not available, by invoking the {@link #isSameFile\n     * isSameFile} method to test if a directory is the same file as an\n     * ancestor. When a cycle is detected it is treated as an I/O error, and the\n     * {@link FileVisitor#visitFileFailed visitFileFailed} method is invoked with\n     * an instance of {@link FileSystemLoopException}.\n     *\n     * \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\n     * directories to visit. A value of {@code 0} means that only the starting\n     * file is visited, unless denied by the security manager. A value of\n     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\n     * levels should be visited. The {@code visitFile} method is invoked for all\n     * files, including directories, encountered at {@code maxDepth}, unless the\n     * basic file attributes cannot be read, in which case the {@code\n     * visitFileFailed} method is invoked.\n     *\n     * \u003cp\u003e If a visitor returns a result of {@code null} then {@code\n     * NullPointerException} is thrown.\n     *\n     * \u003cp\u003e When a security manager is installed and it denies access to a file\n     * (or directory), then it is ignored and the visitor is not invoked for\n     * that file (or directory).\n     *\n     * @param   start\n     *          the starting file\n     * @param   options\n     *          options to configure the traversal\n     * @param   maxDepth\n     *          the maximum number of directory levels to visit\n     * @param   visitor\n     *          the file visitor to invoke for each file\n     *\n     * @return  the starting file\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown by a visitor method\n     */\n    public static Path walkFileTree(Path start,\n                                    Set\u003cFileVisitOption\u003e options,\n                                    int maxDepth,\n                                    FileVisitor\u003c? super Path\u003e visitor)\n        throws IOException\n    {\n        /**\n         * Create a FileTreeWalker to walk the file tree, invoking the visitor\n         * for each event.\n         */\n        try (FileTreeWalker walker \u003d new FileTreeWalker(options, maxDepth)) {\n            FileTreeWalker.Event ev \u003d walker.walk(start);\n            do {\n                FileVisitResult result \u003d switch (ev.type()) {\n                    case ENTRY -\u003e {\n                        IOException ioe \u003d ev.ioeException();\n                        if (ioe \u003d\u003d null) {\n                            assert ev.attributes() !\u003d null;\n                            yield visitor.visitFile(ev.file(), ev.attributes());\n                        } else {\n                            yield visitor.visitFileFailed(ev.file(), ioe);\n                        }\n                    }\n                    case START_DIRECTORY -\u003e {\n                        var res \u003d visitor.preVisitDirectory(ev.file(), ev.attributes());\n\n                        // if SKIP_SIBLINGS and SKIP_SUBTREE is returned then\n                        // there shouldn\u0027t be any more events for the current\n                        // directory.\n                        if (res \u003d\u003d FileVisitResult.SKIP_SUBTREE ||\n                            res \u003d\u003d FileVisitResult.SKIP_SIBLINGS)\n                            walker.pop();\n                        yield res;\n                    }\n                    case END_DIRECTORY -\u003e {\n                        var res \u003d visitor.postVisitDirectory(ev.file(), ev.ioeException());\n\n                        // SKIP_SIBLINGS is a no-op for postVisitDirectory\n                        if (res \u003d\u003d FileVisitResult.SKIP_SIBLINGS)\n                            res \u003d FileVisitResult.CONTINUE;\n                        yield res;\n                    }\n                    default -\u003e throw new AssertionError(\"Should not get here\");\n                };\n\n                if (Objects.requireNonNull(result) !\u003d FileVisitResult.CONTINUE) {\n                    if (result \u003d\u003d FileVisitResult.TERMINATE) {\n                        break;\n                    } else if (result \u003d\u003d FileVisitResult.SKIP_SIBLINGS) {\n                        walker.skipRemainingSiblings();\n                    }\n                }\n                ev \u003d walker.next();\n            } while (ev !\u003d null);\n        }\n\n        return start;\n    }\n\n    /**\n     * Walks a file tree.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * walkFileTree(Path, Set\u003cFileVisitOption\u003e, int, FileVisitor\u003c? super Path\u003e)\n     * Files.walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\n     * }\u003c/blockquote\u003e\n     * In other words, it does not follow symbolic links, and visits all levels\n     * of the file tree.\n     *\n     * @param   start\n     *          the starting file\n     * @param   visitor\n     *          the file visitor to invoke for each file\n     *\n     * @return  the starting file\n     *\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown by a visitor method\n     */\n    public static Path walkFileTree(Path start, FileVisitor\u003c? super Path\u003e visitor)\n        throws IOException\n    {\n        return walkFileTree(start,\n                            EnumSet.noneOf(FileVisitOption.class),\n                            Integer.MAX_VALUE,\n                            visitor);\n    }\n\n\n    // -- Utility methods for simple usages --\n\n\n    /**\n     * Opens a file for reading, returning a {@code BufferedReader} that may be\n     * used to read text from the file in an efficient manner. Bytes from the\n     * file are decoded into characters using the specified charset. Reading\n     * commences at the beginning of the file.\n     *\n     * \u003cp\u003e The {@code Reader} methods that read from the file throw {@code\n     * IOException} if a malformed or unmappable byte sequence is read.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  a new buffered reader, with default buffer size, to read text\n     *          from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see #readAllLines\n     */\n    public static BufferedReader newBufferedReader(Path path, Charset cs)\n        throws IOException\n    {\n        CharsetDecoder decoder \u003d cs.newDecoder();\n        Reader reader \u003d new InputStreamReader(newInputStream(path), decoder);\n        return new BufferedReader(reader);\n    }\n\n    /**\n     * Opens a file for reading, returning a {@code BufferedReader} to read text\n     * from the file in an efficient manner. Bytes from the file are decoded into\n     * characters using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset\n     * charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * newBufferedReader(Path, Charset)\n     * Files.newBufferedReader(path, StandardCharsets.UTF_8)\n     * }\u003c/blockquote\u003e\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  a new buffered reader, with default buffer size, to read text\n     *          from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static BufferedReader newBufferedReader(Path path) throws IOException {\n        return newBufferedReader(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Opens or creates a file for writing, returning a {@code BufferedWriter}\n     * that may be used to write text to the file in an efficient manner.\n     * The {@code options} parameter specifies how the file is created or\n     * opened. If no options are present then this method works as if the {@link\n     * StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0} if it exists.\n     *\n     * \u003cp\u003e The {@code Writer} methods to write text throw {@code IOException}\n     * if the text cannot be encoded using the specified charset. Due to\n     * buffering, an {@code IOException} caused by an encoding error\n     * (unmappable-character or malformed-input) may be thrown when {@linkplain\n     * BufferedWriter#write(char[],int,int) writing}, {@linkplain\n     * BufferedWriter#flush flushing}, or {@linkplain BufferedWriter#close\n     * closing} the buffered writer.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new buffered writer, with default buffer size, to write text\n     *          to the file\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs opening or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @see #write(Path,Iterable,Charset,OpenOption[])\n     */\n    public static BufferedWriter newBufferedWriter(Path path, Charset cs,\n                                                   OpenOption... options)\n        throws IOException\n    {\n        CharsetEncoder encoder \u003d cs.newEncoder();\n        Writer writer \u003d new OutputStreamWriter(newOutputStream(path, options), encoder);\n        return new BufferedWriter(writer);\n    }\n\n    /**\n     * Opens or creates a file for writing, returning a {@code BufferedWriter}\n     * to write text to the file in an efficient manner. The text is encoded\n     * into bytes for writing using the {@link StandardCharsets#UTF_8 UTF-8}\n     * {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * newBufferedWriter(Path, Charset, OpenOption...)\n     * Files.newBufferedWriter(path, StandardCharsets.UTF_8, options)\n     * }\u003c/blockquote\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  a new buffered writer, with default buffer size, to write text\n     *          to the file\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs opening or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 1.8\n     */\n    public static BufferedWriter newBufferedWriter(Path path, OpenOption... options)\n        throws IOException\n    {\n        return newBufferedWriter(path, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Copies all bytes from an input stream to a file. On return, the input\n     * stream will be at end of stream.\n     *\n     * \u003cp\u003e By default, the copy fails if the target file already exists or is a\n     * symbolic link. If the {@link StandardCopyOption#REPLACE_EXISTING\n     * REPLACE_EXISTING} option is specified, and the target file already exists,\n     * then it is replaced if it is not a non-empty directory. If the target\n     * file exists and is a symbolic link, then the symbolic link is replaced.\n     * In this release, the {@code REPLACE_EXISTING} option is the only option\n     * required to be supported by this method. Additional options may be\n     * supported in future releases.\n     *\n     * \u003cp\u003e  If an I/O error occurs reading from the input stream or writing to\n     * the file, then it may do so after the target file has been created and\n     * after some bytes have been read or written. Consequently the input\n     * stream may not be at end of stream and may be in an inconsistent state.\n     * It is strongly recommended that the input stream be promptly closed if an\n     * I/O error occurs.\n     *\n     * \u003cp\u003e This method may block indefinitely reading from the input stream (or\n     * writing to the file). The behavior for the case that the input stream is\n     * \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy is\n     * highly input stream and file system provider specific and therefore not\n     * specified.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: Suppose we want to capture a web page and save\n     * it to a file:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     URI u \u003d URI.create(\"http://www.example.com/\");\n     *     try (InputStream in \u003d u.toURL().openStream()) {\n     *         Files.copy(in, path);\n     *     }\n     * }\n     *\n     * @param   in\n     *          the input stream to read from\n     * @param   target\n     *          the path to the file\n     * @param   options\n     *          options specifying how the copy should be done\n     *\n     * @return  the number of bytes read or written\n     *\n     * @throws  IOException\n     *          if an I/O error occurs when reading or writing\n     * @throws  FileAlreadyExistsException\n     *          if the target file exists but cannot be replaced because the\n     *          {@code REPLACE_EXISTING} option is not specified \u003ci\u003e(optional\n     *          specific exception)\u003c/i\u003e\n     * @throws  DirectoryNotEmptyException\n     *          the {@code REPLACE_EXISTING} option is specified but the file\n     *          cannot be replaced because it is a non-empty directory\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  UnsupportedOperationException\n     *          if {@code options} contains a copy option that is not supported\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. Where the\n     *          {@code REPLACE_EXISTING} option is specified, the security\n     *          manager\u0027s {@link SecurityManager#checkDelete(String) checkDelete}\n     *          method is invoked to check that an existing file can be deleted.\n     */\n    public static long copy(InputStream in, Path target, CopyOption... options)\n        throws IOException\n    {\n        // ensure not null before opening file\n        Objects.requireNonNull(in);\n\n        // check for REPLACE_EXISTING\n        boolean replaceExisting \u003d false;\n        for (CopyOption opt: options) {\n            if (opt \u003d\u003d StandardCopyOption.REPLACE_EXISTING) {\n                replaceExisting \u003d true;\n            } else {\n                if (opt \u003d\u003d null) {\n                    throw new NullPointerException(\"options contains \u0027null\u0027\");\n                }  else {\n                    throw new UnsupportedOperationException(opt + \" not supported\");\n                }\n            }\n        }\n\n        // attempt to delete an existing file\n        SecurityException se \u003d null;\n        if (replaceExisting) {\n            try {\n                deleteIfExists(target);\n            } catch (SecurityException x) {\n                se \u003d x;\n            }\n        }\n\n        // attempt to create target file. If it fails with\n        // FileAlreadyExistsException then it may be because the security\n        // manager prevented us from deleting the file, in which case we just\n        // throw the SecurityException.\n        OutputStream ostream;\n        try {\n            ostream \u003d newOutputStream(target, StandardOpenOption.CREATE_NEW,\n                                              StandardOpenOption.WRITE);\n        } catch (FileAlreadyExistsException x) {\n            if (se !\u003d null)\n                throw se;\n            // someone else won the race and created the file\n            throw x;\n        }\n\n        // do the copy\n        try (OutputStream out \u003d ostream) {\n            return in.transferTo(out);\n        }\n    }\n\n    /**\n     * Copies all bytes from a file to an output stream.\n     *\n     * \u003cp\u003e If an I/O error occurs reading from the file or writing to the output\n     * stream, then it may do so after some bytes have been read or written.\n     * Consequently the output stream may be in an inconsistent state. It is\n     * strongly recommended that the output stream be promptly closed if an I/O\n     * error occurs.\n     *\n     * \u003cp\u003e This method may block indefinitely writing to the output stream (or\n     * reading from the file). The behavior for the case that the output stream\n     * is \u003ci\u003easynchronously closed\u003c/i\u003e or the thread interrupted during the copy\n     * is highly output stream and file system provider specific and therefore\n     * not specified.\n     *\n     * \u003cp\u003e Note that if the given output stream is {@link java.io.Flushable}\n     * then its {@link java.io.Flushable#flush flush} method may need to invoked\n     * after this method completes so as to flush any buffered output.\n     *\n     * @param   source\n     *          the  path to the file\n     * @param   out\n     *          the output stream to write to\n     *\n     * @return  the number of bytes read or written\n     *\n     * @throws  IOException\n     *          if an I/O error occurs when reading or writing\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static long copy(Path source, OutputStream out) throws IOException {\n        // ensure not null before opening file\n        Objects.requireNonNull(out);\n\n        try (InputStream in \u003d newInputStream(source)) {\n            return in.transferTo(out);\n        }\n    }\n\n    private static final jdk.internal.access.JavaLangAccess JLA \u003d\n            jdk.internal.access.SharedSecrets.getJavaLangAccess();\n\n    /**\n     * Reads all the bytes from an input stream. Uses {@code initialSize} as a hint\n     * about how many bytes the stream will have.\n     *\n     * @param   source\n     *          the input stream to read from\n     * @param   initialSize\n     *          the initial size of the byte array to allocate\n     *\n     * @return  a byte array containing the bytes read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the stream\n     * @throws  OutOfMemoryError\n     *          if an array of the required size cannot be allocated\n     */\n    private static byte[] read(InputStream source, int initialSize) throws IOException {\n        int capacity \u003d initialSize;\n        byte[] buf \u003d new byte[capacity];\n        int nread \u003d 0;\n        int n;\n        for (;;) {\n            // read to EOF which may read more or less than initialSize (eg: file\n            // is truncated while we are reading)\n            while ((n \u003d source.read(buf, nread, capacity - nread)) \u003e 0)\n                nread +\u003d n;\n\n            // if last call to source.read() returned -1, we are done\n            // otherwise, try to read one more byte; if that failed we\u0027re done too\n            if (n \u003c 0 || (n \u003d source.read()) \u003c 0)\n                break;\n\n            // one more byte was read; need to allocate a larger buffer\n            capacity \u003d Math.max(ArraysSupport.newLength(capacity,\n                                                        1,       /* minimum growth */\n                                                        capacity /* preferred growth */),\n                                BUFFER_SIZE);\n            buf \u003d Arrays.copyOf(buf, capacity);\n            buf[nread++] \u003d (byte)n;\n        }\n        return (capacity \u003d\u003d nread) ? buf : Arrays.copyOf(buf, nread);\n    }\n\n    /**\n     * Reads all the bytes from a file. The method ensures that the file is\n     * closed when all bytes have been read or an I/O error, or other runtime\n     * exception, is thrown.\n     *\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\n     * convenient to read all bytes into a byte array. It is not intended for\n     * reading in large files.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  a byte array containing the bytes read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the stream\n     * @throws  OutOfMemoryError\n     *          if an array of the required size cannot be allocated, for\n     *          example the file is larger that {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     */\n    public static byte[] readAllBytes(Path path) throws IOException {\n        try (SeekableByteChannel sbc \u003d Files.newByteChannel(path);\n             InputStream in \u003d Channels.newInputStream(sbc)) {\n            if (sbc instanceof FileChannelImpl)\n                ((FileChannelImpl) sbc).setUninterruptible();\n            long size \u003d sbc.size();\n            if (size \u003e (long) Integer.MAX_VALUE)\n                throw new OutOfMemoryError(\"Required array size too large\");\n            return read(in, (int)size);\n        }\n    }\n\n    /**\n     * Reads all content from a file into a string, decoding from bytes to characters\n     * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     * The method ensures that the file is closed when all content have been read\n     * or an I/O error, or other runtime exception, is thrown.\n     *\n     * \u003cp\u003e This method is equivalent to: {@link readString(Path, Charset)\n     * readString(path, StandardCharsets.UTF_8)}.\n     *\n     * @param   path the path to the file\n     *\n     * @return  a String containing the content read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  OutOfMemoryError\n     *          if the file is extremely large, for example larger than {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 11\n     */\n    public static String readString(Path path) throws IOException {\n        return readString(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Reads all characters from a file into a string, decoding from bytes to characters\n     * using the specified {@linkplain Charset charset}.\n     * The method ensures that the file is closed when all content have been read\n     * or an I/O error, or other runtime exception, is thrown.\n     *\n     * \u003cp\u003e This method reads all content including the line separators in the middle\n     * and/or at the end. The resulting string will contain line separators as they\n     * appear in the file.\n     *\n     * @apiNote\n     * This method is intended for simple cases where it is appropriate and convenient\n     * to read the content of a file into a String. It is not intended for reading\n     * very large files.\n     *\n     *\n     *\n     * @param   path the path to the file\n     * @param   cs the charset to use for decoding\n     *\n     * @return  a String containing the content read from the file\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  OutOfMemoryError\n     *          if the file is extremely large, for example larger than {@code 2GB}\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 11\n     */\n    public static String readString(Path path, Charset cs) throws IOException {\n        Objects.requireNonNull(path);\n        Objects.requireNonNull(cs);\n\n        byte[] ba \u003d readAllBytes(path);\n        if (path.getClass().getModule() !\u003d Object.class.getModule())\n            ba \u003d ba.clone();\n        return JLA.newStringNoRepl(ba, cs);\n    }\n\n    /**\n     * Read all lines from a file. This method ensures that the file is\n     * closed when all bytes have been read or an I/O error, or other runtime\n     * exception, is thrown. Bytes from the file are decoded into characters\n     * using the specified charset.\n     *\n     * \u003cp\u003e This method recognizes the following as line terminators:\n     * \u003cul\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e followed by \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e,\n     *     CARRIAGE RETURN followed by LINE FEED \u003c/li\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000A\u003c/code\u003e, LINE FEED \u003c/li\u003e\n     *   \u003cli\u003e \u003ccode\u003e\u0026#92;u000D\u003c/code\u003e, CARRIAGE RETURN \u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e Additional Unicode line terminators may be recognized in future\n     * releases.\n     *\n     * \u003cp\u003e Note that this method is intended for simple cases where it is\n     * convenient to read all lines in a single operation. It is not intended\n     * for reading in large files.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  the lines from the file as a {@code List}; whether the {@code\n     *          List} is modifiable or not is implementation dependent and\n     *          therefore not specified\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see #newBufferedReader\n     */\n    public static List\u003cString\u003e readAllLines(Path path, Charset cs) throws IOException {\n        try (BufferedReader reader \u003d newBufferedReader(path, cs)) {\n            List\u003cString\u003e result \u003d new ArrayList\u003c\u003e();\n            for (;;) {\n                String line \u003d reader.readLine();\n                if (line \u003d\u003d null)\n                    break;\n                result.add(line);\n            }\n            return result;\n        }\n    }\n\n    /**\n     * Read all lines from a file. Bytes from the file are decoded into characters\n     * using the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * readAllLines(Path, Charset)\n     * Files.readAllLines(path, StandardCharsets.UTF_8)\n     * }\u003c/blockquote\u003e\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the lines from the file as a {@code List}; whether the {@code\n     *          List} is modifiable or not is implementation dependent and\n     *          therefore not specified\n     *\n     * @throws  IOException\n     *          if an I/O error occurs reading from the file or a malformed or\n     *          unmappable byte sequence is read\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static List\u003cString\u003e readAllLines(Path path) throws IOException {\n        return readAllLines(path, UTF_8.INSTANCE);\n    }\n\n    /**\n     * Writes bytes to a file. The {@code options} parameter specifies how\n     * the file is created or opened. If no options are present then this method\n     * works as if the {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}. All bytes in the byte array are written to the file.\n     * The method ensures that the file is closed when all bytes have been\n     * written (or an I/O error or other runtime exception is thrown). If an I/O\n     * error occurs then it may do so after the file has been created or\n     * truncated, or after some bytes have been written to the file.\n     *\n     * \u003cp\u003e \u003cb\u003eUsage example\u003c/b\u003e: By default the method creates a new file or\n     * overwrites an existing file. Suppose you instead want to append bytes\n     * to an existing file:\n     * {@snippet lang\u003djava :\n     *     Path path \u003d ...\n     *     byte[] bytes \u003d ...\n     *     Files.write(path, bytes, StandardOpenOption.APPEND);\n     * }\n     *\n     * @param   path\n     *          the path to the file\n     * @param   bytes\n     *          the byte array with the bytes to write\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static Path write(Path path, byte[] bytes, OpenOption... options)\n        throws IOException\n    {\n        // ensure bytes is not null before opening file\n        Objects.requireNonNull(bytes);\n\n        try (OutputStream out \u003d Files.newOutputStream(path, options)) {\n            int len \u003d bytes.length;\n            int rem \u003d len;\n            while (rem \u003e 0) {\n                int n \u003d Math.min(rem, BUFFER_SIZE);\n                out.write(bytes, (len-rem), n);\n                rem -\u003d n;\n            }\n        }\n        return path;\n    }\n\n    /**\n     * Write lines of text to a file. Each line is a char sequence and is\n     * written to the file in sequence with each line terminated by the\n     * platform\u0027s line separator, as defined by the system property {@code\n     * line.separator}. Characters are encoded into bytes using the specified\n     * charset.\n     *\n     * \u003cp\u003e The {@code options} parameter specifies how the file is created\n     * or opened. If no options are present then this method works as if the\n     * {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}. The method ensures that the file is closed when all\n     * lines have been written (or an I/O error or other runtime exception is\n     * thrown). If an I/O error occurs then it may do so after the file has\n     * been created or truncated, or after some bytes have been written to the\n     * file.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   lines\n     *          an object to iterate over the char sequences\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  FileAlreadyExistsException\n     *          If a file of that name already exists and the {@link\n     *          StandardOpenOption#CREATE_NEW CREATE_NEW} option is specified\n     *          \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     */\n    public static Path write(Path path, Iterable\u003c? extends CharSequence\u003e lines,\n                             Charset cs, OpenOption... options)\n        throws IOException\n    {\n        // ensure lines is not null before opening file\n        Objects.requireNonNull(lines);\n        CharsetEncoder encoder \u003d cs.newEncoder();\n        try (OutputStream out \u003d newOutputStream(path, options);\n             BufferedWriter writer \u003d new BufferedWriter(new OutputStreamWriter(out, encoder))) {\n            for (CharSequence line: lines) {\n                writer.append(line);\n                writer.newLine();\n            }\n        }\n        return path;\n    }\n\n    /**\n     * Write lines of text to a file. Characters are encoded into bytes using\n     * the {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * write(Path, Iterable\u003c? extends CharSequence\u003e, Charset, OpenOption...)\n     * Files.write(path, lines, StandardCharsets.UTF_8, options)\n     * }\u003c/blockquote\u003e\n     *\n     * @param   path\n     *          the path to the file\n     * @param   lines\n     *          an object to iterate over the char sequences\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded as {@code UTF-8}\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 1.8\n     */\n    public static Path write(Path path,\n                             Iterable\u003c? extends CharSequence\u003e lines,\n                             OpenOption... options)\n        throws IOException\n    {\n        return write(path, lines, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.\n     * Characters are encoded into bytes using the\n     * {@link StandardCharsets#UTF_8 UTF-8} {@link Charset charset}.\n     *\n     * \u003cp\u003e This method is equivalent to: {@link\n     * writeString(Path, CharSequence, Charset, OpenOption...)\n     * writeString(path, csq, StandardCharsets.UTF_8, options)}.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   csq\n     *          the CharSequence to be written\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using UTF-8\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 11\n     */\n    public static Path writeString(Path path, CharSequence csq, OpenOption... options)\n            throws IOException\n    {\n        return writeString(path, csq, UTF_8.INSTANCE, options);\n    }\n\n    /**\n     * Write a {@linkplain java.lang.CharSequence CharSequence} to a file.\n     * Characters are encoded into bytes using the specified\n     * {@linkplain java.nio.charset.Charset charset}.\n     *\n     * \u003cp\u003e All characters are written as they are, including the line separators in\n     * the char sequence. No extra characters are added.\n     *\n     * \u003cp\u003e The {@code options} parameter specifies how the file is created\n     * or opened. If no options are present then this method works as if the\n     * {@link StandardOpenOption#CREATE CREATE}, {@link\n     * StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and {@link\n     * StandardOpenOption#WRITE WRITE} options are present. In other words, it\n     * opens the file for writing, creating the file if it doesn\u0027t exist, or\n     * initially truncating an existing {@link #isRegularFile regular-file} to\n     * a size of {@code 0}.\n     *\n     *\n     * @param   path\n     *          the path to the file\n     * @param   csq\n     *          the CharSequence to be written\n     * @param   cs\n     *          the charset to use for encoding\n     * @param   options\n     *          options specifying how the file is opened\n     *\n     * @return  the path\n     *\n     * @throws  IllegalArgumentException\n     *          if {@code options} contains an invalid combination of options\n     * @throws  IOException\n     *          if an I/O error occurs writing to or creating the file, or the\n     *          text cannot be encoded using the specified charset\n     * @throws  UnsupportedOperationException\n     *          if an unsupported option is specified\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkWrite(String) checkWrite}\n     *          method is invoked to check write access to the file. The {@link\n     *          SecurityManager#checkDelete(String) checkDelete} method is\n     *          invoked to check delete access if the file is opened with the\n     *          {@code DELETE_ON_CLOSE} option.\n     *\n     * @since 11\n     */\n    public static Path writeString(Path path, CharSequence csq, Charset cs, OpenOption... options)\n            throws IOException\n    {\n        // ensure the text is not null before opening file\n        Objects.requireNonNull(path);\n        Objects.requireNonNull(csq);\n        Objects.requireNonNull(cs);\n\n        byte[] bytes \u003d JLA.getBytesNoRepl(String.valueOf(csq), cs);\n        if (path.getClass().getModule() !\u003d Object.class.getModule())\n            bytes \u003d bytes.clone();\n        write(path, bytes, options);\n\n        return path;\n    }\n\n    // -- Stream APIs --\n\n    /**\n     * Return a lazily populated {@code Stream}, the elements of\n     * which are the entries in the directory.  The listing is not recursive.\n     *\n     * \u003cp\u003e The elements of the stream are {@link Path} objects that are\n     * obtained as if by {@link Path#resolve(Path) resolving} the name of the\n     * directory entry against {@code dir}. Some file systems maintain special\n     * links to the directory itself and the directory\u0027s parent directory.\n     * Entries representing these links are not included.\n     *\n     * \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It is thread safe but does\n     * not freeze the directory while iterating, so it may (or may not)\n     * reflect updates to the directory that occur after returning from this\n     * method.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open directory.\n     * The directory is closed by closing the stream.\n     *\n     * \u003cp\u003e Operating on a closed stream behaves as if the end of stream\n     * has been reached. Due to read-ahead, one or more elements may be\n     * returned after the stream has been closed.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after this method has returned, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directory is closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   dir  The path to the directory\n     *\n     * @return  The {@code Stream} describing the content of the\n     *          directory\n     *\n     * @throws  NotDirectoryException\n     *          if the file could not otherwise be opened because it is not\n     *          a directory \u003ci\u003e(optional specific exception)\u003c/i\u003e\n     * @throws  IOException\n     *          if an I/O error occurs when opening the directory\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the directory.\n     *\n     * @see     #newDirectoryStream(Path)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e list(Path dir) throws IOException {\n        DirectoryStream\u003cPath\u003e ds \u003d Files.newDirectoryStream(dir);\n        try {\n            final Iterator\u003cPath\u003e delegate \u003d ds.iterator();\n\n            // Re-wrap DirectoryIteratorException to UncheckedIOException\n            Iterator\u003cPath\u003e iterator \u003d new Iterator\u003c\u003e() {\n                @Override\n                public boolean hasNext() {\n                    try {\n                        return delegate.hasNext();\n                    } catch (DirectoryIteratorException e) {\n                        throw new UncheckedIOException(e.getCause());\n                    }\n                }\n                @Override\n                public Path next() {\n                    try {\n                        return delegate.next();\n                    } catch (DirectoryIteratorException e) {\n                        throw new UncheckedIOException(e.getCause());\n                    }\n                }\n            };\n\n            Spliterator\u003cPath\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(asUncheckedRunnable(ds));\n        } catch (Error|RuntimeException e) {\n            try {\n                ds.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {}\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by walking the file tree rooted at a given starting file.  The\n     * file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\n     * are {@link Path} objects that are obtained as if by {@link\n     * Path#resolve(Path) resolving} the relative path against {@code start}.\n     *\n     * \u003cp\u003e The {@code stream} walks the file tree as elements are consumed.\n     * The {@code Stream} returned is guaranteed to have at least one\n     * element, the starting file itself. For each file visited, the stream\n     * attempts to read its {@link BasicFileAttributes}. If the file is a\n     * directory and can be opened successfully, entries in the directory, and\n     * their \u003cem\u003edescendants\u003c/em\u003e will follow the directory in the stream as\n     * they are encountered. When all entries have been visited, then the\n     * directory is closed. The file tree walk then continues at the next\n     * \u003cem\u003esibling\u003c/em\u003e of the directory.\n     *\n     * \u003cp\u003e The stream is \u003ci\u003eweakly consistent\u003c/i\u003e. It does not freeze the\n     * file tree while iterating, so it may (or may not) reflect updates to\n     * the file tree that occur after returned from this method.\n     *\n     * \u003cp\u003e By default, symbolic links are not automatically followed by this\n     * method. If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then symbolic links are\n     * followed. When following links, and the attributes of the target cannot\n     * be read, then this method attempts to get the {@code BasicFileAttributes}\n     * of the link.\n     *\n     * \u003cp\u003e If the {@code options} parameter contains the {@link\n     * FileVisitOption#FOLLOW_LINKS FOLLOW_LINKS} option then the stream keeps\n     * track of directories visited so that cycles can be detected. A cycle\n     * arises when there is an entry in a directory that is an ancestor of the\n     * directory. Cycle detection is done by recording the {@link\n     * java.nio.file.attribute.BasicFileAttributes#fileKey file-key} of directories,\n     * or if file keys are not available, by invoking the {@link #isSameFile\n     * isSameFile} method to test if a directory is the same file as an\n     * ancestor. When a cycle is detected it is treated as an I/O error with\n     * an instance of {@link FileSystemLoopException}.\n     *\n     * \u003cp\u003e The {@code maxDepth} parameter is the maximum number of levels of\n     * directories to visit. A value of {@code 0} means that only the starting\n     * file is visited, unless denied by the security manager. A value of\n     * {@link Integer#MAX_VALUE MAX_VALUE} may be used to indicate that all\n     * levels should be visited.\n     *\n     * \u003cp\u003e When a security manager is installed and it denies access to a file\n     * (or directory), then it is ignored and not included in the stream.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after this method has returned, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   maxDepth\n     *          the maximum number of directory levels to visit\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e walk(Path start,\n                                    int maxDepth,\n                                    FileVisitOption... options)\n        throws IOException\n    {\n        FileTreeIterator iterator \u003d new FileTreeIterator(start, maxDepth, options);\n        try {\n            Spliterator\u003cFileTreeWalker.Event\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(iterator::close)\n                                .map(entry -\u003e entry.file());\n        } catch (Error|RuntimeException e) {\n            iterator.close();\n            throw e;\n        }\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by walking the file tree rooted at a given starting file.  The\n     * file tree is traversed \u003cem\u003edepth-first\u003c/em\u003e, the elements in the stream\n     * are {@link Path} objects that are obtained as if by {@link\n     * Path#resolve(Path) resolving} the relative path against {@code start}.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * walk(Path, int, FileVisitOption...)\n     * Files.walk(start, Integer.MAX_VALUE, options)\n     * }\u003c/blockquote\u003e\n     * In other words, it visits all levels of the file tree.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     *\n     * @see     #walk(Path, int, FileVisitOption...)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e walk(Path start, FileVisitOption... options) throws IOException {\n        return walk(start, Integer.MAX_VALUE, options);\n    }\n\n    /**\n     * Return a {@code Stream} that is lazily populated with {@code\n     * Path} by searching for files in a file tree rooted at a given starting\n     * file.\n     *\n     * \u003cp\u003e This method walks the file tree in exactly the manner specified by\n     * the {@link #walk walk} method. For each file encountered, the given\n     * {@link BiPredicate} is invoked with its {@link Path} and {@link\n     * BasicFileAttributes}. The {@code Path} object is obtained as if by\n     * {@link Path#resolve(Path) resolving} the relative path against {@code\n     * start} and is only included in the returned {@link Stream} if\n     * the {@code BiPredicate} returns true. Compare to calling {@link\n     * java.util.stream.Stream#filter filter} on the {@code Stream}\n     * returned by {@code walk} method, this method may be more efficient by\n     * avoiding redundant retrieval of the {@code BasicFileAttributes}.\n     *\n     * \u003cp\u003e The returned stream contains references to one or more open directories.\n     * The directories are closed by closing the stream.\n     *\n     * \u003cp\u003e If an {@link IOException} is thrown when accessing the directory\n     * after returned from this method, it is wrapped in an {@link\n     * UncheckedIOException} which will be thrown from the method that caused\n     * the access to take place.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open directories are closed\n     * promptly after the stream\u0027s operations have completed.\n     *\n     * @param   start\n     *          the starting file\n     * @param   maxDepth\n     *          the maximum number of directory levels to search\n     * @param   matcher\n     *          the function used to decide whether a file should be included\n     *          in the returned stream\n     * @param   options\n     *          options to configure the traversal\n     *\n     * @return  the {@link Stream} of {@link Path}\n     *\n     * @throws  IllegalArgumentException\n     *          if the {@code maxDepth} parameter is negative\n     * @throws  SecurityException\n     *          If the security manager denies access to the starting file.\n     *          In the case of the default provider, the {@link\n     *          SecurityManager#checkRead(String) checkRead} method is invoked\n     *          to check read access to the directory.\n     * @throws  IOException\n     *          if an I/O error is thrown when accessing the starting file.\n     *\n     * @see     #walk(Path, int, FileVisitOption...)\n     * @since   1.8\n     */\n    public static Stream\u003cPath\u003e find(Path start,\n                                    int maxDepth,\n                                    BiPredicate\u003cPath, BasicFileAttributes\u003e matcher,\n                                    FileVisitOption... options)\n        throws IOException\n    {\n        FileTreeIterator iterator \u003d new FileTreeIterator(start, maxDepth, options);\n        try {\n            Spliterator\u003cFileTreeWalker.Event\u003e spliterator \u003d\n                Spliterators.spliteratorUnknownSize(iterator, Spliterator.DISTINCT);\n            return StreamSupport.stream(spliterator, false)\n                                .onClose(iterator::close)\n                                .filter(entry -\u003e matcher.test(entry.file(), entry.attributes()))\n                                .map(entry -\u003e entry.file());\n        } catch (Error|RuntimeException e) {\n            iterator.close();\n            throw e;\n        }\n    }\n\n\n    /**\n     * Read all lines from a file as a {@code Stream}. Unlike {@link\n     * #readAllLines(Path, Charset) readAllLines}, this method does not read\n     * all lines into a {@code List}, but instead populates lazily as the stream\n     * is consumed.\n     *\n     * \u003cp\u003e Bytes from the file are decoded into characters using the specified\n     * charset and the same line terminators as specified by {@code\n     * readAllLines} are supported.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open file. The file\n     * is closed by closing the stream.\n     *\n     * \u003cp\u003e The file contents should not be modified during the execution of the\n     * terminal stream operation. Otherwise, the result of the terminal stream\n     * operation is undefined.\n     *\n     * \u003cp\u003e After this method returns, then any subsequent I/O exception that\n     * occurs while reading from the file or when a malformed or unmappable byte\n     * sequence is read, is wrapped in an {@link UncheckedIOException} that will\n     * be thrown from the\n     * {@link java.util.stream.Stream} method that caused the read to take\n     * place. In case an {@code IOException} is thrown when closing the file,\n     * it is also wrapped as an {@code UncheckedIOException}.\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open file is closed promptly\n     * after the stream\u0027s operations have completed.\n     *\n     * @implNote\n     * This implementation supports good parallel stream performance for the\n     * standard charsets {@link StandardCharsets#UTF_8 UTF-8},\n     * {@link StandardCharsets#US_ASCII US-ASCII} and\n     * {@link StandardCharsets#ISO_8859_1 ISO-8859-1}.  Such\n     * \u003cem\u003eline-optimal\u003c/em\u003e charsets have the property that the encoded bytes\n     * of a line feed (\u0027\\n\u0027) or a carriage return (\u0027\\r\u0027) are efficiently\n     * identifiable from other encoded characters when randomly accessing the\n     * bytes of the file.\n     *\n     * \u003cp\u003e For non-\u003cem\u003eline-optimal\u003c/em\u003e charsets the stream source\u0027s\n     * spliterator has poor splitting properties, similar to that of a\n     * spliterator associated with an iterator or that associated with a stream\n     * returned from {@link BufferedReader#lines()}.  Poor splitting properties\n     * can result in poor parallel stream performance.\n     *\n     * \u003cp\u003e For \u003cem\u003eline-optimal\u003c/em\u003e charsets the stream source\u0027s spliterator\n     * has good splitting properties, assuming the file contains a regular\n     * sequence of lines.  Good splitting properties can result in good parallel\n     * stream performance.  The spliterator for a \u003cem\u003eline-optimal\u003c/em\u003e charset\n     * takes advantage of the charset properties (a line feed or a carriage\n     * return being efficient identifiable) such that when splitting it can\n     * approximately divide the number of covered lines in half.\n     *\n     * @param   path\n     *          the path to the file\n     * @param   cs\n     *          the charset to use for decoding\n     *\n     * @return  the lines from the file as a {@code Stream}\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @see     #readAllLines(Path, Charset)\n     * @see     #newBufferedReader(Path, Charset)\n     * @see     java.io.BufferedReader#lines()\n     * @since   1.8\n     */\n    public static Stream\u003cString\u003e lines(Path path, Charset cs) throws IOException {\n        // Use the good splitting spliterator if:\n        // 1) the path is associated with the default file system;\n        // 2) the character set is supported; and\n        // 3) the file size is such that all bytes can be indexed by int values\n        //    (this limitation is imposed by ByteBuffer)\n        if (path.getFileSystem() \u003d\u003d FileSystems.getDefault() \u0026\u0026\n            FileChannelLinesSpliterator.SUPPORTED_CHARSETS.contains(cs)) {\n            FileChannel fc \u003d FileChannel.open(path, StandardOpenOption.READ);\n\n            Stream\u003cString\u003e fcls \u003d createFileChannelLinesStream(fc, cs);\n            if (fcls !\u003d null) {\n                return fcls;\n            }\n            fc.close();\n        }\n\n        return createBufferedReaderLinesStream(Files.newBufferedReader(path, cs));\n    }\n\n    private static Stream\u003cString\u003e createFileChannelLinesStream(FileChannel fc, Charset cs) throws IOException {\n        try {\n            // Obtaining the size from the FileChannel is much faster\n            // than obtaining using path.toFile().length()\n            long length \u003d fc.size();\n            // FileChannel.size() may in certain circumstances return zero\n            // for a non-zero length file so disallow this case.\n            if (length \u003e 0 \u0026\u0026 length \u003c\u003d Integer.MAX_VALUE) {\n                FileChannelLinesSpliterator fcls \u003d\n                    new FileChannelLinesSpliterator(fc, cs, 0, (int) length);\n                return StreamSupport.stream(fcls, false)\n                        .onClose(Files.asUncheckedRunnable(fc))\n                        .onClose(() -\u003e fcls.close());\n            }\n        } catch (Error|RuntimeException|IOException e) {\n            try {\n                fc.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {\n                }\n            }\n            throw e;\n        }\n        return null;\n    }\n\n    private static Stream\u003cString\u003e createBufferedReaderLinesStream(BufferedReader br) {\n        try {\n            return br.lines().onClose(asUncheckedRunnable(br));\n        } catch (Error|RuntimeException e) {\n            try {\n                br.close();\n            } catch (IOException ex) {\n                try {\n                    e.addSuppressed(ex);\n                } catch (Throwable ignore) {\n                }\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * Read all lines from a file as a {@code Stream}. Bytes from the file are\n     * decoded into characters using the {@link StandardCharsets#UTF_8 UTF-8}\n     * {@link Charset charset}.\n     *\n     * \u003cp\u003e The returned stream contains a reference to an open file. The file\n     * is closed by closing the stream.\n     *\n     * \u003cp\u003e The file contents should not be modified during the execution of the\n     * terminal stream operation. Otherwise, the result of the terminal stream\n     * operation is undefined.\n     *\n     * \u003cp\u003e This method works as if invoking it were equivalent to evaluating the\n     * expression:\n     * \u003cblockquote\u003e{@link\n     * lines(Path, Charset)\n     * Files.lines(path, StandardCharsets.UTF_8)\n     * }\u003c/blockquote\u003e\n     *\n     * @apiNote\n     * This method must be used within a try-with-resources statement or similar\n     * control structure to ensure that the stream\u0027s open file is closed promptly\n     * after the stream\u0027s operations have completed.\n     *\n     * @param   path\n     *          the path to the file\n     *\n     * @return  the lines from the file as a {@code Stream}\n     *\n     * @throws  IOException\n     *          if an I/O error occurs opening the file\n     * @throws  SecurityException\n     *          In the case of the default provider, and a security manager is\n     *          installed, the {@link SecurityManager#checkRead(String) checkRead}\n     *          method is invoked to check read access to the file.\n     *\n     * @since 1.8\n     */\n    public static Stream\u003cString\u003e lines(Path path) throws IOException {\n        return lines(path, UTF_8.INSTANCE);\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didOpen(WorkspaceLspService.scala:339)
	at scala.meta.metals.lsp.DelegatingScalaService.didOpen(DelegatingScalaService.scala:39)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

Π°ΠΏΡ€. 25, 2024 4:32:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///C%3A/Program%20Files/Java/jdk-22/lib/src.zip%21/java.base/java/nio/file/Files.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:572)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:317)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:118)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.IllegalArgumentException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI.create(URI.java:932)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:177)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.$anonfun$toAbsolutePath$3(MtagsEnrichments.scala:174)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.withTryDecode$1(MtagsEnrichments.scala:153)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:174)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:732)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:729)
	at scala.meta.internal.metals.WorkspaceLspService.didClose(WorkspaceLspService.scala:358)
	at scala.meta.metals.lsp.DelegatingScalaService.didClose(DelegatingScalaService.scala:53)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	... 13 more
Caused by: java.net.URISyntaxException: Illegal character in opaque part at index 22: jar:file:///C:/Program Files/Java/jdk-22/lib/src.zip!/java.base/java/nio/file/Files.java
	at java.base/java.net.URI$Parser.fail(URI.java:2995)
	at java.base/java.net.URI$Parser.checkChars(URI.java:3166)
	at java.base/java.net.URI$Parser.parse(URI.java:3202)
	at java.base/java.net.URI.<init>(URI.java:645)
	at java.base/java.net.URI.create(URI.java:930)
	... 22 more

2024.04.25 16:32:45 INFO  compiling bestgame (1 scala source)
2024.04.25 16:32:45 INFO  time: compiled bestgame in 0.28s
2024.04.25 16:32:47 INFO  compiling bestgame (1 scala source)
2024.04.25 16:32:47 INFO  time: compiled bestgame in 0.27s
2024.04.25 16:32:51 INFO  compiling bestgame (1 scala source)
2024.04.25 16:32:51 INFO  time: compiled bestgame in 84ms
2024.04.25 16:32:54 INFO  compiling bestgame (1 scala source)
2024.04.25 16:32:54 INFO  time: compiled bestgame in 0.29s
2024.04.25 16:34:59 INFO  compiling bestgame (1 scala source)
2024.04.25 16:34:59 INFO  time: compiled bestgame in 0.52s
Π°ΠΏΡ€. 25, 2024 4:35:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: org.scalameta.invariants.InvariantFailedException: invariant failed:
when verifying scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable
found that scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable is false
where tpe = (bytes, "UTF-8")

java.util.concurrent.CompletionException: org.scalameta.invariants.InvariantFailedException: invariant failed:
when verifying scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable
found that scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable is false
where tpe = (bytes, "UTF-8")

	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:332)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:347)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:708)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:484)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: org.scalameta.invariants.InvariantFailedException: invariant failed:
when verifying scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable
found that scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable is false
where tpe = (bytes, "UTF-8")

	at org.scalameta.invariants.InvariantFailedException$.raise(InvariantFailedException.scala:27)
	at scala.meta.Init$.apply(Trees.scala:881)
	at scala.meta.Init$.apply(Trees.scala:880)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$initRest$1(ScalametaParser.scala:4244)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.initRest(ScalametaParser.scala:4206)
	at scala.meta.internal.parsers.ScalametaParser.initInsideTemplate(ScalametaParser.scala:4188)
	at scala.meta.internal.parsers.ScalametaParser.init(ScalametaParser.scala:4328)
	at scala.meta.internal.parsers.ScalametaParser.templateParents(ScalametaParser.scala:4338)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4386)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:316)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4374)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$2(ScalametaParser.scala:2263)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:316)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2261)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2230)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2227)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2085)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:1682)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1587)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2517)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsInParens$1(ScalametaParser.scala:2544)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$commaSeparated$1(ScalametaParser.scala:657)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$commaSeparated$1$adapted(ScalametaParser.scala:657)
	at scala.meta.internal.parsers.ScalametaParser.iter$1(ScalametaParser.scala:647)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$tokenSeparated$1(ScalametaParser.scala:653)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$tokenSeparated$1$adapted(ScalametaParser.scala:640)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$listBy(ScalametaParser.scala:565)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:640)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparatedWithIndex(ScalametaParser.scala:660)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:657)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsInParens(ScalametaParser.scala:2544)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$getArgClauseOnParen$2(ScalametaParser.scala:2532)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$inParensAfterOpenOr(ScalametaParser.scala:252)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$inParensOnOpenOr(ScalametaParser.scala:244)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$getArgClauseOnParen$1(ScalametaParser.scala:2533)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:316)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.getArgClauseOnParen(ScalametaParser.scala:2533)
	at scala.meta.internal.parsers.ScalametaParser.argClause$1(ScalametaParser.scala:2352)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2353)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2278)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2230)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2227)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2085)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:1682)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1587)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1486)
	at scala.meta.internal.parsers.ScalametaParser.generatorBuf(ScalametaParser.scala:2708)
	at scala.meta.internal.parsers.ScalametaParser.enumeratorBuf(ScalametaParser.scala:2677)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$enumerators$1(ScalametaParser.scala:2664)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$enumerators$1$adapted(ScalametaParser.scala:2661)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$listBy(ScalametaParser.scala:565)
	at scala.meta.internal.parsers.ScalametaParser.enumerators(ScalametaParser.scala:2661)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:1648)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1587)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$3(ScalametaParser.scala:4681)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4518)
	at scala.meta.internal.parsers.ScalametaParser.iter$7(ScalametaParser.scala:4681)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$1(ScalametaParser.scala:4695)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$1$adapted(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.scala$meta$internal$parsers$ScalametaParser$$listBy(ScalametaParser.scala:565)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.blockWithinDelims(ScalametaParser.scala:2574)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockInDelims$2(ScalametaParser.scala:2577)
	at scala.meta.internal.parsers.ScalametaParser.indentedOnOpen(ScalametaParser.scala:276)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockOnIndent$1(ScalametaParser.scala:2581)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockInDelims$1(ScalametaParser.scala:2577)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:316)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.blockInDelims(ScalametaParser.scala:2577)
	at scala.meta.internal.parsers.ScalametaParser.blockOnIndent(ScalametaParser.scala:2580)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExprOnIndent$1(ScalametaParser.scala:2585)
	at scala.meta.internal.parsers.ScalametaParser.blockExprPartial(ScalametaParser.scala:2570)
	at scala.meta.internal.parsers.ScalametaParser.blockExprOnIndent(ScalametaParser.scala:2585)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2274)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2230)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2227)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2085)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:1682)
	at scala.meta.internal.parsers.ScalametaParser.atPosOpt(ScalametaParser.scala:319)
	at scala.meta.internal.parsers.ScalametaParser.autoPosOpt(ScalametaParser.scala:366)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1587)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:1486)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:3906)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:368)
	at scala.meta.internal.parsers.ScalametaParser.autoEndPos(ScalametaParser.scala:373)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:3868)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:3813)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3643)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3620)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$2.applyOrElse(ScalametaParser.scala:4562)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$2.applyOrElse(ScalametaParser.scala:4546)
	at scala.PartialFunction.$anonfun$runWith$1(PartialFunction.scala:231)
	at scala.PartialFunction.$anonfun$runWith$1$adapted(PartialFunction.scala:230)
	at scala.meta.internal.parsers.ScalametaParser.statSeqBuf(ScalametaParser.scala:4537)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$13(ScalametaParser.scala:4771)
	at scala.Option.getOrElse(Option.scala:201)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:4771)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:316)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4727)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4720)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:316)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:365)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4720)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4725)
	at scala.meta.internal.parsers.ScalametaParser.parseSourceImpl(ScalametaParser.scala:135)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$1(ScalametaParser.scala:132)
	at scala.meta.internal.parsers.ScalametaParser.parseRuleAfterBOF(ScalametaParser.scala:59)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:54)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:132)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.parsers.Parse$$anon$1.apply(Parse.scala:36)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.parsing.Trees.$anonfun$parse$2(Trees.scala:151)
	at scala.Option.map(Option.scala:242)
	at scala.meta.internal.parsing.Trees.parse(Trees.scala:142)
	at scala.meta.internal.parsing.Trees.didChange(Trees.scala:101)
	at scala.meta.internal.metals.MetalsLspService.$anonfun$parseTreesAndPublishDiags$2(MetalsLspService.scala:866)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:687)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	... 3 more

2024.04.25 16:35:15 INFO  compiling bestgame (1 scala source)
2024.04.25 16:35:15 INFO  time: compiled bestgame in 0.45s
2024.04.25 16:36:22 INFO  compiling bestgame (1 scala source)
2024.04.25 16:36:22 INFO  time: compiled bestgame in 0.58s
Π°ΠΏΡ€. 25, 2024 4:39:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12617
2024.04.25 16:39:37 INFO  compiling bestgame (1 scala source)
2024.04.25 16:39:37 INFO  time: compiled bestgame in 0.6s
2024.04.25 16:39:51 INFO  compiling bestgame (1 scala source)
2024.04.25 16:39:51 INFO  time: compiled bestgame in 0.12s
2024.04.25 16:39:53 INFO  compiling bestgame (1 scala source)
2024.04.25 16:39:53 INFO  time: compiled bestgame in 0.38s
2024.04.25 16:40:16 INFO  compiling bestgame (1 scala source)
2024.04.25 16:40:16 INFO  time: compiled bestgame in 0.37s
2024.04.25 16:40:17 INFO  compiling bestgame (1 scala source)
2024.04.25 16:40:17 INFO  time: compiled bestgame in 0.74s
2024.04.25 16:43:01 INFO  compiling bestgame (1 scala source)
2024.04.25 16:43:02 INFO  time: compiled bestgame in 1.62s
2024.04.25 16:43:46 INFO  compiling bestgame (1 scala source)
2024.04.25 16:43:46 INFO  time: compiled bestgame in 0.5s
2024.04.25 16:43:53 INFO  compiling bestgame (1 scala source)
2024.04.25 16:43:53 INFO  time: compiled bestgame in 0.64s
2024.04.25 16:44:06 INFO  compiling bestgame (1 scala source)
2024.04.25 16:44:06 INFO  time: compiled bestgame in 0.37s
2024.04.25 16:44:11 INFO  compiling bestgame (1 scala source)
2024.04.25 16:44:11 INFO  time: compiled bestgame in 0.34s
2024.04.25 16:44:30 INFO  compiling bestgame (1 scala source)
2024.04.25 16:44:30 INFO  time: compiled bestgame in 0.88s
2024.04.25 16:44:30 INFO  compiling bestgame (3 scala sources)
2024.04.25 16:44:32 INFO  time: compiled bestgame in 0.49s
2024.04.25 16:45:23 INFO  compiling bestgame (4 scala sources)
2024.04.25 16:45:23 INFO  time: compiled bestgame in 0.5s
2024.04.25 16:45:23 INFO  compiling bestgame (4 scala sources)
2024.04.25 16:45:24 INFO  time: compiled bestgame in 0.73s
2024.04.25 16:46:49 INFO  compiling bestgame (4 scala sources)
2024.04.25 16:46:49 INFO  time: compiled bestgame in 0.39s
2024.04.25 16:47:23 INFO  compiling bestgame (4 scala sources)
2024.04.25 16:47:23 INFO  time: compiled bestgame in 0.39s
2024.04.25 16:47:25 INFO  compiling bestgame (4 scala sources)
2024.04.25 16:47:25 INFO  time: compiled bestgame in 0.43s
2024.04.25 16:47:31 INFO  compiling bestgame (4 scala sources)
2024.04.25 16:47:31 INFO  time: compiled bestgame in 0.38s
Π°ΠΏΡ€. 25, 2024 4:54:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13477
Π°ΠΏΡ€. 25, 2024 4:57:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13562
2024.04.25 16:57:28 INFO  compiling bestgame (4 scala sources)
2024.04.25 16:57:28 INFO  time: compiled bestgame in 0.86s
2024.04.25 16:57:33 INFO  compiling bestgame (4 scala sources)
2024.04.25 16:57:33 INFO  time: compiled bestgame in 0.56s
2024.04.25 16:57:48 INFO  compiling bestgame (4 scala sources)
2024.04.25 16:57:48 INFO  time: compiled bestgame in 0.48s
2024.04.25 16:59:45 INFO  compiling bestgame (4 scala sources)
2024.04.25 16:59:45 INFO  time: compiled bestgame in 0.43s
2024.04.25 16:59:49 INFO  compiling bestgame (4 scala sources)
2024.04.25 16:59:49 INFO  time: compiled bestgame in 0.52s
2024.04.25 17:02:11 INFO  compiling bestgame (4 scala sources)
2024.04.25 17:02:11 INFO  time: compiled bestgame in 0.43s
2024.04.25 17:03:17 INFO  compiling bestgame (4 scala sources)
2024.04.25 17:03:17 INFO  time: compiled bestgame in 0.47s
Π°ΠΏΡ€. 25, 2024 5:08:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14742
2024.04.25 17:08:32 INFO  compiling bestgame (4 scala sources)
2024.04.25 17:08:32 INFO  time: compiled bestgame in 0.7s
2024.04.25 17:08:38 INFO  compiling bestgame (4 scala sources)
2024.04.25 17:08:38 INFO  time: compiled bestgame in 0.56s
2024.04.25 17:09:55 INFO  compiling bestgame (4 scala sources)
2024.04.25 17:09:55 INFO  time: compiled bestgame in 0.44s
Π°ΠΏΡ€. 25, 2024 5:10:55 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\bestgame\src\main\scala\gameClasses\Seeds.scala
java.nio.file.NoSuchFileException: D:\bestgame\src\main\scala\gameClasses\Seeds.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3273)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:410)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:279)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:290)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:205)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:205)
	at scala.collection.immutable.Set$Set1.foreach(Set.scala:177)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:205)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:178)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:159)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:159)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.mtags.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:255)
	at scala.meta.internal.pc.printer.MetalsPrinter.paramsDocs$lzyINIT1$1(MetalsPrinter.scala:188)
	at scala.meta.internal.pc.printer.MetalsPrinter.paramsDocs$1(MetalsPrinter.scala:192)
	at scala.meta.internal.pc.printer.MetalsPrinter.$anonfun$6(MetalsPrinter.scala:209)
	at scala.meta.internal.pc.printer.MetalsPrinter.paramLabel(MetalsPrinter.scala:358)
	at scala.meta.internal.pc.printer.MetalsPrinter.$anonfun$5(MetalsPrinter.scala:210)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.pc.printer.MetalsPrinter.label$1$$anonfun$1(MetalsPrinter.scala:213)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.pc.printer.MetalsPrinter.label$1(MetalsPrinter.scala:218)
	at scala.meta.internal.pc.printer.MetalsPrinter.defaultMethodSignature(MetalsPrinter.scala:221)
	at scala.meta.internal.pc.printer.MetalsPrinter.hoverSymbol(MetalsPrinter.scala:117)
	at scala.meta.internal.pc.HoverProvider$.hover(HoverProvider.scala:130)
	at scala.meta.internal.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:368)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:156)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:142)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:245)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)

Π°ΠΏΡ€. 25, 2024 5:10:55 PM scala.meta.internal.mtags.SymbolIndexBucket addMtagsSourceFile
WARNING: Error indexing D:\bestgame\src\main\scala\gameClasses\Seeds.scala
java.nio.file.NoSuchFileException: D:\bestgame\src\main\scala\gameClasses\Seeds.scala
	at java.base/sun.nio.fs.WindowsException.translateToIOException(WindowsException.java:85)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:103)
	at java.base/sun.nio.fs.WindowsException.rethrowAsIOException(WindowsException.java:108)
	at java.base/sun.nio.fs.WindowsFileSystemProvider.newByteChannel(WindowsFileSystemProvider.java:234)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:379)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:431)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3273)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.ScalametaCommonEnrichments$XtensionAbsolutePath.toInput(ScalametaCommonEnrichments.scala:410)
	at scala.meta.internal.mtags.Mtags.index(Mtags.scala:96)
	at scala.meta.internal.mtags.Mtags.allSymbols(Mtags.scala:21)
	at scala.meta.internal.mtags.SymbolIndexBucket.allSymbols(SymbolIndexBucket.scala:279)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:290)
	at scala.meta.internal.mtags.SymbolIndexBucket.addMtagsSourceFile(SymbolIndexBucket.scala:301)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1(SymbolIndexBucket.scala:205)
	at scala.meta.internal.mtags.SymbolIndexBucket.$anonfun$query0$1$adapted(SymbolIndexBucket.scala:205)
	at scala.collection.immutable.Set$Set1.foreach(Set.scala:177)
	at scala.meta.internal.mtags.SymbolIndexBucket.query0(SymbolIndexBucket.scala:205)
	at scala.meta.internal.mtags.SymbolIndexBucket.query(SymbolIndexBucket.scala:178)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.$anonfun$findSymbolDefinition$1(OnDemandSymbolIndex.scala:159)
	at scala.collection.immutable.List.flatMap(List.scala:294)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.findSymbolDefinition(OnDemandSymbolIndex.scala:159)
	at scala.meta.internal.mtags.OnDemandSymbolIndex.definition(OnDemandSymbolIndex.scala:48)
	at scala.meta.internal.metals.Docstrings.indexSymbol(Docstrings.scala:118)
	at scala.meta.internal.metals.Docstrings.documentation(Docstrings.scala:44)
	at scala.meta.internal.metals.MetalsSymbolSearch.documentation(MetalsSymbolSearch.scala:43)
	at scala.meta.internal.mtags.MtagsEnrichments$.symbolDocumentation(MtagsEnrichments.scala:255)
	at scala.meta.internal.pc.printer.MetalsPrinter.paramsDocs$lzyINIT1$1(MetalsPrinter.scala:188)
	at scala.meta.internal.pc.printer.MetalsPrinter.paramsDocs$1(MetalsPrinter.scala:192)
	at scala.meta.internal.pc.printer.MetalsPrinter.$anonfun$6(MetalsPrinter.scala:209)
	at scala.meta.internal.pc.printer.MetalsPrinter.paramLabel(MetalsPrinter.scala:358)
	at scala.meta.internal.pc.printer.MetalsPrinter.$anonfun$5(MetalsPrinter.scala:210)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.pc.printer.MetalsPrinter.label$1$$anonfun$1(MetalsPrinter.scala:213)
	at scala.collection.immutable.List.flatMap(List.scala:293)
	at scala.meta.internal.pc.printer.MetalsPrinter.label$1(MetalsPrinter.scala:218)
	at scala.meta.internal.pc.printer.MetalsPrinter.defaultMethodSignature(MetalsPrinter.scala:221)
	at scala.meta.internal.pc.printer.MetalsPrinter.hoverSymbol(MetalsPrinter.scala:117)
	at scala.meta.internal.pc.HoverProvider$.hover(HoverProvider.scala:130)
	at scala.meta.internal.pc.ScalaPresentationCompiler.hover$$anonfun$1(ScalaPresentationCompiler.scala:368)
	at scala.meta.internal.pc.CompilerAccess.withSharedCompiler(CompilerAccess.scala:156)
	at scala.meta.internal.pc.CompilerAccess.withNonInterruptableCompiler$$anonfun$1(CompilerAccess.scala:142)
	at scala.meta.internal.pc.CompilerAccess.onCompilerJobQueue$$anonfun$1(CompilerAccess.scala:245)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:152)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)

Π°ΠΏΡ€. 25, 2024 9:10:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15223
Π°ΠΏΡ€. 25, 2024 9:10:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15222
Π°ΠΏΡ€. 25, 2024 9:10:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15224
2024.04.25 21:10:49 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
2024.04.25 21:10:50 INFO  Connected to Build server: Bloop v1.5.17
2024.04.25 21:10:49 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at D:\bestgame\project\.metals\bsp.trace.json or C:\Users\yidtdr\AppData\Local\scalameta\metals\cache\bsp.trace.json
Π°ΠΏΡ€. 25, 2024 9:11:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15456
Π°ΠΏΡ€. 25, 2024 9:11:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15464
2024.04.25 21:13:44 INFO  file:///D:/bestgame/src/main/scala/App.scala:45:18: stale bloop error: Not found: stringToItem
      val item = stringToItem(data._1);
                 ^^^^^^^^^^^^
2024.04.25 21:13:44 INFO  file:///D:/bestgame/src/main/scala/App.scala:58:18: stale bloop error: Wrong number of argument patterns for Plant; expected: (String, Seed, Product)
            case Plant(data)                    =>
                 ^^^^^^^^^^^
2024.04.25 21:13:45 WARN  Could not find semantic tokens for: file:///D:/bestgame/src/main/scala/App.scala
Π°ΠΏΡ€. 25, 2024 9:14:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15864
Π°ΠΏΡ€. 25, 2024 9:14:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15882
Π°ΠΏΡ€. 25, 2024 9:15:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15994
Π°ΠΏΡ€. 25, 2024 9:15:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15999
2024.04.25 21:15:52 INFO  Shutting down server
2024.04.25 21:15:52 INFO  shutting down Metals
2024.04.25 21:15:52 INFO  Shut down connection with build server.
2024.04.25 21:15:52 INFO  Shut down connection with build server.
Π°ΠΏΡ€. 25, 2024 9:15:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint notify
INFO: Failed to send notification message.
org.eclipse.lsp4j.jsonrpc.JsonRpcException: java.nio.channels.ClosedChannelException
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:72)
	at scala.meta.internal.metals.RequestMonitorImpl$$anon$1.consume(ServerLivenessMonitor.scala:41)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.notify(RemoteEndpoint.java:126)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.sendCancelNotification(RemoteEndpoint.java:180)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint$1.cancel(RemoteEndpoint.java:150)
	at scala.meta.internal.metals.utils.FutureWithTimeout$$anon$1.$anonfun$cancel$1(FutureWithTimeout.scala:37)
	at scala.runtime.java8.JFunction0$mcZ$sp.apply(JFunction0$mcZ$sp.scala:17)
	at scala.util.Try$.apply(Try.scala:217)
	at scala.meta.internal.metals.utils.FutureWithTimeout$$anon$1.cancel(FutureWithTimeout.scala:37)
	at scala.meta.internal.metals.Cancelable$.$anonfun$cancelAll$1(Cancelable.scala:29)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.metals.Cancelable$.cancelAll(Cancelable.scala:28)
	at scala.meta.internal.metals.MutableCancelable.cancel(MutableCancelable.scala:25)
	at scala.meta.internal.metals.utils.RequestRegistry.cancel(RequestRegistry.scala:94)
	at scala.meta.internal.metals.BuildServerConnection.cancel(BuildServerConnection.scala:411)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$shutdown$1(BuildServerConnection.scala:175)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$shutdown$1$adapted(BuildServerConnection.scala:167)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.nio.channels.ClosedChannelException
	at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:224)
	at java.base/sun.nio.ch.SocketChannelImpl.implWrite(SocketChannelImpl.java:560)
	at java.base/sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:618)
	at java.base/sun.nio.ch.SinkChannelImpl.write(SinkChannelImpl.java:124)
	at java.base/sun.nio.ch.ChannelOutputStream.writeFully(ChannelOutputStream.java:68)
	at java.base/sun.nio.ch.ChannelOutputStream.write(ChannelOutputStream.java:102)
	at java.base/java.io.OutputStream.write(OutputStream.java:124)
	at java.base/sun.nio.ch.ChannelOutputStream.write(ChannelOutputStream.java:79)
	at scala.meta.internal.metals.ClosableOutputStream.write(ClosableOutputStream.scala:26)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:139)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:110)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:67)
	... 20 more

Π°ΠΏΡ€. 25, 2024 9:15:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint notify
INFO: Failed to send notification message.
org.eclipse.lsp4j.jsonrpc.JsonRpcException: java.nio.channels.ClosedChannelException
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:72)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.notify(RemoteEndpoint.java:126)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.sendCancelNotification(RemoteEndpoint.java:180)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint$1.cancel(RemoteEndpoint.java:150)
	at scala.meta.internal.metals.utils.RequestRegistry.$anonfun$register$5(RequestRegistry.scala:78)
	at scala.runtime.java8.JFunction0$mcZ$sp.apply(JFunction0$mcZ$sp.scala:17)
	at scala.util.Try$.apply(Try.scala:217)
	at scala.meta.internal.metals.utils.RequestRegistry.$anonfun$register$4(RequestRegistry.scala:78)
	at scala.meta.internal.metals.Cancelable$$anon$1.cancel(Cancelable.scala:18)
	at scala.meta.internal.metals.Cancelable$.$anonfun$cancelAll$1(Cancelable.scala:29)
	at scala.collection.immutable.List.foreach(List.scala:334)
	at scala.meta.internal.metals.Cancelable$.cancelAll(Cancelable.scala:28)
	at scala.meta.internal.metals.MutableCancelable.cancel(MutableCancelable.scala:25)
	at scala.meta.internal.metals.utils.RequestRegistry.cancel(RequestRegistry.scala:94)
	at scala.meta.internal.metals.BuildServerConnection.cancel(BuildServerConnection.scala:411)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$shutdown$1(BuildServerConnection.scala:175)
	at scala.meta.internal.metals.BuildServerConnection.$anonfun$shutdown$1$adapted(BuildServerConnection.scala:167)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:467)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)
	at java.base/java.lang.Thread.run(Thread.java:1570)
Caused by: java.nio.channels.ClosedChannelException
	at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:224)
	at java.base/sun.nio.ch.SocketChannelImpl.implWrite(SocketChannelImpl.java:560)
	at java.base/sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:618)
	at java.base/sun.nio.ch.SinkChannelImpl.write(SinkChannelImpl.java:124)
	at java.base/sun.nio.ch.ChannelOutputStream.writeFully(ChannelOutputStream.java:68)
	at java.base/sun.nio.ch.ChannelOutputStream.write(ChannelOutputStream.java:102)
	at java.base/java.io.OutputStream.write(OutputStream.java:124)
	at java.base/sun.nio.ch.ChannelOutputStream.write(ChannelOutputStream.java:79)
	at scala.meta.internal.metals.ClosableOutputStream.write(ClosableOutputStream.scala:26)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:139)
	at java.base/java.io.FilterOutputStream.write(FilterOutputStream.java:110)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageConsumer.consume(StreamMessageConsumer.java:67)
	... 20 more

2024.04.25 21:15:52 INFO  Cancelling compilation on Bloop server
2024.04.25 21:15:52 INFO  Failed to run request with params WorkspaceBuildTargetsResult
2024.04.25 21:15:52 INFO  Exiting server
